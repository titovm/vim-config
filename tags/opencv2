!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* A;$/;"	m	class:cv::LevMarqSparse	access:protected
A	/usr/include/opencv2/core/core.hpp	/^    enum { A=4164903690U, UNIFORM=0, NORMAL=1 };$/;"	e	enum:cv::RNG::__anon143
ABSOLUTE_LOSS	/usr/include/opencv2/ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon87
ADAPTIVE_THRESH_GAUSSIAN_C	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { ADAPTIVE_THRESH_MEAN_C=0, ADAPTIVE_THRESH_GAUSSIAN_C=1 };$/;"	e	enum:cv::__anon43
ADAPTIVE_THRESH_MEAN_C	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { ADAPTIVE_THRESH_MEAN_C=0, ADAPTIVE_THRESH_GAUSSIAN_C=1 };$/;"	e	enum:cv::__anon43
ALLOC_PAGE_LOCKED	/usr/include/opencv2/gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon152
ALLOC_WRITE_COMBINED	/usr/include/opencv2/gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon152
ALLOC_ZEROCOPY	/usr/include/opencv2/gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon152
ANN_MLP_TrainParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvANN_MLP_TrainParams ANN_MLP_TrainParams;$/;"	t	namespace:cv
APPEND	/usr/include/opencv2/core/core.hpp	/^        APPEND=2 \/\/! append mode$/;"	e	enum:cv::FileStorage::__anon149
ARRAY_LEN	/usr/include/opencv2/flann/general.h	42;"	d
ARRAY_LEN	/usr/include/opencv2/flann/general.h	43;"	d
AUTOTUNED	/usr/include/opencv2/flann/general.h	/^	AUTOTUNED = 255$/;"	e	enum:cvflann::flann_algorithm_t
AUTO_STEP	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon142
AVERAGE_ANGLE	/usr/include/opencv2/features2d/features2d.hpp	/^        enum{ FIRST_ANGLE = 0, AVERAGE_ANGLE = 1 };$/;"	e	enum:cv::SIFT::CommonParams::__anon73
Accumulator	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS Accumulator$/;"	s	namespace:cv
Accumulator	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<char>   { typedef float Type; };$/;"	s	namespace:cv
Accumulator	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<short>  { typedef float Type; };$/;"	s	namespace:cv
Accumulator	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<unsigned char>  { typedef float Type; };$/;"	s	namespace:cv
Accumulator	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<unsigned short> { typedef float Type; };$/;"	s	namespace:cv
AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* AddBlob(CvBlob* pBlob, IplImage* pImg, IplImage* pImgFG = NULL ) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(CvBlob* pBlob, IplImage* pImg, IplImage* pImgFG = NULL )
AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(CvBlob* pBlob)
AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(CvBlob* pBlob)
AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(CvBlob* pBlob)
AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:(CvBlob* pBlob)
AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void AddBlob(CvBlob* pB)$/;"	f	class:CvBlobSeq	access:public	signature:(CvBlob* pB)
AddBlobTrack	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void AddBlobTrack(int TrackID, int StartFrame = 0);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID, int StartFrame = 0)
AddFeature	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void AddFeature(float W, int* comps, int x =0, int y = 0) = 0;$/;"	p	class:CvProb	access:public	signature:(float W, int* comps, int x =0, int y = 0)
AddFormat	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddFormat(const char* str){strcat(m_pElemFormat,str);}$/;"	f	class:CvBlobSeq	access:public	signature:(const char* str)
AddParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
AddParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddParam(const char* name, const char** pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, const char** pAddr)
AddParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddParam(const char* name, double* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, double* pAddr)
AddParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddParam(const char* name, float* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, float* pAddr)
AddParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddParam(const char* name, int* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, int* pAddr)
AdjusterAdapter	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS AdjusterAdapter: public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
All	/usr/include/opencv2/legacy/legacy.hpp	/^    int** All;$/;"	m	struct:CvCliqueFinder	access:public
Allocate	/usr/include/opencv2/core/wimage.hpp	/^    void Allocate(int width, int height);$/;"	p	class:cv::WImageBufferC	access:public	signature:(int width, int height)
Allocate	/usr/include/opencv2/core/wimage.hpp	/^    void Allocate(int width, int height, int nchannels);$/;"	p	class:cv::WImageBuffer	access:public	signature:(int width, int height, int nchannels)
Allocate	/usr/include/opencv2/core/wimage.hpp	/^inline void WImageBuffer<T>::Allocate(int width, int height, int nchannels)$/;"	f	class:cv::WImageBuffer	signature:(int width, int height, int nchannels)
Allocate	/usr/include/opencv2/core/wimage.hpp	/^inline void WImageBufferC<T, C>::Allocate(int width, int height)$/;"	f	class:cv::WImageBufferC	signature:(int width, int height)
Allocate	/usr/include/opencv2/features2d/features2d.hpp	/^    void Allocate(int pose_count, CvSize size, int nChannels);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, CvSize size, int nChannels)
Allocate	/usr/include/opencv2/features2d/features2d.hpp	/^    void Allocate(int train_feature_count);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int train_feature_count)
Allocate	/usr/include/opencv2/features2d/features2d.hpp	/^    void Allocate(int train_feature_count, int object_feature_count);$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int train_feature_count, int object_feature_count)
AllocatePCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void AllocatePCADescriptors();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
Allocator	/usr/include/opencv2/core/core.hpp	/^    explicit Allocator() {}$/;"	f	class:cv::Allocator	access:public	signature:()
Allocator	/usr/include/opencv2/core/core.hpp	/^    explicit Allocator(Allocator const&) {}$/;"	f	class:cv::Allocator	access:public	signature:(Allocator const&)
Allocator	/usr/include/opencv2/core/core.hpp	/^    explicit Allocator(Allocator<U> const&) {}$/;"	f	class:cv::Allocator	access:public	signature:(Allocator<U> const&)
Allocator	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Allocator$/;"	c	namespace:cv
AutoBuffer	/usr/include/opencv2/core/core.hpp	/^    AutoBuffer();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
AutoBuffer	/usr/include/opencv2/core/core.hpp	/^    AutoBuffer(size_t _size);$/;"	p	class:cv::AutoBuffer	access:public	signature:(size_t _size)
AutoBuffer	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, size_t fixed_size=4096\/sizeof(_Tp)+8> class CV_EXPORTS AutoBuffer$/;"	c	namespace:cv
AutoBuffer	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer()$/;"	f	class:cv::AutoBuffer	signature:()
AutoBuffer	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer(size_t _size)$/;"	f	class:cv::AutoBuffer	signature:(size_t _size)
AutotunedIndex	/usr/include/opencv2/flann/autotuned_index.h	/^    AutotunedIndex(const Matrix<ELEM_TYPE>& inputData, const AutotunedIndexParams& params = AutotunedIndexParams() ) :$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(const Matrix<ELEM_TYPE>& inputData, const AutotunedIndexParams& params = AutotunedIndexParams() )
AutotunedIndex	/usr/include/opencv2/flann/autotuned_index.h	/^class AutotunedIndex : public NNIndex<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:NNIndex
AutotunedIndexParams	/usr/include/opencv2/flann/autotuned_index.h	/^	AutotunedIndexParams( float target_precision_ = 0.8, float build_weight_ = 0.01,$/;"	f	struct:cvflann::AutotunedIndexParams	access:public	signature:( float target_precision_ = 0.8, float build_weight_ = 0.01, float memory_weight_ = 0, float sample_fraction_ = 0.1)
AutotunedIndexParams	/usr/include/opencv2/flann/autotuned_index.h	/^struct AutotunedIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
B	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* B;$/;"	m	class:cv::LevMarqSparse	access:protected
BACKPROP	/usr/include/opencv2/ml/ml.hpp	/^    enum { BACKPROP=0, RPROP=1 };$/;"	e	enum:CvANN_MLP_TrainParams::__anon88
BASIC_PRESET	/usr/include/opencv2/calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon71
BASIC_PRESET	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { BASIC_PRESET = 0, PREFILTER_XSOBEL = 1 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon153
BLOCKSIZE	/usr/include/opencv2/flann/allocator.h	/^const  size_t     BLOCKSIZE=8192;$/;"	m	namespace:cvflann
BOOST	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { BOOST = 0 };$/;"	e	enum:cv::CascadeClassifier::__anon62
BORDER_CONSTANT	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { BORDER_REPLICATE=IPL_BORDER_REPLICATE, BORDER_CONSTANT=IPL_BORDER_CONSTANT,$/;"	e	enum:cv::__anon36
BORDER_DEFAULT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       BORDER_DEFAULT=BORDER_REFLECT_101, BORDER_ISOLATED=16 };$/;"	e	enum:cv::__anon36
BORDER_ISOLATED	/usr/include/opencv2/imgproc/imgproc.hpp	/^       BORDER_DEFAULT=BORDER_REFLECT_101, BORDER_ISOLATED=16 };$/;"	e	enum:cv::__anon36
BORDER_REFLECT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       BORDER_REFLECT=IPL_BORDER_REFLECT, BORDER_WRAP=IPL_BORDER_WRAP, $/;"	e	enum:cv::__anon36
BORDER_REFLECT101	/usr/include/opencv2/imgproc/imgproc.hpp	/^ 	   BORDER_REFLECT_101=IPL_BORDER_REFLECT_101, BORDER_REFLECT101=BORDER_REFLECT_101,$/;"	e	enum:cv::__anon36
BORDER_REFLECT_101	/usr/include/opencv2/imgproc/imgproc.hpp	/^ 	   BORDER_REFLECT_101=IPL_BORDER_REFLECT_101, BORDER_REFLECT101=BORDER_REFLECT_101,$/;"	e	enum:cv::__anon36
BORDER_REPLICATE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { BORDER_REPLICATE=IPL_BORDER_REPLICATE, BORDER_CONSTANT=IPL_BORDER_CONSTANT,$/;"	e	enum:cv::__anon36
BORDER_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^    static const int BORDER_SIZE = 16;$/;"	m	class:cv::CalonderDescriptorExtractor	access:protected
BORDER_TRANSPARENT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       BORDER_TRANSPARENT=IPL_BORDER_TRANSPARENT,$/;"	e	enum:cv::__anon36
BORDER_WRAP	/usr/include/opencv2/imgproc/imgproc.hpp	/^       BORDER_REFLECT=IPL_BORDER_REFLECT, BORDER_WRAP=IPL_BORDER_WRAP, $/;"	e	enum:cv::__anon36
BOWImgDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    BOWImgDescriptorExtractor( const Ptr<DescriptorExtractor>& dextractor,$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Ptr<DescriptorExtractor>& dextractor, const Ptr<DescriptorMatcher>& dmatcher )
BOWImgDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS BOWImgDescriptorExtractor$/;"	c	namespace:cv
BOWKMeansTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^    BOWKMeansTrainer( int clusterCount, const TermCriteria& termcrit=TermCriteria(),$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:( int clusterCount, const TermCriteria& termcrit=TermCriteria(), int attempts=3, int flags=KMEANS_PP_CENTERS )
BOWKMeansTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS BOWKMeansTrainer : public BOWTrainer$/;"	c	namespace:cv	inherits:BOWTrainer
BOWTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^    BOWTrainer();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
BOWTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS BOWTrainer$/;"	c	namespace:cv
BackgroundSubtractor	/usr/include/opencv2/video/background_segm.hpp	/^class CV_EXPORTS_W BackgroundSubtractor$/;"	c	namespace:cv
BackgroundSubtractorMOG	/usr/include/opencv2/video/background_segm.hpp	/^    CV_WRAP BackgroundSubtractorMOG();$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:()
BackgroundSubtractorMOG	/usr/include/opencv2/video/background_segm.hpp	/^    CV_WRAP BackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma=0);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(int history, int nmixtures, double backgroundRatio, double noiseSigma=0)
BackgroundSubtractorMOG	/usr/include/opencv2/video/background_segm.hpp	/^class CV_EXPORTS_W BackgroundSubtractorMOG : public BackgroundSubtractor$/;"	c	namespace:cv	inherits:BackgroundSubtractor
BaseColumnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    BaseColumnFilter();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
BaseColumnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^class CV_EXPORTS BaseColumnFilter$/;"	c	namespace:cv
BaseColumnFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            BaseColumnFilter_GPU(int ksize_, int anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:(int ksize_, int anchor_)
BaseColumnFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS BaseColumnFilter_GPU$/;"	c	namespace:cv::gpu
BaseFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    BaseFilter();$/;"	p	class:cv::BaseFilter	access:public	signature:()
BaseFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^class CV_EXPORTS BaseFilter$/;"	c	namespace:cv
BaseFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            BaseFilter_GPU(const Size& ksize_, const Point& anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseFilter_GPU	access:public	signature:(const Size& ksize_, const Point& anchor_)
BaseFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS BaseFilter_GPU$/;"	c	namespace:cv::gpu
BaseKeypoint	/usr/include/opencv2/features2d/features2d.hpp	/^  BaseKeypoint()$/;"	f	struct:cv::BaseKeypoint	access:public	signature:()
BaseKeypoint	/usr/include/opencv2/features2d/features2d.hpp	/^  BaseKeypoint(int x, int y, IplImage* image)$/;"	f	struct:cv::BaseKeypoint	access:public	signature:(int x, int y, IplImage* image)
BaseKeypoint	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS BaseKeypoint$/;"	s	namespace:cv
BaseRowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    BaseRowFilter();$/;"	p	class:cv::BaseRowFilter	access:public	signature:()
BaseRowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^class CV_EXPORTS BaseRowFilter$/;"	c	namespace:cv
BaseRowFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            BaseRowFilter_GPU(int ksize_, int anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:(int ksize_, int anchor_)
BaseRowFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS BaseRowFilter_GPU$/;"	c	namespace:cv::gpu
BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef T BaseType;$/;"	t	class:cv::WImage	access:public
BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageBuffer	access:public
BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageBufferC	access:public
BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageC	access:public
BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageView	access:public
BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageViewC	access:public
BlockedRange	/usr/include/opencv2/core/internal.hpp	/^        typedef tbb::blocked_range<int> BlockedRange;$/;"	t	namespace:cv
Boost	/usr/include/opencv2/ml/ml.hpp	/^typedef CvBoost Boost;$/;"	t	namespace:cv
BoostParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvBoostParams BoostParams;$/;"	t	namespace:cv
BoostTree	/usr/include/opencv2/ml/ml.hpp	/^typedef CvBoostTree BoostTree;$/;"	t	namespace:cv
BorderConst	/usr/include/opencv2/core/types_c.h	/^    int  BorderConst[4];    \/* Ditto.                                 *\/$/;"	m	struct:_IplImage	access:public
BorderMode	/usr/include/opencv2/core/types_c.h	/^    int  BorderMode[4];     \/* Ignored by OpenCV.                     *\/$/;"	m	struct:_IplImage	access:public
Branch	/usr/include/opencv2/flann/kdtree_index.h	/^    typedef BranchSt* Branch;$/;"	t	class:cvflann::KDTreeIndex	access:private
BranchSt	/usr/include/opencv2/flann/kdtree_index.h	/^    typedef BranchStruct<Tree> BranchSt;$/;"	t	class:cvflann::KDTreeIndex	access:private
BranchSt	/usr/include/opencv2/flann/kmeans_index.h	/^    typedef BranchStruct<KMeansNode> BranchSt;$/;"	t	class:cvflann::KMeansIndex	access:private
BranchStruct	/usr/include/opencv2/flann/result_set.h	/^struct BranchStruct {$/;"	s	namespace:cvflann
BriefDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    BriefDescriptorExtractor( int bytes = 32 );$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:( int bytes = 32 )
BriefDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS BriefDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
BruteForceMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    BruteForceMatcher( Distance d = Distance() ) : distance(d) {}$/;"	f	class:cv::BruteForceMatcher	access:public	signature:( Distance d = Distance() )
BruteForceMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS BruteForceMatcher : public DescriptorMatcher$/;"	c	namespace:cv	inherits:DescriptorMatcher
ButtonCallback	/usr/include/opencv2/highgui/highgui.hpp	/^typedef void (CV_CDECL *ButtonCallback)(int state, void* userdata);$/;"	t	namespace:cv
C	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      C;  \/\/ for CV_SVM_C_SVC, CV_SVM_EPS_SVR and CV_SVM_NU_SVR$/;"	m	struct:CvSVMParams	access:public
C	/usr/include/opencv2/ml/ml.hpp	/^    double C[2];  \/\/ C[0] == Cn, C[1] == Cp$/;"	m	class:CvSVMSolver	access:public
C	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
CALC_J	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon66
CALIB_CB_ADAPTIVE_THRESH	/usr/include/opencv2/calib3d/calib3d.hpp	/^enum { CALIB_CB_ADAPTIVE_THRESH = 1, CALIB_CB_NORMALIZE_IMAGE = 2,$/;"	e	enum:cv::__anon68
CALIB_CB_FAST_CHECK	/usr/include/opencv2/calib3d/calib3d.hpp	/^       CALIB_CB_FILTER_QUADS = 4, CALIB_CB_FAST_CHECK = 8 };$/;"	e	enum:cv::__anon68
CALIB_CB_FILTER_QUADS	/usr/include/opencv2/calib3d/calib3d.hpp	/^       CALIB_CB_FILTER_QUADS = 4, CALIB_CB_FAST_CHECK = 8 };$/;"	e	enum:cv::__anon68
CALIB_CB_NORMALIZE_IMAGE	/usr/include/opencv2/calib3d/calib3d.hpp	/^enum { CALIB_CB_ADAPTIVE_THRESH = 1, CALIB_CB_NORMALIZE_IMAGE = 2,$/;"	e	enum:cv::__anon68
CALIB_FIX_ASPECT_RATIO	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_ASPECT_RATIO = CV_CALIB_FIX_ASPECT_RATIO,$/;"	e	enum:cv::__anon69
CALIB_FIX_FOCAL_LENGTH	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_FOCAL_LENGTH = CV_CALIB_FIX_FOCAL_LENGTH,$/;"	e	enum:cv::__anon69
CALIB_FIX_INTRINSIC	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_INTRINSIC = CV_CALIB_FIX_INTRINSIC,$/;"	e	enum:cv::__anon69
CALIB_FIX_K1	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K1 = CV_CALIB_FIX_K1,$/;"	e	enum:cv::__anon69
CALIB_FIX_K2	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K2 = CV_CALIB_FIX_K2,$/;"	e	enum:cv::__anon69
CALIB_FIX_K3	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K3 = CV_CALIB_FIX_K3,$/;"	e	enum:cv::__anon69
CALIB_FIX_K4	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K4 = CV_CALIB_FIX_K4,$/;"	e	enum:cv::__anon69
CALIB_FIX_K5	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K5 = CV_CALIB_FIX_K5,$/;"	e	enum:cv::__anon69
CALIB_FIX_K6	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K6 = CV_CALIB_FIX_K6,$/;"	e	enum:cv::__anon69
CALIB_FIX_PRINCIPAL_POINT	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_PRINCIPAL_POINT = CV_CALIB_FIX_PRINCIPAL_POINT,$/;"	e	enum:cv::__anon69
CALIB_RATIONAL_MODEL	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_RATIONAL_MODEL = CV_CALIB_RATIONAL_MODEL,$/;"	e	enum:cv::__anon69
CALIB_SAME_FOCAL_LENGTH	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_SAME_FOCAL_LENGTH = CV_CALIB_SAME_FOCAL_LENGTH,$/;"	e	enum:cv::__anon69
CALIB_USE_INTRINSIC_GUESS	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_USE_INTRINSIC_GUESS = CV_CALIB_USE_INTRINSIC_GUESS,$/;"	e	enum:cv::__anon69
CALIB_ZERO_DISPARITY	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_ZERO_DISPARITY = CV_CALIB_ZERO_DISPARITY$/;"	e	enum:cv::__anon69
CALIB_ZERO_TANGENT_DIST	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_ZERO_TANGENT_DIST = CV_CALIB_ZERO_TANGENT_DIST,$/;"	e	enum:cv::__anon69
CENTERS_GONZALES	/usr/include/opencv2/flann/general.h	/^	CENTERS_GONZALES = 1,$/;"	e	enum:cvflann::flann_centers_init_t
CENTERS_KMEANSPP	/usr/include/opencv2/flann/general.h	/^	CENTERS_KMEANSPP = 2$/;"	e	enum:cvflann::flann_centers_init_t
CENTERS_RANDOM	/usr/include/opencv2/flann/general.h	/^	CENTERS_RANDOM = 0,$/;"	e	enum:cvflann::flann_centers_init_t
CHAIN_APPROX_NONE	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CHAIN_APPROX_NONE=0,$/;"	e	enum:cv::__anon51
CHAIN_APPROX_SIMPLE	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CHAIN_APPROX_SIMPLE=1,$/;"	e	enum:cv::__anon51
CHAIN_APPROX_TC89_KCOS	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CHAIN_APPROX_TC89_KCOS=3$/;"	e	enum:cv::__anon51
CHAIN_APPROX_TC89_L1	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CHAIN_APPROX_TC89_L1=2,$/;"	e	enum:cv::__anon51
CHECK_ERR	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon66
CHI_SQUARE	/usr/include/opencv2/flann/general.h	/^	CHI_SQUARE = 7,$/;"	e	enum:cvflann::flann_distance_t
CLIQUE_END	/usr/include/opencv2/legacy/legacy.hpp	355;"	d
CLIQUE_FOUND	/usr/include/opencv2/legacy/legacy.hpp	354;"	d
CLIQUE_TIME_OFF	/usr/include/opencv2/legacy/legacy.hpp	353;"	d
CMP_EQ	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
CMP_GE	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
CMP_GT	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
CMP_LE	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
CMP_LT	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
CMP_NE	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
COEF	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
COMPOSITE	/usr/include/opencv2/flann/general.h	/^	COMPOSITE = 3,$/;"	e	enum:cvflann::flann_algorithm_t
COMPRESSION_NONE	/usr/include/opencv2/features2d/features2d.hpp	/^        COMPRESSION_NONE = 0,$/;"	e	enum:cv::FernClassifier::__anon74
COMPRESSION_PCA	/usr/include/opencv2/features2d/features2d.hpp	/^        COMPRESSION_PCA = 2,$/;"	e	enum:cv::FernClassifier::__anon74
COMPRESSION_RANDOM_PROJ	/usr/include/opencv2/features2d/features2d.hpp	/^        COMPRESSION_RANDOM_PROJ = 1,$/;"	e	enum:cv::FernClassifier::__anon74
CONTINUOUS_FLAG	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon142
COUNT	/usr/include/opencv2/core/core.hpp	/^        COUNT=1, \/\/!< the maximum number of iterations or elements to compute$/;"	e	enum:cv::TermCriteria::__anon144
COV_MAT_DIAGONAL	/usr/include/opencv2/ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon81
COV_MAT_GENERIC	/usr/include/opencv2/ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon81
COV_MAT_SPHERICAL	/usr/include/opencv2/ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon81
CP	/usr/include/opencv2/video/tracking.hpp	/^    int CP;                     \/* number of control vector dimensions *\/$/;"	m	struct:CvKalman	access:public
CS	/usr/include/opencv2/flann/general.h	/^	CS        = 7,$/;"	e	enum:cvflann::flann_distance_t
CVAPI	/usr/include/opencv2/core/types_c.h	142;"	d
CVAPI	/usr/include/opencv2/ml/ml.hpp	103;"	d
CVAUX_STR	/usr/include/opencv2/core/version.hpp	55;"	d
CVAUX_STR_EXP	/usr/include/opencv2/core/version.hpp	54;"	d
CVStatus	/usr/include/opencv2/core/types_c.h	/^typedef int CVStatus;$/;"	t
CV_16S	/usr/include/opencv2/core/types_c.h	547;"	d
CV_16SC	/usr/include/opencv2/core/types_c.h	581;"	d
CV_16SC1	/usr/include/opencv2/core/types_c.h	577;"	d
CV_16SC2	/usr/include/opencv2/core/types_c.h	578;"	d
CV_16SC3	/usr/include/opencv2/core/types_c.h	579;"	d
CV_16SC4	/usr/include/opencv2/core/types_c.h	580;"	d
CV_16U	/usr/include/opencv2/core/types_c.h	546;"	d
CV_16UC	/usr/include/opencv2/core/types_c.h	575;"	d
CV_16UC1	/usr/include/opencv2/core/types_c.h	571;"	d
CV_16UC2	/usr/include/opencv2/core/types_c.h	572;"	d
CV_16UC3	/usr/include/opencv2/core/types_c.h	573;"	d
CV_16UC4	/usr/include/opencv2/core/types_c.h	574;"	d
CV_1F	/usr/include/opencv2/core/internal.hpp	317;"	d
CV_32F	/usr/include/opencv2/core/types_c.h	549;"	d
CV_32FC	/usr/include/opencv2/core/types_c.h	593;"	d
CV_32FC1	/usr/include/opencv2/core/types_c.h	589;"	d
CV_32FC2	/usr/include/opencv2/core/types_c.h	590;"	d
CV_32FC3	/usr/include/opencv2/core/types_c.h	591;"	d
CV_32FC4	/usr/include/opencv2/core/types_c.h	592;"	d
CV_32S	/usr/include/opencv2/core/types_c.h	548;"	d
CV_32SC	/usr/include/opencv2/core/types_c.h	587;"	d
CV_32SC1	/usr/include/opencv2/core/types_c.h	583;"	d
CV_32SC2	/usr/include/opencv2/core/types_c.h	584;"	d
CV_32SC3	/usr/include/opencv2/core/types_c.h	585;"	d
CV_32SC4	/usr/include/opencv2/core/types_c.h	586;"	d
CV_64F	/usr/include/opencv2/core/types_c.h	550;"	d
CV_64FC	/usr/include/opencv2/core/types_c.h	599;"	d
CV_64FC1	/usr/include/opencv2/core/types_c.h	595;"	d
CV_64FC2	/usr/include/opencv2/core/types_c.h	596;"	d
CV_64FC3	/usr/include/opencv2/core/types_c.h	597;"	d
CV_64FC4	/usr/include/opencv2/core/types_c.h	598;"	d
CV_8S	/usr/include/opencv2/core/types_c.h	545;"	d
CV_8SC	/usr/include/opencv2/core/types_c.h	569;"	d
CV_8SC1	/usr/include/opencv2/core/types_c.h	565;"	d
CV_8SC2	/usr/include/opencv2/core/types_c.h	566;"	d
CV_8SC3	/usr/include/opencv2/core/types_c.h	567;"	d
CV_8SC4	/usr/include/opencv2/core/types_c.h	568;"	d
CV_8U	/usr/include/opencv2/core/types_c.h	544;"	d
CV_8UC	/usr/include/opencv2/core/types_c.h	563;"	d
CV_8UC1	/usr/include/opencv2/core/types_c.h	559;"	d
CV_8UC2	/usr/include/opencv2/core/types_c.h	560;"	d
CV_8UC3	/usr/include/opencv2/core/types_c.h	561;"	d
CV_8UC4	/usr/include/opencv2/core/types_c.h	562;"	d
CV_AA	/usr/include/opencv2/core/core_c.h	1267;"	d
CV_ADAPTIVE_THRESH_GAUSSIAN_C	/usr/include/opencv2/imgproc/types_c.h	/^    CV_ADAPTIVE_THRESH_GAUSSIAN_C  =1$/;"	e	enum:__anon32
CV_ADAPTIVE_THRESH_MEAN_C	/usr/include/opencv2/imgproc/types_c.h	/^    CV_ADAPTIVE_THRESH_MEAN_C  =0,$/;"	e	enum:__anon32
CV_ADD	/usr/include/opencv2/core/internal.hpp	323;"	d
CV_AND	/usr/include/opencv2/core/internal.hpp	326;"	d
CV_ANDN	/usr/include/opencv2/core/internal.hpp	329;"	d
CV_ARE_CNS_EQ	/usr/include/opencv2/core/types_c.h	678;"	d
CV_ARE_DEPTHS_EQ	/usr/include/opencv2/core/types_c.h	681;"	d
CV_ARE_SIZES_EQ	/usr/include/opencv2/core/types_c.h	684;"	d
CV_ARE_TYPES_EQ	/usr/include/opencv2/core/types_c.h	675;"	d
CV_ARRAY	/usr/include/opencv2/legacy/legacy.hpp	815;"	d
CV_ASSERT	/usr/include/opencv2/core/core_c.h	1847;"	d
CV_AUTOSTEP	/usr/include/opencv2/core/core_c.h	111;"	d
CV_AUTO_STEP	/usr/include/opencv2/core/types_c.h	601;"	d
CV_Assert	/usr/include/opencv2/core/core.hpp	202;"	d
CV_Assert	/usr/include/opencv2/core/core.hpp	206;"	d
CV_BACK	/usr/include/opencv2/core/core_c.h	971;"	d
CV_BADARG_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADARG_ERR      = -49,  \/\/ipp comp$/;"	e	enum:CvStatus
CV_BADCHANNELS_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADCHANNELS_ERR = -47,  \/\/ipp comp$/;"	e	enum:CvStatus
CV_BADCOEF_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADCOEF_ERR     =  -10,$/;"	e	enum:CvStatus
CV_BADCONVERGENCE_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADCONVERGENCE_ERR       = -109,$/;"	e	enum:CvStatus
CV_BADDEPTH_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADDEPTH_ERR             = -107,$/;"	e	enum:CvStatus
CV_BADFACTOR_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADFACTOR_ERR   =  -7,$/;"	e	enum:CvStatus
CV_BADFLAG_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADFLAG_ERR     =  -12,$/;"	e	enum:CvStatus
CV_BADHEADER_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADHEADER_ERR            = -105,$/;"	e	enum:CvStatus
CV_BADMEMBLOCK_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADMEMBLOCK_ERR          = -113,$/;"	e	enum:CvStatus
CV_BADPOINT_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADPOINT_ERR    =  -6,$/;"	e	enum:CvStatus
CV_BADRANGE_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADRANGE_ERR    = -44,  \/\/ipp comp$/;"	e	enum:CvStatus
CV_BADROI_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADROI_ERR               = -106,$/;"	e	enum:CvStatus
CV_BADSCALE_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADSCALE_ERR    =  -4,$/;"	e	enum:CvStatus
CV_BADSIZE_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADSIZE_ERR     =  -1,$/;"	e	enum:CvStatus
CV_BADSTEP_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_BADSTEP_ERR     = -29,  \/\/ipp comp$/;"	e	enum:CvStatus
CV_BGFG_FGD_ALPHA_1	/usr/include/opencv2/video/background_segm.hpp	147;"	d
CV_BGFG_FGD_ALPHA_2	/usr/include/opencv2/video/background_segm.hpp	152;"	d
CV_BGFG_FGD_ALPHA_3	/usr/include/opencv2/video/background_segm.hpp	155;"	d
CV_BGFG_FGD_BG_UPDATE_TRESH	/usr/include/opencv2/video/background_segm.hpp	163;"	d
CV_BGFG_FGD_DELTA	/usr/include/opencv2/video/background_segm.hpp	157;"	d
CV_BGFG_FGD_LC	/usr/include/opencv2/video/background_segm.hpp	138;"	d
CV_BGFG_FGD_LCC	/usr/include/opencv2/video/background_segm.hpp	142;"	d
CV_BGFG_FGD_MINAREA	/usr/include/opencv2/video/background_segm.hpp	161;"	d
CV_BGFG_FGD_N1C	/usr/include/opencv2/video/background_segm.hpp	139;"	d
CV_BGFG_FGD_N1CC	/usr/include/opencv2/video/background_segm.hpp	143;"	d
CV_BGFG_FGD_N2C	/usr/include/opencv2/video/background_segm.hpp	140;"	d
CV_BGFG_FGD_N2CC	/usr/include/opencv2/video/background_segm.hpp	144;"	d
CV_BGFG_FGD_T	/usr/include/opencv2/video/background_segm.hpp	159;"	d
CV_BGFG_MOG_BACKGROUND_THRESHOLD	/usr/include/opencv2/video/background_segm.hpp	254;"	d
CV_BGFG_MOG_MAX_NGAUSSIANS	/usr/include/opencv2/video/background_segm.hpp	251;"	d
CV_BGFG_MOG_MINAREA	/usr/include/opencv2/video/background_segm.hpp	260;"	d
CV_BGFG_MOG_NCOLORS	/usr/include/opencv2/video/background_segm.hpp	263;"	d
CV_BGFG_MOG_NGAUSSIANS	/usr/include/opencv2/video/background_segm.hpp	257;"	d
CV_BGFG_MOG_SIGMA_INIT	/usr/include/opencv2/video/background_segm.hpp	259;"	d
CV_BGFG_MOG_STD_THRESHOLD	/usr/include/opencv2/video/background_segm.hpp	255;"	d
CV_BGFG_MOG_WEIGHT_INIT	/usr/include/opencv2/video/background_segm.hpp	258;"	d
CV_BGFG_MOG_WINDOW_SIZE	/usr/include/opencv2/video/background_segm.hpp	256;"	d
CV_BGR2BGR555	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2BGR555  =22,$/;"	e	enum:__anon17
CV_BGR2BGR565	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2BGR565  =12,$/;"	e	enum:__anon17
CV_BGR2BGRA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2BGRA    =0,$/;"	e	enum:__anon17
CV_BGR2GRAY	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2GRAY    =6,$/;"	e	enum:__anon17
CV_BGR2HLS	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2HLS     =52,$/;"	e	enum:__anon17
CV_BGR2HLS_FULL	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2HLS_FULL = 68,$/;"	e	enum:__anon17
CV_BGR2HSV	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2HSV     =40,$/;"	e	enum:__anon17
CV_BGR2HSV_FULL	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2HSV_FULL = 66,$/;"	e	enum:__anon17
CV_BGR2Lab	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2Lab     =44,$/;"	e	enum:__anon17
CV_BGR2Luv	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2Luv     =50,$/;"	e	enum:__anon17
CV_BGR2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2RGB     =4,$/;"	e	enum:__anon17
CV_BGR2RGBA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2RGBA    =2,$/;"	e	enum:__anon17
CV_BGR2XYZ	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2XYZ     =32,$/;"	e	enum:__anon17
CV_BGR2YCrCb	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2YCrCb   =36,$/;"	e	enum:__anon17
CV_BGR2YUV	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR2YUV      = 82,$/;"	e	enum:__anon17
CV_BGR5552BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR5552BGR  =24,$/;"	e	enum:__anon17
CV_BGR5552BGRA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR5552BGRA =28,$/;"	e	enum:__anon17
CV_BGR5552GRAY	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR5552GRAY =31,$/;"	e	enum:__anon17
CV_BGR5552RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR5552RGB  =25,$/;"	e	enum:__anon17
CV_BGR5552RGBA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR5552RGBA =29,$/;"	e	enum:__anon17
CV_BGR5652BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR5652BGR  =14,$/;"	e	enum:__anon17
CV_BGR5652BGRA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR5652BGRA =18,$/;"	e	enum:__anon17
CV_BGR5652GRAY	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR5652GRAY =21,$/;"	e	enum:__anon17
CV_BGR5652RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR5652RGB  =15,$/;"	e	enum:__anon17
CV_BGR5652RGBA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGR5652RGBA =19,$/;"	e	enum:__anon17
CV_BGRA2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGRA2BGR    =1,$/;"	e	enum:__anon17
CV_BGRA2BGR555	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGRA2BGR555 =26,$/;"	e	enum:__anon17
CV_BGRA2BGR565	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGRA2BGR565 =16,$/;"	e	enum:__anon17
CV_BGRA2GRAY	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGRA2GRAY   =10,$/;"	e	enum:__anon17
CV_BGRA2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGRA2RGB    =CV_RGBA2BGR,$/;"	e	enum:__anon17
CV_BGRA2RGBA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BGRA2RGBA   =5,$/;"	e	enum:__anon17
CV_BG_MODEL_FGD	/usr/include/opencv2/video/background_segm.hpp	86;"	d
CV_BG_MODEL_FGD_SIMPLE	/usr/include/opencv2/video/background_segm.hpp	88;"	d
CV_BG_MODEL_MOG	/usr/include/opencv2/video/background_segm.hpp	87;"	d
CV_BG_STAT_MODEL_FIELDS	/usr/include/opencv2/video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvBGStatModel	access:public	signature:()
CV_BG_STAT_MODEL_FIELDS	/usr/include/opencv2/video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvFGDStatModel	access:public	signature:()
CV_BG_STAT_MODEL_FIELDS	/usr/include/opencv2/video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvGaussBGModel	access:public	signature:()
CV_BG_STAT_MODEL_FIELDS	/usr/include/opencv2/video/background_segm.hpp	96;"	d
CV_BIG_INT	/usr/include/opencv2/core/internal.hpp	291;"	d
CV_BIG_UINT	/usr/include/opencv2/core/internal.hpp	292;"	d
CV_BILATERAL	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BILATERAL =4$/;"	e	enum:__anon13
CV_BLOB_CENTER	/usr/include/opencv2/legacy/blobtrack.hpp	168;"	d
CV_BLOB_ID	/usr/include/opencv2/legacy/blobtrack.hpp	167;"	d
CV_BLOB_MINH	/usr/include/opencv2/legacy/blobtrack.hpp	166;"	d
CV_BLOB_MINW	/usr/include/opencv2/legacy/blobtrack.hpp	165;"	d
CV_BLOB_RECT	/usr/include/opencv2/legacy/blobtrack.hpp	175;"	d
CV_BLOB_RX	/usr/include/opencv2/legacy/blobtrack.hpp	173;"	d
CV_BLOB_RY	/usr/include/opencv2/legacy/blobtrack.hpp	174;"	d
CV_BLOB_WX	/usr/include/opencv2/legacy/blobtrack.hpp	171;"	d
CV_BLOB_WY	/usr/include/opencv2/legacy/blobtrack.hpp	172;"	d
CV_BLOB_X	/usr/include/opencv2/legacy/blobtrack.hpp	169;"	d
CV_BLOB_Y	/usr/include/opencv2/legacy/blobtrack.hpp	170;"	d
CV_BLUR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BLUR  =1,$/;"	e	enum:__anon13
CV_BLUR_NO_SCALE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BLUR_NO_SCALE =0,$/;"	e	enum:__anon13
CV_BT_HIST_TYPE_H	/usr/include/opencv2/legacy/blobtrack.hpp	873;"	d
CV_BT_HIST_TYPE_MG	/usr/include/opencv2/legacy/blobtrack.hpp	871;"	d
CV_BT_HIST_TYPE_MG2	/usr/include/opencv2/legacy/blobtrack.hpp	872;"	d
CV_BT_HIST_TYPE_S	/usr/include/opencv2/legacy/blobtrack.hpp	870;"	d
CV_BadAlign	/usr/include/opencv2/core/types_c.h	/^ CV_BadAlign=                  -21, \/**\/$/;"	e	enum:__anon93
CV_BadAlphaChannel	/usr/include/opencv2/core/types_c.h	/^ CV_BadAlphaChannel=           -18, \/**\/$/;"	e	enum:__anon93
CV_BadCOI	/usr/include/opencv2/core/types_c.h	/^ CV_BadCOI=                    -24, \/**\/$/;"	e	enum:__anon93
CV_BadCallBack	/usr/include/opencv2/core/types_c.h	/^ CV_BadCallBack=               -22, \/**\/$/;"	e	enum:__anon93
CV_BadDataPtr	/usr/include/opencv2/core/types_c.h	/^ CV_BadDataPtr=                -12, \/**\/$/;"	e	enum:__anon93
CV_BadDepth	/usr/include/opencv2/core/types_c.h	/^ CV_BadDepth=                  -17, \/**\/$/;"	e	enum:__anon93
CV_BadImageSize	/usr/include/opencv2/core/types_c.h	/^ CV_BadImageSize=              -10, \/* image size is invalid           *\/$/;"	e	enum:__anon93
CV_BadModelOrChSeq	/usr/include/opencv2/core/types_c.h	/^ CV_BadModelOrChSeq=           -14, \/**\/$/;"	e	enum:__anon93
CV_BadNumChannel1U	/usr/include/opencv2/core/types_c.h	/^ CV_BadNumChannel1U=           -16, \/**\/$/;"	e	enum:__anon93
CV_BadNumChannels	/usr/include/opencv2/core/types_c.h	/^ CV_BadNumChannels=            -15, \/**\/$/;"	e	enum:__anon93
CV_BadOffset	/usr/include/opencv2/core/types_c.h	/^ CV_BadOffset=                 -11, \/* offset is invalid               *\/$/;"	e	enum:__anon93
CV_BadOrder	/usr/include/opencv2/core/types_c.h	/^ CV_BadOrder=                  -19, \/**\/$/;"	e	enum:__anon93
CV_BadOrigin	/usr/include/opencv2/core/types_c.h	/^ CV_BadOrigin=                 -20, \/**\/$/;"	e	enum:__anon93
CV_BadROISize	/usr/include/opencv2/core/types_c.h	/^ CV_BadROISize=                -25, \/**\/$/;"	e	enum:__anon93
CV_BadStep	/usr/include/opencv2/core/types_c.h	/^ CV_BadStep=                   -13, \/**\/$/;"	e	enum:__anon93
CV_BadTileSize	/usr/include/opencv2/core/types_c.h	/^ CV_BadTileSize=               -23, \/**\/$/;"	e	enum:__anon93
CV_BayerBG2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerBG2BGR =46,$/;"	e	enum:__anon17
CV_BayerBG2BGR_VNG	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerBG2BGR_VNG =62,$/;"	e	enum:__anon17
CV_BayerBG2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerBG2RGB =CV_BayerRG2BGR,$/;"	e	enum:__anon17
CV_BayerBG2RGB_VNG	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerBG2RGB_VNG =CV_BayerRG2BGR_VNG,$/;"	e	enum:__anon17
CV_BayerGB2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerGB2BGR =47,$/;"	e	enum:__anon17
CV_BayerGB2BGR_VNG	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerGB2BGR_VNG =63,$/;"	e	enum:__anon17
CV_BayerGB2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerGB2RGB =CV_BayerGR2BGR,$/;"	e	enum:__anon17
CV_BayerGB2RGB_VNG	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerGB2RGB_VNG =CV_BayerGR2BGR_VNG,$/;"	e	enum:__anon17
CV_BayerGR2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerGR2BGR =49,$/;"	e	enum:__anon17
CV_BayerGR2BGR_VNG	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerGR2BGR_VNG =65,$/;"	e	enum:__anon17
CV_BayerGR2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerGR2RGB =CV_BayerGB2BGR,$/;"	e	enum:__anon17
CV_BayerGR2RGB_VNG	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerGR2RGB_VNG =CV_BayerGB2BGR_VNG,$/;"	e	enum:__anon17
CV_BayerRG2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerRG2BGR =48,$/;"	e	enum:__anon17
CV_BayerRG2BGR_VNG	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerRG2BGR_VNG =64,$/;"	e	enum:__anon17
CV_BayerRG2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerRG2RGB =CV_BayerBG2BGR,$/;"	e	enum:__anon17
CV_BayerRG2RGB_VNG	/usr/include/opencv2/imgproc/types_c.h	/^    CV_BayerRG2RGB_VNG =CV_BayerBG2BGR_VNG,$/;"	e	enum:__anon17
CV_C	/usr/include/opencv2/core/core_c.h	839;"	d
CV_CALIB_CB_ADAPTIVE_THRESH	/usr/include/opencv2/calib3d/calib3d.hpp	192;"	d
CV_CALIB_CB_FAST_CHECK	/usr/include/opencv2/calib3d/calib3d.hpp	195;"	d
CV_CALIB_CB_FILTER_QUADS	/usr/include/opencv2/calib3d/calib3d.hpp	194;"	d
CV_CALIB_CB_NORMALIZE_IMAGE	/usr/include/opencv2/calib3d/calib3d.hpp	193;"	d
CV_CALIB_ETALON_CHECKERBOARD	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_CALIB_ETALON_CHECKERBOARD = CV_CALIB_ETALON_CHESSBOARD$/;"	e	enum:CvCalibEtalonType
CV_CALIB_ETALON_CHESSBOARD	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_CALIB_ETALON_CHESSBOARD = 0,$/;"	e	enum:CvCalibEtalonType
CV_CALIB_ETALON_USER	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_CALIB_ETALON_USER = -1,$/;"	e	enum:CvCalibEtalonType
CV_CALIB_FIX_ASPECT_RATIO	/usr/include/opencv2/calib3d/calib3d.hpp	218;"	d
CV_CALIB_FIX_FOCAL_LENGTH	/usr/include/opencv2/calib3d/calib3d.hpp	221;"	d
CV_CALIB_FIX_INTRINSIC	/usr/include/opencv2/calib3d/calib3d.hpp	254;"	d
CV_CALIB_FIX_K1	/usr/include/opencv2/calib3d/calib3d.hpp	222;"	d
CV_CALIB_FIX_K2	/usr/include/opencv2/calib3d/calib3d.hpp	223;"	d
CV_CALIB_FIX_K3	/usr/include/opencv2/calib3d/calib3d.hpp	224;"	d
CV_CALIB_FIX_K4	/usr/include/opencv2/calib3d/calib3d.hpp	225;"	d
CV_CALIB_FIX_K5	/usr/include/opencv2/calib3d/calib3d.hpp	226;"	d
CV_CALIB_FIX_K6	/usr/include/opencv2/calib3d/calib3d.hpp	227;"	d
CV_CALIB_FIX_PRINCIPAL_POINT	/usr/include/opencv2/calib3d/calib3d.hpp	219;"	d
CV_CALIB_RATIONAL_MODEL	/usr/include/opencv2/calib3d/calib3d.hpp	228;"	d
CV_CALIB_SAME_FOCAL_LENGTH	/usr/include/opencv2/calib3d/calib3d.hpp	255;"	d
CV_CALIB_USE_INTRINSIC_GUESS	/usr/include/opencv2/calib3d/calib3d.hpp	217;"	d
CV_CALIB_ZERO_DISPARITY	/usr/include/opencv2/calib3d/calib3d.hpp	270;"	d
CV_CALIB_ZERO_TANGENT_DIST	/usr/include/opencv2/calib3d/calib3d.hpp	220;"	d
CV_CALL	/usr/include/opencv2/core/core_c.h	1839;"	d
CV_CAMERA_TO_WARP	/usr/include/opencv2/legacy/legacy.hpp	563;"	d
CV_CANNY_L2_GRADIENT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_CANNY_L2_GRADIENT  =(1 << 31)$/;"	e	enum:__anon34
CV_CAP_ANY	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_ANY      =0,     \/\/ autodetect$/;"	e	enum:__anon11
CV_CAP_CMU1394	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_CMU1394  =300,$/;"	e	enum:__anon11
CV_CAP_DC1394	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_DC1394   =300,$/;"	e	enum:__anon11
CV_CAP_DSHOW	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_DSHOW    =700,   \/\/ DirectShow (via videoInput)$/;"	e	enum:__anon11
CV_CAP_FIREWARE	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_FIREWARE =300,   \/\/ IEEE 1394 drivers$/;"	e	enum:__anon11
CV_CAP_FIREWIRE	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_FIREWIRE =300,$/;"	e	enum:__anon11
CV_CAP_IEEE1394	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_IEEE1394 =300,$/;"	e	enum:__anon11
CV_CAP_MIL	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_MIL      =100,   \/\/ MIL proprietary drivers$/;"	e	enum:__anon11
CV_CAP_PROP_BRIGHTNESS	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_BRIGHTNESS    =10,$/;"	e	enum:__anon12
CV_CAP_PROP_CONTRAST	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_CONTRAST      =11,$/;"	e	enum:__anon12
CV_CAP_PROP_CONVERT_RGB	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_CONVERT_RGB   =16,$/;"	e	enum:__anon12
CV_CAP_PROP_EXPOSURE	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_EXPOSURE      =15,$/;"	e	enum:__anon12
CV_CAP_PROP_FORMAT	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_FORMAT         =8,$/;"	e	enum:__anon12
CV_CAP_PROP_FOURCC	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_FOURCC         =6,$/;"	e	enum:__anon12
CV_CAP_PROP_FPS	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_FPS            =5,$/;"	e	enum:__anon12
CV_CAP_PROP_FRAME_COUNT	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_FRAME_COUNT    =7,$/;"	e	enum:__anon12
CV_CAP_PROP_FRAME_HEIGHT	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_FRAME_HEIGHT   =4,$/;"	e	enum:__anon12
CV_CAP_PROP_FRAME_WIDTH	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_FRAME_WIDTH    =3,$/;"	e	enum:__anon12
CV_CAP_PROP_GAIN	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_GAIN          =14,$/;"	e	enum:__anon12
CV_CAP_PROP_HUE	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_HUE           =13,$/;"	e	enum:__anon12
CV_CAP_PROP_MODE	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_MODE           =9,$/;"	e	enum:__anon12
CV_CAP_PROP_MONOCROME	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_MONOCROME	  =19$/;"	e	enum:__anon12
CV_CAP_PROP_POS_AVI_RATIO	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_POS_AVI_RATIO  =2,$/;"	e	enum:__anon12
CV_CAP_PROP_POS_FRAMES	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_POS_FRAMES     =1,$/;"	e	enum:__anon12
CV_CAP_PROP_POS_MSEC	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_POS_MSEC       =0,$/;"	e	enum:__anon12
CV_CAP_PROP_RECTIFICATION	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_RECTIFICATION =18,$/;"	e	enum:__anon12
CV_CAP_PROP_SATURATION	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_SATURATION    =12,$/;"	e	enum:__anon12
CV_CAP_PROP_WHITE_BALANCE	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PROP_WHITE_BALANCE =17,$/;"	e	enum:__anon12
CV_CAP_PVAPI	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_PVAPI    =800   \/\/ PvAPI, Prosilica GigE SDK$/;"	e	enum:__anon11
CV_CAP_QT	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_QT       =500,   \/\/ QuickTime$/;"	e	enum:__anon11
CV_CAP_STEREO	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_STEREO   =400,   \/\/ TYZX proprietary drivers$/;"	e	enum:__anon11
CV_CAP_TYZX	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_TYZX     =400,$/;"	e	enum:__anon11
CV_CAP_UNICAP	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_UNICAP   =600,   \/\/ Unicap drivers$/;"	e	enum:__anon11
CV_CAP_V4L	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_V4L      =200,$/;"	e	enum:__anon11
CV_CAP_V4L2	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_V4L2     =200,$/;"	e	enum:__anon11
CV_CAP_VFW	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CAP_VFW      =200,   \/\/ platform native$/;"	e	enum:__anon11
CV_CARRAY	/usr/include/opencv2/core/types_c.h	161;"	d
CV_CAST_16S	/usr/include/opencv2/core/internal.hpp	347;"	d
CV_CAST_16U	/usr/include/opencv2/core/internal.hpp	346;"	d
CV_CAST_32F	/usr/include/opencv2/core/internal.hpp	350;"	d
CV_CAST_32S	/usr/include/opencv2/core/internal.hpp	348;"	d
CV_CAST_64F	/usr/include/opencv2/core/internal.hpp	351;"	d
CV_CAST_64S	/usr/include/opencv2/core/internal.hpp	349;"	d
CV_CAST_8S	/usr/include/opencv2/core/internal.hpp	345;"	d
CV_CAST_8U	/usr/include/opencv2/core/internal.hpp	344;"	d
CV_CDECL	/usr/include/opencv2/core/types_c.h	100;"	d
CV_CDECL	/usr/include/opencv2/core/types_c.h	103;"	d
CV_CDECL	/usr/include/opencv2/ml/ml.hpp	61;"	d
CV_CDECL	/usr/include/opencv2/ml/ml.hpp	64;"	d
CV_CHAIN_APPROX_NONE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_CHAIN_APPROX_NONE=1,$/;"	e	enum:__anon24
CV_CHAIN_APPROX_SIMPLE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_CHAIN_APPROX_SIMPLE=2,$/;"	e	enum:__anon24
CV_CHAIN_APPROX_TC89_KCOS	/usr/include/opencv2/imgproc/types_c.h	/^    CV_CHAIN_APPROX_TC89_KCOS=4,$/;"	e	enum:__anon24
CV_CHAIN_APPROX_TC89_L1	/usr/include/opencv2/imgproc/types_c.h	/^    CV_CHAIN_APPROX_TC89_L1=3,$/;"	e	enum:__anon24
CV_CHAIN_CODE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_CHAIN_CODE=0,$/;"	e	enum:__anon24
CV_CHECK	/usr/include/opencv2/core/core_c.h	1827;"	d
CV_CHECKBOX	/usr/include/opencv2/highgui/highgui_c.h	/^enum {CV_PUSH_BUTTON = 0, CV_CHECKBOX = 1, CV_RADIOBOX = 2};$/;"	e	enum:__anon4
CV_CHECK_NANS	/usr/include/opencv2/core/internal.hpp	257;"	d
CV_CHECK_QUIET	/usr/include/opencv2/core/core_c.h	642;"	d
CV_CHECK_RANGE	/usr/include/opencv2/core/core_c.h	641;"	d
CV_CHOLESKY	/usr/include/opencv2/core/core_c.h	740;"	d
CV_CLOCKWISE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_CLOCKWISE         =1,$/;"	e	enum:__anon27
CV_CMP	/usr/include/opencv2/core/types_c.h	281;"	d
CV_CMP_EQ	/usr/include/opencv2/core/core_c.h	565;"	d
CV_CMP_GE	/usr/include/opencv2/core/core_c.h	567;"	d
CV_CMP_GT	/usr/include/opencv2/core/core_c.h	566;"	d
CV_CMP_LE	/usr/include/opencv2/core/core_c.h	569;"	d
CV_CMP_LT	/usr/include/opencv2/core/core_c.h	568;"	d
CV_CMP_NE	/usr/include/opencv2/core/core_c.h	570;"	d
CV_CN_MAX	/usr/include/opencv2/core/types_c.h	540;"	d
CV_CN_SHIFT	/usr/include/opencv2/core/types_c.h	541;"	d
CV_COLORCVT_MAX	/usr/include/opencv2/imgproc/types_c.h	/^    CV_COLORCVT_MAX  =100$/;"	e	enum:__anon17
CV_COL_SAMPLE	/usr/include/opencv2/ml/ml.hpp	123;"	d
CV_COMP_BHATTACHARYYA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_COMP_BHATTACHARYYA =3$/;"	e	enum:__anon28
CV_COMP_CHISQR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_COMP_CHISQR        =1,$/;"	e	enum:__anon28
CV_COMP_CORREL	/usr/include/opencv2/imgproc/types_c.h	/^    CV_COMP_CORREL        =0,$/;"	e	enum:__anon28
CV_COMP_INTERSECT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_COMP_INTERSECT     =2,$/;"	e	enum:__anon28
CV_CONTOURS_MATCH_I1	/usr/include/opencv2/imgproc/types_c.h	/^    CV_CONTOURS_MATCH_I1  =1,$/;"	e	enum:__anon26
CV_CONTOURS_MATCH_I2	/usr/include/opencv2/imgproc/types_c.h	/^    CV_CONTOURS_MATCH_I2  =2,$/;"	e	enum:__anon26
CV_CONTOURS_MATCH_I3	/usr/include/opencv2/imgproc/types_c.h	/^    CV_CONTOURS_MATCH_I3  =3$/;"	e	enum:__anon26
CV_CONTOUR_FIELDS	/usr/include/opencv2/core/types_c.h	1428;"	d
CV_CONTOUR_TREES_MATCH_I1	/usr/include/opencv2/legacy/legacy.hpp	/^enum { CV_CONTOUR_TREES_MATCH_I1 = 1 };$/;"	e	enum:__anon172
CV_COUNT	/usr/include/opencv2/ml/ml.hpp	2079;"	d
CV_COUNTER_CLOCKWISE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_COUNTER_CLOCKWISE =2$/;"	e	enum:__anon27
CV_COUNT_OBS	/usr/include/opencv2/legacy/legacy.hpp	174;"	d
CV_COVAR_COLS	/usr/include/opencv2/core/core_c.h	794;"	d
CV_COVAR_NORMAL	/usr/include/opencv2/core/core_c.h	781;"	d
CV_COVAR_ROWS	/usr/include/opencv2/core/core_c.h	791;"	d
CV_COVAR_SCALE	/usr/include/opencv2/core/core_c.h	788;"	d
CV_COVAR_SCRAMBLED	/usr/include/opencv2/core/core_c.h	778;"	d
CV_COVAR_USE_AVG	/usr/include/opencv2/core/core_c.h	785;"	d
CV_CPU_AVX	/usr/include/opencv2/core/core_c.h	1708;"	d
CV_CPU_MMX	/usr/include/opencv2/core/core_c.h	1701;"	d
CV_CPU_NONE	/usr/include/opencv2/core/core_c.h	1700;"	d
CV_CPU_SSE	/usr/include/opencv2/core/core_c.h	1702;"	d
CV_CPU_SSE2	/usr/include/opencv2/core/core_c.h	1703;"	d
CV_CPU_SSE3	/usr/include/opencv2/core/core_c.h	1704;"	d
CV_CPU_SSE4_1	/usr/include/opencv2/core/core_c.h	1706;"	d
CV_CPU_SSE4_2	/usr/include/opencv2/core/core_c.h	1707;"	d
CV_CPU_SSSE3	/usr/include/opencv2/core/core_c.h	1705;"	d
CV_CURRENT_INT	/usr/include/opencv2/legacy/legacy.hpp	280;"	d
CV_CURRENT_POINT	/usr/include/opencv2/core/types_c.h	1687;"	d
CV_CUSTOM_CARRAY	/usr/include/opencv2/core/types_c.h	162;"	d
CV_CVTIMG_FLIP	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CVTIMG_FLIP      =1,$/;"	e	enum:__anon10
CV_CVTIMG_SWAP_RB	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_CVTIMG_SWAP_RB   =2$/;"	e	enum:__anon10
CV_DBG_BREAK	/usr/include/opencv2/core/internal.hpp	302;"	d
CV_DECL_ALIGNED	/usr/include/opencv2/core/internal.hpp	280;"	d
CV_DEFAULT	/usr/include/opencv2/core/core_c.h	/^                               CvFreeFunc free_func CV_DEFAULT(NULL),$/;"	p	signature:(NULL)
CV_DEFAULT	/usr/include/opencv2/core/core_c.h	/^                               void* userdata CV_DEFAULT(NULL));$/;"	p	signature:(NULL)
CV_DEFAULT	/usr/include/opencv2/core/core_c.h	/^CVAPI(void) cvSetMemoryManager( CvAllocFunc alloc_func CV_DEFAULT(NULL),$/;"	p	signature:(NULL)
CV_DEFAULT	/usr/include/opencv2/core/types_c.h	110;"	d
CV_DEFAULT	/usr/include/opencv2/core/types_c.h	113;"	d
CV_DEFAULT	/usr/include/opencv2/ml/ml.hpp	71;"	d
CV_DEFAULT	/usr/include/opencv2/ml/ml.hpp	74;"	d
CV_DEFAULT_IMAGE_ROW_ALIGN	/usr/include/opencv2/core/internal.hpp	224;"	d
CV_DEFAULT_MAT_ROW_ALIGN	/usr/include/opencv2/core/internal.hpp	227;"	d
CV_DEPTH_MAX	/usr/include/opencv2/core/types_c.h	542;"	d
CV_DESCALE	/usr/include/opencv2/core/internal.hpp	385;"	d
CV_DIFF	/usr/include/opencv2/core/core_c.h	844;"	d
CV_DIFF_C	/usr/include/opencv2/core/core_c.h	847;"	d
CV_DIFF_L1	/usr/include/opencv2/core/core_c.h	848;"	d
CV_DIFF_L2	/usr/include/opencv2/core/core_c.h	849;"	d
CV_DIM	/usr/include/opencv2/core/internal.hpp	361;"	d
CV_DISPARITY_BIRCHFIELD	/usr/include/opencv2/legacy/legacy.hpp	468;"	d
CV_DIST_C	/usr/include/opencv2/imgproc/types_c.h	/^    CV_DIST_C       =3,   \/* distance = max(|x1-x2|,|y1-y2|) *\/$/;"	e	enum:__anon30
CV_DIST_FAIR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_DIST_FAIR    =5,   \/* distance = c^2(|x|\/c-log(1+|x|\/c)), c = 1.3998 *\/$/;"	e	enum:__anon30
CV_DIST_HUBER	/usr/include/opencv2/imgproc/types_c.h	/^    CV_DIST_HUBER   =7    \/* distance = |x|<c ? x^2\/2 : c(|x|-c\/2), c=1.345 *\/$/;"	e	enum:__anon30
CV_DIST_L1	/usr/include/opencv2/imgproc/types_c.h	/^    CV_DIST_L1      =1,   \/* distance = |x1-x2| + |y1-y2| *\/$/;"	e	enum:__anon30
CV_DIST_L12	/usr/include/opencv2/imgproc/types_c.h	/^    CV_DIST_L12     =4,   \/* L1-L2 metric: distance = 2(sqrt(1+x*x\/2) - 1)) *\/$/;"	e	enum:__anon30
CV_DIST_L2	/usr/include/opencv2/imgproc/types_c.h	/^    CV_DIST_L2      =2,   \/* the simple euclidean distance *\/$/;"	e	enum:__anon30
CV_DIST_MASK_3	/usr/include/opencv2/imgproc/types_c.h	/^    CV_DIST_MASK_3   =3,$/;"	e	enum:__anon29
CV_DIST_MASK_5	/usr/include/opencv2/imgproc/types_c.h	/^    CV_DIST_MASK_5   =5,$/;"	e	enum:__anon29
CV_DIST_MASK_PRECISE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_DIST_MASK_PRECISE =0$/;"	e	enum:__anon29
CV_DIST_USER	/usr/include/opencv2/imgproc/types_c.h	/^    CV_DIST_USER    =-1,  \/* User defined distance *\/$/;"	e	enum:__anon30
CV_DIST_WELSCH	/usr/include/opencv2/imgproc/types_c.h	/^    CV_DIST_WELSCH  =6,   \/* distance = c^2\/2(1-exp(-(x\/c)^2)), c = 2.9846 *\/$/;"	e	enum:__anon30
CV_DIV_BY_ZERO_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_DIV_BY_ZERO_ERR =  -11, \/\/ipp comp$/;"	e	enum:CvStatus
CV_DLL	/usr/include/opencv2/core/internal.hpp	82;"	d
CV_DOMINANT_IPAN	/usr/include/opencv2/legacy/legacy.hpp	310;"	d
CV_DTREE_CAT_DIR	/usr/include/opencv2/ml/ml.hpp	731;"	d
CV_DXT_FORWARD	/usr/include/opencv2/core/core_c.h	877;"	d
CV_DXT_INVERSE	/usr/include/opencv2/core/core_c.h	878;"	d
CV_DXT_INVERSE_SCALE	/usr/include/opencv2/core/core_c.h	881;"	d
CV_DXT_INV_SCALE	/usr/include/opencv2/core/core_c.h	880;"	d
CV_DXT_MUL_CONJ	/usr/include/opencv2/core/core_c.h	883;"	d
CV_DXT_ROWS	/usr/include/opencv2/core/core_c.h	882;"	d
CV_DXT_SCALE	/usr/include/opencv2/core/core_c.h	879;"	d
CV_DbgAssert	/usr/include/opencv2/core/core.hpp	210;"	d
CV_DbgAssert	/usr/include/opencv2/core/core.hpp	212;"	d
CV_EIGOBJ_BOTH_CALLBACK	/usr/include/opencv2/legacy/legacy.hpp	74;"	d
CV_EIGOBJ_INPUT_CALLBACK	/usr/include/opencv2/legacy/legacy.hpp	72;"	d
CV_EIGOBJ_NO_CALLBACK	/usr/include/opencv2/legacy/legacy.hpp	71;"	d
CV_EIGOBJ_OUTPUT_CALLBACK	/usr/include/opencv2/legacy/legacy.hpp	73;"	d
CV_ELEM_SIZE	/usr/include/opencv2/core/types_c.h	696;"	d
CV_ELEM_SIZE1	/usr/include/opencv2/core/types_c.h	692;"	d
CV_EMPTY	/usr/include/opencv2/core/internal.hpp	356;"	d
CV_EQ	/usr/include/opencv2/core/internal.hpp	335;"	d
CV_ERROR	/usr/include/opencv2/core/core_c.h	1812;"	d
CV_ERROR_FROM_CODE	/usr/include/opencv2/core/core_c.h	1819;"	d
CV_EVENT_FLAG_ALTKEY	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_FLAG_ALTKEY    =32$/;"	e	enum:__anon7
CV_EVENT_FLAG_CTRLKEY	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_FLAG_CTRLKEY   =8,$/;"	e	enum:__anon7
CV_EVENT_FLAG_LBUTTON	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_FLAG_LBUTTON   =1,$/;"	e	enum:__anon7
CV_EVENT_FLAG_MBUTTON	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_FLAG_MBUTTON   =4,$/;"	e	enum:__anon7
CV_EVENT_FLAG_RBUTTON	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_FLAG_RBUTTON   =2,$/;"	e	enum:__anon7
CV_EVENT_FLAG_SHIFTKEY	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_FLAG_SHIFTKEY  =16,$/;"	e	enum:__anon7
CV_EVENT_LBUTTONDBLCLK	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_LBUTTONDBLCLK  =7,$/;"	e	enum:__anon6
CV_EVENT_LBUTTONDOWN	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_LBUTTONDOWN    =1,$/;"	e	enum:__anon6
CV_EVENT_LBUTTONUP	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_LBUTTONUP      =4,$/;"	e	enum:__anon6
CV_EVENT_MBUTTONDBLCLK	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_MBUTTONDBLCLK  =9$/;"	e	enum:__anon6
CV_EVENT_MBUTTONDOWN	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_MBUTTONDOWN    =3,$/;"	e	enum:__anon6
CV_EVENT_MBUTTONUP	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_MBUTTONUP      =6,$/;"	e	enum:__anon6
CV_EVENT_MOUSEMOVE	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_MOUSEMOVE      =0,$/;"	e	enum:__anon6
CV_EVENT_RBUTTONDBLCLK	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_RBUTTONDBLCLK  =8,$/;"	e	enum:__anon6
CV_EVENT_RBUTTONDOWN	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_RBUTTONDOWN    =2,$/;"	e	enum:__anon6
CV_EVENT_RBUTTONUP	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_EVENT_RBUTTONUP      =5,$/;"	e	enum:__anon6
CV_EXPORTS	/usr/include/opencv2/core/types_c.h	136;"	d
CV_EXPORTS	/usr/include/opencv2/core/types_c.h	138;"	d
CV_EXPORTS	/usr/include/opencv2/ml/ml.hpp	97;"	d
CV_EXPORTS	/usr/include/opencv2/ml/ml.hpp	99;"	d
CV_EXPORTS_AS	/usr/include/opencv2/core/types_c.h	165;"	d
CV_EXPORTS_W	/usr/include/opencv2/core/types_c.h	163;"	d
CV_EXPORTS_W_MAP	/usr/include/opencv2/core/types_c.h	166;"	d
CV_EXPORTS_W_SIMPLE	/usr/include/opencv2/core/types_c.h	164;"	d
CV_EXTERN_C	/usr/include/opencv2/core/types_c.h	109;"	d
CV_EXTERN_C	/usr/include/opencv2/core/types_c.h	112;"	d
CV_EXTERN_C	/usr/include/opencv2/ml/ml.hpp	70;"	d
CV_EXTERN_C	/usr/include/opencv2/ml/ml.hpp	73;"	d
CV_EXTERN_C_FUNCPTR	/usr/include/opencv2/core/types_c.h	119;"	d
CV_EXTERN_C_FUNCPTR	/usr/include/opencv2/core/types_c.h	121;"	d
CV_EXTERN_C_FUNCPTR	/usr/include/opencv2/ml/ml.hpp	80;"	d
CV_EXTERN_C_FUNCPTR	/usr/include/opencv2/ml/ml.hpp	82;"	d
CV_ErrModeLeaf	/usr/include/opencv2/core/core_c.h	1730;"	d
CV_ErrModeParent	/usr/include/opencv2/core/core_c.h	1731;"	d
CV_ErrModeSilent	/usr/include/opencv2/core/core_c.h	1732;"	d
CV_Error	/usr/include/opencv2/core/core.hpp	200;"	d
CV_Error	/usr/include/opencv2/core/core.hpp	204;"	d
CV_Error_	/usr/include/opencv2/core/core.hpp	201;"	d
CV_Error_	/usr/include/opencv2/core/core.hpp	205;"	d
CV_FACE_ELEMENTS	/usr/include/opencv2/legacy/legacy.hpp	/^enum CV_FACE_ELEMENTS$/;"	g
CV_FACE_LEFT_EYE	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_FACE_LEFT_EYE = 1,$/;"	e	enum:CV_FACE_ELEMENTS
CV_FACE_MOUTH	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_FACE_MOUTH = 0,$/;"	e	enum:CV_FACE_ELEMENTS
CV_FACE_RIGHT_EYE	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_FACE_RIGHT_EYE = 2$/;"	e	enum:CV_FACE_ELEMENTS
CV_FILLED	/usr/include/opencv2/core/core_c.h	1265;"	d
CV_FIRST_VORONOIEDGE2D	/usr/include/opencv2/legacy/legacy.hpp	992;"	d
CV_FLOODFILL_FIXED_RANGE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_FLOODFILL_FIXED_RANGE =(1 << 16),$/;"	e	enum:__anon33
CV_FLOODFILL_MASK_ONLY	/usr/include/opencv2/imgproc/types_c.h	/^    CV_FLOODFILL_MASK_ONLY   =(1 << 17)$/;"	e	enum:__anon33
CV_FLT_TO_FIX	/usr/include/opencv2/core/internal.hpp	386;"	d
CV_FM_7POINT	/usr/include/opencv2/calib3d/calib3d.hpp	78;"	d
CV_FM_8POINT	/usr/include/opencv2/calib3d/calib3d.hpp	79;"	d
CV_FM_LMEDS	/usr/include/opencv2/calib3d/calib3d.hpp	86;"	d
CV_FM_LMEDS_ONLY	/usr/include/opencv2/calib3d/calib3d.hpp	84;"	d
CV_FM_RANSAC	/usr/include/opencv2/calib3d/calib3d.hpp	87;"	d
CV_FM_RANSAC_ONLY	/usr/include/opencv2/calib3d/calib3d.hpp	85;"	d
CV_FONT_BLACK	/usr/include/opencv2/highgui/highgui_c.h	/^		CV_FONT_BLACK 			= 87 \/\/QFont::Black$/;"	e	enum:__anon2
CV_FONT_BOLD	/usr/include/opencv2/highgui/highgui_c.h	/^		CV_FONT_BOLD 			= 75,\/\/QFont::Bold,$/;"	e	enum:__anon2
CV_FONT_DEMIBOLD	/usr/include/opencv2/highgui/highgui_c.h	/^		CV_FONT_DEMIBOLD 		= 63,\/\/QFont::DemiBold,$/;"	e	enum:__anon2
CV_FONT_HERSHEY_COMPLEX	/usr/include/opencv2/core/core_c.h	1362;"	d
CV_FONT_HERSHEY_COMPLEX_SMALL	/usr/include/opencv2/core/core_c.h	1364;"	d
CV_FONT_HERSHEY_DUPLEX	/usr/include/opencv2/core/core_c.h	1361;"	d
CV_FONT_HERSHEY_PLAIN	/usr/include/opencv2/core/core_c.h	1360;"	d
CV_FONT_HERSHEY_SCRIPT_COMPLEX	/usr/include/opencv2/core/core_c.h	1366;"	d
CV_FONT_HERSHEY_SCRIPT_SIMPLEX	/usr/include/opencv2/core/core_c.h	1365;"	d
CV_FONT_HERSHEY_SIMPLEX	/usr/include/opencv2/core/core_c.h	1359;"	d
CV_FONT_HERSHEY_TRIPLEX	/usr/include/opencv2/core/core_c.h	1363;"	d
CV_FONT_ITALIC	/usr/include/opencv2/core/core_c.h	1369;"	d
CV_FONT_LIGHT	/usr/include/opencv2/highgui/highgui_c.h	/^enum {	CV_FONT_LIGHT 			= 25,\/\/QFont::Light,$/;"	e	enum:__anon2
CV_FONT_NORMAL	/usr/include/opencv2/highgui/highgui_c.h	/^		CV_FONT_NORMAL 			= 50,\/\/QFont::Normal,$/;"	e	enum:__anon2
CV_FONT_VECTOR0	/usr/include/opencv2/core/core_c.h	1371;"	d
CV_FOURCC	/usr/include/opencv2/highgui/highgui_c.h	/^CV_INLINE int CV_FOURCC(char c1, char c2, char c3, char c4)$/;"	f	signature:(char c1, char c2, char c3, char c4)
CV_FOURCC_DEFAULT	/usr/include/opencv2/highgui/highgui_c.h	354;"	d
CV_FOURCC_PROMPT	/usr/include/opencv2/highgui/highgui_c.h	353;"	d
CV_FRONT	/usr/include/opencv2/core/core_c.h	970;"	d
CV_FUNCNAME	/usr/include/opencv2/core/core_c.h	1800;"	d
CV_FUNCNAME	/usr/include/opencv2/core/core_c.h	1803;"	d
CV_GAUSSIAN	/usr/include/opencv2/imgproc/types_c.h	/^    CV_GAUSSIAN  =2,$/;"	e	enum:__anon13
CV_GAUSSIAN_5x5	/usr/include/opencv2/imgproc/types_c.h	/^    CV_GAUSSIAN_5x5 = 7$/;"	e	enum:__anon14
CV_GE	/usr/include/opencv2/core/internal.hpp	338;"	d
CV_GEMM_A_T	/usr/include/opencv2/core/core_c.h	682;"	d
CV_GEMM_B_T	/usr/include/opencv2/core/core_c.h	683;"	d
CV_GEMM_C_T	/usr/include/opencv2/core/core_c.h	684;"	d
CV_GET_CURRENT	/usr/include/opencv2/legacy/compat.hpp	399;"	d
CV_GET_SEQ_ELEM	/usr/include/opencv2/core/types_c.h	1613;"	d
CV_GLCMDESC_CLUSTERSHADE	/usr/include/opencv2/legacy/legacy.hpp	841;"	d
CV_GLCMDESC_CLUSTERTENDENCY	/usr/include/opencv2/legacy/legacy.hpp	840;"	d
CV_GLCMDESC_CONTRAST	/usr/include/opencv2/legacy/legacy.hpp	839;"	d
CV_GLCMDESC_CORRELATION	/usr/include/opencv2/legacy/legacy.hpp	842;"	d
CV_GLCMDESC_CORRELATIONINFO1	/usr/include/opencv2/legacy/legacy.hpp	843;"	d
CV_GLCMDESC_CORRELATIONINFO2	/usr/include/opencv2/legacy/legacy.hpp	844;"	d
CV_GLCMDESC_ENERGY	/usr/include/opencv2/legacy/legacy.hpp	837;"	d
CV_GLCMDESC_ENTROPY	/usr/include/opencv2/legacy/legacy.hpp	836;"	d
CV_GLCMDESC_HOMOGENITY	/usr/include/opencv2/legacy/legacy.hpp	838;"	d
CV_GLCMDESC_MAXIMUMPROBABILITY	/usr/include/opencv2/legacy/legacy.hpp	845;"	d
CV_GLCMDESC_OPTIMIZATION_ALLOWDOUBLENEST	/usr/include/opencv2/legacy/legacy.hpp	832;"	d
CV_GLCMDESC_OPTIMIZATION_ALLOWTRIPLENEST	/usr/include/opencv2/legacy/legacy.hpp	833;"	d
CV_GLCMDESC_OPTIMIZATION_HISTOGRAM	/usr/include/opencv2/legacy/legacy.hpp	834;"	d
CV_GLCM_ALL	/usr/include/opencv2/legacy/legacy.hpp	847;"	d
CV_GLCM_DESC	/usr/include/opencv2/legacy/legacy.hpp	849;"	d
CV_GLCM_GLCM	/usr/include/opencv2/legacy/legacy.hpp	848;"	d
CV_GLCM_OPTIMIZATION_HISTOGRAM	/usr/include/opencv2/legacy/legacy.hpp	830;"	d
CV_GLCM_OPTIMIZATION_LUT	/usr/include/opencv2/legacy/legacy.hpp	829;"	d
CV_GLCM_OPTIMIZATION_NONE	/usr/include/opencv2/legacy/legacy.hpp	828;"	d
CV_GRAPH	/usr/include/opencv2/core/types_c.h	1493;"	d
CV_GRAPH_ALL_ITEMS	/usr/include/opencv2/core/core_c.h	1212;"	d
CV_GRAPH_ANY_EDGE	/usr/include/opencv2/core/core_c.h	1207;"	d
CV_GRAPH_BACKTRACKING	/usr/include/opencv2/core/core_c.h	1209;"	d
CV_GRAPH_BACK_EDGE	/usr/include/opencv2/core/core_c.h	1204;"	d
CV_GRAPH_CROSS_EDGE	/usr/include/opencv2/core/core_c.h	1206;"	d
CV_GRAPH_EDGE_FIELDS	/usr/include/opencv2/core/types_c.h	1372;"	d
CV_GRAPH_FIELDS	/usr/include/opencv2/core/types_c.h	1407;"	d
CV_GRAPH_FLAG_ORIENTED	/usr/include/opencv2/core/types_c.h	1491;"	d
CV_GRAPH_FORWARD_EDGE	/usr/include/opencv2/core/core_c.h	1205;"	d
CV_GRAPH_FORWARD_EDGE_FLAG	/usr/include/opencv2/core/core_c.h	1221;"	d
CV_GRAPH_ITEM_VISITED_FLAG	/usr/include/opencv2/core/core_c.h	1215;"	d
CV_GRAPH_NEW_TREE	/usr/include/opencv2/core/core_c.h	1208;"	d
CV_GRAPH_OVER	/usr/include/opencv2/core/core_c.h	1210;"	d
CV_GRAPH_SEARCH_TREE_NODE_FLAG	/usr/include/opencv2/core/core_c.h	1220;"	d
CV_GRAPH_TREE_EDGE	/usr/include/opencv2/core/core_c.h	1203;"	d
CV_GRAPH_VERTEX	/usr/include/opencv2/core/core_c.h	1202;"	d
CV_GRAPH_VERTEX_FIELDS	/usr/include/opencv2/core/types_c.h	1379;"	d
CV_GRAPH_WEIGHTED_EDGE_FIELDS	/usr/include/opencv2/legacy/legacy.hpp	286;"	d
CV_GRAPH_WEIGHTED_VERTEX_FIELDS	/usr/include/opencv2/legacy/legacy.hpp	283;"	d
CV_GRAY2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_GRAY2BGR    =8,$/;"	e	enum:__anon17
CV_GRAY2BGR555	/usr/include/opencv2/imgproc/types_c.h	/^    CV_GRAY2BGR555 =30,$/;"	e	enum:__anon17
CV_GRAY2BGR565	/usr/include/opencv2/imgproc/types_c.h	/^    CV_GRAY2BGR565 =20,$/;"	e	enum:__anon17
CV_GRAY2BGRA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_GRAY2BGRA   =9,$/;"	e	enum:__anon17
CV_GRAY2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_GRAY2RGB    =CV_GRAY2BGR,$/;"	e	enum:__anon17
CV_GRAY2RGBA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_GRAY2RGBA   =CV_GRAY2BGRA,$/;"	e	enum:__anon17
CV_GT	/usr/include/opencv2/core/internal.hpp	337;"	d
CV_GUI_EXPANDED	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_GUI_EXPANDED 		= 0x00000000,\/\/status bar and tool bar$/;"	e	enum:__anon5
CV_GUI_NORMAL	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_GUI_NORMAL 			= 0x00000010,\/\/old fashious way$/;"	e	enum:__anon5
CV_GpuApiCallError	/usr/include/opencv2/core/types_c.h	/^ CV_GpuApiCallError=           -217, $/;"	e	enum:__anon93
CV_GpuNotSupported	/usr/include/opencv2/core/types_c.h	/^ CV_GpuNotSupported=           -216,  $/;"	e	enum:__anon93
CV_GpuNppCallError	/usr/include/opencv2/core/types_c.h	/^ CV_GpuNppCallError=           -218  $/;"	e	enum:__anon93
CV_HAAR_DO_CANNY_PRUNING	/usr/include/opencv2/objdetect/objdetect.hpp	122;"	d
CV_HAAR_DO_ROUGH_SEARCH	/usr/include/opencv2/objdetect/objdetect.hpp	125;"	d
CV_HAAR_FEATURE_MAX	/usr/include/opencv2/objdetect/objdetect.hpp	63;"	d
CV_HAAR_FIND_BIGGEST_OBJECT	/usr/include/opencv2/objdetect/objdetect.hpp	124;"	d
CV_HAAR_MAGIC_VAL	/usr/include/opencv2/objdetect/objdetect.hpp	56;"	d
CV_HAAR_SCALE_IMAGE	/usr/include/opencv2/objdetect/objdetect.hpp	123;"	d
CV_HARDWARE_MAX_FEATURE	/usr/include/opencv2/core/core_c.h	1709;"	d
CV_HIST_ARRAY	/usr/include/opencv2/core/types_c.h	888;"	d
CV_HIST_HAS_RANGES	/usr/include/opencv2/core/types_c.h	917;"	d
CV_HIST_MAGIC_VAL	/usr/include/opencv2/core/types_c.h	882;"	d
CV_HIST_RANGES_FLAG	/usr/include/opencv2/core/types_c.h	886;"	d
CV_HIST_SPARSE	/usr/include/opencv2/core/types_c.h	889;"	d
CV_HIST_TREE	/usr/include/opencv2/core/types_c.h	890;"	d
CV_HIST_UNIFORM	/usr/include/opencv2/core/types_c.h	894;"	d
CV_HIST_UNIFORM_FLAG	/usr/include/opencv2/core/types_c.h	883;"	d
CV_HLS2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HLS2BGR     =60,$/;"	e	enum:__anon17
CV_HLS2BGR_FULL	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HLS2BGR_FULL = 72,$/;"	e	enum:__anon17
CV_HLS2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HLS2RGB     =61,$/;"	e	enum:__anon17
CV_HLS2RGB_FULL	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HLS2RGB_FULL = 73,$/;"	e	enum:__anon17
CV_HOUGH_GRADIENT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HOUGH_GRADIENT =3$/;"	e	enum:__anon35
CV_HOUGH_MULTI_SCALE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HOUGH_MULTI_SCALE =2,$/;"	e	enum:__anon35
CV_HOUGH_PROBABILISTIC	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HOUGH_PROBABILISTIC =1,$/;"	e	enum:__anon35
CV_HOUGH_STANDARD	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HOUGH_STANDARD =0,$/;"	e	enum:__anon35
CV_HSV2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HSV2BGR     =54,$/;"	e	enum:__anon17
CV_HSV2BGR_FULL	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HSV2BGR_FULL = 70,$/;"	e	enum:__anon17
CV_HSV2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HSV2RGB     =55,$/;"	e	enum:__anon17
CV_HSV2RGB_FULL	/usr/include/opencv2/imgproc/types_c.h	/^    CV_HSV2RGB_FULL = 71,$/;"	e	enum:__anon17
CV_HeaderIsNull	/usr/include/opencv2/core/types_c.h	/^ CV_HeaderIsNull=               -9,  \/* image header is NULL            *\/$/;"	e	enum:__anon93
CV_IABS	/usr/include/opencv2/core/types_c.h	277;"	d
CV_IABS	/usr/include/opencv2/core/types_c.h	279;"	d
CV_ICC	/usr/include/opencv2/core/types_c.h	62;"	d
CV_ICC	/usr/include/opencv2/core/types_c.h	64;"	d
CV_ICC	/usr/include/opencv2/core/types_c.h	66;"	d
CV_ICC	/usr/include/opencv2/core/types_c.h	68;"	d
CV_ICC	/usr/include/opencv2/core/types_c.h	70;"	d
CV_IDP_BIRCHFIELD_PARAM1	/usr/include/opencv2/legacy/legacy.hpp	461;"	d
CV_IDP_BIRCHFIELD_PARAM2	/usr/include/opencv2/legacy/legacy.hpp	462;"	d
CV_IDP_BIRCHFIELD_PARAM3	/usr/include/opencv2/legacy/legacy.hpp	463;"	d
CV_IDP_BIRCHFIELD_PARAM4	/usr/include/opencv2/legacy/legacy.hpp	464;"	d
CV_IDP_BIRCHFIELD_PARAM5	/usr/include/opencv2/legacy/legacy.hpp	465;"	d
CV_IMAGE_ELEM	/usr/include/opencv2/core/types_c.h	533;"	d
CV_IMAX	/usr/include/opencv2/core/types_c.h	273;"	d
CV_IMIN	/usr/include/opencv2/core/types_c.h	271;"	d
CV_IMPL	/usr/include/opencv2/core/internal.hpp	299;"	d
CV_IMPLEMENT_QSORT	/usr/include/opencv2/core/internal.hpp	614;"	d
CV_IMPLEMENT_QSORT_EX	/usr/include/opencv2/core/internal.hpp	450;"	d
CV_IMWRITE_JPEG_QUALITY	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_IMWRITE_JPEG_QUALITY =1,$/;"	e	enum:__anon9
CV_IMWRITE_PNG_COMPRESSION	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_IMWRITE_PNG_COMPRESSION =16,$/;"	e	enum:__anon9
CV_IMWRITE_PXM_BINARY	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_IMWRITE_PXM_BINARY =32$/;"	e	enum:__anon9
CV_INIT_3X3_DELTAS	/usr/include/opencv2/imgproc/types_c.h	332;"	d
CV_INIT_FUNC_TAB	/usr/include/opencv2/core/internal.hpp	675;"	d
CV_INIT_PIXEL_POS	/usr/include/opencv2/legacy/compat.hpp	373;"	d
CV_INLINE	/usr/include/opencv2/core/types_c.h	127;"	d
CV_INLINE	/usr/include/opencv2/core/types_c.h	129;"	d
CV_INLINE	/usr/include/opencv2/core/types_c.h	131;"	d
CV_INLINE	/usr/include/opencv2/ml/ml.hpp	88;"	d
CV_INLINE	/usr/include/opencv2/ml/ml.hpp	90;"	d
CV_INLINE	/usr/include/opencv2/ml/ml.hpp	92;"	d
CV_INPAINT_NS	/usr/include/opencv2/imgproc/types_c.h	/^    CV_INPAINT_NS      =0,$/;"	e	enum:__anon15
CV_INPAINT_TELEA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_INPAINT_TELEA   =1$/;"	e	enum:__anon15
CV_INPLACE_NOT_SUPPORTED_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_INPLACE_NOT_SUPPORTED_ERR= -112,$/;"	e	enum:CvStatus
CV_INTER_AREA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_INTER_AREA      =3,$/;"	e	enum:__anon18
CV_INTER_CUBIC	/usr/include/opencv2/imgproc/types_c.h	/^    CV_INTER_CUBIC     =2,$/;"	e	enum:__anon18
CV_INTER_LANCZOS4	/usr/include/opencv2/imgproc/types_c.h	/^    CV_INTER_LANCZOS4  =4$/;"	e	enum:__anon18
CV_INTER_LINEAR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_INTER_LINEAR    =1,$/;"	e	enum:__anon18
CV_INTER_NN	/usr/include/opencv2/imgproc/types_c.h	/^    CV_INTER_NN        =0,$/;"	e	enum:__anon18
CV_IN_OUT	/usr/include/opencv2/core/types_c.h	167;"	d
CV_IS_CONT_MAT	/usr/include/opencv2/core/types_c.h	611;"	d
CV_IS_GRAPH	/usr/include/opencv2/core/types_c.h	1556;"	d
CV_IS_GRAPH_EDGE_VISITED	/usr/include/opencv2/core/core_c.h	1218;"	d
CV_IS_GRAPH_ORIENTED	/usr/include/opencv2/core/types_c.h	1559;"	d
CV_IS_GRAPH_VERTEX_VISITED	/usr/include/opencv2/core/core_c.h	1216;"	d
CV_IS_HAAR_CLASSIFIER	/usr/include/opencv2/objdetect/objdetect.hpp	59;"	d
CV_IS_HIST	/usr/include/opencv2/core/types_c.h	906;"	d
CV_IS_IMAGE	/usr/include/opencv2/core/types_c.h	524;"	d
CV_IS_IMAGE_HDR	/usr/include/opencv2/core/types_c.h	521;"	d
CV_IS_MASK_ARR	/usr/include/opencv2/core/types_c.h	672;"	d
CV_IS_MAT	/usr/include/opencv2/core/types_c.h	669;"	d
CV_IS_MATND	/usr/include/opencv2/core/types_c.h	820;"	d
CV_IS_MATND_HDR	/usr/include/opencv2/core/types_c.h	817;"	d
CV_IS_MAT_CONST	/usr/include/opencv2/core/types_c.h	687;"	d
CV_IS_MAT_CONT	/usr/include/opencv2/core/types_c.h	610;"	d
CV_IS_MAT_HDR	/usr/include/opencv2/core/types_c.h	659;"	d
CV_IS_MAT_HDR_Z	/usr/include/opencv2/core/types_c.h	664;"	d
CV_IS_ROW_SAMPLE	/usr/include/opencv2/ml/ml.hpp	128;"	d
CV_IS_SEQ	/usr/include/opencv2/core/types_c.h	1448;"	d
CV_IS_SEQ_CHAIN	/usr/include/opencv2/core/types_c.h	1543;"	d
CV_IS_SEQ_CHAIN_CONTOUR	/usr/include/opencv2/core/types_c.h	1549;"	d
CV_IS_SEQ_CLOSED	/usr/include/opencv2/core/types_c.h	1525;"	d
CV_IS_SEQ_CONTOUR	/usr/include/opencv2/core/types_c.h	1546;"	d
CV_IS_SEQ_CONVEX	/usr/include/opencv2/core/types_c.h	1526;"	d
CV_IS_SEQ_CURVE	/usr/include/opencv2/core/types_c.h	1524;"	d
CV_IS_SEQ_HOLE	/usr/include/opencv2/core/types_c.h	1527;"	d
CV_IS_SEQ_INDEX	/usr/include/opencv2/core/types_c.h	1521;"	d
CV_IS_SEQ_POINT_SET	/usr/include/opencv2/core/types_c.h	1531;"	d
CV_IS_SEQ_POINT_SUBSET	/usr/include/opencv2/core/types_c.h	1534;"	d
CV_IS_SEQ_POLYGON	/usr/include/opencv2/core/types_c.h	1540;"	d
CV_IS_SEQ_POLYGON_TREE	/usr/include/opencv2/core/types_c.h	1552;"	d
CV_IS_SEQ_POLYLINE	/usr/include/opencv2/core/types_c.h	1537;"	d
CV_IS_SEQ_SIMPLE	/usr/include/opencv2/core/types_c.h	1528;"	d
CV_IS_SET	/usr/include/opencv2/core/types_c.h	1452;"	d
CV_IS_SET_ELEM	/usr/include/opencv2/core/types_c.h	1350;"	d
CV_IS_SET_ELEM_EXISTS	/usr/include/opencv2/legacy/compat.hpp	271;"	d
CV_IS_SPARSE_HIST	/usr/include/opencv2/core/types_c.h	914;"	d
CV_IS_SPARSE_MAT	/usr/include/opencv2/core/types_c.h	853;"	d
CV_IS_SPARSE_MAT_HDR	/usr/include/opencv2/core/types_c.h	849;"	d
CV_IS_STORAGE	/usr/include/opencv2/core/types_c.h	1258;"	d
CV_IS_SUBDIV2D	/usr/include/opencv2/core/types_c.h	1562;"	d
CV_IS_SUBMAT	/usr/include/opencv2/core/types_c.h	614;"	d
CV_IS_UNIFORM_HIST	/usr/include/opencv2/core/types_c.h	911;"	d
CV_KMEANS_USE_INITIAL_LABELS	/usr/include/opencv2/core/core_c.h	1471;"	d
CV_L1	/usr/include/opencv2/core/core_c.h	840;"	d
CV_L2	/usr/include/opencv2/core/core_c.h	841;"	d
CV_LAST_VORONOIEDGE2D	/usr/include/opencv2/legacy/legacy.hpp	993;"	d
CV_LBGR2Lab	/usr/include/opencv2/imgproc/types_c.h	/^    CV_LBGR2Lab     = 74,$/;"	e	enum:__anon17
CV_LBGR2Luv	/usr/include/opencv2/imgproc/types_c.h	/^    CV_LBGR2Luv     = 76,$/;"	e	enum:__anon17
CV_LE	/usr/include/opencv2/core/internal.hpp	334;"	d
CV_LEE_AUTO	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_LEE_AUTO = -1,$/;"	e	enum:CvLeeParameters
CV_LEE_DOUBLE	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_LEE_DOUBLE = 2,$/;"	e	enum:CvLeeParameters
CV_LEE_ERODE	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_LEE_ERODE = 0,$/;"	e	enum:CvLeeParameters
CV_LEE_FLOAT	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_LEE_FLOAT = 1,$/;"	e	enum:CvLeeParameters
CV_LEE_INT	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_LEE_INT = 0,$/;"	e	enum:CvLeeParameters
CV_LEE_NON	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_LEE_NON = 2$/;"	e	enum:CvLeeParameters
CV_LEE_ZOOM	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_LEE_ZOOM = 1,$/;"	e	enum:CvLeeParameters
CV_LINK_RUNS	/usr/include/opencv2/imgproc/types_c.h	/^    CV_LINK_RUNS=5$/;"	e	enum:__anon24
CV_LKFLOW_GET_MIN_EIGENVALS	/usr/include/opencv2/video/tracking.hpp	81;"	d
CV_LKFLOW_INITIAL_GUESSES	/usr/include/opencv2/video/tracking.hpp	80;"	d
CV_LKFLOW_PYR_A_READY	/usr/include/opencv2/video/tracking.hpp	78;"	d
CV_LKFLOW_PYR_B_READY	/usr/include/opencv2/video/tracking.hpp	79;"	d
CV_LMEDS	/usr/include/opencv2/calib3d/calib3d.hpp	81;"	d
CV_LOAD_IMAGE_ANYCOLOR	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_LOAD_IMAGE_ANYCOLOR   =4$/;"	e	enum:__anon8
CV_LOAD_IMAGE_ANYDEPTH	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_LOAD_IMAGE_ANYDEPTH   =2,$/;"	e	enum:__anon8
CV_LOAD_IMAGE_COLOR	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_LOAD_IMAGE_COLOR      =1,$/;"	e	enum:__anon8
CV_LOAD_IMAGE_GRAYSCALE	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_LOAD_IMAGE_GRAYSCALE  =0,$/;"	e	enum:__anon8
CV_LOAD_IMAGE_UNCHANGED	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_LOAD_IMAGE_UNCHANGED  =-1,$/;"	e	enum:__anon8
CV_LOG2	/usr/include/opencv2/core/types_c.h	258;"	d
CV_LOG2PI	/usr/include/opencv2/ml/ml.hpp	120;"	d
CV_LRGB2Lab	/usr/include/opencv2/imgproc/types_c.h	/^    CV_LRGB2Lab     = 75,$/;"	e	enum:__anon17
CV_LRGB2Luv	/usr/include/opencv2/imgproc/types_c.h	/^    CV_LRGB2Luv     = 77,$/;"	e	enum:__anon17
CV_LT	/usr/include/opencv2/core/internal.hpp	333;"	d
CV_LU	/usr/include/opencv2/core/core_c.h	737;"	d
CV_Lab2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_Lab2BGR     =56,$/;"	e	enum:__anon17
CV_Lab2LBGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_Lab2LBGR     = 78,$/;"	e	enum:__anon17
CV_Lab2LRGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_Lab2LRGB     = 79,$/;"	e	enum:__anon17
CV_Lab2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_Lab2RGB     =57,$/;"	e	enum:__anon17
CV_Luv2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_Luv2BGR     =58,$/;"	e	enum:__anon17
CV_Luv2LBGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_Luv2LBGR     = 80,$/;"	e	enum:__anon17
CV_Luv2LRGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_Luv2LRGB     = 81,$/;"	e	enum:__anon17
CV_Luv2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_Luv2RGB     =59,$/;"	e	enum:__anon17
CV_MAGIC_MASK	/usr/include/opencv2/core/types_c.h	616;"	d
CV_MAJOR_VERSION	/usr/include/opencv2/core/version.hpp	50;"	d
CV_MAKETYPE	/usr/include/opencv2/core/types_c.h	556;"	d
CV_MAKE_STR	/usr/include/opencv2/core/internal.hpp	357;"	d
CV_MAKE_TYPE	/usr/include/opencv2/core/types_c.h	557;"	d
CV_MALLOC_ALIGN	/usr/include/opencv2/core/internal.hpp	234;"	d
CV_MAT32F	/usr/include/opencv2/legacy/compat.hpp	/^    CV_MAT32F      = CV_32FC1,$/;"	e	enum:__anon179
CV_MAT3x1_32F	/usr/include/opencv2/legacy/compat.hpp	/^    CV_MAT3x1_32F  = CV_32FC1,$/;"	e	enum:__anon179
CV_MAT3x1_64D	/usr/include/opencv2/legacy/compat.hpp	/^    CV_MAT3x1_64D  = CV_64FC1,$/;"	e	enum:__anon179
CV_MAT3x3_32F	/usr/include/opencv2/legacy/compat.hpp	/^    CV_MAT3x3_32F  = CV_32FC1,$/;"	e	enum:__anon179
CV_MAT3x3_64D	/usr/include/opencv2/legacy/compat.hpp	/^    CV_MAT3x3_64D  = CV_64FC1,$/;"	e	enum:__anon179
CV_MAT4x1_32F	/usr/include/opencv2/legacy/compat.hpp	/^    CV_MAT4x1_32F  = CV_32FC1,$/;"	e	enum:__anon179
CV_MAT4x1_64D	/usr/include/opencv2/legacy/compat.hpp	/^    CV_MAT4x1_64D  = CV_64FC1,$/;"	e	enum:__anon179
CV_MAT4x4_32F	/usr/include/opencv2/legacy/compat.hpp	/^    CV_MAT4x4_32F  = CV_32FC1,$/;"	e	enum:__anon179
CV_MAT4x4_64D	/usr/include/opencv2/legacy/compat.hpp	/^    CV_MAT4x4_64D  = CV_64FC1$/;"	e	enum:__anon179
CV_MAT64D	/usr/include/opencv2/legacy/compat.hpp	/^    CV_MAT64D      = CV_64FC1,$/;"	e	enum:__anon179
CV_MATND_MAGIC_VAL	/usr/include/opencv2/core/types_c.h	785;"	d
CV_MAT_CN	/usr/include/opencv2/core/types_c.h	605;"	d
CV_MAT_CN_MASK	/usr/include/opencv2/core/types_c.h	604;"	d
CV_MAT_CONT_FLAG	/usr/include/opencv2/core/types_c.h	609;"	d
CV_MAT_CONT_FLAG_SHIFT	/usr/include/opencv2/core/types_c.h	608;"	d
CV_MAT_DEPTH	/usr/include/opencv2/core/types_c.h	554;"	d
CV_MAT_DEPTH_MASK	/usr/include/opencv2/core/types_c.h	553;"	d
CV_MAT_ELEM	/usr/include/opencv2/core/types_c.h	734;"	d
CV_MAT_ELEM_PTR	/usr/include/opencv2/core/types_c.h	731;"	d
CV_MAT_ELEM_PTR_FAST	/usr/include/opencv2/core/types_c.h	726;"	d
CV_MAT_MAGIC_VAL	/usr/include/opencv2/core/types_c.h	617;"	d
CV_MAT_TYPE	/usr/include/opencv2/core/types_c.h	607;"	d
CV_MAT_TYPE_MASK	/usr/include/opencv2/core/types_c.h	606;"	d
CV_MAX_ALLOC_SIZE	/usr/include/opencv2/core/internal.hpp	231;"	d
CV_MAX_ARR	/usr/include/opencv2/core/core_c.h	267;"	d
CV_MAX_DIM	/usr/include/opencv2/core/types_c.h	788;"	d
CV_MAX_DIM_HEAP	/usr/include/opencv2/core/types_c.h	789;"	d
CV_MAX_INLINE_MAT_OP_SIZE	/usr/include/opencv2/core/internal.hpp	214;"	d
CV_MAX_LOCAL_MAT_SIZE	/usr/include/opencv2/core/internal.hpp	217;"	d
CV_MAX_LOCAL_SIZE	/usr/include/opencv2/core/internal.hpp	220;"	d
CV_MAX_SOBEL_KSIZE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_MAX_SOBEL_KSIZE =7$/;"	e	enum:__anon16
CV_MAX_STRLEN	/usr/include/opencv2/core/internal.hpp	252;"	d
CV_MEDIAN	/usr/include/opencv2/imgproc/types_c.h	/^    CV_MEDIAN =3,$/;"	e	enum:__anon13
CV_MINMAX	/usr/include/opencv2/core/core_c.h	845;"	d
CV_MINOR_VERSION	/usr/include/opencv2/core/version.hpp	51;"	d
CV_MOP_BLACKHAT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_MOP_BLACKHAT     =6$/;"	e	enum:__anon21
CV_MOP_CLOSE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_MOP_CLOSE        =3,$/;"	e	enum:__anon21
CV_MOP_DILATE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_MOP_DILATE       =1,$/;"	e	enum:__anon21
CV_MOP_ERODE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_MOP_ERODE        =0,$/;"	e	enum:__anon21
CV_MOP_GRADIENT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_MOP_GRADIENT     =4,$/;"	e	enum:__anon21
CV_MOP_OPEN	/usr/include/opencv2/imgproc/types_c.h	/^    CV_MOP_OPEN         =2,$/;"	e	enum:__anon21
CV_MOP_TOPHAT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_MOP_TOPHAT       =5,$/;"	e	enum:__anon21
CV_MOVE_DOWN	/usr/include/opencv2/legacy/compat.hpp	418;"	d
CV_MOVE_DOWN_WRAP	/usr/include/opencv2/legacy/compat.hpp	454;"	d
CV_MOVE_LD	/usr/include/opencv2/legacy/compat.hpp	428;"	d
CV_MOVE_LD_WRAP	/usr/include/opencv2/legacy/compat.hpp	463;"	d
CV_MOVE_LEFT	/usr/include/opencv2/legacy/compat.hpp	406;"	d
CV_MOVE_LEFT_WRAP	/usr/include/opencv2/legacy/compat.hpp	441;"	d
CV_MOVE_LU	/usr/include/opencv2/legacy/compat.hpp	422;"	d
CV_MOVE_LU_WRAP	/usr/include/opencv2/legacy/compat.hpp	459;"	d
CV_MOVE_PARAM	/usr/include/opencv2/legacy/compat.hpp	485;"	d
CV_MOVE_PARAM_WRAP	/usr/include/opencv2/legacy/compat.hpp	495;"	d
CV_MOVE_RD	/usr/include/opencv2/legacy/compat.hpp	431;"	d
CV_MOVE_RD_WRAP	/usr/include/opencv2/legacy/compat.hpp	465;"	d
CV_MOVE_RIGHT	/usr/include/opencv2/legacy/compat.hpp	410;"	d
CV_MOVE_RIGHT_WRAP	/usr/include/opencv2/legacy/compat.hpp	445;"	d
CV_MOVE_RU	/usr/include/opencv2/legacy/compat.hpp	425;"	d
CV_MOVE_RU_WRAP	/usr/include/opencv2/legacy/compat.hpp	461;"	d
CV_MOVE_TO	/usr/include/opencv2/legacy/compat.hpp	391;"	d
CV_MOVE_UP	/usr/include/opencv2/legacy/compat.hpp	414;"	d
CV_MOVE_UP_WRAP	/usr/include/opencv2/legacy/compat.hpp	449;"	d
CV_MUL	/usr/include/opencv2/core/internal.hpp	325;"	d
CV_MaskIsTiled	/usr/include/opencv2/core/types_c.h	/^ CV_MaskIsTiled=               -26, \/**\/$/;"	e	enum:__anon93
CV_NE	/usr/include/opencv2/core/internal.hpp	336;"	d
CV_NEG_INF	/usr/include/opencv2/core/internal.hpp	316;"	d
CV_NEXT_AROUND_DST	/usr/include/opencv2/imgproc/types_c.h	/^    CV_NEXT_AROUND_DST   = 0x22,$/;"	e	enum:CvNextEdgeType
CV_NEXT_AROUND_LEFT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_NEXT_AROUND_LEFT  = 0x13,$/;"	e	enum:CvNextEdgeType
CV_NEXT_AROUND_ORG	/usr/include/opencv2/imgproc/types_c.h	/^    CV_NEXT_AROUND_ORG   = 0x00,$/;"	e	enum:CvNextEdgeType
CV_NEXT_AROUND_RIGHT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_NEXT_AROUND_RIGHT = 0x31,$/;"	e	enum:CvNextEdgeType
CV_NEXT_GRAPH_EDGE	/usr/include/opencv2/core/types_c.h	1704;"	d
CV_NEXT_LINE_POINT	/usr/include/opencv2/core/core_c.h	1348;"	d
CV_NEXT_SEQ_ELEM	/usr/include/opencv2/core/types_c.h	1640;"	d
CV_NEXT_VORONOIEDGE2D	/usr/include/opencv2/legacy/legacy.hpp	994;"	d
CV_NEXT_VORONOISITE2D	/usr/include/opencv2/legacy/legacy.hpp	990;"	d
CV_NODE_EMPTY	/usr/include/opencv2/core/types_c.h	1761;"	d
CV_NODE_FLOAT	/usr/include/opencv2/core/types_c.h	1748;"	d
CV_NODE_FLOW	/usr/include/opencv2/core/types_c.h	1759;"	d
CV_NODE_HAS_NAME	/usr/include/opencv2/core/types_c.h	1773;"	d
CV_NODE_IDX	/usr/include/opencv2/core/types_c.h	874;"	d
CV_NODE_INT	/usr/include/opencv2/core/types_c.h	1745;"	d
CV_NODE_INTEGER	/usr/include/opencv2/core/types_c.h	1746;"	d
CV_NODE_IS_COLLECTION	/usr/include/opencv2/core/types_c.h	1769;"	d
CV_NODE_IS_EMPTY	/usr/include/opencv2/core/types_c.h	1771;"	d
CV_NODE_IS_FLOW	/usr/include/opencv2/core/types_c.h	1770;"	d
CV_NODE_IS_INT	/usr/include/opencv2/core/types_c.h	1764;"	d
CV_NODE_IS_MAP	/usr/include/opencv2/core/types_c.h	1768;"	d
CV_NODE_IS_REAL	/usr/include/opencv2/core/types_c.h	1765;"	d
CV_NODE_IS_SEQ	/usr/include/opencv2/core/types_c.h	1767;"	d
CV_NODE_IS_STRING	/usr/include/opencv2/core/types_c.h	1766;"	d
CV_NODE_IS_USER	/usr/include/opencv2/core/types_c.h	1772;"	d
CV_NODE_MAP	/usr/include/opencv2/core/types_c.h	1753;"	d
CV_NODE_NAMED	/usr/include/opencv2/core/types_c.h	1762;"	d
CV_NODE_NONE	/usr/include/opencv2/core/types_c.h	1744;"	d
CV_NODE_REAL	/usr/include/opencv2/core/types_c.h	1747;"	d
CV_NODE_REF	/usr/include/opencv2/core/types_c.h	1751;"	d
CV_NODE_SEQ	/usr/include/opencv2/core/types_c.h	1752;"	d
CV_NODE_SEQ_IS_SIMPLE	/usr/include/opencv2/core/types_c.h	1776;"	d
CV_NODE_SEQ_SIMPLE	/usr/include/opencv2/core/types_c.h	1775;"	d
CV_NODE_STR	/usr/include/opencv2/core/types_c.h	1749;"	d
CV_NODE_STRING	/usr/include/opencv2/core/types_c.h	1750;"	d
CV_NODE_TYPE	/usr/include/opencv2/core/types_c.h	1756;"	d
CV_NODE_TYPE_MASK	/usr/include/opencv2/core/types_c.h	1754;"	d
CV_NODE_USER	/usr/include/opencv2/core/types_c.h	1760;"	d
CV_NODE_VAL	/usr/include/opencv2/core/types_c.h	873;"	d
CV_NOISE_GAUSSIAN	/usr/include/opencv2/legacy/blobtrack.hpp	887;"	d
CV_NOISE_NONE	/usr/include/opencv2/legacy/blobtrack.hpp	886;"	d
CV_NOISE_SALT_AND_PEPPER	/usr/include/opencv2/legacy/blobtrack.hpp	890;"	d
CV_NOISE_SPECKLE	/usr/include/opencv2/legacy/blobtrack.hpp	889;"	d
CV_NOISE_UNIFORM	/usr/include/opencv2/legacy/blobtrack.hpp	888;"	d
CV_NONZERO	/usr/include/opencv2/core/internal.hpp	340;"	d
CV_NONZERO_FLT	/usr/include/opencv2/core/internal.hpp	341;"	d
CV_NOP	/usr/include/opencv2/core/internal.hpp	322;"	d
CV_NORMAL	/usr/include/opencv2/core/core_c.h	742;"	d
CV_NORM_MASK	/usr/include/opencv2/core/core_c.h	842;"	d
CV_NOTDEFINED_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_NOTDEFINED_ERR  = -48,  \/\/ipp comp$/;"	e	enum:CvStatus
CV_NOTFOUND_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_NOTFOUND_ERR             = -110,$/;"	e	enum:CvStatus
CV_NOTHROW	/usr/include/opencv2/core/internal.hpp	661;"	d
CV_NOT_WEIGHTED	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_NOT_WEIGHTED,$/;"	e	enum:CvGraphWeightType
CV_NO_CN_CHECK	/usr/include/opencv2/core/core_c.h	282;"	d
CV_NO_DEPTH_CHECK	/usr/include/opencv2/core/core_c.h	281;"	d
CV_NO_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_NO_ERR          =   0,$/;"	e	enum:CvStatus
CV_NO_SIZE_CHECK	/usr/include/opencv2/core/core_c.h	283;"	d
CV_NULLPTR_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_NULLPTR_ERR     =  -2,$/;"	e	enum:CvStatus
CV_NUM_FACE_ELEMENTS	/usr/include/opencv2/legacy/legacy.hpp	879;"	d
CV_OK	/usr/include/opencv2/core/internal.hpp	/^    CV_OK              =   CV_NO_ERR$/;"	e	enum:CvStatus
CV_OR	/usr/include/opencv2/core/internal.hpp	327;"	d
CV_ORIENTED_GRAPH	/usr/include/opencv2/core/types_c.h	1494;"	d
CV_ORIGIN_BL	/usr/include/opencv2/core/internal.hpp	312;"	d
CV_ORIGIN_TL	/usr/include/opencv2/core/internal.hpp	311;"	d
CV_ORN	/usr/include/opencv2/core/internal.hpp	330;"	d
CV_OUT	/usr/include/opencv2/core/types_c.h	168;"	d
CV_OUTOFMEM_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_OUTOFMEM_ERR    =  -3,$/;"	e	enum:CvStatus
CV_PASTE	/usr/include/opencv2/core/internal.hpp	354;"	d
CV_PASTE2	/usr/include/opencv2/core/internal.hpp	353;"	d
CV_PCA_DATA_AS_COL	/usr/include/opencv2/core/core_c.h	800;"	d
CV_PCA_DATA_AS_ROW	/usr/include/opencv2/core/core_c.h	799;"	d
CV_PCA_USE_AVG	/usr/include/opencv2/core/core_c.h	801;"	d
CV_PI	/usr/include/opencv2/core/types_c.h	257;"	d
CV_POLY_APPROX_DP	/usr/include/opencv2/imgproc/types_c.h	/^    CV_POLY_APPROX_DP = 0$/;"	e	enum:__anon25
CV_PORTION	/usr/include/opencv2/ml/ml.hpp	2080;"	d
CV_POS_INF	/usr/include/opencv2/core/internal.hpp	315;"	d
CV_PREV_AROUND_DST	/usr/include/opencv2/imgproc/types_c.h	/^    CV_PREV_AROUND_DST   = 0x33,$/;"	e	enum:CvNextEdgeType
CV_PREV_AROUND_LEFT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_PREV_AROUND_LEFT  = 0x20,$/;"	e	enum:CvNextEdgeType
CV_PREV_AROUND_ORG	/usr/include/opencv2/imgproc/types_c.h	/^    CV_PREV_AROUND_ORG   = 0x11,$/;"	e	enum:CvNextEdgeType
CV_PREV_AROUND_RIGHT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_PREV_AROUND_RIGHT = 0x02$/;"	e	enum:CvNextEdgeType
CV_PREV_INT	/usr/include/opencv2/legacy/legacy.hpp	281;"	d
CV_PREV_POINT	/usr/include/opencv2/core/types_c.h	1688;"	d
CV_PREV_SEQ_ELEM	/usr/include/opencv2/core/types_c.h	1650;"	d
CV_PREV_VORONOIEDGE2D	/usr/include/opencv2/legacy/legacy.hpp	995;"	d
CV_PREV_VORONOISITE2D	/usr/include/opencv2/legacy/legacy.hpp	991;"	d
CV_PROP	/usr/include/opencv2/core/types_c.h	169;"	d
CV_PROP_RW	/usr/include/opencv2/core/types_c.h	170;"	d
CV_PTLOC_ERROR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_PTLOC_ERROR = -2,$/;"	e	enum:CvSubdiv2DPointLocation
CV_PTLOC_INSIDE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_PTLOC_INSIDE = 0,$/;"	e	enum:CvSubdiv2DPointLocation
CV_PTLOC_ON_EDGE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_PTLOC_ON_EDGE = 2$/;"	e	enum:CvSubdiv2DPointLocation
CV_PTLOC_OUTSIDE_RECT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_PTLOC_OUTSIDE_RECT = -1,$/;"	e	enum:CvSubdiv2DPointLocation
CV_PTLOC_VERTEX	/usr/include/opencv2/imgproc/types_c.h	/^    CV_PTLOC_VERTEX = 1,$/;"	e	enum:CvSubdiv2DPointLocation
CV_PUSH_BUTTON	/usr/include/opencv2/highgui/highgui_c.h	/^enum {CV_PUSH_BUTTON = 0, CV_CHECKBOX = 1, CV_RADIOBOX = 2};$/;"	e	enum:__anon4
CV_QR	/usr/include/opencv2/core/core_c.h	741;"	d
CV_QUADEDGE2D_FIELDS	/usr/include/opencv2/imgproc/types_c.h	345;"	d
CV_RADIOBOX	/usr/include/opencv2/highgui/highgui_c.h	/^enum {CV_PUSH_BUTTON = 0, CV_CHECKBOX = 1, CV_RADIOBOX = 2};$/;"	e	enum:__anon4
CV_RAND_NORMAL	/usr/include/opencv2/core/core_c.h	648;"	d
CV_RAND_UNI	/usr/include/opencv2/core/core_c.h	647;"	d
CV_RANSAC	/usr/include/opencv2/calib3d/calib3d.hpp	82;"	d
CV_READ_CHAIN_POINT	/usr/include/opencv2/core/types_c.h	1675;"	d
CV_READ_EDGE	/usr/include/opencv2/core/types_c.h	1690;"	d
CV_READ_SEQ_ELEM	/usr/include/opencv2/core/types_c.h	1659;"	d
CV_REDUCE_AVG	/usr/include/opencv2/core/core_c.h	866;"	d
CV_REDUCE_MAX	/usr/include/opencv2/core/core_c.h	867;"	d
CV_REDUCE_MIN	/usr/include/opencv2/core/core_c.h	868;"	d
CV_REDUCE_SUM	/usr/include/opencv2/core/core_c.h	865;"	d
CV_RELATIVE	/usr/include/opencv2/core/core_c.h	843;"	d
CV_RELATIVE_C	/usr/include/opencv2/core/core_c.h	850;"	d
CV_RELATIVE_L1	/usr/include/opencv2/core/core_c.h	851;"	d
CV_RELATIVE_L2	/usr/include/opencv2/core/core_c.h	852;"	d
CV_RETR_CCOMP	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RETR_CCOMP=2,$/;"	e	enum:__anon23
CV_RETR_EXTERNAL	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RETR_EXTERNAL=0,$/;"	e	enum:__anon23
CV_RETR_LIST	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RETR_LIST=1,$/;"	e	enum:__anon23
CV_RETR_TREE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RETR_TREE=3$/;"	e	enum:__anon23
CV_REV_READ_SEQ_ELEM	/usr/include/opencv2/core/types_c.h	1667;"	d
CV_RGB	/usr/include/opencv2/core/core_c.h	1264;"	d
CV_RGB2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2BGR     =CV_BGR2RGB,$/;"	e	enum:__anon17
CV_RGB2BGR555	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2BGR555  =23,$/;"	e	enum:__anon17
CV_RGB2BGR565	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2BGR565  =13,$/;"	e	enum:__anon17
CV_RGB2BGRA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2BGRA    =CV_BGR2RGBA,$/;"	e	enum:__anon17
CV_RGB2GRAY	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2GRAY    =7,$/;"	e	enum:__anon17
CV_RGB2HLS	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2HLS     =53,$/;"	e	enum:__anon17
CV_RGB2HLS_FULL	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2HLS_FULL = 69,$/;"	e	enum:__anon17
CV_RGB2HSV	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2HSV     =41,$/;"	e	enum:__anon17
CV_RGB2HSV_FULL	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2HSV_FULL = 67,$/;"	e	enum:__anon17
CV_RGB2Lab	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2Lab     =45,$/;"	e	enum:__anon17
CV_RGB2Luv	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2Luv     =51,$/;"	e	enum:__anon17
CV_RGB2RGBA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2RGBA    =CV_BGR2BGRA,$/;"	e	enum:__anon17
CV_RGB2XYZ	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2XYZ     =33,$/;"	e	enum:__anon17
CV_RGB2YCrCb	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2YCrCb   =37,$/;"	e	enum:__anon17
CV_RGB2YUV	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGB2YUV      = 83,$/;"	e	enum:__anon17
CV_RGBA2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGBA2BGR    =3,$/;"	e	enum:__anon17
CV_RGBA2BGR555	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGBA2BGR555 =27,$/;"	e	enum:__anon17
CV_RGBA2BGR565	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGBA2BGR565 =17,$/;"	e	enum:__anon17
CV_RGBA2BGRA	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGBA2BGRA   =CV_BGRA2RGBA,$/;"	e	enum:__anon17
CV_RGBA2GRAY	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGBA2GRAY   =11,$/;"	e	enum:__anon17
CV_RGBA2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_RGBA2RGB    =CV_BGRA2BGR,$/;"	e	enum:__anon17
CV_RODRIGUES_M2V	/usr/include/opencv2/legacy/compat.hpp	/^    CV_RODRIGUES_M2V = 0,$/;"	e	enum:__anon182
CV_RODRIGUES_V2M	/usr/include/opencv2/legacy/compat.hpp	/^    CV_RODRIGUES_V2M = 1$/;"	e	enum:__anon182
CV_ROW_SAMPLE	/usr/include/opencv2/ml/ml.hpp	126;"	d
CV_SCHARR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_SCHARR =-1,$/;"	e	enum:__anon16
CV_SEQUENCE_FIELDS	/usr/include/opencv2/core/types_c.h	1297;"	d
CV_SEQ_CHAIN	/usr/include/opencv2/core/types_c.h	1505;"	d
CV_SEQ_CHAIN_CONTOUR	/usr/include/opencv2/core/types_c.h	1506;"	d
CV_SEQ_CONNECTED_COMP	/usr/include/opencv2/core/types_c.h	1512;"	d
CV_SEQ_CONTOUR	/usr/include/opencv2/core/types_c.h	1501;"	d
CV_SEQ_ELEM	/usr/include/opencv2/core/types_c.h	1605;"	d
CV_SEQ_ELTYPE	/usr/include/opencv2/core/types_c.h	1517;"	d
CV_SEQ_ELTYPE_BITS	/usr/include/opencv2/core/types_c.h	1455;"	d
CV_SEQ_ELTYPE_CODE	/usr/include/opencv2/core/types_c.h	1459;"	d
CV_SEQ_ELTYPE_CONNECTED_COMP	/usr/include/opencv2/core/types_c.h	1467;"	d
CV_SEQ_ELTYPE_GENERIC	/usr/include/opencv2/core/types_c.h	1460;"	d
CV_SEQ_ELTYPE_GRAPH_EDGE	/usr/include/opencv2/core/types_c.h	1464;"	d
CV_SEQ_ELTYPE_GRAPH_VERTEX	/usr/include/opencv2/core/types_c.h	1465;"	d
CV_SEQ_ELTYPE_INDEX	/usr/include/opencv2/core/types_c.h	1463;"	d
CV_SEQ_ELTYPE_MASK	/usr/include/opencv2/core/types_c.h	1456;"	d
CV_SEQ_ELTYPE_POINT	/usr/include/opencv2/core/types_c.h	1458;"	d
CV_SEQ_ELTYPE_POINT3D	/usr/include/opencv2/core/types_c.h	1468;"	d
CV_SEQ_ELTYPE_PPOINT	/usr/include/opencv2/core/types_c.h	1462;"	d
CV_SEQ_ELTYPE_PTR	/usr/include/opencv2/core/types_c.h	1461;"	d
CV_SEQ_ELTYPE_TRIAN_ATR	/usr/include/opencv2/core/types_c.h	1466;"	d
CV_SEQ_FLAG_CLOSED	/usr/include/opencv2/core/types_c.h	1485;"	d
CV_SEQ_FLAG_CONVEX	/usr/include/opencv2/core/types_c.h	1487;"	d
CV_SEQ_FLAG_HOLE	/usr/include/opencv2/core/types_c.h	1488;"	d
CV_SEQ_FLAG_SHIFT	/usr/include/opencv2/core/types_c.h	1482;"	d
CV_SEQ_FLAG_SIMPLE	/usr/include/opencv2/core/types_c.h	1486;"	d
CV_SEQ_INDEX	/usr/include/opencv2/core/types_c.h	1515;"	d
CV_SEQ_KIND	/usr/include/opencv2/core/types_c.h	1518;"	d
CV_SEQ_KIND_BIN_TREE	/usr/include/opencv2/core/types_c.h	1476;"	d
CV_SEQ_KIND_BITS	/usr/include/opencv2/core/types_c.h	1470;"	d
CV_SEQ_KIND_CURVE	/usr/include/opencv2/core/types_c.h	1475;"	d
CV_SEQ_KIND_GENERIC	/usr/include/opencv2/core/types_c.h	1474;"	d
CV_SEQ_KIND_GRAPH	/usr/include/opencv2/core/types_c.h	1479;"	d
CV_SEQ_KIND_MASK	/usr/include/opencv2/core/types_c.h	1471;"	d
CV_SEQ_KIND_SUBDIV2D	/usr/include/opencv2/core/types_c.h	1480;"	d
CV_SEQ_MAGIC_VAL	/usr/include/opencv2/core/types_c.h	1446;"	d
CV_SEQ_POINT3D_SET	/usr/include/opencv2/core/types_c.h	1498;"	d
CV_SEQ_POINT_SET	/usr/include/opencv2/core/types_c.h	1497;"	d
CV_SEQ_POLYGON	/usr/include/opencv2/core/types_c.h	1500;"	d
CV_SEQ_POLYGON_TREE	/usr/include/opencv2/core/types_c.h	1509;"	d
CV_SEQ_POLYLINE	/usr/include/opencv2/core/types_c.h	1499;"	d
CV_SEQ_READER_FIELDS	/usr/include/opencv2/core/types_c.h	1584;"	d
CV_SEQ_SIMPLE_POLYGON	/usr/include/opencv2/core/types_c.h	1502;"	d
CV_SEQ_WRITER_FIELDS	/usr/include/opencv2/core/types_c.h	1569;"	d
CV_SET_ELEM_FIELDS	/usr/include/opencv2/core/types_c.h	1324;"	d
CV_SET_ELEM_FREE_FLAG	/usr/include/opencv2/core/types_c.h	1347;"	d
CV_SET_ELEM_IDX_MASK	/usr/include/opencv2/core/types_c.h	1346;"	d
CV_SET_FIELDS	/usr/include/opencv2/core/types_c.h	1334;"	d
CV_SET_MAGIC_VAL	/usr/include/opencv2/core/types_c.h	1451;"	d
CV_SHAPE_CROSS	/usr/include/opencv2/imgproc/types_c.h	/^    CV_SHAPE_CROSS     =1,$/;"	e	enum:__anon20
CV_SHAPE_CUSTOM	/usr/include/opencv2/imgproc/types_c.h	/^    CV_SHAPE_CUSTOM    =100$/;"	e	enum:__anon20
CV_SHAPE_ELLIPSE	/usr/include/opencv2/imgproc/types_c.h	/^    CV_SHAPE_ELLIPSE   =2,$/;"	e	enum:__anon20
CV_SHAPE_RECT	/usr/include/opencv2/imgproc/types_c.h	/^    CV_SHAPE_RECT      =0,$/;"	e	enum:__anon20
CV_SHIFT_DOWN	/usr/include/opencv2/legacy/compat.hpp	/^    CV_SHIFT_DOWN = 10,$/;"	e	enum:__anon181
CV_SHIFT_LD	/usr/include/opencv2/legacy/compat.hpp	/^    CV_SHIFT_LD = 9,$/;"	e	enum:__anon181
CV_SHIFT_LEFT	/usr/include/opencv2/legacy/compat.hpp	/^    CV_SHIFT_LEFT = 1,$/;"	e	enum:__anon181
CV_SHIFT_LU	/usr/include/opencv2/legacy/compat.hpp	/^    CV_SHIFT_LU = 5,$/;"	e	enum:__anon181
CV_SHIFT_NONE	/usr/include/opencv2/legacy/compat.hpp	/^    CV_SHIFT_NONE = 2,$/;"	e	enum:__anon181
CV_SHIFT_RD	/usr/include/opencv2/legacy/compat.hpp	/^    CV_SHIFT_RD = 11$/;"	e	enum:__anon181
CV_SHIFT_RIGHT	/usr/include/opencv2/legacy/compat.hpp	/^    CV_SHIFT_RIGHT = 3,$/;"	e	enum:__anon181
CV_SHIFT_RU	/usr/include/opencv2/legacy/compat.hpp	/^    CV_SHIFT_RU = 7,$/;"	e	enum:__anon181
CV_SHIFT_UP	/usr/include/opencv2/legacy/compat.hpp	/^    CV_SHIFT_UP = 6,$/;"	e	enum:__anon181
CV_SIGN	/usr/include/opencv2/core/types_c.h	282;"	d
CV_SIZEOF_FLOAT	/usr/include/opencv2/core/internal.hpp	308;"	d
CV_SIZEOF_SHORT	/usr/include/opencv2/core/internal.hpp	309;"	d
CV_SORT_ASCENDING	/usr/include/opencv2/core/core_c.h	657;"	d
CV_SORT_DESCENDING	/usr/include/opencv2/core/core_c.h	658;"	d
CV_SORT_EVERY_COLUMN	/usr/include/opencv2/core/core_c.h	656;"	d
CV_SORT_EVERY_ROW	/usr/include/opencv2/core/core_c.h	655;"	d
CV_SPARSE_HASH_RATIO	/usr/include/opencv2/core/internal.hpp	249;"	d
CV_SPARSE_HASH_SIZE0	/usr/include/opencv2/core/internal.hpp	246;"	d
CV_SPARSE_MAT_BLOCK	/usr/include/opencv2/core/internal.hpp	243;"	d
CV_SPARSE_MAT_MAGIC_VAL	/usr/include/opencv2/core/types_c.h	828;"	d
CV_SQR	/usr/include/opencv2/core/internal.hpp	331;"	d
CV_SSE	/usr/include/opencv2/core/internal.hpp	110;"	d
CV_SSE	/usr/include/opencv2/core/internal.hpp	117;"	d
CV_SSE2	/usr/include/opencv2/core/internal.hpp	111;"	d
CV_SSE2	/usr/include/opencv2/core/internal.hpp	118;"	d
CV_SSE3	/usr/include/opencv2/core/internal.hpp	114;"	d
CV_SSE3	/usr/include/opencv2/core/internal.hpp	119;"	d
CV_STDCALL	/usr/include/opencv2/core/types_c.h	101;"	d
CV_STDCALL	/usr/include/opencv2/core/types_c.h	104;"	d
CV_STDCALL	/usr/include/opencv2/ml/ml.hpp	62;"	d
CV_STDCALL	/usr/include/opencv2/ml/ml.hpp	65;"	d
CV_STEREO_BM_BASIC	/usr/include/opencv2/calib3d/calib3d.hpp	334;"	d
CV_STEREO_BM_FISH_EYE	/usr/include/opencv2/calib3d/calib3d.hpp	335;"	d
CV_STEREO_BM_NARROW	/usr/include/opencv2/calib3d/calib3d.hpp	336;"	d
CV_STEREO_BM_NORMALIZED_RESPONSE	/usr/include/opencv2/calib3d/calib3d.hpp	296;"	d
CV_STEREO_BM_XSOBEL	/usr/include/opencv2/calib3d/calib3d.hpp	297;"	d
CV_STEREO_GC_OCCLUDED	/usr/include/opencv2/calib3d/calib3d.hpp	354;"	d
CV_STORAGE_APPEND	/usr/include/opencv2/core/types_c.h	1722;"	d
CV_STORAGE_BLOCK_SIZE	/usr/include/opencv2/core/internal.hpp	240;"	d
CV_STORAGE_MAGIC_VAL	/usr/include/opencv2/core/types_c.h	1245;"	d
CV_STORAGE_READ	/usr/include/opencv2/core/types_c.h	1718;"	d
CV_STORAGE_WRITE	/usr/include/opencv2/core/types_c.h	1719;"	d
CV_STORAGE_WRITE_BINARY	/usr/include/opencv2/core/types_c.h	1721;"	d
CV_STORAGE_WRITE_TEXT	/usr/include/opencv2/core/types_c.h	1720;"	d
CV_STRUCT_ALIGN	/usr/include/opencv2/core/internal.hpp	237;"	d
CV_STUB_STEP	/usr/include/opencv2/core/internal.hpp	306;"	d
CV_STYLE_ITALIC	/usr/include/opencv2/highgui/highgui_c.h	/^		CV_STYLE_ITALIC 		= 1,\/\/QFont::StyleItalic,$/;"	e	enum:__anon3
CV_STYLE_NORMAL	/usr/include/opencv2/highgui/highgui_c.h	/^enum {	CV_STYLE_NORMAL			= 0,\/\/QFont::StyleNormal,$/;"	e	enum:__anon3
CV_STYLE_OBLIQUE	/usr/include/opencv2/highgui/highgui_c.h	/^		CV_STYLE_OBLIQUE 		= 2 \/\/QFont::StyleOblique$/;"	e	enum:__anon3
CV_SUB	/usr/include/opencv2/core/internal.hpp	324;"	d
CV_SUBDIV2D_FIELDS	/usr/include/opencv2/imgproc/types_c.h	370;"	d
CV_SUBDIV2D_NEXT_EDGE	/usr/include/opencv2/imgproc/types_c.h	409;"	d
CV_SUBDIV2D_POINT_FIELDS	/usr/include/opencv2/imgproc/types_c.h	350;"	d
CV_SUBDIV2D_VIRTUAL_POINT_FLAG	/usr/include/opencv2/imgproc/types_c.h	356;"	d
CV_SUBMAT_FLAG	/usr/include/opencv2/core/types_c.h	613;"	d
CV_SUBMAT_FLAG_SHIFT	/usr/include/opencv2/core/types_c.h	612;"	d
CV_SUBMINOR_VERSION	/usr/include/opencv2/core/version.hpp	52;"	d
CV_SVD	/usr/include/opencv2/core/core_c.h	738;"	d
CV_SVD_MODIFY_A	/usr/include/opencv2/core/core_c.h	723;"	d
CV_SVD_SYM	/usr/include/opencv2/core/core_c.h	739;"	d
CV_SVD_U_T	/usr/include/opencv2/core/core_c.h	724;"	d
CV_SVD_V_T	/usr/include/opencv2/core/core_c.h	725;"	d
CV_SWAP	/usr/include/opencv2/core/types_c.h	260;"	d
CV_StsAssert	/usr/include/opencv2/core/types_c.h	/^ CV_StsAssert=                 -215, \/* assertion failed *\/    $/;"	e	enum:__anon93
CV_StsAutoTrace	/usr/include/opencv2/core/types_c.h	/^ CV_StsAutoTrace=               -8,  \/* tracing                         *\/$/;"	e	enum:__anon93
CV_StsBackTrace	/usr/include/opencv2/core/types_c.h	/^ CV_StsBackTrace=               -1,  \/* pseudo error for back trace     *\/$/;"	e	enum:__anon93
CV_StsBadArg	/usr/include/opencv2/core/types_c.h	/^ CV_StsBadArg=                  -5,  \/* function arg\/param is bad       *\/$/;"	e	enum:__anon93
CV_StsBadFlag	/usr/include/opencv2/core/types_c.h	/^ CV_StsBadFlag=                -206, \/* flag is wrong or not supported *\/  $/;"	e	enum:__anon93
CV_StsBadFunc	/usr/include/opencv2/core/types_c.h	/^ CV_StsBadFunc=                 -6,  \/* unsupported function            *\/$/;"	e	enum:__anon93
CV_StsBadMask	/usr/include/opencv2/core/types_c.h	/^ CV_StsBadMask=                -208, \/* bad format of mask (neither 8uC1 nor 8sC1)*\/$/;"	e	enum:__anon93
CV_StsBadMemBlock	/usr/include/opencv2/core/types_c.h	/^ CV_StsBadMemBlock=            -214, \/* an allocated block has been corrupted *\/$/;"	e	enum:__anon93
CV_StsBadPoint	/usr/include/opencv2/core/types_c.h	/^ CV_StsBadPoint=               -207, \/* bad CvPoint *\/ $/;"	e	enum:__anon93
CV_StsBadSize	/usr/include/opencv2/core/types_c.h	/^ CV_StsBadSize=                -201, \/* the input\/output structure size is incorrect  *\/$/;"	e	enum:__anon93
CV_StsDivByZero	/usr/include/opencv2/core/types_c.h	/^ CV_StsDivByZero=              -202, \/* division by zero *\/$/;"	e	enum:__anon93
CV_StsError	/usr/include/opencv2/core/types_c.h	/^ CV_StsError=                   -2,  \/* unknown \/unspecified error      *\/$/;"	e	enum:__anon93
CV_StsFilterOffsetErr	/usr/include/opencv2/core/types_c.h	/^ CV_StsFilterOffsetErr=        -31, \/* incorrect filter ofset value *\/$/;"	e	enum:__anon93
CV_StsFilterStructContentErr	/usr/include/opencv2/core/types_c.h	/^ CV_StsFilterStructContentErr= -29, \/* incorr. filter structure content *\/$/;"	e	enum:__anon93
CV_StsInplaceNotSupported	/usr/include/opencv2/core/types_c.h	/^ CV_StsInplaceNotSupported=    -203, \/* in-place operation is not supported *\/$/;"	e	enum:__anon93
CV_StsInternal	/usr/include/opencv2/core/types_c.h	/^ CV_StsInternal=                -3,  \/* internal error (bad state)      *\/$/;"	e	enum:__anon93
CV_StsKernelStructContentErr	/usr/include/opencv2/core/types_c.h	/^ CV_StsKernelStructContentErr= -30, \/* incorr. transform kernel content *\/$/;"	e	enum:__anon93
CV_StsNoConv	/usr/include/opencv2/core/types_c.h	/^ CV_StsNoConv=                  -7,  \/* iter. didn't converge           *\/$/;"	e	enum:__anon93
CV_StsNoMem	/usr/include/opencv2/core/types_c.h	/^ CV_StsNoMem=                   -4,  \/* insufficient memory             *\/$/;"	e	enum:__anon93
CV_StsNotImplemented	/usr/include/opencv2/core/types_c.h	/^ CV_StsNotImplemented=         -213, \/* the requested function\/feature is not implemented *\/$/;"	e	enum:__anon93
CV_StsNullPtr	/usr/include/opencv2/core/types_c.h	/^ CV_StsNullPtr=                -27, \/* null pointer *\/$/;"	e	enum:__anon93
CV_StsObjectNotFound	/usr/include/opencv2/core/types_c.h	/^ CV_StsObjectNotFound=         -204, \/* request can't be completed *\/$/;"	e	enum:__anon93
CV_StsOk	/usr/include/opencv2/core/types_c.h	/^ CV_StsOk=                       0,  \/* everithing is ok                *\/$/;"	e	enum:__anon93
CV_StsOutOfRange	/usr/include/opencv2/core/types_c.h	/^ CV_StsOutOfRange=             -211, \/* some of parameters are out of range *\/$/;"	e	enum:__anon93
CV_StsParseError	/usr/include/opencv2/core/types_c.h	/^ CV_StsParseError=             -212, \/* invalid syntax\/structure of the parsed file *\/$/;"	e	enum:__anon93
CV_StsUnmatchedFormats	/usr/include/opencv2/core/types_c.h	/^ CV_StsUnmatchedFormats=       -205, \/* formats of input\/output arrays differ *\/$/;"	e	enum:__anon93
CV_StsUnmatchedSizes	/usr/include/opencv2/core/types_c.h	/^ CV_StsUnmatchedSizes=         -209, \/* sizes of input\/output structures do not match *\/$/;"	e	enum:__anon93
CV_StsUnsupportedFormat	/usr/include/opencv2/core/types_c.h	/^ CV_StsUnsupportedFormat=      -210, \/* the data format\/type is not supported by the function*\/$/;"	e	enum:__anon93
CV_StsVecLengthErr	/usr/include/opencv2/core/types_c.h	/^ CV_StsVecLengthErr=           -28, \/* incorrect vector length *\/$/;"	e	enum:__anon93
CV_TERMCRIT_EPS	/usr/include/opencv2/core/types_c.h	970;"	d
CV_TERMCRIT_ITER	/usr/include/opencv2/core/types_c.h	968;"	d
CV_TERMCRIT_NUMBER	/usr/include/opencv2/core/types_c.h	969;"	d
CV_TEST_ERROR	/usr/include/opencv2/ml/ml.hpp	189;"	d
CV_THRESH_BINARY	/usr/include/opencv2/imgproc/types_c.h	/^    CV_THRESH_BINARY      =0,  \/* value = value > threshold ? max_value : 0       *\/$/;"	e	enum:__anon31
CV_THRESH_BINARY_INV	/usr/include/opencv2/imgproc/types_c.h	/^    CV_THRESH_BINARY_INV  =1,  \/* value = value > threshold ? 0 : max_value       *\/$/;"	e	enum:__anon31
CV_THRESH_MASK	/usr/include/opencv2/imgproc/types_c.h	/^    CV_THRESH_MASK        =7,$/;"	e	enum:__anon31
CV_THRESH_OTSU	/usr/include/opencv2/imgproc/types_c.h	/^    CV_THRESH_OTSU        =8  \/* use Otsu algorithm to choose the optimal threshold value;$/;"	e	enum:__anon31
CV_THRESH_TOZERO	/usr/include/opencv2/imgproc/types_c.h	/^    CV_THRESH_TOZERO      =3,  \/* value = value > threshold ? value : 0           *\/$/;"	e	enum:__anon31
CV_THRESH_TOZERO_INV	/usr/include/opencv2/imgproc/types_c.h	/^    CV_THRESH_TOZERO_INV  =4,  \/* value = value > threshold ? 0 : value           *\/$/;"	e	enum:__anon31
CV_THRESH_TRUNC	/usr/include/opencv2/imgproc/types_c.h	/^    CV_THRESH_TRUNC       =2,  \/* value = value > threshold ? threshold : value   *\/$/;"	e	enum:__anon31
CV_TM_CCOEFF	/usr/include/opencv2/imgproc/types_c.h	/^    CV_TM_CCOEFF        =4,$/;"	e	enum:__anon22
CV_TM_CCOEFF_NORMED	/usr/include/opencv2/imgproc/types_c.h	/^    CV_TM_CCOEFF_NORMED =5$/;"	e	enum:__anon22
CV_TM_CCORR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_TM_CCORR         =2,$/;"	e	enum:__anon22
CV_TM_CCORR_NORMED	/usr/include/opencv2/imgproc/types_c.h	/^    CV_TM_CCORR_NORMED  =3,$/;"	e	enum:__anon22
CV_TM_SQDIFF	/usr/include/opencv2/imgproc/types_c.h	/^    CV_TM_SQDIFF        =0,$/;"	e	enum:__anon22
CV_TM_SQDIFF_NORMED	/usr/include/opencv2/imgproc/types_c.h	/^    CV_TM_SQDIFF_NORMED =1,$/;"	e	enum:__anon22
CV_TOGGLE_DBL	/usr/include/opencv2/core/internal.hpp	319;"	d
CV_TOGGLE_FLT	/usr/include/opencv2/core/internal.hpp	318;"	d
CV_TRAIN_ERROR	/usr/include/opencv2/ml/ml.hpp	188;"	d
CV_TREE_NODE_FIELDS	/usr/include/opencv2/core/types_c.h	1285;"	d
CV_TS_CONCENTRIC_SPHERES	/usr/include/opencv2/ml/ml.hpp	2059;"	d
CV_TURN_ON_IPL_COMPATIBILITY	/usr/include/opencv2/core/core_c.h	1517;"	d
CV_TWIN_VORONOISITE2D	/usr/include/opencv2/legacy/legacy.hpp	998;"	d
CV_TYPE_NAME_GRAPH	/usr/include/opencv2/core/types_c.h	1417;"	d
CV_TYPE_NAME_HAAR	/usr/include/opencv2/objdetect/objdetect.hpp	57;"	d
CV_TYPE_NAME_IMAGE	/usr/include/opencv2/core/types_c.h	519;"	d
CV_TYPE_NAME_MAT	/usr/include/opencv2/core/types_c.h	618;"	d
CV_TYPE_NAME_MATND	/usr/include/opencv2/core/types_c.h	786;"	d
CV_TYPE_NAME_ML_ANN_MLP	/usr/include/opencv2/ml/ml.hpp	183;"	d
CV_TYPE_NAME_ML_BOOSTING	/usr/include/opencv2/ml/ml.hpp	181;"	d
CV_TYPE_NAME_ML_CNN	/usr/include/opencv2/ml/ml.hpp	184;"	d
CV_TYPE_NAME_ML_EM	/usr/include/opencv2/ml/ml.hpp	180;"	d
CV_TYPE_NAME_ML_GBT	/usr/include/opencv2/ml/ml.hpp	186;"	d
CV_TYPE_NAME_ML_KNN	/usr/include/opencv2/ml/ml.hpp	178;"	d
CV_TYPE_NAME_ML_NBAYES	/usr/include/opencv2/ml/ml.hpp	179;"	d
CV_TYPE_NAME_ML_RTREES	/usr/include/opencv2/ml/ml.hpp	185;"	d
CV_TYPE_NAME_ML_SVM	/usr/include/opencv2/ml/ml.hpp	177;"	d
CV_TYPE_NAME_ML_TREE	/usr/include/opencv2/ml/ml.hpp	182;"	d
CV_TYPE_NAME_SEQ	/usr/include/opencv2/core/types_c.h	1314;"	d
CV_TYPE_NAME_SEQ_TREE	/usr/include/opencv2/core/types_c.h	1315;"	d
CV_TYPE_NAME_SPARSE_MAT	/usr/include/opencv2/core/types_c.h	829;"	d
CV_TYZX_COLOR	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_TYZX_COLOR   =402,$/;"	e	enum:__anon11
CV_TYZX_LEFT	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_TYZX_LEFT    =400,$/;"	e	enum:__anon11
CV_TYZX_RIGHT	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_TYZX_RIGHT   =401,$/;"	e	enum:__anon11
CV_TYZX_Z	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_TYZX_Z       =403,$/;"	e	enum:__anon11
CV_UNDEF_SC_PARAM	/usr/include/opencv2/legacy/legacy.hpp	459;"	d
CV_UNMATCHED_FORMATS_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_UNMATCHED_FORMATS_ERR    = -104,$/;"	e	enum:CvStatus
CV_UNMATCHED_ROI_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_UNMATCHED_ROI_ERR        = -111,$/;"	e	enum:CvStatus
CV_UNSUPPORTED_CHANNELS_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_UNSUPPORTED_CHANNELS_ERR = -102,$/;"	e	enum:CvStatus
CV_UNSUPPORTED_COI_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_UNSUPPORTED_COI_ERR      = -103,$/;"	e	enum:CvStatus
CV_UNSUPPORTED_DEPTH_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_UNSUPPORTED_DEPTH_ERR    = -101,$/;"	e	enum:CvStatus
CV_UNSUPPORTED_FORMAT_ERR	/usr/include/opencv2/core/internal.hpp	/^    CV_UNSUPPORTED_FORMAT_ERR   = -100,$/;"	e	enum:CvStatus
CV_USRTYPE1	/usr/include/opencv2/core/types_c.h	551;"	d
CV_VALUE	/usr/include/opencv2/legacy/legacy.hpp	814;"	d
CV_VAR_CATEGORICAL	/usr/include/opencv2/ml/ml.hpp	175;"	d
CV_VAR_NUMERICAL	/usr/include/opencv2/ml/ml.hpp	173;"	d
CV_VAR_ORDERED	/usr/include/opencv2/ml/ml.hpp	174;"	d
CV_VERSION	/usr/include/opencv2/core/version.hpp	56;"	d
CV_VORONOIDIAGRAM2D_FIELDS	/usr/include/opencv2/legacy/legacy.hpp	1030;"	d
CV_VORONOIEDGE2D_BEGINNODE	/usr/include/opencv2/legacy/legacy.hpp	996;"	d
CV_VORONOIEDGE2D_ENDNODE	/usr/include/opencv2/legacy/legacy.hpp	997;"	d
CV_VORONOIEDGE2D_FIELDS	/usr/include/opencv2/legacy/legacy.hpp	1010;"	d
CV_VORONOINODE2D_FIELDS	/usr/include/opencv2/legacy/legacy.hpp	1020;"	d
CV_VORONOISITE2D_FIELDS	/usr/include/opencv2/legacy/legacy.hpp	1000;"	d
CV_WARP_FILL_OUTLIERS	/usr/include/opencv2/imgproc/types_c.h	/^    CV_WARP_FILL_OUTLIERS =8,$/;"	e	enum:__anon19
CV_WARP_INVERSE_MAP	/usr/include/opencv2/imgproc/types_c.h	/^    CV_WARP_INVERSE_MAP  =16$/;"	e	enum:__anon19
CV_WARP_TO_CAMERA	/usr/include/opencv2/legacy/legacy.hpp	564;"	d
CV_WEIGHTED_ALL	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_WEIGHTED_ALL$/;"	e	enum:CvGraphWeightType
CV_WEIGHTED_EDGE	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_WEIGHTED_EDGE,$/;"	e	enum:CvGraphWeightType
CV_WEIGHTED_VTX	/usr/include/opencv2/legacy/legacy.hpp	/^    CV_WEIGHTED_VTX,$/;"	e	enum:CvGraphWeightType
CV_WHOLE_ARR	/usr/include/opencv2/core/types_c.h	602;"	d
CV_WHOLE_SEQ	/usr/include/opencv2/core/types_c.h	1193;"	d
CV_WHOLE_SEQ_END_INDEX	/usr/include/opencv2/core/types_c.h	1192;"	d
CV_WINDOW_AUTOSIZE	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_WINDOW_AUTOSIZE 	   = 0x00000001,\/\/the user cannot resize the window, the size is constrainted by the image displayed$/;"	e	enum:__anon5
CV_WINDOW_FREERATIO	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_WINDOW_FREERATIO	   = 0x00000100,\/\/the image expends as much as it can (no ratio constraint)$/;"	e	enum:__anon5
CV_WINDOW_FULLSCREEN	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_WINDOW_FULLSCREEN   = 1,\/\/change the window to fullscreen$/;"	e	enum:__anon5
CV_WINDOW_KEEPRATIO	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_WINDOW_KEEPRATIO    = 0x00000000\/\/the ration image is respected.$/;"	e	enum:__anon5
CV_WINDOW_NORMAL	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_WINDOW_NORMAL       = 0x00000000,\/\/the user can resize the window (no constraint)  \/ also use to switch a fullscreen window to a normal size$/;"	e	enum:__anon5
CV_WND_PROP_ASPECTRATIO	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_WND_PROP_ASPECTRATIO= 2,\/\/to change\/get window's aspectratio property$/;"	e	enum:__anon5
CV_WND_PROP_AUTOSIZE	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_WND_PROP_AUTOSIZE   = 1,\/\/to change\/get window's autosize property$/;"	e	enum:__anon5
CV_WND_PROP_FULLSCREEN	/usr/include/opencv2/highgui/highgui_c.h	/^	CV_WND_PROP_FULLSCREEN = 0,\/\/to change\/get window's fullscreen property$/;"	e	enum:__anon5
CV_WRAP	/usr/include/opencv2/core/types_c.h	171;"	d
CV_WRAP_AS	/usr/include/opencv2/core/types_c.h	172;"	d
CV_WRAP_DEFAULT	/usr/include/opencv2/core/types_c.h	173;"	d
CV_WRITE_SEQ_ELEM	/usr/include/opencv2/core/types_c.h	1626;"	d
CV_WRITE_SEQ_ELEM_VAR	/usr/include/opencv2/core/types_c.h	1616;"	d
CV_XADD	/usr/include/opencv2/core/operations.hpp	/^    static inline int CV_XADD( int* addr, int delta )$/;"	f	signature:( int* addr, int delta )
CV_XADD	/usr/include/opencv2/core/operations.hpp	/^  template<typename _Tp> static inline _Tp CV_XADD(_Tp* addr, _Tp delta)$/;"	f	signature:(_Tp* addr, _Tp delta)
CV_XADD	/usr/include/opencv2/core/operations.hpp	60;"	d
CV_XADD	/usr/include/opencv2/core/operations.hpp	63;"	d
CV_XADD	/usr/include/opencv2/core/operations.hpp	69;"	d
CV_XADD	/usr/include/opencv2/core/operations.hpp	71;"	d
CV_XADD	/usr/include/opencv2/core/operations.hpp	94;"	d
CV_XOR	/usr/include/opencv2/core/internal.hpp	328;"	d
CV_XYZ2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_XYZ2BGR     =34,$/;"	e	enum:__anon17
CV_XYZ2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_XYZ2RGB     =35,$/;"	e	enum:__anon17
CV_YCrCb2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_YCrCb2BGR   =38,$/;"	e	enum:__anon17
CV_YCrCb2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_YCrCb2RGB   =39,$/;"	e	enum:__anon17
CV_YUV2BGR	/usr/include/opencv2/imgproc/types_c.h	/^    CV_YUV2BGR      = 84,$/;"	e	enum:__anon17
CV_YUV2RGB	/usr/include/opencv2/imgproc/types_c.h	/^    CV_YUV2RGB      = 85,$/;"	e	enum:__anon17
CV_ZERO_OBJ	/usr/include/opencv2/core/internal.hpp	359;"	d
C_SVC	/usr/include/opencv2/ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon78
Calc	/usr/include/opencv2/ml/ml.hpp	/^    typedef void (CvSVMKernel::*Calc)( int vec_count, int vec_size, const float** vecs,$/;"	t	struct:CvSVMKernel	access:public
CalcRho	/usr/include/opencv2/ml/ml.hpp	/^    typedef void (CvSVMSolver::*CalcRho)( double& rho, double& r );$/;"	t	class:CvSVMSolver	access:public
CalonderDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    CalonderDescriptorExtractor( const string& classifierFile );$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( const string& classifierFile )
CalonderDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^CalonderDescriptorExtractor<T>::CalonderDescriptorExtractor(const std::string& classifier_file)$/;"	f	class:cv::CalonderDescriptorExtractor	signature:(const std::string& classifier_file)
CalonderDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS CalonderDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
CamShift	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W RotatedRect CamShift( const Mat& probImage, CV_IN_OUT Rect& window,$/;"	p	namespace:cv	signature:( const Mat& probImage, CV_IN_OUT Rect& window, TermCriteria criteria )
Canny	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void Canny(const GpuMat& image, GpuMat& edges, double threshold1, double threshold2, int apertureSize = 3);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, GpuMat& edges, double threshold1, double threshold2, int apertureSize = 3)
Canny	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(canny) void Canny( const Mat& image, CV_OUT Mat& edges,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT Mat& edges, double threshold1, double threshold2, int apertureSize=3, bool L2gradient=false )
CascadeClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP CascadeClassifier();$/;"	p	class:cv::CascadeClassifier	access:public	signature:()
CascadeClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP CascadeClassifier(const string& filename);$/;"	p	class:cv::CascadeClassifier	access:public	signature:(const string& filename)
CascadeClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^class CV_EXPORTS_W CascadeClassifier$/;"	c	namespace:cv
ChannelSize	/usr/include/opencv2/core/wimage.hpp	/^    int ChannelSize() const {return sizeof(T); }  \/\/ number of bytes per channel$/;"	f	class:cv::WImage	access:public	signature:() const
Channels	/usr/include/opencv2/core/wimage.hpp	/^    int Channels() const {return C; }$/;"	f	class:cv::WImageC	access:public	signature:() const
Channels	/usr/include/opencv2/core/wimage.hpp	/^    int Channels() const {return image_->nChannels; }$/;"	f	class:cv::WImage	access:public	signature:() const
Cholesky	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS bool Cholesky(double* A, int m, double* b, int n);    $/;"	p	namespace:cv	signature:(double* A, int m, double* b, int n)
Cholesky	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS bool Cholesky(float* A, int m, float* b, int n);$/;"	p	namespace:cv	signature:(float* A, int m, float* b, int n)
Clear	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Clear()$/;"	f	class:CvBlobSeq	access:public	signature:()
Clear	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Clear();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
CloneFrom	/usr/include/opencv2/core/wimage.hpp	/^    void CloneFrom(const WImage<T>& src) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(const WImage<T>& src)
CloneFrom	/usr/include/opencv2/core/wimage.hpp	/^    void CloneFrom(const WImageC<T, C>& src) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(const WImageC<T, C>& src)
CommentParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void CommentParam(const char* name, const char* pComment);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, const char* pComment)
CommonParams	/usr/include/opencv2/features2d/features2d.hpp	/^        CommonParams( int _nOctaves, int _nOctaveLayers, int _firstOctave, int _angleMode );$/;"	p	struct:cv::SIFT::CommonParams	access:public	signature:( int _nOctaves, int _nOctaveLayers, int _firstOctave, int _angleMode )
CommonParams	/usr/include/opencv2/features2d/features2d.hpp	/^        CommonParams();$/;"	p	struct:cv::SIFT::CommonParams	access:public	signature:()
CommonParams	/usr/include/opencv2/features2d/features2d.hpp	/^    struct CV_EXPORTS CommonParams$/;"	s	class:cv::SIFT	access:public
Complex	/usr/include/opencv2/core/core.hpp	/^    Complex( _Tp _re, _Tp _im=0 );$/;"	p	class:cv::Complex	access:public	signature:( _Tp _re, _Tp _im=0 )
Complex	/usr/include/opencv2/core/core.hpp	/^    Complex( const std::complex<_Tp>& c );$/;"	p	class:cv::Complex	access:public	signature:( const std::complex<_Tp>& c )
Complex	/usr/include/opencv2/core/core.hpp	/^    Complex();$/;"	p	class:cv::Complex	access:public	signature:()
Complex	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Complex$/;"	c	namespace:cv
Complex	/usr/include/opencv2/core/core.hpp	73;"	d
Complex	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp>::Complex( _Tp _re, _Tp _im ) : re(_re), im(_im) {}$/;"	f	class:cv::Complex	signature:( _Tp _re, _Tp _im )
Complex	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp>::Complex() : re(0), im(0) {}$/;"	f	class:cv::Complex	signature:()
Complexd	/usr/include/opencv2/core/core.hpp	/^typedef Complex<double> Complexd;$/;"	t	namespace:cv
Complexf	/usr/include/opencv2/core/core.hpp	/^typedef Complex<float> Complexf;$/;"	t	namespace:cv
CompositeIndex	/usr/include/opencv2/flann/composite_index.h	/^	CompositeIndex(const Matrix<ELEM_TYPE>& inputData, const CompositeIndexParams& params = CompositeIndexParams() ) :$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(const Matrix<ELEM_TYPE>& inputData, const CompositeIndexParams& params = CompositeIndexParams() )
CompositeIndex	/usr/include/opencv2/flann/composite_index.h	/^class CompositeIndex : public NNIndex<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:NNIndex
CompositeIndexParams	/usr/include/opencv2/flann/composite_index.h	/^	CompositeIndexParams(int trees_ = 4, int branching_ = 32, int iterations_ = 11,$/;"	f	struct:cvflann::CompositeIndexParams	access:public	signature:(int trees_ = 4, int branching_ = 32, int iterations_ = 11, flann_centers_init_t centers_init_ = CENTERS_RANDOM, float cb_index_ = 0.2 )
CompositeIndexParams	/usr/include/opencv2/flann/composite_index.h	/^struct CompositeIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
ConcurrentRectVector	/usr/include/opencv2/core/internal.hpp	/^        typedef tbb::concurrent_vector<Rect> ConcurrentRectVector;$/;"	t	namespace:cv
ConvertData	/usr/include/opencv2/core/core.hpp	/^typedef void (*ConvertData)(const void* from, void* to, int cn);$/;"	t	namespace:cv
ConvertDescriptorsArrayToTree	/usr/include/opencv2/features2d/features2d.hpp	/^    void ConvertDescriptorsArrayToTree(); \/\/ Converting pca_descriptors array to KD tree$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
ConvertScaleData	/usr/include/opencv2/core/core.hpp	/^typedef void (*ConvertScaleData)(const void* from, void* to, int cn, double alpha, double beta);$/;"	t	namespace:cv
CopyFrom	/usr/include/opencv2/core/wimage.hpp	/^    void CopyFrom(const WImage<T>& src) { cvCopy(src.Ipl(), image_); }$/;"	f	class:cv::WImage	access:public	signature:(const WImage<T>& src)
CopyFrom	/usr/include/opencv2/core/wimage.hpp	/^    void CopyFrom(const WImageC<T, C>& src) {$/;"	f	class:cv::WImageC	access:public	signature:(const WImageC<T, C>& src)
CostData	/usr/include/opencv2/flann/autotuned_index.h	/^    struct CostData {$/;"	s	class:cvflann::AutotunedIndex	access:private
CreateDescriptorsFromImage	/usr/include/opencv2/features2d/features2d.hpp	/^    void CreateDescriptorsFromImage(IplImage* src, const std::vector<cv::KeyPoint>& features);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* src, const std::vector<cv::KeyPoint>& features)
CreateObjectFunc	/usr/include/opencv2/flann/object_factory.h	/^	typedef BaseClass* (*CreateObjectFunc)();$/;"	t	class:cvflann::ObjectFactory	access:private
CreatePCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void CreatePCADescriptors();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED)
CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem(const CudaMem& m);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const CudaMem& m)
CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem(int rows, int cols, int type, int _alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(int rows, int cols, int type, int _alloc_type = ALLOC_PAGE_LOCKED)
CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            explicit CudaMem(const Mat& m, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const Mat& m, int alloc_type = ALLOC_PAGE_LOCKED)
CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS CudaMem$/;"	c	namespace:cv::gpu
CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem()  : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0) {}$/;"	f	class:cv::gpu::CudaMem	signature:()
CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(Size _size, int _type, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(Size _size, int _type, int _alloc_type)
CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(const CudaMem& m) : flags(m.flags), rows(m.rows), cols(m.cols), step(m.step), data(m.data), refcount(m.refcount), datastart(m.datastart), dataend(m.dataend), alloc_type(m.alloc_type)$/;"	f	class:cv::gpu::CudaMem	signature:(const CudaMem& m)
CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(const Mat& m, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(const Mat& m, int _alloc_type)
CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(int _rows, int _cols, int _type, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(int _rows, int _cols, int _type, int _alloc_type)
Cv1DObsInfo	/usr/include/opencv2/legacy/legacy.hpp	/^typedef CvImgObsInfo Cv1DObsInfo;$/;"	t
Cv32suf	/usr/include/opencv2/core/types_c.h	/^Cv32suf;$/;"	t	typeref:union:Cv32suf
Cv32suf	/usr/include/opencv2/core/types_c.h	/^typedef union Cv32suf$/;"	u
Cv32suf::f	/usr/include/opencv2/core/types_c.h	/^    float f;$/;"	m	union:Cv32suf	access:public
Cv32suf::i	/usr/include/opencv2/core/types_c.h	/^    int i;$/;"	m	union:Cv32suf	access:public
Cv32suf::u	/usr/include/opencv2/core/types_c.h	/^    unsigned u;$/;"	m	union:Cv32suf	access:public
Cv3dTracker2dTrackedObject	/usr/include/opencv2/legacy/legacy.hpp	/^} Cv3dTracker2dTrackedObject;$/;"	t	typeref:struct:__anon173
Cv3dTrackerCameraInfo	/usr/include/opencv2/legacy/legacy.hpp	/^} Cv3dTrackerCameraInfo;$/;"	t	typeref:struct:__anon175
Cv3dTrackerCameraIntrinsics	/usr/include/opencv2/legacy/legacy.hpp	/^} Cv3dTrackerCameraIntrinsics;$/;"	t	typeref:struct:__anon176
Cv3dTrackerTrackedObject	/usr/include/opencv2/legacy/legacy.hpp	/^} Cv3dTrackerTrackedObject;$/;"	t	typeref:struct:__anon174
Cv64suf	/usr/include/opencv2/core/types_c.h	/^Cv64suf;$/;"	t	typeref:union:Cv64suf
Cv64suf	/usr/include/opencv2/core/types_c.h	/^typedef union Cv64suf$/;"	u
Cv64suf::f	/usr/include/opencv2/core/types_c.h	/^    double f;$/;"	m	union:Cv64suf	access:public
Cv64suf::i	/usr/include/opencv2/core/types_c.h	/^    int64 i;$/;"	m	union:Cv64suf	access:public
Cv64suf::u	/usr/include/opencv2/core/types_c.h	/^    uint64 u;$/;"	m	union:Cv64suf	access:public
CvANN_MLP	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvANN_MLP( const cv::Mat& layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvANN_MLP();$/;"	p	class:CvANN_MLP	access:public	signature:()
CvANN_MLP	/usr/include/opencv2/ml/ml.hpp	/^    CvANN_MLP( const CvMat* layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS_W CvANN_MLP : public CvStatModel$/;"	c	inherits:CvStatModel
CvANN_MLP::CvANN_MLP	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvANN_MLP( const cv::Mat& layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP::CvANN_MLP	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvANN_MLP();$/;"	p	class:CvANN_MLP	access:public	signature:()
CvANN_MLP::CvANN_MLP	/usr/include/opencv2/ml/ml.hpp	/^    CvANN_MLP( const CvMat* layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP::GAUSSIAN	/usr/include/opencv2/ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon89
CvANN_MLP::IDENTITY	/usr/include/opencv2/ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon89
CvANN_MLP::NO_INPUT_SCALE	/usr/include/opencv2/ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon90
CvANN_MLP::NO_OUTPUT_SCALE	/usr/include/opencv2/ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon90
CvANN_MLP::SIGMOID_SYM	/usr/include/opencv2/ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon89
CvANN_MLP::UPDATE_WEIGHTS	/usr/include/opencv2/ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon90
CvANN_MLP::activ_func	/usr/include/opencv2/ml/ml.hpp	/^    int activ_func;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::calc_activ_func	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_activ_func( CvMat* xf, const double* bias ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( CvMat* xf, const double* bias ) const
CvANN_MLP::calc_activ_func_deriv	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_activ_func_deriv( CvMat* xf, CvMat* deriv, const double* bias ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( CvMat* xf, CvMat* deriv, const double* bias ) const
CvANN_MLP::calc_input_scale	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_input_scale( const CvVectors* vecs, int flags );$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvVectors* vecs, int flags )
CvANN_MLP::calc_output_scale	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_output_scale( const CvVectors* vecs, int flags );$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvVectors* vecs, int flags )
CvANN_MLP::clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvANN_MLP	access:public	signature:()
CvANN_MLP::create	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void create( const cv::Mat& layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP::create	/usr/include/opencv2/ml/ml.hpp	/^    virtual void create( const CvMat* layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP::f_param1	/usr/include/opencv2/ml/ml.hpp	/^    double f_param1, f_param2;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::f_param2	/usr/include/opencv2/ml/ml.hpp	/^    double f_param1, f_param2;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::get_layer_count	/usr/include/opencv2/ml/ml.hpp	/^    int get_layer_count() { return layer_sizes ? layer_sizes->cols : 0; }$/;"	f	class:CvANN_MLP	access:public	signature:()
CvANN_MLP::get_layer_sizes	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_layer_sizes() { return layer_sizes; }$/;"	f	class:CvANN_MLP	access:public	signature:()
CvANN_MLP::get_weights	/usr/include/opencv2/ml/ml.hpp	/^    double* get_weights(int layer)$/;"	f	class:CvANN_MLP	access:public	signature:(int layer)
CvANN_MLP::init_weights	/usr/include/opencv2/ml/ml.hpp	/^    virtual void init_weights();$/;"	p	class:CvANN_MLP	access:protected	signature:()
CvANN_MLP::layer_sizes	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* layer_sizes;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::max_buf_sz	/usr/include/opencv2/ml/ml.hpp	/^    int max_count, max_buf_sz;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::max_count	/usr/include/opencv2/ml/ml.hpp	/^    int max_count, max_buf_sz;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::max_val	/usr/include/opencv2/ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::max_val1	/usr/include/opencv2/ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::min_val	/usr/include/opencv2/ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::min_val1	/usr/include/opencv2/ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::params	/usr/include/opencv2/ml/ml.hpp	/^    CvANN_MLP_TrainParams params;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& inputs, cv::Mat& outputs ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& inputs, cv::Mat& outputs ) const
CvANN_MLP::predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* inputs, CV_OUT CvMat* outputs ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* inputs, CV_OUT CvMat* outputs ) const
CvANN_MLP::prepare_to_train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool prepare_to_train( const CvMat* _inputs, const CvMat* _outputs,$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _inputs, const CvMat* _outputs, const CvMat* _sample_weights, const CvMat* sampleIdx, CvVectors* _ivecs, CvVectors* _ovecs, double** _sw, int _flags )
CvANN_MLP::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvANN_MLP	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvANN_MLP::read_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
CvANN_MLP::rng	/usr/include/opencv2/ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::sample_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* sample_weights;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::scale_input	/usr/include/opencv2/ml/ml.hpp	/^    virtual void scale_input( const CvMat* _src, CvMat* _dst ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _src, CvMat* _dst ) const
CvANN_MLP::scale_output	/usr/include/opencv2/ml/ml.hpp	/^    virtual void scale_output( const CvMat* _src, CvMat* _dst ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _src, CvMat* _dst ) const
CvANN_MLP::set_activ_func	/usr/include/opencv2/ml/ml.hpp	/^    virtual void set_activ_func( int _activ_func=SIGMOID_SYM,$/;"	p	class:CvANN_MLP	access:protected	signature:( int _activ_func=SIGMOID_SYM, double _f_param1=0, double _f_param2=0 )
CvANN_MLP::train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual int train( const cv::Mat& inputs, const cv::Mat& outputs,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& inputs, const cv::Mat& outputs, const cv::Mat& sampleWeights, const cv::Mat& sampleIdx=cv::Mat(), CvANN_MLP_TrainParams params = CvANN_MLP_TrainParams(), int flags=0 )
CvANN_MLP::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual int train( const CvMat* inputs, const CvMat* outputs,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* inputs, const CvMat* outputs, const CvMat* sampleWeights, const CvMat* sampleIdx=0, CvANN_MLP_TrainParams params = CvANN_MLP_TrainParams(), int flags=0 )
CvANN_MLP::train_backprop	/usr/include/opencv2/ml/ml.hpp	/^    virtual int train_backprop( CvVectors _ivecs, CvVectors _ovecs, const double* _sw );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvVectors _ivecs, CvVectors _ovecs, const double* _sw )
CvANN_MLP::train_rprop	/usr/include/opencv2/ml/ml.hpp	/^    virtual int train_rprop( CvVectors _ivecs, CvVectors _ovecs, const double* _sw );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvVectors _ivecs, CvVectors _ovecs, const double* _sw )
CvANN_MLP::wbuf	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* wbuf;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::weights	/usr/include/opencv2/ml/ml.hpp	/^    double** weights;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( CvFileStorage* storage, const char* name ) const
CvANN_MLP::write_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( CvFileStorage* fs ) const
CvANN_MLP::~CvANN_MLP	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvANN_MLP();$/;"	p	class:CvANN_MLP	access:public	signature:()
CvANN_MLP_TrainParams	/usr/include/opencv2/ml/ml.hpp	/^    CvANN_MLP_TrainParams( CvTermCriteria term_crit, int train_method,$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:( CvTermCriteria term_crit, int train_method, double param1, double param2=0 )
CvANN_MLP_TrainParams	/usr/include/opencv2/ml/ml.hpp	/^    CvANN_MLP_TrainParams();$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:()
CvANN_MLP_TrainParams	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvANN_MLP_TrainParams$/;"	s
CvANN_MLP_TrainParams::BACKPROP	/usr/include/opencv2/ml/ml.hpp	/^    enum { BACKPROP=0, RPROP=1 };$/;"	e	enum:CvANN_MLP_TrainParams::__anon88
CvANN_MLP_TrainParams::CvANN_MLP_TrainParams	/usr/include/opencv2/ml/ml.hpp	/^    CvANN_MLP_TrainParams( CvTermCriteria term_crit, int train_method,$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:( CvTermCriteria term_crit, int train_method, double param1, double param2=0 )
CvANN_MLP_TrainParams::CvANN_MLP_TrainParams	/usr/include/opencv2/ml/ml.hpp	/^    CvANN_MLP_TrainParams();$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:()
CvANN_MLP_TrainParams::RPROP	/usr/include/opencv2/ml/ml.hpp	/^    enum { BACKPROP=0, RPROP=1 };$/;"	e	enum:CvANN_MLP_TrainParams::__anon88
CvANN_MLP_TrainParams::bp_dw_scale	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double bp_dw_scale, bp_moment_scale;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::bp_moment_scale	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double bp_dw_scale, bp_moment_scale;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::rp_dw0	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::rp_dw_max	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::rp_dw_min	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::rp_dw_minus	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::rp_dw_plus	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::term_crit	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::train_method	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int train_method;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::~CvANN_MLP_TrainParams	/usr/include/opencv2/ml/ml.hpp	/^    ~CvANN_MLP_TrainParams();$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:()
CvAdaptiveSkinDetector	/usr/include/opencv2/contrib/contrib.hpp	/^    CvAdaptiveSkinDetector(int samplingDivider = 1, int morphingMethod = MORPHING_METHOD_NONE);$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:(int samplingDivider = 1, int morphingMethod = MORPHING_METHOD_NONE)
CvAdaptiveSkinDetector	/usr/include/opencv2/contrib/contrib.hpp	/^class CV_EXPORTS CvAdaptiveSkinDetector$/;"	c
CvAdaptiveSkinDetector::CvAdaptiveSkinDetector	/usr/include/opencv2/contrib/contrib.hpp	/^    CvAdaptiveSkinDetector(int samplingDivider = 1, int morphingMethod = MORPHING_METHOD_NONE);$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:(int samplingDivider = 1, int morphingMethod = MORPHING_METHOD_NONE)
CvAdaptiveSkinDetector::GSD_HUE_LT	/usr/include/opencv2/contrib/contrib.hpp	/^        GSD_HUE_LT = 3,$/;"	e	enum:CvAdaptiveSkinDetector::__anon52
CvAdaptiveSkinDetector::GSD_HUE_UT	/usr/include/opencv2/contrib/contrib.hpp	/^        GSD_HUE_UT = 33,$/;"	e	enum:CvAdaptiveSkinDetector::__anon52
CvAdaptiveSkinDetector::GSD_INTENSITY_LT	/usr/include/opencv2/contrib/contrib.hpp	/^        GSD_INTENSITY_LT = 15,$/;"	e	enum:CvAdaptiveSkinDetector::__anon52
CvAdaptiveSkinDetector::GSD_INTENSITY_UT	/usr/include/opencv2/contrib/contrib.hpp	/^        GSD_INTENSITY_UT = 250$/;"	e	enum:CvAdaptiveSkinDetector::__anon52
CvAdaptiveSkinDetector::Histogram	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS Histogram$/;"	c	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::Histogram::Histogram	/usr/include/opencv2/contrib/contrib.hpp	/^        Histogram();$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:()
CvAdaptiveSkinDetector::Histogram::HistogramSize	/usr/include/opencv2/contrib/contrib.hpp	/^            HistogramSize = (GSD_HUE_UT - GSD_HUE_LT + 1)$/;"	e	enum:CvAdaptiveSkinDetector::Histogram::__anon53
CvAdaptiveSkinDetector::Histogram::fHistogram	/usr/include/opencv2/contrib/contrib.hpp	/^        CvHistogram *fHistogram;$/;"	m	class:CvAdaptiveSkinDetector::Histogram	access:public
CvAdaptiveSkinDetector::Histogram::findCoverageIndex	/usr/include/opencv2/contrib/contrib.hpp	/^        int findCoverageIndex(double surfaceToCover, int defaultValue = 0);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:protected	signature:(double surfaceToCover, int defaultValue = 0)
CvAdaptiveSkinDetector::Histogram::findCurveThresholds	/usr/include/opencv2/contrib/contrib.hpp	/^        void findCurveThresholds(int &x1, int &x2, double percent = 0.05);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:(int &x1, int &x2, double percent = 0.05)
CvAdaptiveSkinDetector::Histogram::mergeWith	/usr/include/opencv2/contrib/contrib.hpp	/^        void mergeWith(Histogram *source, double weight);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:(Histogram *source, double weight)
CvAdaptiveSkinDetector::Histogram::~Histogram	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual ~Histogram();$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:()
CvAdaptiveSkinDetector::MORPHING_METHOD_ERODE	/usr/include/opencv2/contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE = 1,$/;"	e	enum:CvAdaptiveSkinDetector::__anon54
CvAdaptiveSkinDetector::MORPHING_METHOD_ERODE_DILATE	/usr/include/opencv2/contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE_DILATE = 3$/;"	e	enum:CvAdaptiveSkinDetector::__anon54
CvAdaptiveSkinDetector::MORPHING_METHOD_ERODE_ERODE	/usr/include/opencv2/contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE_ERODE = 2,$/;"	e	enum:CvAdaptiveSkinDetector::__anon54
CvAdaptiveSkinDetector::MORPHING_METHOD_NONE	/usr/include/opencv2/contrib/contrib.hpp	/^        MORPHING_METHOD_NONE = 0,$/;"	e	enum:CvAdaptiveSkinDetector::__anon54
CvAdaptiveSkinDetector::adaptiveFilter	/usr/include/opencv2/contrib/contrib.hpp	/^    void adaptiveFilter();$/;"	p	class:CvAdaptiveSkinDetector	access:protected	signature:()
CvAdaptiveSkinDetector::fHistogramMergeFactor	/usr/include/opencv2/contrib/contrib.hpp	/^    double fHistogramMergeFactor, fHuePercentCovered;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::fHuePercentCovered	/usr/include/opencv2/contrib/contrib.hpp	/^    double fHistogramMergeFactor, fHuePercentCovered;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::histogramHueMotion	/usr/include/opencv2/contrib/contrib.hpp	/^    Histogram histogramHueMotion, skinHueHistogram;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgFilteredFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgGrayFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgHSVFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgHueFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgLastGrayFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgMotionFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgSaturationFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgShrinked	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgTemp	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::initData	/usr/include/opencv2/contrib/contrib.hpp	/^    void initData(IplImage *src, int widthDivider, int heightDivider);$/;"	p	class:CvAdaptiveSkinDetector	access:protected	signature:(IplImage *src, int widthDivider, int heightDivider)
CvAdaptiveSkinDetector::nFrameCount	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::nMorphingMethod	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::nSamplingDivider	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::nSkinHueLowerBound	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::nSkinHueUpperBound	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::nStartCounter	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::process	/usr/include/opencv2/contrib/contrib.hpp	/^    virtual void process(IplImage *inputBGRImage, IplImage *outputHueMask);$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:(IplImage *inputBGRImage, IplImage *outputHueMask)
CvAdaptiveSkinDetector::skinHueHistogram	/usr/include/opencv2/contrib/contrib.hpp	/^    Histogram histogramHueMotion, skinHueHistogram;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::~CvAdaptiveSkinDetector	/usr/include/opencv2/contrib/contrib.hpp	/^    virtual ~CvAdaptiveSkinDetector();$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:()
CvAdaptiveThreshMethod	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvAdaptiveThreshMethod;$/;"	t
CvAffinePose	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS CvAffinePose$/;"	c	namespace:cv
CvAllocFunc	/usr/include/opencv2/core/core_c.h	/^typedef void* (CV_CDECL *CvAllocFunc)(size_t size, void* userdata);$/;"	t
CvArr	/usr/include/opencv2/core/types_c.h	/^typedef void CvArr;$/;"	t
CvAttrList	/usr/include/opencv2/core/types_c.h	/^CvAttrList;$/;"	t	typeref:struct:CvAttrList
CvAttrList	/usr/include/opencv2/core/types_c.h	/^typedef struct CvAttrList$/;"	s
CvAttrList::attr	/usr/include/opencv2/core/types_c.h	/^    const char** attr;         \/* NULL-terminated array of (attribute_name,attribute_value) pairs. *\/$/;"	m	struct:CvAttrList	access:public
CvAttrList::next	/usr/include/opencv2/core/types_c.h	/^    struct CvAttrList* next;   \/* Pointer to next chunk of the attributes list.                    *\/$/;"	m	struct:CvAttrList	typeref:struct:CvAttrList::CvAttrList	access:public
CvAvgComp	/usr/include/opencv2/objdetect/objdetect.hpp	/^typedef struct CvAvgComp$/;"	s
CvAvgComp	/usr/include/opencv2/objdetect/objdetect.hpp	/^} CvAvgComp;$/;"	t	typeref:struct:CvAvgComp
CvAvgComp::neighbors	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int neighbors;$/;"	m	struct:CvAvgComp	access:public
CvAvgComp::rect	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvRect rect;$/;"	m	struct:CvAvgComp	access:public
CvBGCodeBookElem	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvBGCodeBookElem$/;"	s
CvBGCodeBookElem	/usr/include/opencv2/video/background_segm.hpp	/^} CvBGCodeBookElem;$/;"	t	typeref:struct:CvBGCodeBookElem
CvBGCodeBookElem::boxMax	/usr/include/opencv2/video/background_segm.hpp	/^    uchar boxMax[3];$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookElem::boxMin	/usr/include/opencv2/video/background_segm.hpp	/^    uchar boxMin[3];$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookElem::learnMax	/usr/include/opencv2/video/background_segm.hpp	/^    uchar learnMax[3];$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookElem::learnMin	/usr/include/opencv2/video/background_segm.hpp	/^    uchar learnMin[3];$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookElem::next	/usr/include/opencv2/video/background_segm.hpp	/^    struct CvBGCodeBookElem* next;$/;"	m	struct:CvBGCodeBookElem	typeref:struct:CvBGCodeBookElem::CvBGCodeBookElem	access:public
CvBGCodeBookElem::stale	/usr/include/opencv2/video/background_segm.hpp	/^    int stale;$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookElem::tLastUpdate	/usr/include/opencv2/video/background_segm.hpp	/^    int tLastUpdate;$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookModel	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvBGCodeBookModel$/;"	s
CvBGCodeBookModel	/usr/include/opencv2/video/background_segm.hpp	/^} CvBGCodeBookModel;$/;"	t	typeref:struct:CvBGCodeBookModel
CvBGCodeBookModel::cbBounds	/usr/include/opencv2/video/background_segm.hpp	/^    uchar cbBounds[3];$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::cbmap	/usr/include/opencv2/video/background_segm.hpp	/^    CvBGCodeBookElem** cbmap;$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::freeList	/usr/include/opencv2/video/background_segm.hpp	/^    CvBGCodeBookElem* freeList;$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::modMax	/usr/include/opencv2/video/background_segm.hpp	/^    uchar modMax[3];$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::modMin	/usr/include/opencv2/video/background_segm.hpp	/^    uchar modMin[3];$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::size	/usr/include/opencv2/video/background_segm.hpp	/^    CvSize size;$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::storage	/usr/include/opencv2/video/background_segm.hpp	/^    CvMemStorage* storage;$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::t	/usr/include/opencv2/video/background_segm.hpp	/^    int t;$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGPixelCCStatTable	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvBGPixelCCStatTable$/;"	s
CvBGPixelCCStatTable	/usr/include/opencv2/video/background_segm.hpp	/^} CvBGPixelCCStatTable;$/;"	t	typeref:struct:CvBGPixelCCStatTable
CvBGPixelCCStatTable::Pv	/usr/include/opencv2/video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCCStatTable	access:public
CvBGPixelCCStatTable::Pvb	/usr/include/opencv2/video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCCStatTable	access:public
CvBGPixelCCStatTable::v	/usr/include/opencv2/video/background_segm.hpp	/^    uchar          v[6];$/;"	m	struct:CvBGPixelCCStatTable	access:public
CvBGPixelCStatTable	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvBGPixelCStatTable$/;"	s
CvBGPixelCStatTable	/usr/include/opencv2/video/background_segm.hpp	/^} CvBGPixelCStatTable;$/;"	t	typeref:struct:CvBGPixelCStatTable
CvBGPixelCStatTable::Pv	/usr/include/opencv2/video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCStatTable	access:public
CvBGPixelCStatTable::Pvb	/usr/include/opencv2/video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCStatTable	access:public
CvBGPixelCStatTable::v	/usr/include/opencv2/video/background_segm.hpp	/^    uchar          v[3];$/;"	m	struct:CvBGPixelCStatTable	access:public
CvBGPixelStat	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvBGPixelStat$/;"	s
CvBGPixelStat	/usr/include/opencv2/video/background_segm.hpp	/^} CvBGPixelStat;$/;"	t	typeref:struct:CvBGPixelStat
CvBGPixelStat::Pbc	/usr/include/opencv2/video/background_segm.hpp	/^    float                 Pbc;$/;"	m	struct:CvBGPixelStat	access:public
CvBGPixelStat::Pbcc	/usr/include/opencv2/video/background_segm.hpp	/^    float                 Pbcc;$/;"	m	struct:CvBGPixelStat	access:public
CvBGPixelStat::cctable	/usr/include/opencv2/video/background_segm.hpp	/^    CvBGPixelCCStatTable* cctable;$/;"	m	struct:CvBGPixelStat	access:public
CvBGPixelStat::ctable	/usr/include/opencv2/video/background_segm.hpp	/^    CvBGPixelCStatTable*  ctable;$/;"	m	struct:CvBGPixelStat	access:public
CvBGPixelStat::is_trained_dyn_model	/usr/include/opencv2/video/background_segm.hpp	/^    uchar                 is_trained_dyn_model;$/;"	m	struct:CvBGPixelStat	access:public
CvBGPixelStat::is_trained_st_model	/usr/include/opencv2/video/background_segm.hpp	/^    uchar                 is_trained_st_model;$/;"	m	struct:CvBGPixelStat	access:public
CvBGStatModel	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvBGStatModel$/;"	s
CvBGStatModel	/usr/include/opencv2/video/background_segm.hpp	/^} CvBGStatModel;$/;"	t	typeref:struct:CvBGStatModel
CvBGStatModel::CV_BG_STAT_MODEL_FIELDS	/usr/include/opencv2/video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvBGStatModel	access:public	signature:()
CvBigFuncTable	/usr/include/opencv2/core/internal.hpp	/^CvBigFuncTable;$/;"	t	typeref:struct:CvBigFuncTable
CvBigFuncTable	/usr/include/opencv2/core/internal.hpp	/^typedef struct CvBigFuncTable$/;"	s
CvBigFuncTable::fn_2d	/usr/include/opencv2/core/internal.hpp	/^    void*   fn_2d[CV_DEPTH_MAX*4];$/;"	m	struct:CvBigFuncTable	access:public
CvBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^struct CvBlob$/;"	s
CvBlob::ID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     ID;  \/* blob ID         *\/$/;"	m	struct:CvBlob	access:public
CvBlob::h	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float   w,h; \/* blob sizes      *\/$/;"	m	struct:CvBlob	access:public
CvBlob::w	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float   w,h; \/* blob sizes      *\/$/;"	m	struct:CvBlob	access:public
CvBlob::x	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float   x,y; \/* blob position   *\/$/;"	m	struct:CvBlob	access:public
CvBlob::y	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float   x,y; \/* blob position   *\/$/;"	m	struct:CvBlob	access:public
CvBlobDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobDetector(){SetTypeName("BlobDetector");};$/;"	f	class:CvBlobDetector	access:public	signature:()
CvBlobDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobDetector: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobDetector::CvBlobDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobDetector(){SetTypeName("BlobDetector");};$/;"	f	class:CvBlobDetector	access:public	signature:()
CvBlobDetector::DetectNewBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int DetectNewBlob(IplImage* pImg, IplImage* pImgFG, CvBlobSeq* pNewBlobList, CvBlobSeq* pOldBlobList) = 0;$/;"	p	class:CvBlobDetector	access:public	signature:(IplImage* pImg, IplImage* pImgFG, CvBlobSeq* pNewBlobList, CvBlobSeq* pOldBlobList)
CvBlobDetector::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Release()=0;$/;"	p	class:CvBlobDetector	access:public	signature:()
CvBlobSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobSeq(int BlobSize = sizeof(CvBlob))$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobSize = sizeof(CvBlob))
CvBlobSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobSeq$/;"	c
CvBlobSeq::AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void AddBlob(CvBlob* pB)$/;"	f	class:CvBlobSeq	access:public	signature:(CvBlob* pB)
CvBlobSeq::AddFormat	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddFormat(const char* str){strcat(m_pElemFormat,str);}$/;"	f	class:CvBlobSeq	access:public	signature:(const char* str)
CvBlobSeq::Clear	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Clear()$/;"	f	class:CvBlobSeq	access:public	signature:()
CvBlobSeq::CvBlobSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobSeq(int BlobSize = sizeof(CvBlob))$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobSize = sizeof(CvBlob))
CvBlobSeq::DelBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void DelBlob(int BlobIndex)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobIndex)
CvBlobSeq::DelBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void DelBlobByID(int BlobID)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobID)
CvBlobSeq::GetBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int BlobIndex)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobIndex)
CvBlobSeq::GetBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobID)
CvBlobSeq::GetBlobNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int GetBlobNum()$/;"	f	class:CvBlobSeq	access:public	signature:()
CvBlobSeq::Load	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Load(CvFileStorage* fs, CvFileNode* node)$/;"	f	class:CvBlobSeq	access:public	signature:(CvFileStorage* fs, CvFileNode* node)
CvBlobSeq::Write	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Write(CvFileStorage* fs, const char* name)$/;"	f	class:CvBlobSeq	access:public	signature:(CvFileStorage* fs, const char* name)
CvBlobSeq::m_pElemFormat	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char            m_pElemFormat[1024];$/;"	m	class:CvBlobSeq	access:protected
CvBlobSeq::m_pMem	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvMemStorage*   m_pMem;$/;"	m	class:CvBlobSeq	access:protected
CvBlobSeq::m_pSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvSeq*          m_pSeq;$/;"	m	class:CvBlobSeq	access:protected
CvBlobSeq::~CvBlobSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual ~CvBlobSeq()$/;"	f	class:CvBlobSeq	access:public	signature:()
CvBlobTrack	/usr/include/opencv2/legacy/blobtrack.hpp	/^struct CvBlobTrack$/;"	s
CvBlobTrack::StartFrame	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int         StartFrame;$/;"	m	struct:CvBlobTrack	access:public
CvBlobTrack::TrackID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int         TrackID;$/;"	m	struct:CvBlobTrack	access:public
CvBlobTrack::pBlobSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobSeq*  pBlobSeq;$/;"	m	struct:CvBlobTrack	access:public
CvBlobTrackAnalysis	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackAnalysis(){SetTypeName("BlobTrackAnalysis");};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:()
CvBlobTrackAnalysis	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackAnalysis: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackAnalysis::AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(CvBlob* pBlob)
CvBlobTrackAnalysis::CvBlobTrackAnalysis	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackAnalysis(){SetTypeName("BlobTrackAnalysis");};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:()
CvBlobTrackAnalysis::GetState	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float   GetState(int BlobID) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(int BlobID)
CvBlobTrackAnalysis::GetStateDesc	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual const char*   GetStateDesc(int \/*BlobID*\/){return NULL;};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:(int )
CvBlobTrackAnalysis::Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(IplImage* pImg, IplImage* pFG)
CvBlobTrackAnalysis::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:()
CvBlobTrackAnalysis::SetFileName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    SetFileName(char* \/*DataBaseName*\/){};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:(char* )
CvBlobTrackAnalysisHeight	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackAnalysisHeight: public CvBlobTrackAnalysis$/;"	c	inherits:CvBlobTrackAnalysis
CvBlobTrackAnalysisHeight::GetHeight	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual double  GetHeight(CvBlob* pB) = 0;$/;"	p	class:CvBlobTrackAnalysisHeight	access:public	signature:(CvBlob* pB)
CvBlobTrackAnalysisOne	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackAnalysisOne$/;"	c
CvBlobTrackAnalysisOne::Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     Process(CvBlob* pBlob, IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackAnalysisOne	access:public	signature:(CvBlob* pBlob, IplImage* pImg, IplImage* pFG)
CvBlobTrackAnalysisOne::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackAnalysisOne	access:public	signature:()
CvBlobTrackAnalysisOne::~CvBlobTrackAnalysisOne	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual ~CvBlobTrackAnalysisOne() {};$/;"	f	class:CvBlobTrackAnalysisOne	access:public	signature:()
CvBlobTrackFVGen	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackFVGen(){SetTypeName("BlobTrackFVGen");};$/;"	f	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackFVGen : public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackFVGen::AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(CvBlob* pBlob)
CvBlobTrackFVGen::CvBlobTrackFVGen	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackFVGen(){SetTypeName("BlobTrackFVGen");};$/;"	f	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::GetFV	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float*  GetFV(int index, int* pFVID) = 0; \/* Returns pointer to FV, if return 0 then FV not created *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(int index, int* pFVID)
CvBlobTrackFVGen::GetFVMax	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float*  GetFVMax() = 0; \/* Returns pointer to array of maximal values of FV, if returns 0 then FVrange does not exist *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::GetFVMin	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float*  GetFVMin() = 0; \/* Returns pointer to array of minimal values of FV, if returns 0 then FVrange does not exist *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::GetFVNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetFVNum() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::GetFVSize	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetFVSize() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::GetFVVar	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float*  GetFVVar(){return NULL;}; \/* Returns pointer to array of variation of values of FV, if returns 0 then FVVar does not exist. *\/$/;"	f	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(IplImage* pImg, IplImage* pFG)
CvBlobTrackFVGen::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackGen	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackGen(){SetTypeName("BlobTrackGen");};$/;"	f	class:CvBlobTrackGen	access:public	signature:()
CvBlobTrackGen	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackGen: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackGen::AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(CvBlob* pBlob)
CvBlobTrackGen::CvBlobTrackGen	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackGen(){SetTypeName("BlobTrackGen");};$/;"	f	class:CvBlobTrackGen	access:public	signature:()
CvBlobTrackGen::Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg = NULL, IplImage* pFG = NULL) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(IplImage* pImg = NULL, IplImage* pFG = NULL)
CvBlobTrackGen::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:()
CvBlobTrackGen::SetFileName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    SetFileName(char* pFileName) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(char* pFileName)
CvBlobTrackPostProc	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackPostProc(){SetTypeName("BlobTrackPostProc");};$/;"	f	class:CvBlobTrackPostProc	access:public	signature:()
CvBlobTrackPostProc	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackPostProc: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackPostProc::AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:(CvBlob* pBlob)
CvBlobTrackPostProc::CvBlobTrackPostProc	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackPostProc(){SetTypeName("BlobTrackPostProc");};$/;"	f	class:CvBlobTrackPostProc	access:public	signature:()
CvBlobTrackPostProc::GetBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int index) = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:(int index)
CvBlobTrackPostProc::GetBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID)$/;"	f	class:CvBlobTrackPostProc	access:public	signature:(int BlobID)
CvBlobTrackPostProc::GetBlobNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetBlobNum() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
CvBlobTrackPostProc::Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
CvBlobTrackPostProc::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
CvBlobTrackPostProcOne	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackPostProcOne(){SetTypeName("BlobTrackPostOne");};$/;"	f	class:CvBlobTrackPostProcOne	access:public	signature:()
CvBlobTrackPostProcOne	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackPostProcOne: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackPostProcOne::CvBlobTrackPostProcOne	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackPostProcOne(){SetTypeName("BlobTrackPostOne");};$/;"	f	class:CvBlobTrackPostProcOne	access:public	signature:()
CvBlobTrackPostProcOne::Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* Process(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPostProcOne	access:public	signature:(CvBlob* pBlob)
CvBlobTrackPostProcOne::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPostProcOne	access:public	signature:()
CvBlobTrackPredictor	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackPredictor(){SetTypeName("BlobTrackPredictor");};$/;"	f	class:CvBlobTrackPredictor	access:public	signature:()
CvBlobTrackPredictor	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CvBlobTrackPredictor: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackPredictor::CvBlobTrackPredictor	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackPredictor(){SetTypeName("BlobTrackPredictor");};$/;"	f	class:CvBlobTrackPredictor	access:public	signature:()
CvBlobTrackPredictor::Predict	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* Predict() = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:()
CvBlobTrackPredictor::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:()
CvBlobTrackPredictor::Update	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Update(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:(CvBlob* pBlob)
CvBlobTrackSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTrackSeq(int TrackSize = sizeof(CvBlobTrack));$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackSize = sizeof(CvBlobTrack))
CvBlobTrackSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackSeq$/;"	c
CvBlobTrackSeq::AddBlobTrack	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void AddBlobTrack(int TrackID, int StartFrame = 0);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID, int StartFrame = 0)
CvBlobTrackSeq::Clear	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Clear();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
CvBlobTrackSeq::CvBlobTrackSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTrackSeq(int TrackSize = sizeof(CvBlobTrack));$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackSize = sizeof(CvBlobTrack))
CvBlobTrackSeq::DelBlobTrack	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void DelBlobTrack(int TrackIndex);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackIndex)
CvBlobTrackSeq::DelBlobTrackByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void DelBlobTrackByID(int TrackID);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID)
CvBlobTrackSeq::GetBlobTrack	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlobTrack* GetBlobTrack(int TrackIndex);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackIndex)
CvBlobTrackSeq::GetBlobTrackByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlobTrack* GetBlobTrackByID(int TrackID);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID)
CvBlobTrackSeq::GetBlobTrackNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int GetBlobTrackNum();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
CvBlobTrackSeq::m_pMem	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvMemStorage*   m_pMem;$/;"	m	class:CvBlobTrackSeq	access:protected
CvBlobTrackSeq::m_pSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvSeq*          m_pSeq;$/;"	m	class:CvBlobTrackSeq	access:protected
CvBlobTrackSeq::~CvBlobTrackSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual ~CvBlobTrackSeq();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
CvBlobTracker	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTracker();$/;"	p	class:CvBlobTracker	access:public	signature:()
CvBlobTracker	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTracker: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTracker::AddBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* AddBlob(CvBlob* pBlob, IplImage* pImg, IplImage* pImgFG = NULL ) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(CvBlob* pBlob, IplImage* pImg, IplImage* pImgFG = NULL )
CvBlobTracker::CvBlobTracker	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTracker();$/;"	p	class:CvBlobTracker	access:public	signature:()
CvBlobTracker::DelBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    DelBlob(int BlobIndex) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex)
CvBlobTracker::DelBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    DelBlobByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
CvBlobTracker::GetBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int BlobIndex) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex)
CvBlobTracker::GetBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
CvBlobTracker::GetBlobHyp	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobHyp(int BlobIndex, int \/*hypothesis*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex, int )
CvBlobTracker::GetBlobHypNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetBlobHypNum(int \/*BlobIdx*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int )
CvBlobTracker::GetBlobIndexByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetBlobIndexByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
CvBlobTracker::GetBlobNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetBlobNum() = 0;$/;"	p	class:CvBlobTracker	access:public	signature:()
CvBlobTracker::GetConfidence	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual double  GetConfidence(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* , IplImage* , IplImage* = NULL)
CvBlobTracker::GetConfidenceList	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual double GetConfidenceList(CvBlobSeq* pBlobList, IplImage* pImg, IplImage* pImgFG = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(CvBlobSeq* pBlobList, IplImage* pImg, IplImage* pImgFG = NULL)
CvBlobTracker::Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(IplImage* pImg, IplImage* pImgFG = NULL)
CvBlobTracker::ProcessBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void ProcessBlob(int BlobIndex, CvBlob* pBlob, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex, CvBlob* pBlob, IplImage* , IplImage* = NULL)
CvBlobTracker::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTracker	access:public	signature:()
CvBlobTracker::SetBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    SetBlob(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* )
CvBlobTracker::SetBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    SetBlobByID(int BlobID, CvBlob* pBlob);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID, CvBlob* pBlob)
CvBlobTracker::SetBlobHyp	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    SetBlobHyp(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* )
CvBlobTracker::Update	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Update(IplImage* pImg, IplImage* pImgFG = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(IplImage* pImg, IplImage* pImgFG = NULL)
CvBlobTracker::UpdateBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void UpdateBlob(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* , IplImage* , IplImage* = NULL)
CvBlobTrackerAuto	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackerAuto(){SetTypeName("BlobTrackerAuto");};$/;"	f	class:CvBlobTrackerAuto	access:public	signature:()
CvBlobTrackerAuto	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackerAuto: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackerAuto::CvBlobTrackerAuto	/usr/include/opencv2/legacy/blobtrack.hpp	/^	CvBlobTrackerAuto(){SetTypeName("BlobTrackerAuto");};$/;"	f	class:CvBlobTrackerAuto	access:public	signature:()
CvBlobTrackerAuto::GetBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob*     GetBlob(int index) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int index)
CvBlobTrackerAuto::GetBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob*     GetBlobByID(int ID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int ID)
CvBlobTrackerAuto::GetBlobNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int         GetBlobNum() = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:()
CvBlobTrackerAuto::GetFGMask	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual IplImage*   GetFGMask(){return NULL;};$/;"	f	class:CvBlobTrackerAuto	access:public	signature:()
CvBlobTrackerAuto::GetState	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float       GetState(int BlobID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int BlobID)
CvBlobTrackerAuto::GetStateDesc	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual const char*       GetStateDesc(int BlobID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int BlobID)
CvBlobTrackerAuto::Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void        Process(IplImage* pImg, IplImage* pMask = NULL) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(IplImage* pImg, IplImage* pMask = NULL)
CvBlobTrackerAuto::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:()
CvBlobTrackerAutoParam1	/usr/include/opencv2/legacy/blobtrack.hpp	/^struct CvBlobTrackerAutoParam1$/;"	s
CvBlobTrackerAutoParam1::FGTrainFrames	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int                     FGTrainFrames; \/* Number of frames needed for FG (foreground) detector to train.        *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::UsePPData	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int                     UsePPData;$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pBD	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobDetector*         pBD;           \/* Selected blob detector module. 					    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pBT	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTracker*          pBT;           \/* Selected blob tracking module.					    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pBTA	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTrackAnalysis*    pBTA;          \/* Selected blob trajectory analysis module.                             *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pBTGen	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTrackGen*         pBTGen;        \/* Selected blob trajectory generator.				    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pBTPP	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTrackPostProc*    pBTPP;         \/* Selected blob trajectory postprocessing module.			    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pFG	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvFGDetector*           pFG;           \/* FGDetector module. If this field is NULL the Process FG mask is used. *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerOne	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackerOne : public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackerOne::GetConfidence	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual double GetConfidence(CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/,$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL, IplImage* = NULL)
CvBlobTrackerOne::Init	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Init(CvBlob* pBlobInit, IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:(CvBlob* pBlobInit, IplImage* pImg, IplImage* pImgFG = NULL)
CvBlobTrackerOne::Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* Process(CvBlob* pBlobPrev, IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:(CvBlob* pBlobPrev, IplImage* pImg, IplImage* pImgFG = NULL)
CvBlobTrackerOne::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Release() =  0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:()
CvBlobTrackerOne::SetCollision	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void SetCollision(int \/*CollisionFlag*\/){}; \/* call in case of blob collision situation*\/$/;"	f	class:CvBlobTrackerOne	access:public	signature:(int )
CvBlobTrackerOne::SkipProcess	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void SkipProcess(CvBlob* \/*pBlobPrev*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL){};$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL)
CvBlobTrackerOne::Update	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Update(CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL){};$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL)
CvBlobTrackerParamLH	/usr/include/opencv2/legacy/blobtrack.hpp	/^struct CvBlobTrackerParamLH$/;"	s
CvBlobTrackerParamLH::HistType	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     HistType; \/* see Prob.h *\/$/;"	m	struct:CvBlobTrackerParamLH	access:public
CvBlobTrackerParamLH::ScaleAfter	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     ScaleAfter;$/;"	m	struct:CvBlobTrackerParamLH	access:public
CvBlobTrackerParamMS	/usr/include/opencv2/legacy/blobtrack.hpp	/^struct CvBlobTrackerParamMS$/;"	s
CvBlobTrackerParamMS::appearance_profile	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     appearance_profile;$/;"	m	struct:CvBlobTrackerParamMS	access:public
CvBlobTrackerParamMS::meanshift_profile	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     meanshift_profile;$/;"	m	struct:CvBlobTrackerParamMS	access:public
CvBlobTrackerParamMS::noOfSigBits	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     noOfSigBits;$/;"	m	struct:CvBlobTrackerParamMS	access:public
CvBlobTrackerParamMS::sigma	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float   sigma;$/;"	m	struct:CvBlobTrackerParamMS	access:public
CvBool	/usr/include/opencv2/legacy/legacy.hpp	/^typedef unsigned char CvBool;$/;"	t
CvBoost	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvBoost( const cv::Mat& trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvBoostParams params=CvBoostParams() )
CvBoost	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvBoost();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost	/usr/include/opencv2/ml/ml.hpp	/^    CvBoost( const CvMat* trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvBoostParams params=CvBoostParams() )
CvBoost	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS_W CvBoost : public CvStatModel$/;"	c	inherits:CvStatModel
CvBoost::CvBoost	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvBoost( const cv::Mat& trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvBoostParams params=CvBoostParams() )
CvBoost::CvBoost	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvBoost();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::CvBoost	/usr/include/opencv2/ml/ml.hpp	/^    CvBoost( const CvMat* trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvBoostParams params=CvBoostParams() )
CvBoost::DEFAULT	/usr/include/opencv2/ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon86
CvBoost::DISCRETE	/usr/include/opencv2/ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon85
CvBoost::GENTLE	/usr/include/opencv2/ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon85
CvBoost::GINI	/usr/include/opencv2/ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon86
CvBoost::LOGIT	/usr/include/opencv2/ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon85
CvBoost::MISCLASS	/usr/include/opencv2/ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon86
CvBoost::REAL	/usr/include/opencv2/ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon85
CvBoost::SQERR	/usr/include/opencv2/ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon86
CvBoost::active_vars	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* active_vars;$/;"	m	class:CvBoost	access:protected
CvBoost::active_vars_abs	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* active_vars_abs;$/;"	m	class:CvBoost	access:protected
CvBoost::calc_error	/usr/include/opencv2/ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type , std::vector<float> *resp = 0 ); \/\/ type in {CV_TRAIN_ERROR, CV_TEST_ERROR}$/;"	p	class:CvBoost	access:public	signature:( CvMLData* _data, int type , std::vector<float> *resp = 0 )
CvBoost::clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::data	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvBoost	access:protected
CvBoost::get_active_vars	/usr/include/opencv2/ml/ml.hpp	/^    virtual const CvMat* get_active_vars(bool absolute_idx=true);$/;"	p	class:CvBoost	access:public	signature:(bool absolute_idx=true)
CvBoost::get_data	/usr/include/opencv2/ml/ml.hpp	/^    const CvDTreeTrainData* get_data() const;$/;"	p	class:CvBoost	access:public	signature:() const
CvBoost::get_params	/usr/include/opencv2/ml/ml.hpp	/^    const CvBoostParams& get_params() const;$/;"	p	class:CvBoost	access:public	signature:() const
CvBoost::get_subtree_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* get_subtree_weights();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::get_weak_predictors	/usr/include/opencv2/ml/ml.hpp	/^    CvSeq* get_weak_predictors();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::get_weak_response	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* get_weak_response();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::get_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* get_weights();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::have_active_cat_vars	/usr/include/opencv2/ml/ml.hpp	/^    bool have_active_cat_vars;$/;"	m	class:CvBoost	access:protected
CvBoost::have_subsample	/usr/include/opencv2/ml/ml.hpp	/^    bool have_subsample;$/;"	m	class:CvBoost	access:protected
CvBoost::orig_response	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* orig_response;$/;"	m	class:CvBoost	access:protected
CvBoost::params	/usr/include/opencv2/ml/ml.hpp	/^    CvBoostParams params;$/;"	m	class:CvBoost	access:protected
CvBoost::predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(),$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(), const cv::Range& slice=cv::Range::all(), bool rawMode=false, bool returnSum=false ) const
CvBoost::predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing=0,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* sample, const CvMat* missing=0, CvMat* weak_responses=0, CvSlice slice=CV_WHOLE_SEQ, bool raw_mode=false, bool return_sum=false ) const
CvBoost::prune	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void prune( CvSlice slice );$/;"	p	class:CvBoost	access:public	signature:( CvSlice slice )
CvBoost::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvBoost	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
CvBoost::read_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvBoost	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
CvBoost::set_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool set_params( const CvBoostParams& params );$/;"	p	class:CvBoost	access:protected	signature:( const CvBoostParams& params )
CvBoost::subsample_mask	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* subsample_mask;$/;"	m	class:CvBoost	access:protected
CvBoost::subtree_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* subtree_weights;$/;"	m	class:CvBoost	access:protected
CvBoost::sum_response	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* sum_response;$/;"	m	class:CvBoost	access:protected
CvBoost::train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvBoostParams params=CvBoostParams(), bool update=false )
CvBoost::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvMLData* data,$/;"	p	class:CvBoost	access:public	signature:( CvMLData* data, CvBoostParams params=CvBoostParams(), bool update=false )
CvBoost::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvBoostParams params=CvBoostParams(), bool update=false )
CvBoost::trim_weights	/usr/include/opencv2/ml/ml.hpp	/^    virtual void trim_weights();$/;"	p	class:CvBoost	access:protected	signature:()
CvBoost::update_weights	/usr/include/opencv2/ml/ml.hpp	/^    virtual void update_weights( CvBoostTree* tree );$/;"	p	class:CvBoost	access:protected	signature:( CvBoostTree* tree )
CvBoost::weak	/usr/include/opencv2/ml/ml.hpp	/^    CvSeq* weak;$/;"	m	class:CvBoost	access:protected
CvBoost::weak_eval	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* weak_eval;$/;"	m	class:CvBoost	access:protected
CvBoost::weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* weights;$/;"	m	class:CvBoost	access:protected
CvBoost::write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvBoost	access:public	signature:( CvFileStorage* storage, const char* name ) const
CvBoost::write_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvBoost	access:protected	signature:( CvFileStorage* fs ) const
CvBoost::~CvBoost	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvBoost();$/;"	p	class:CvBoost	access:public	signature:()
CvBoostParams	/usr/include/opencv2/ml/ml.hpp	/^    CvBoostParams( int boost_type, int weak_count, double weight_trim_rate,$/;"	p	struct:CvBoostParams	access:public	signature:( int boost_type, int weak_count, double weight_trim_rate, int max_depth, bool use_surrogates, const float* priors )
CvBoostParams	/usr/include/opencv2/ml/ml.hpp	/^    CvBoostParams();$/;"	p	struct:CvBoostParams	access:public	signature:()
CvBoostParams	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvBoostParams : public CvDTreeParams$/;"	s	inherits:CvDTreeParams
CvBoostParams::CvBoostParams	/usr/include/opencv2/ml/ml.hpp	/^    CvBoostParams( int boost_type, int weak_count, double weight_trim_rate,$/;"	p	struct:CvBoostParams	access:public	signature:( int boost_type, int weak_count, double weight_trim_rate, int max_depth, bool use_surrogates, const float* priors )
CvBoostParams::CvBoostParams	/usr/include/opencv2/ml/ml.hpp	/^    CvBoostParams();$/;"	p	struct:CvBoostParams	access:public	signature:()
CvBoostParams::boost_type	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int boost_type;$/;"	m	struct:CvBoostParams	access:public
CvBoostParams::split_criteria	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int split_criteria;$/;"	m	struct:CvBoostParams	access:public
CvBoostParams::weak_count	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int weak_count;$/;"	m	struct:CvBoostParams	access:public
CvBoostParams::weight_trim_rate	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double weight_trim_rate;$/;"	m	struct:CvBoostParams	access:public
CvBoostTree	/usr/include/opencv2/ml/ml.hpp	/^    CvBoostTree();$/;"	p	class:CvBoostTree	access:public	signature:()
CvBoostTree	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS CvBoostTree: public CvDTree$/;"	c	inherits:CvDTree
CvBoostTree::CvBoostTree	/usr/include/opencv2/ml/ml.hpp	/^    CvBoostTree();$/;"	p	class:CvBoostTree	access:public	signature:()
CvBoostTree::calc_node_dir	/usr/include/opencv2/ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
CvBoostTree::calc_node_value	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_node_value( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
CvBoostTree::clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvBoostTree	access:public	signature:()
CvBoostTree::ensemble	/usr/include/opencv2/ml/ml.hpp	/^    CvBoost* ensemble;$/;"	m	class:CvBoostTree	access:protected
CvBoostTree::find_split_cat_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvBoostTree::find_split_cat_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvBoostTree::find_split_ord_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvBoostTree::find_split_ord_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvBoostTree::find_surrogate_split_cat	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_cat( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
CvBoostTree::find_surrogate_split_ord	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_ord( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
CvBoostTree::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvBoostTree::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvBoost* ensemble, CvDTreeTrainData* _data )
CvBoostTree::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
CvBoostTree::scale	/usr/include/opencv2/ml/ml.hpp	/^    virtual void scale( double s );$/;"	p	class:CvBoostTree	access:public	signature:( double s )
CvBoostTree::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx );$/;"	p	class:CvBoostTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx )
CvBoostTree::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData,$/;"	p	class:CvBoostTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* subsample_idx, CvBoost* ensemble )
CvBoostTree::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvBoostTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
CvBoostTree::try_split_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual void try_split_node( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
CvBoostTree::~CvBoostTree	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvBoostTree();$/;"	p	class:CvBoostTree	access:public	signature:()
CvBox2D	/usr/include/opencv2/core/types_c.h	/^CvBox2D;$/;"	t	typeref:struct:CvBox2D
CvBox2D	/usr/include/opencv2/core/types_c.h	/^typedef struct CvBox2D$/;"	s
CvBox2D32f	/usr/include/opencv2/legacy/compat.hpp	/^typedef CvBox2D  CvBox2D32f;$/;"	t
CvBox2D::angle	/usr/include/opencv2/core/types_c.h	/^    float angle;          \/* Angle between the horizontal axis           *\/$/;"	m	struct:CvBox2D	access:public
CvBox2D::center	/usr/include/opencv2/core/types_c.h	/^    CvPoint2D32f center;  \/* Center of the box.                          *\/$/;"	m	struct:CvBox2D	access:public
CvBox2D::size	/usr/include/opencv2/core/types_c.h	/^    CvSize2D32f  size;    \/* Box width and length.                       *\/$/;"	m	struct:CvBox2D	access:public
CvButtonCallback	/usr/include/opencv2/highgui/highgui_c.h	/^typedef void (CV_CDECL *CvButtonCallback)(int state, void* userdata);$/;"	t
CvCalibEtalonType	/usr/include/opencv2/legacy/legacy.hpp	/^CvCalibEtalonType;$/;"	t	typeref:enum:CvCalibEtalonType
CvCalibEtalonType	/usr/include/opencv2/legacy/legacy.hpp	/^typedef enum CvCalibEtalonType$/;"	g
CvCalibFilter	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCalibFilter();$/;"	p	class:CvCalibFilter	access:public	signature:()
CvCalibFilter	/usr/include/opencv2/legacy/legacy.hpp	/^class CV_EXPORTS CvCalibFilter$/;"	c
CvCalibFilter::CvCalibFilter	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCalibFilter();$/;"	p	class:CvCalibFilter	access:public	signature:()
CvCalibFilter::DrawPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void DrawPoints( CvMat** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** dst )
CvCalibFilter::DrawPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void DrawPoints( IplImage** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** dst )
CvCalibFilter::FindEtalon	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool FindEtalon( CvMat** imgs );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** imgs )
CvCalibFilter::FindEtalon	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool FindEtalon( IplImage** imgs );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** imgs )
CvCalibFilter::GetCameraCount	/usr/include/opencv2/legacy/legacy.hpp	/^    int GetCameraCount() const { return cameraCount; }$/;"	f	class:CvCalibFilter	access:public	signature:() const
CvCalibFilter::GetCameraParams	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual const CvCamera* GetCameraParams( int idx = 0 ) const;$/;"	p	class:CvCalibFilter	access:public	signature:( int idx = 0 ) const
CvCalibFilter::GetEtalon	/usr/include/opencv2/legacy/legacy.hpp	/^        GetEtalon( int* paramCount = 0, const double** etalonParams = 0,$/;"	p	class:CvCalibFilter	access:public	signature:( int* paramCount = 0, const double** etalonParams = 0, int* pointCount = 0, const CvPoint2D32f** etalonPoints = 0 ) const
CvCalibFilter::GetFrameCount	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual int GetFrameCount( int* framesTotal = 0 ) const;$/;"	p	class:CvCalibFilter	access:public	signature:( int* framesTotal = 0 ) const
CvCalibFilter::GetLatestPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool GetLatestPoints( int idx, CvPoint2D32f** pts,$/;"	p	class:CvCalibFilter	access:public	signature:( int idx, CvPoint2D32f** pts, int* count, bool* found )
CvCalibFilter::GetStereoParams	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual const CvStereoCamera* GetStereoParams() const;$/;"	p	class:CvCalibFilter	access:public	signature:() const
CvCalibFilter::IsCalibrated	/usr/include/opencv2/legacy/legacy.hpp	/^    bool IsCalibrated() const { return isCalibrated; }$/;"	f	class:CvCalibFilter	access:public	signature:() const
CvCalibFilter::LoadCameraParams	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool LoadCameraParams( const char* filename );$/;"	p	class:CvCalibFilter	access:public	signature:( const char* filename )
CvCalibFilter::MAX_CAMERAS	/usr/include/opencv2/legacy/legacy.hpp	/^    enum { MAX_CAMERAS = 3 };$/;"	e	enum:CvCalibFilter::__anon177
CvCalibFilter::Push	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool Push( const CvPoint2D32f** points = 0 );$/;"	p	class:CvCalibFilter	access:public	signature:( const CvPoint2D32f** points = 0 )
CvCalibFilter::Rectify	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool Rectify( CvMat** srcarr, CvMat** dstarr );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** srcarr, CvMat** dstarr )
CvCalibFilter::Rectify	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool Rectify( IplImage** srcarr, IplImage** dstarr );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** srcarr, IplImage** dstarr )
CvCalibFilter::SaveCameraParams	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool SaveCameraParams( const char* filename );$/;"	p	class:CvCalibFilter	access:public	signature:( const char* filename )
CvCalibFilter::SetCameraCount	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void SetCameraCount( int cameraCount );$/;"	p	class:CvCalibFilter	access:public	signature:( int cameraCount )
CvCalibFilter::SetCameraParams	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool SetCameraParams( CvCamera* params );$/;"	p	class:CvCalibFilter	access:public	signature:( CvCamera* params )
CvCalibFilter::SetEtalon	/usr/include/opencv2/legacy/legacy.hpp	/^        SetEtalon( CvCalibEtalonType etalonType, double* etalonParams,$/;"	p	class:CvCalibFilter	access:public	signature:( CvCalibEtalonType etalonType, double* etalonParams, int pointCount = 0, CvPoint2D32f* points = 0 )
CvCalibFilter::SetFrames	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool SetFrames( int totalFrames );$/;"	p	class:CvCalibFilter	access:public	signature:( int totalFrames )
CvCalibFilter::Stop	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void Stop( bool calibrate = false );$/;"	p	class:CvCalibFilter	access:public	signature:( bool calibrate = false )
CvCalibFilter::Undistort	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool Undistort( CvMat** src, CvMat** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** src, CvMat** dst )
CvCalibFilter::Undistort	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool Undistort( IplImage** src, IplImage** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** src, IplImage** dst )
CvCalibFilter::cameraCount	/usr/include/opencv2/legacy/legacy.hpp	/^    int     cameraCount;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::cameraParams	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCamera cameraParams[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::etalonParamCount	/usr/include/opencv2/legacy/legacy.hpp	/^    int     etalonParamCount;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::etalonParams	/usr/include/opencv2/legacy/legacy.hpp	/^    double* etalonParams;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::etalonPointCount	/usr/include/opencv2/legacy/legacy.hpp	/^    int     etalonPointCount;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::etalonPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f* etalonPoints;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::etalonType	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCalibEtalonType  etalonType;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::framesAccepted	/usr/include/opencv2/legacy/legacy.hpp	/^    int     framesAccepted;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::framesTotal	/usr/include/opencv2/legacy/legacy.hpp	/^    int     framesTotal;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::grayImg	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat*  grayImg;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::imgSize	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSize  imgSize;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::isCalibrated	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    isCalibrated;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::latestCounts	/usr/include/opencv2/legacy/legacy.hpp	/^    int     latestCounts[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::latestPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f* latestPoints[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::maxPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    int     maxPoints;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::points	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f* points[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::rectMap	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat*  rectMap[MAX_CAMERAS][2];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::stereo	/usr/include/opencv2/legacy/legacy.hpp	/^    CvStereoCamera stereo;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::storage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::tempImg	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat*  tempImg;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::undistImg	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat*  undistImg;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::undistMap	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat*  undistMap[MAX_CAMERAS][2];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::~CvCalibFilter	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual ~CvCalibFilter();$/;"	p	class:CvCalibFilter	access:public	signature:()
CvCallback	/usr/include/opencv2/legacy/legacy.hpp	/^typedef int (CV_CDECL * CvCallback)(int index, void* buffer, void* user_data);$/;"	t
CvCamShiftTracker	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCamShiftTracker();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
CvCamShiftTracker	/usr/include/opencv2/legacy/legacy.hpp	/^class CV_EXPORTS CvCamShiftTracker$/;"	c
CvCamShiftTracker::CvCamShiftTracker	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCamShiftTracker();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
CvCamShiftTracker::color_transform	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void color_transform( const IplImage* img );$/;"	p	class:CvCamShiftTracker	access:protected	signature:( const IplImage* img )
CvCamShiftTracker::get_back_project	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual IplImage* get_back_project()$/;"	f	class:CvCamShiftTracker	access:public	signature:()
CvCamShiftTracker::get_center	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f get_center() const \/\/ center of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::get_hist_dims	/usr/include/opencv2/legacy/legacy.hpp	/^    int     get_hist_dims( int* dims = 0 ) const \/\/ returns number of histogram dimensions and sets$/;"	f	class:CvCamShiftTracker	access:public	signature:( int* dims = 0 ) const
CvCamShiftTracker::get_length	/usr/include/opencv2/legacy/legacy.hpp	/^    float   get_length() const \/\/ the larger linear size of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::get_max_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    int     get_max_ch_val( int channel ) const \/\/ get the maximum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel ) const
CvCamShiftTracker::get_min_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    int     get_min_ch_val( int channel ) const \/\/ get the minimum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel ) const
CvCamShiftTracker::get_orientation	/usr/include/opencv2/legacy/legacy.hpp	/^    float   get_orientation() const \/\/ orientation of the object in degrees$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::get_threshold	/usr/include/opencv2/legacy/legacy.hpp	/^    int     get_threshold() const \/\/ thresholding value that applied to back project$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::get_width	/usr/include/opencv2/legacy/legacy.hpp	/^    float   get_width() const \/\/ the smaller linear size of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::get_window	/usr/include/opencv2/legacy/legacy.hpp	/^    CvRect get_window() const \/\/ bounding rectangle for the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::m_back_project	/usr/include/opencv2/legacy/legacy.hpp	/^    IplImage*  m_back_project;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_box	/usr/include/opencv2/legacy/legacy.hpp	/^    CvBox2D    m_box;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_color_planes	/usr/include/opencv2/legacy/legacy.hpp	/^    IplImage*  m_color_planes[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_comp	/usr/include/opencv2/legacy/legacy.hpp	/^    CvConnectedComp m_comp;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_hist	/usr/include/opencv2/legacy/legacy.hpp	/^    CvHistogram* m_hist;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_hist_ranges	/usr/include/opencv2/legacy/legacy.hpp	/^    float*     m_hist_ranges[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_hist_ranges_data	/usr/include/opencv2/legacy/legacy.hpp	/^    float      m_hist_ranges_data[CV_MAX_DIM][2];$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_mask	/usr/include/opencv2/legacy/legacy.hpp	/^    IplImage*  m_mask;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_max_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    int        m_max_ch_val[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_min_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    int        m_min_ch_val[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_temp	/usr/include/opencv2/legacy/legacy.hpp	/^    IplImage*  m_temp;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_threshold	/usr/include/opencv2/legacy/legacy.hpp	/^    int        m_threshold;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::query	/usr/include/opencv2/legacy/legacy.hpp	/^    float query( int* bin ) const$/;"	f	class:CvCamShiftTracker	access:public	signature:( int* bin ) const
CvCamShiftTracker::reset_histogram	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void  reset_histogram();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
CvCamShiftTracker::set_hist_bin_range	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_hist_bin_range( int dim, int min_val, int max_val );$/;"	p	class:CvCamShiftTracker	access:public	signature:( int dim, int min_val, int max_val )
CvCamShiftTracker::set_hist_dims	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_hist_dims( int c_dims, int* dims );\/\/ set the histogram parameters$/;"	p	class:CvCamShiftTracker	access:public	signature:( int c_dims, int* dims )
CvCamShiftTracker::set_max_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_max_ch_val( int channel, int val ) \/\/ set the maximum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel, int val )
CvCamShiftTracker::set_min_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_min_ch_val( int channel, int val ) \/\/ set the minimum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel, int val )
CvCamShiftTracker::set_threshold	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_threshold( int threshold ) \/\/ threshold applied to the histogram bins$/;"	f	class:CvCamShiftTracker	access:public	signature:( int threshold )
CvCamShiftTracker::set_window	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_window( CvRect window)$/;"	f	class:CvCamShiftTracker	access:public	signature:( CvRect window)
CvCamShiftTracker::track_object	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool  track_object( const IplImage* cur_frame );$/;"	p	class:CvCamShiftTracker	access:public	signature:( const IplImage* cur_frame )
CvCamShiftTracker::update_histogram	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool  update_histogram( const IplImage* cur_frame );$/;"	p	class:CvCamShiftTracker	access:public	signature:( const IplImage* cur_frame )
CvCamShiftTracker::~CvCamShiftTracker	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual ~CvCamShiftTracker();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
CvCamera	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvCamera$/;"	s
CvCamera	/usr/include/opencv2/legacy/legacy.hpp	/^} CvCamera;$/;"	t	typeref:struct:CvCamera
CvCamera::distortion	/usr/include/opencv2/legacy/legacy.hpp	/^    float   distortion[4]; \/* distortion coefficients - two coefficients for radial distortion$/;"	m	struct:CvCamera	access:public
CvCamera::imgSize	/usr/include/opencv2/legacy/legacy.hpp	/^    float   imgSize[2]; \/* size of the camera view, used during calibration *\/$/;"	m	struct:CvCamera	access:public
CvCamera::matrix	/usr/include/opencv2/legacy/legacy.hpp	/^    float   matrix[9]; \/* intinsic camera parameters:  [ fx 0 cx; 0 fy cy; 0 0 1 ] *\/$/;"	m	struct:CvCamera	access:public
CvCamera::rotMatr	/usr/include/opencv2/legacy/legacy.hpp	/^    float   rotMatr[9];$/;"	m	struct:CvCamera	access:public
CvCamera::transVect	/usr/include/opencv2/legacy/legacy.hpp	/^    float   transVect[3]; \/* rotation matrix and transition vector relatively$/;"	m	struct:CvCamera	access:public
CvCapture	/usr/include/opencv2/highgui/highgui_c.h	/^typedef struct CvCapture CvCapture;$/;"	t	typeref:struct:CvCapture
CvChain	/usr/include/opencv2/core/types_c.h	/^CvChain;$/;"	t	typeref:struct:CvChain
CvChain	/usr/include/opencv2/core/types_c.h	/^typedef struct CvChain$/;"	s
CvChain::origin	/usr/include/opencv2/core/types_c.h	/^    CvPoint  origin;$/;"	m	struct:CvChain	access:public
CvChainApproxMethod	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvChainApproxMethod;$/;"	t
CvChainPtReader	/usr/include/opencv2/imgproc/types_c.h	/^CvChainPtReader;$/;"	t	typeref:struct:CvChainPtReader
CvChainPtReader	/usr/include/opencv2/imgproc/types_c.h	/^typedef struct CvChainPtReader$/;"	s
CvChainPtReader::code	/usr/include/opencv2/imgproc/types_c.h	/^    char      code;$/;"	m	struct:CvChainPtReader	access:public
CvChainPtReader::deltas	/usr/include/opencv2/imgproc/types_c.h	/^    schar     deltas[8][2];$/;"	m	struct:CvChainPtReader	access:public
CvChainPtReader::pt	/usr/include/opencv2/imgproc/types_c.h	/^    CvPoint   pt;$/;"	m	struct:CvChainPtReader	access:public
CvCliqueFinder	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvCliqueFinder$/;"	s
CvCliqueFinder	/usr/include/opencv2/legacy/legacy.hpp	/^} CvCliqueFinder;$/;"	t	typeref:struct:CvCliqueFinder
CvCliqueFinder::All	/usr/include/opencv2/legacy/legacy.hpp	/^    int** All;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::N	/usr/include/opencv2/legacy/legacy.hpp	/^    int N; \/\/graph size$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::adj_matr	/usr/include/opencv2/legacy/legacy.hpp	/^    int**    adj_matr;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::best_score	/usr/include/opencv2/legacy/legacy.hpp	/^    int best_score;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::best_weight	/usr/include/opencv2/legacy/legacy.hpp	/^    float best_weight;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::cand_weight	/usr/include/opencv2/legacy/legacy.hpp	/^    float* cand_weight;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::ce	/usr/include/opencv2/legacy/legacy.hpp	/^    int* ce;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::cur_weight	/usr/include/opencv2/legacy/legacy.hpp	/^    float* cur_weight;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::current_comp	/usr/include/opencv2/legacy/legacy.hpp	/^    int* current_comp;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::edge_weights	/usr/include/opencv2/legacy/legacy.hpp	/^    float* edge_weights;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::fixp	/usr/include/opencv2/legacy/legacy.hpp	/^    int* fixp; \/\/node with minimal disconnections$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::graph	/usr/include/opencv2/legacy/legacy.hpp	/^    CvGraph* graph;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::k	/usr/include/opencv2/legacy/legacy.hpp	/^    int k; \/\/stack size$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::ne	/usr/include/opencv2/legacy/legacy.hpp	/^    int* ne;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::nod	/usr/include/opencv2/legacy/legacy.hpp	/^    int* nod;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::s	/usr/include/opencv2/legacy/legacy.hpp	/^    int* s; \/\/for selected candidate$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::status	/usr/include/opencv2/legacy/legacy.hpp	/^    int status;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::vertex_weights	/usr/include/opencv2/legacy/legacy.hpp	/^    float* vertex_weights;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::weighted	/usr/include/opencv2/legacy/legacy.hpp	/^    int weighted;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::weighted_edges	/usr/include/opencv2/legacy/legacy.hpp	/^    int weighted_edges;    $/;"	m	struct:CvCliqueFinder	access:public
CvCloneFunc	/usr/include/opencv2/core/types_c.h	/^typedef void* (CV_CDECL *CvCloneFunc)( const void* struct_ptr );$/;"	t
CvCmpFunc	/usr/include/opencv2/core/core_c.h	/^typedef int (CV_CDECL* CvCmpFunc)(const void* a, const void* b, void* userdata );$/;"	t
CvCoeffType	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvCoeffType;$/;"	t
CvCompareMethod	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvCompareMethod;$/;"	t
CvConDensation	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvConDensation$/;"	s
CvConDensation	/usr/include/opencv2/legacy/legacy.hpp	/^} CvConDensation;$/;"	t	typeref:struct:CvConDensation
CvConDensation::DP	/usr/include/opencv2/legacy/legacy.hpp	/^    int DP;$/;"	m	struct:CvConDensation	access:public
CvConDensation::DynamMatr	/usr/include/opencv2/legacy/legacy.hpp	/^    float* DynamMatr;       \/* Matrix of the linear Dynamics system  *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::MP	/usr/include/opencv2/legacy/legacy.hpp	/^    int MP;$/;"	m	struct:CvConDensation	access:public
CvConDensation::RandS	/usr/include/opencv2/legacy/legacy.hpp	/^    struct CvRandState* RandS; \/* Array of structures to generate random vectors *\/$/;"	m	struct:CvConDensation	typeref:struct:CvConDensation::CvRandState	access:public
CvConDensation::RandomSample	/usr/include/opencv2/legacy/legacy.hpp	/^    float* RandomSample;    \/* RandomVector to update sample set     *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::SamplesNum	/usr/include/opencv2/legacy/legacy.hpp	/^    int SamplesNum;         \/* Number of the Samples                 *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::State	/usr/include/opencv2/legacy/legacy.hpp	/^    float* State;           \/* Vector of State                       *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::Temp	/usr/include/opencv2/legacy/legacy.hpp	/^    float* Temp;            \/* Temporary vector                      *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::flConfidence	/usr/include/opencv2/legacy/legacy.hpp	/^    float* flConfidence;    \/* Confidence for each Sample            *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::flCumulative	/usr/include/opencv2/legacy/legacy.hpp	/^    float* flCumulative;    \/* Cumulative confidence                 *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::flNewSamples	/usr/include/opencv2/legacy/legacy.hpp	/^    float** flNewSamples;   \/* temporary array of the Sample Vectors *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::flSamples	/usr/include/opencv2/legacy/legacy.hpp	/^    float** flSamples;      \/* arr of the Sample Vectors             *\/$/;"	m	struct:CvConDensation	access:public
CvConnectedComp	/usr/include/opencv2/imgproc/types_c.h	/^CvConnectedComp;$/;"	t	typeref:struct:CvConnectedComp
CvConnectedComp	/usr/include/opencv2/imgproc/types_c.h	/^typedef struct CvConnectedComp$/;"	s
CvConnectedComp::area	/usr/include/opencv2/imgproc/types_c.h	/^    double area;    \/* area of the connected component  *\/$/;"	m	struct:CvConnectedComp	access:public
CvConnectedComp::contour	/usr/include/opencv2/imgproc/types_c.h	/^    CvSeq* contour; \/* optional component boundary$/;"	m	struct:CvConnectedComp	access:public
CvConnectedComp::rect	/usr/include/opencv2/imgproc/types_c.h	/^    CvRect rect;    \/* ROI of the component  *\/$/;"	m	struct:CvConnectedComp	access:public
CvConnectedComp::value	/usr/include/opencv2/imgproc/types_c.h	/^    CvScalar value; \/* average color of the connected component *\/$/;"	m	struct:CvConnectedComp	access:public
CvContour	/usr/include/opencv2/core/types_c.h	/^CvContour;$/;"	t	typeref:struct:CvContour
CvContour	/usr/include/opencv2/core/types_c.h	/^typedef struct CvContour$/;"	s
CvContourOrientation	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvContourOrientation$/;"	s
CvContourOrientation	/usr/include/opencv2/legacy/legacy.hpp	/^} CvContourOrientation;$/;"	t	typeref:struct:CvContourOrientation
CvContourOrientation::egvals	/usr/include/opencv2/legacy/legacy.hpp	/^    float egvals[2];$/;"	m	struct:CvContourOrientation	access:public
CvContourOrientation::egvects	/usr/include/opencv2/legacy/legacy.hpp	/^    float egvects[4];$/;"	m	struct:CvContourOrientation	access:public
CvContourOrientation::imax	/usr/include/opencv2/legacy/legacy.hpp	/^    int imax, imin;$/;"	m	struct:CvContourOrientation	access:public
CvContourOrientation::imin	/usr/include/opencv2/legacy/legacy.hpp	/^    int imax, imin;$/;"	m	struct:CvContourOrientation	access:public
CvContourOrientation::max	/usr/include/opencv2/legacy/legacy.hpp	/^    float max, min; \/\/ minimum and maximum projections$/;"	m	struct:CvContourOrientation	access:public
CvContourOrientation::min	/usr/include/opencv2/legacy/legacy.hpp	/^    float max, min; \/\/ minimum and maximum projections$/;"	m	struct:CvContourOrientation	access:public
CvContourRetrievalMode	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvContourRetrievalMode;$/;"	t
CvContourScanner	/usr/include/opencv2/imgproc/types_c.h	/^typedef struct _CvContourScanner* CvContourScanner;$/;"	t	typeref:struct:_CvContourScanner
CvContourTree	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvContourTree$/;"	s
CvContourTree	/usr/include/opencv2/legacy/legacy.hpp	/^} CvContourTree;$/;"	t	typeref:struct:CvContourTree
CvContourTree::p1	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint p1;            \/* the first point of the binary tree root segment *\/$/;"	m	struct:CvContourTree	access:public
CvContourTree::p2	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint p2;            \/* the last point of the binary tree root segment *\/$/;"	m	struct:CvContourTree	access:public
CvContourTreesMatchMethod	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvContourTreesMatchMethod;$/;"	t
CvContoursMatchMethod	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvContoursMatchMethod;$/;"	t
CvConvexityDefect	/usr/include/opencv2/imgproc/types_c.h	/^typedef struct CvConvexityDefect$/;"	s
CvConvexityDefect	/usr/include/opencv2/imgproc/types_c.h	/^} CvConvexityDefect;$/;"	t	typeref:struct:CvConvexityDefect
CvConvexityDefect::depth	/usr/include/opencv2/imgproc/types_c.h	/^    float depth; \/* distance between the farthest point and the convex hull *\/$/;"	m	struct:CvConvexityDefect	access:public
CvConvexityDefect::depth_point	/usr/include/opencv2/imgproc/types_c.h	/^    CvPoint* depth_point; \/* the farthest from the convex hull point within the defect *\/$/;"	m	struct:CvConvexityDefect	access:public
CvConvexityDefect::end	/usr/include/opencv2/imgproc/types_c.h	/^    CvPoint* end; \/* point of the contour where the defect ends *\/$/;"	m	struct:CvConvexityDefect	access:public
CvConvexityDefect::start	/usr/include/opencv2/imgproc/types_c.h	/^    CvPoint* start; \/* point of the contour where the defect begins *\/$/;"	m	struct:CvConvexityDefect	access:public
CvDTree	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvDTree();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS_W CvDTree : public CvStatModel$/;"	c	inherits:CvStatModel
CvDTree::CvDTree	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvDTree();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree::calc_error	/usr/include/opencv2/ml/ml.hpp	/^    virtual float calc_error( CvMLData* trainData, int type, std::vector<float> *resp = 0 );$/;"	p	class:CvDTree	access:public	signature:( CvMLData* trainData, int type, std::vector<float> *resp = 0 )
CvDTree::calc_node_dir	/usr/include/opencv2/ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
CvDTree::calc_node_value	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_node_value( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
CvDTree::clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree::cluster_categories	/usr/include/opencv2/ml/ml.hpp	/^    virtual void cluster_categories( const int* vectors, int vector_count,$/;"	p	class:CvDTree	access:protected	signature:( const int* vectors, int vector_count, int var_count, int* sums, int k, int* cluster_labels )
CvDTree::complete_node_dir	/usr/include/opencv2/ml/ml.hpp	/^    virtual void complete_node_dir( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
CvDTree::cut_tree	/usr/include/opencv2/ml/ml.hpp	/^    virtual int cut_tree( int T, int fold, double min_alpha );$/;"	p	class:CvDTree	access:protected	signature:( int T, int fold, double min_alpha )
CvDTree::data	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvDTree	access:protected
CvDTree::do_train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool do_train( const CvMat* _subsample_idx );$/;"	p	class:CvDTree	access:protected	signature:( const CvMat* _subsample_idx )
CvDTree::find_best_split	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_best_split( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
CvDTree::find_split_cat_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvDTree::find_split_cat_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvDTree::find_split_ord_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvDTree::find_split_ord_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvDTree::find_surrogate_split_cat	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_cat( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
CvDTree::find_surrogate_split_ord	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_ord( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
CvDTree::free_prune_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void free_prune_data(bool cut_tree);$/;"	p	class:CvDTree	access:protected	signature:(bool cut_tree)
CvDTree::free_tree	/usr/include/opencv2/ml/ml.hpp	/^    virtual void free_tree();$/;"	p	class:CvDTree	access:protected	signature:()
CvDTree::getVarImportance	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual cv::Mat getVarImportance();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree::get_data	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData* get_data();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree::get_pruned_tree_idx	/usr/include/opencv2/ml/ml.hpp	/^    int get_pruned_tree_idx() const;$/;"	p	class:CvDTree	access:public	signature:() const
CvDTree::get_root	/usr/include/opencv2/ml/ml.hpp	/^    const CvDTreeNode* get_root() const;$/;"	p	class:CvDTree	access:public	signature:() const
CvDTree::get_var_importance	/usr/include/opencv2/ml/ml.hpp	/^    virtual const CvMat* get_var_importance();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree::predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual CvDTreeNode* predict( const cv::Mat& sample, const cv::Mat& missingDataMask=cv::Mat(),$/;"	p	class:CvDTree	access:public	signature:( const cv::Mat& sample, const cv::Mat& missingDataMask=cv::Mat(), bool preprocessedInput=false ) const
CvDTree::predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeNode* predict( const CvMat* sample, const CvMat* missingDataMask=0,$/;"	p	class:CvDTree	access:public	signature:( const CvMat* sample, const CvMat* missingDataMask=0, bool preprocessedInput=false ) const
CvDTree::prune_cv	/usr/include/opencv2/ml/ml.hpp	/^    virtual void prune_cv();$/;"	p	class:CvDTree	access:protected	signature:()
CvDTree::pruned_tree_idx	/usr/include/opencv2/ml/ml.hpp	/^    int pruned_tree_idx;$/;"	m	class:CvDTree	access:public
CvDTree::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvDTree::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
CvDTree::read_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeNode* read_node( CvFileStorage* fs, CvFileNode* node, CvDTreeNode* parent );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeNode* parent )
CvDTree::read_split	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* read_split( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
CvDTree::read_tree_nodes	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_tree_nodes( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
CvDTree::root	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode* root;$/;"	m	class:CvDTree	access:protected
CvDTree::split_node_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void split_node_data( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
CvDTree::train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvDTree	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvDTreeParams params=CvDTreeParams() )
CvDTree::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* subsampleIdx );$/;"	p	class:CvDTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* subsampleIdx )
CvDTree::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvMLData* trainData, CvDTreeParams params=CvDTreeParams() );$/;"	p	class:CvDTree	access:public	signature:( CvMLData* trainData, CvDTreeParams params=CvDTreeParams() )
CvDTree::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvDTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
CvDTree::try_split_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual void try_split_node( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
CvDTree::update_tree_rnc	/usr/include/opencv2/ml/ml.hpp	/^    virtual double update_tree_rnc( int T, int fold );$/;"	p	class:CvDTree	access:protected	signature:( int T, int fold )
CvDTree::var_importance	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_importance;$/;"	m	class:CvDTree	access:protected
CvDTree::write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* fs ) const;$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs ) const
CvDTree::write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, const char* name ) const
CvDTree::write_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_node( CvFileStorage* fs, CvDTreeNode* node ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvDTreeNode* node ) const
CvDTree::write_split	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_split( CvFileStorage* fs, CvDTreeSplit* split ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvDTreeSplit* split ) const
CvDTree::write_tree_nodes	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_tree_nodes( CvFileStorage* fs ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs ) const
CvDTree::~CvDTree	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvDTree();$/;"	p	class:CvDTree	access:public	signature:()
CvDTreeNode	/usr/include/opencv2/ml/ml.hpp	/^struct CvDTreeNode$/;"	s
CvDTreeNode::Tn	/usr/include/opencv2/ml/ml.hpp	/^    int Tn;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::alpha	/usr/include/opencv2/ml/ml.hpp	/^    double alpha;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::buf_idx	/usr/include/opencv2/ml/ml.hpp	/^    int buf_idx;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::class_idx	/usr/include/opencv2/ml/ml.hpp	/^    int class_idx;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::complexity	/usr/include/opencv2/ml/ml.hpp	/^    int complexity;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::cv_Tn	/usr/include/opencv2/ml/ml.hpp	/^    int* cv_Tn;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::cv_node_error	/usr/include/opencv2/ml/ml.hpp	/^    double* cv_node_error;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::cv_node_risk	/usr/include/opencv2/ml/ml.hpp	/^    double* cv_node_risk;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::depth	/usr/include/opencv2/ml/ml.hpp	/^    int depth;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::get_num_valid	/usr/include/opencv2/ml/ml.hpp	/^    int get_num_valid(int vi) { return num_valid ? num_valid[vi] : sample_count; }$/;"	f	struct:CvDTreeNode	access:public	signature:(int vi)
CvDTreeNode::left	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode* left;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::maxlr	/usr/include/opencv2/ml/ml.hpp	/^    double maxlr;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::node_risk	/usr/include/opencv2/ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::num_valid	/usr/include/opencv2/ml/ml.hpp	/^    int* num_valid;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::offset	/usr/include/opencv2/ml/ml.hpp	/^    int offset;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::parent	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode* parent;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::right	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode* right;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::sample_count	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::set_num_valid	/usr/include/opencv2/ml/ml.hpp	/^    void set_num_valid(int vi, int n) { if( num_valid ) num_valid[vi] = n; }$/;"	f	struct:CvDTreeNode	access:public	signature:(int vi, int n)
CvDTreeNode::split	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeSplit* split;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::tree_error	/usr/include/opencv2/ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::tree_risk	/usr/include/opencv2/ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::value	/usr/include/opencv2/ml/ml.hpp	/^    double value;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeParams	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeParams( int _max_depth, int _min_sample_count,$/;"	f	struct:CvDTreeParams	access:public	signature:( int _max_depth, int _min_sample_count, float _regression_accuracy, bool _use_surrogates, int _max_categories, int _cv_folds, bool _use_1se_rule, bool _truncate_pruned_tree, const float* _priors )
CvDTreeParams	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeParams() : max_categories(10), max_depth(INT_MAX), min_sample_count(10),$/;"	f	struct:CvDTreeParams	access:public	signature:()
CvDTreeParams	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvDTreeParams$/;"	s
CvDTreeParams::CvDTreeParams	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeParams( int _max_depth, int _min_sample_count,$/;"	f	struct:CvDTreeParams	access:public	signature:( int _max_depth, int _min_sample_count, float _regression_accuracy, bool _use_surrogates, int _max_categories, int _cv_folds, bool _use_1se_rule, bool _truncate_pruned_tree, const float* _priors )
CvDTreeParams::CvDTreeParams	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeParams() : max_categories(10), max_depth(INT_MAX), min_sample_count(10),$/;"	f	struct:CvDTreeParams	access:public	signature:()
CvDTreeParams::cv_folds	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int   cv_folds;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::max_categories	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int   max_categories;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::max_depth	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int   max_depth;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::min_sample_count	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int   min_sample_count;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::priors	/usr/include/opencv2/ml/ml.hpp	/^    const float* priors;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::regression_accuracy	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW float regression_accuracy;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::truncate_pruned_tree	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW bool  truncate_pruned_tree;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::use_1se_rule	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW bool  use_1se_rule;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::use_surrogates	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW bool  use_surrogates;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeSplit	/usr/include/opencv2/ml/ml.hpp	/^struct CvDTreeSplit$/;"	s
CvDTreeSplit::__anon83::__anon84::c	/usr/include/opencv2/ml/ml.hpp	/^            float c;$/;"	m	struct:CvDTreeSplit::__anon83::__anon84	access:public
CvDTreeSplit::__anon83::__anon84::split_point	/usr/include/opencv2/ml/ml.hpp	/^            int split_point;$/;"	m	struct:CvDTreeSplit::__anon83::__anon84	access:public
CvDTreeSplit::__anon83::ord	/usr/include/opencv2/ml/ml.hpp	/^        ord;$/;"	m	union:CvDTreeSplit::__anon83	typeref:struct:CvDTreeSplit::__anon83::__anon84	access:public
CvDTreeSplit::__anon83::subset	/usr/include/opencv2/ml/ml.hpp	/^        int subset[2];$/;"	m	union:CvDTreeSplit::__anon83	access:public
CvDTreeSplit::condensed_idx	/usr/include/opencv2/ml/ml.hpp	/^    int condensed_idx;$/;"	m	struct:CvDTreeSplit	access:public
CvDTreeSplit::inversed	/usr/include/opencv2/ml/ml.hpp	/^    int inversed;$/;"	m	struct:CvDTreeSplit	access:public
CvDTreeSplit::next	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeSplit* next;$/;"	m	struct:CvDTreeSplit	access:public
CvDTreeSplit::quality	/usr/include/opencv2/ml/ml.hpp	/^    float quality;$/;"	m	struct:CvDTreeSplit	access:public
CvDTreeSplit::var_idx	/usr/include/opencv2/ml/ml.hpp	/^    int var_idx;$/;"	m	struct:CvDTreeSplit	access:public
CvDTreeTrainData	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData( const CvMat* trainData, int tflag,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false )
CvDTreeTrainData	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDTreeTrainData	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS CvDTreeTrainData$/;"	s
CvDTreeTrainData::CvDTreeTrainData	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData( const CvMat* trainData, int tflag,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false )
CvDTreeTrainData::CvDTreeTrainData	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDTreeTrainData::buf	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* buf;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::buf_count	/usr/include/opencv2/ml/ml.hpp	/^    int buf_count, buf_size;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::buf_size	/usr/include/opencv2/ml/ml.hpp	/^    int buf_count, buf_size;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::cat_count	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* cat_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::cat_map	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* cat_map;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::cat_ofs	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* cat_ofs;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::cat_var_count	/usr/include/opencv2/ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDTreeTrainData::counts	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* counts;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::cv_heap	/usr/include/opencv2/ml/ml.hpp	/^    CvSet* cv_heap;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::data_root	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode* data_root;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::direction	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* direction;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::do_responses_copy	/usr/include/opencv2/ml/ml.hpp	/^    virtual void do_responses_copy();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDTreeTrainData::free_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual void free_node( CvDTreeNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* node )
CvDTreeTrainData::free_node_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void free_node_data( CvDTreeNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* node )
CvDTreeTrainData::free_train_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void free_train_data();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDTreeTrainData::get_cat_var_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_cat_var_data( CvDTreeNode* n, int vi, int* cat_values_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, int* cat_values_buf )
CvDTreeTrainData::get_child_buf_idx	/usr/include/opencv2/ml/ml.hpp	/^    virtual int get_child_buf_idx( CvDTreeNode* n );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n )
CvDTreeTrainData::get_class_labels	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_class_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
CvDTreeTrainData::get_cv_labels	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_cv_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
CvDTreeTrainData::get_num_classes	/usr/include/opencv2/ml/ml.hpp	/^    int get_num_classes() const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:() const
CvDTreeTrainData::get_ord_responses	/usr/include/opencv2/ml/ml.hpp	/^    virtual const float* get_ord_responses( CvDTreeNode* n, float* values_buf, int* sample_indices_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, float* values_buf, int* sample_indices_buf )
CvDTreeTrainData::get_ord_var_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void get_ord_var_data( CvDTreeNode* n, int vi, float* ord_values_buf, int* sorted_indices_buf,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, float* ord_values_buf, int* sorted_indices_buf, const float** ord_values, const int** sorted_indices, int* sample_indices_buf )
CvDTreeTrainData::get_sample_indices	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_sample_indices( CvDTreeNode* n, int* indices_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* indices_buf )
CvDTreeTrainData::get_var_type	/usr/include/opencv2/ml/ml.hpp	/^    int get_var_type(int vi) const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:(int vi) const
CvDTreeTrainData::get_vectors	/usr/include/opencv2/ml/ml.hpp	/^    virtual void get_vectors( const CvMat* _subsample_idx,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* _subsample_idx, float* values, uchar* missing, float* responses, bool get_class_idx=false )
CvDTreeTrainData::get_work_var_count	/usr/include/opencv2/ml/ml.hpp	/^    int get_work_var_count() const {return work_var_count;}$/;"	f	struct:CvDTreeTrainData	access:public	signature:() const
CvDTreeTrainData::have_labels	/usr/include/opencv2/ml/ml.hpp	/^    bool have_labels, have_priors;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::have_priors	/usr/include/opencv2/ml/ml.hpp	/^    bool have_labels, have_priors;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::is_buf_16u	/usr/include/opencv2/ml/ml.hpp	/^    int is_buf_16u;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::is_classifier	/usr/include/opencv2/ml/ml.hpp	/^    bool is_classifier;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::max_c_count	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::new_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeNode* new_node( CvDTreeNode* parent, int count,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* parent, int count, int storage_idx, int offset )
CvDTreeTrainData::new_split_cat	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* new_split_cat( int vi, float quality );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( int vi, float quality )
CvDTreeTrainData::new_split_ord	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* new_split_ord( int vi, float cmp_val,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( int vi, float cmp_val, int split_point, int inversed, float quality )
CvDTreeTrainData::node_heap	/usr/include/opencv2/ml/ml.hpp	/^    CvSet* node_heap;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::nv_heap	/usr/include/opencv2/ml/ml.hpp	/^    CvSet* nv_heap;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::ord_var_count	/usr/include/opencv2/ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::params	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeParams params;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::priors	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* priors;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::priors_mult	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* priors_mult;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::read_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvDTreeTrainData::responses	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* responses;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::responses_copy	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* responses_copy; \/\/ used in Boosting$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::rng	/usr/include/opencv2/ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::sample_count	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::set_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void set_data( const CvMat* trainData, int tflag,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false, bool _update_data=false )
CvDTreeTrainData::set_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool set_params( const CvDTreeParams& params );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvDTreeParams& params )
CvDTreeTrainData::shared	/usr/include/opencv2/ml/ml.hpp	/^    bool shared;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::split_buf	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* split_buf;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::split_heap	/usr/include/opencv2/ml/ml.hpp	/^    CvSet* split_heap;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::subsample_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeNode* subsample_data( const CvMat* _subsample_idx );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* _subsample_idx )
CvDTreeTrainData::temp_storage	/usr/include/opencv2/ml/ml.hpp	/^    CvMemStorage* temp_storage;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::tflag	/usr/include/opencv2/ml/ml.hpp	/^    int tflag;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::train_data	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* train_data;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::tree_storage	/usr/include/opencv2/ml/ml.hpp	/^    CvMemStorage* tree_storage;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::var_all	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::var_count	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::var_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_idx;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::var_type	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_type; \/\/ i-th element =$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::work_var_count	/usr/include/opencv2/ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::write_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvFileStorage* fs ) const
CvDTreeTrainData::~CvDTreeTrainData	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvDTreeTrainData();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDefParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^struct CvDefParam$/;"	s
CvDefParam::Double	/usr/include/opencv2/legacy/blobtrack.hpp	/^    double              Double;$/;"	m	struct:CvDefParam	access:public
CvDefParam::Float	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float               Float;$/;"	m	struct:CvDefParam	access:public
CvDefParam::Int	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int                 Int;$/;"	m	struct:CvDefParam	access:public
CvDefParam::Str	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*               Str;$/;"	m	struct:CvDefParam	access:public
CvDefParam::next	/usr/include/opencv2/legacy/blobtrack.hpp	/^    struct CvDefParam*    next;$/;"	m	struct:CvDefParam	typeref:struct:CvDefParam::CvDefParam	access:public
CvDefParam::pComment	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*               pComment;$/;"	m	struct:CvDefParam	access:public
CvDefParam::pDouble	/usr/include/opencv2/legacy/blobtrack.hpp	/^    double*             pDouble;$/;"	m	struct:CvDefParam	access:public
CvDefParam::pFloat	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float*              pFloat;$/;"	m	struct:CvDefParam	access:public
CvDefParam::pInt	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int*                pInt;$/;"	m	struct:CvDefParam	access:public
CvDefParam::pName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*               pName;$/;"	m	struct:CvDefParam	access:public
CvDefParam::pStr	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char**              pStr;$/;"	m	struct:CvDefParam	access:public
CvDetectedBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^struct CV_EXPORTS CvDetectedBlob : public CvBlob$/;"	s	inherits:CvBlob
CvDetectedBlob::response	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float response;$/;"	m	struct:CvDetectedBlob	access:public
CvDisMaskType	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvDisMaskType;$/;"	t
CvDisType	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvDisType;$/;"	t
CvDistanceFunction	/usr/include/opencv2/imgproc/types_c.h	/^typedef float (CV_CDECL * CvDistanceFunction)( const float* a, const float* b, void* user_param );$/;"	t
CvDrawShape	/usr/include/opencv2/legacy/blobtrack.hpp	/^struct CvDrawShape$/;"	s
CvDrawShape::ELLIPSE	/usr/include/opencv2/legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	e	enum:CvDrawShape::__anon178
CvDrawShape::RECT	/usr/include/opencv2/legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	e	enum:CvDrawShape::__anon178
CvDrawShape::color	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvScalar color;$/;"	m	struct:CvDrawShape	access:public
CvDrawShape::shape	/usr/include/opencv2/legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	m	struct:CvDrawShape	typeref:enum:CvDrawShape::__anon178	access:public
CvEHMM	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvEHMM$/;"	s
CvEHMM	/usr/include/opencv2/legacy/legacy.hpp	/^} CvEHMM;$/;"	t	typeref:struct:CvEHMM
CvEHMM::__anon171::ehmm	/usr/include/opencv2/legacy/legacy.hpp	/^        struct CvEHMM* ehmm; \/* pointer to an embedded model or NULL, if it is a leaf *\/$/;"	m	union:CvEHMM::__anon171	typeref:struct:CvEHMM::__anon171::CvEHMM	access:public
CvEHMM::__anon171::state	/usr/include/opencv2/legacy/legacy.hpp	/^        CvEHMMState* state; \/* if level == 0 points to real states array,$/;"	m	union:CvEHMM::__anon171	access:public
CvEHMM::level	/usr/include/opencv2/legacy/legacy.hpp	/^    int level; \/* 0 - lowest(i.e its states are real states), ..... *\/$/;"	m	struct:CvEHMM	access:public
CvEHMM::num_states	/usr/include/opencv2/legacy/legacy.hpp	/^    int num_states; \/* number of HMM states *\/$/;"	m	struct:CvEHMM	access:public
CvEHMM::obsProb	/usr/include/opencv2/legacy/legacy.hpp	/^    float** obsProb; \/* if level == 0 - array of brob matrices corresponding to hmm$/;"	m	struct:CvEHMM	access:public
CvEHMM::transP	/usr/include/opencv2/legacy/legacy.hpp	/^    float*  transP;\/*transition probab. matrices for states *\/$/;"	m	struct:CvEHMM	access:public
CvEHMM::u	/usr/include/opencv2/legacy/legacy.hpp	/^    } u;$/;"	m	struct:CvEHMM	typeref:union:CvEHMM::__anon171	access:public
CvEHMMState	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvEHMMState$/;"	s
CvEHMMState	/usr/include/opencv2/legacy/legacy.hpp	/^} CvEHMMState;$/;"	t	typeref:struct:CvEHMMState
CvEHMMState::inv_var	/usr/include/opencv2/legacy/legacy.hpp	/^    float* inv_var;     \/* square root of inversed variances corresp. to each mixture*\/$/;"	m	struct:CvEHMMState	access:public
CvEHMMState::log_var_val	/usr/include/opencv2/legacy/legacy.hpp	/^    float* log_var_val; \/* sum of 0.5 (LN2PI + ln(variance[i]) ) for i=1,n *\/$/;"	m	struct:CvEHMMState	access:public
CvEHMMState::mu	/usr/include/opencv2/legacy/legacy.hpp	/^    float* mu;          \/*mean vectors corresponding to each mixture*\/$/;"	m	struct:CvEHMMState	access:public
CvEHMMState::num_mix	/usr/include/opencv2/legacy/legacy.hpp	/^    int num_mix;        \/*number of mixtures in this state*\/$/;"	m	struct:CvEHMMState	access:public
CvEHMMState::weight	/usr/include/opencv2/legacy/legacy.hpp	/^    float* weight;      \/*array of mixture weights. Summ of all weights in state is 1. *\/$/;"	m	struct:CvEHMMState	access:public
CvEM	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvEM( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(),$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(), CvEMParams params=CvEMParams() )
CvEM	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvEM();$/;"	p	class:CvEM	access:public	signature:()
CvEM	/usr/include/opencv2/ml/ml.hpp	/^    CvEM( const CvMat* samples, const CvMat* sampleIdx=0,$/;"	p	class:CvEM	access:public	signature:( const CvMat* samples, const CvMat* sampleIdx=0, CvEMParams params=CvEMParams(), CvMat* labels=0 )
CvEM	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS_W CvEM : public CvStatModel$/;"	c	inherits:CvStatModel
CvEM::COV_MAT_DIAGONAL	/usr/include/opencv2/ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon81
CvEM::COV_MAT_GENERIC	/usr/include/opencv2/ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon81
CvEM::COV_MAT_SPHERICAL	/usr/include/opencv2/ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon81
CvEM::CvEM	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvEM( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(),$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(), CvEMParams params=CvEMParams() )
CvEM::CvEM	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvEM();$/;"	p	class:CvEM	access:public	signature:()
CvEM::CvEM	/usr/include/opencv2/ml/ml.hpp	/^    CvEM( const CvMat* samples, const CvMat* sampleIdx=0,$/;"	p	class:CvEM	access:public	signature:( const CvMat* samples, const CvMat* sampleIdx=0, CvEMParams params=CvEMParams(), CvMat* labels=0 )
CvEM::START_AUTO_STEP	/usr/include/opencv2/ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon82
CvEM::START_E_STEP	/usr/include/opencv2/ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon82
CvEM::START_M_STEP	/usr/include/opencv2/ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon82
CvEM::clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvEM	access:public	signature:()
CvEM::cov_rotate_mats	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** cov_rotate_mats;$/;"	m	class:CvEM	access:protected
CvEM::covs	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** covs;$/;"	m	class:CvEM	access:protected
CvEM::getCovs	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP void getCovs(CV_OUT std::vector<cv::Mat>& covs)      const;$/;"	p	class:CvEM	access:public	signature:(CV_OUT std::vector<cv::Mat>& covs) const
CvEM::getLikelihood	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP inline double getLikelihood() const { return log_likelihood;     };$/;"	f	class:CvEM	access:public	signature:() const
CvEM::getMeans	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP cv::Mat  getMeans()     const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::getNClusters	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP int  getNClusters() const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::getProbs	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP cv::Mat  getProbs()     const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::getWeights	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP cv::Mat  getWeights()   const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::get_covs	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat** get_covs()      const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::get_log_likelihood	/usr/include/opencv2/ml/ml.hpp	/^    inline double         get_log_likelihood     () const { return log_likelihood;     };$/;"	f	class:CvEM	access:public	signature:() const
CvEM::get_means	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat*  get_means()     const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::get_nclusters	/usr/include/opencv2/ml/ml.hpp	/^    int           get_nclusters() const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::get_probs	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat*  get_probs()     const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::get_weights	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat*  get_weights()   const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::init_auto	/usr/include/opencv2/ml/ml.hpp	/^    virtual void init_auto( const CvVectors& samples );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& samples )
CvEM::init_em	/usr/include/opencv2/ml/ml.hpp	/^    virtual void init_em( const CvVectors& train_data );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data )
CvEM::inv_eigen_values	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* inv_eigen_values;$/;"	m	class:CvEM	access:protected
CvEM::kmeans	/usr/include/opencv2/ml/ml.hpp	/^    virtual void kmeans( const CvVectors& train_data, int nclusters,$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data, int nclusters, CvMat* labels, CvTermCriteria criteria, const CvMat* means )
CvEM::log_likelihood	/usr/include/opencv2/ml/ml.hpp	/^    double log_likelihood;$/;"	m	class:CvEM	access:protected
CvEM::log_weight_div_det	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* log_weight_div_det;$/;"	m	class:CvEM	access:protected
CvEM::means	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* means;$/;"	m	class:CvEM	access:protected
CvEM::params	/usr/include/opencv2/ml/ml.hpp	/^    CvEMParams params;$/;"	m	class:CvEM	access:protected
CvEM::predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, CV_OUT cv::Mat* probs=0 ) const;$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& sample, CV_OUT cv::Mat* probs=0 ) const
CvEM::predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* sample, CV_OUT CvMat* probs ) const;$/;"	p	class:CvEM	access:public	signature:( const CvMat* sample, CV_OUT CvMat* probs ) const
CvEM::probs	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* probs;$/;"	m	class:CvEM	access:protected
CvEM::run_em	/usr/include/opencv2/ml/ml.hpp	/^    virtual double run_em( const CvVectors& train_data );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data )
CvEM::set_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void set_params( const CvEMParams& params,$/;"	p	class:CvEM	access:protected	signature:( const CvEMParams& params, const CvVectors& train_data )
CvEM::train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& samples,$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(), CvEMParams params=CvEMParams(), CV_OUT cv::Mat* labels=0 )
CvEM::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* samples, const CvMat* sampleIdx=0,$/;"	p	class:CvEM	access:public	signature:( const CvMat* samples, const CvMat* sampleIdx=0, CvEMParams params=CvEMParams(), CvMat* labels=0 )
CvEM::weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* weights;$/;"	m	class:CvEM	access:protected
CvEM::~CvEM	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvEM();$/;"	p	class:CvEM	access:public	signature:()
CvEMParams	/usr/include/opencv2/ml/ml.hpp	/^    CvEMParams( int _nclusters, int _cov_mat_type=1\/*CvEM::COV_MAT_DIAGONAL*\/,$/;"	f	struct:CvEMParams	access:public	signature:( int _nclusters, int _cov_mat_type=1 , int _start_step=0 , CvTermCriteria _term_crit=cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 100, FLT_EPSILON), const CvMat* _probs=0, const CvMat* _weights=0, const CvMat* _means=0, const CvMat** _covs=0 )
CvEMParams	/usr/include/opencv2/ml/ml.hpp	/^    CvEMParams() : nclusters(10), cov_mat_type(1\/*CvEM::COV_MAT_DIAGONAL*\/),$/;"	f	struct:CvEMParams	access:public	signature:()
CvEMParams	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvEMParams$/;"	s
CvEMParams::CvEMParams	/usr/include/opencv2/ml/ml.hpp	/^    CvEMParams( int _nclusters, int _cov_mat_type=1\/*CvEM::COV_MAT_DIAGONAL*\/,$/;"	f	struct:CvEMParams	access:public	signature:( int _nclusters, int _cov_mat_type=1 , int _start_step=0 , CvTermCriteria _term_crit=cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 100, FLT_EPSILON), const CvMat* _probs=0, const CvMat* _weights=0, const CvMat* _means=0, const CvMat** _covs=0 )
CvEMParams::CvEMParams	/usr/include/opencv2/ml/ml.hpp	/^    CvEMParams() : nclusters(10), cov_mat_type(1\/*CvEM::COV_MAT_DIAGONAL*\/),$/;"	f	struct:CvEMParams	access:public	signature:()
CvEMParams::cov_mat_type	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int cov_mat_type;$/;"	m	struct:CvEMParams	access:public
CvEMParams::covs	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat** covs;$/;"	m	struct:CvEMParams	access:public
CvEMParams::means	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* means;$/;"	m	struct:CvEMParams	access:public
CvEMParams::nclusters	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int nclusters;$/;"	m	struct:CvEMParams	access:public
CvEMParams::probs	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* probs;$/;"	m	struct:CvEMParams	access:public
CvEMParams::start_step	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int start_step;$/;"	m	struct:CvEMParams	access:public
CvEMParams::term_crit	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvEMParams	access:public
CvEMParams::weights	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* weights;$/;"	m	struct:CvEMParams	access:public
CvERTreeTrainData	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS CvERTreeTrainData : public CvDTreeTrainData$/;"	s	inherits:CvDTreeTrainData
CvERTreeTrainData::get_cat_var_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_cat_var_data( CvDTreeNode* n, int vi, int* cat_values_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, int* cat_values_buf )
CvERTreeTrainData::get_cv_labels	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_cv_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
CvERTreeTrainData::get_ord_var_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void get_ord_var_data( CvDTreeNode* n, int vi, float* ord_values_buf, int* missing_buf,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, float* ord_values_buf, int* missing_buf, const float** ord_values, const int** missing, int* sample_buf = 0 )
CvERTreeTrainData::get_sample_indices	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_sample_indices( CvDTreeNode* n, int* indices_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int* indices_buf )
CvERTreeTrainData::get_vectors	/usr/include/opencv2/ml/ml.hpp	/^    virtual void get_vectors( const CvMat* _subsample_idx, float* values, uchar* missing,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* _subsample_idx, float* values, uchar* missing, float* responses, bool get_class_idx=false )
CvERTreeTrainData::missing_mask	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* missing_mask;$/;"	m	struct:CvERTreeTrainData	access:public
CvERTreeTrainData::set_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void set_data( const CvMat* trainData, int tflag,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false, bool _update_data=false )
CvERTreeTrainData::subsample_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeNode* subsample_data( const CvMat* _subsample_idx );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* _subsample_idx )
CvERTrees	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvERTrees();$/;"	p	class:CvERTrees	access:public	signature:()
CvERTrees	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS_W CvERTrees : public CvRTrees$/;"	c	inherits:CvRTrees
CvERTrees::CvERTrees	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvERTrees();$/;"	p	class:CvERTrees	access:public	signature:()
CvERTrees::grow_forest	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool grow_forest( const CvTermCriteria term_crit );$/;"	p	class:CvERTrees	access:protected	signature:( const CvTermCriteria term_crit )
CvERTrees::train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvERTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvRTParams params=CvRTParams())
CvERTrees::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvMLData* data, CvRTParams params=CvRTParams() );$/;"	p	class:CvERTrees	access:public	signature:( CvMLData* data, CvRTParams params=CvRTParams() )
CvERTrees::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvERTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvRTParams params=CvRTParams())
CvERTrees::~CvERTrees	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvERTrees();$/;"	p	class:CvERTrees	access:public	signature:()
CvElementShape	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvElementShape;$/;"	t
CvErrorCallback	/usr/include/opencv2/core/core_c.h	/^typedef int (CV_CDECL *CvErrorCallback)( int status, const char* func_name,$/;"	t
CvFGDStatModel	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvFGDStatModel$/;"	s
CvFGDStatModel	/usr/include/opencv2/video/background_segm.hpp	/^} CvFGDStatModel;$/;"	t	typeref:struct:CvFGDStatModel
CvFGDStatModel::CV_BG_STAT_MODEL_FIELDS	/usr/include/opencv2/video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvFGDStatModel	access:public	signature:()
CvFGDStatModel::Fbd	/usr/include/opencv2/video/background_segm.hpp	/^    IplImage*              Fbd;$/;"	m	struct:CvFGDStatModel	access:public
CvFGDStatModel::Ftd	/usr/include/opencv2/video/background_segm.hpp	/^    IplImage*              Ftd;$/;"	m	struct:CvFGDStatModel	access:public
CvFGDStatModel::params	/usr/include/opencv2/video/background_segm.hpp	/^    CvFGDStatModelParams   params;$/;"	m	struct:CvFGDStatModel	access:public
CvFGDStatModel::pixel_stat	/usr/include/opencv2/video/background_segm.hpp	/^    CvBGPixelStat*         pixel_stat;$/;"	m	struct:CvFGDStatModel	access:public
CvFGDStatModel::prev_frame	/usr/include/opencv2/video/background_segm.hpp	/^    IplImage*              prev_frame;$/;"	m	struct:CvFGDStatModel	access:public
CvFGDStatModelParams	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvFGDStatModelParams$/;"	s
CvFGDStatModelParams	/usr/include/opencv2/video/background_segm.hpp	/^} CvFGDStatModelParams;$/;"	t	typeref:struct:CvFGDStatModelParams
CvFGDStatModelParams::Lc	/usr/include/opencv2/video/background_segm.hpp	/^    int    Lc;			\/* Quantized levels per 'color' component. Power of two, typically 32, 64 or 128.				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::Lcc	/usr/include/opencv2/video/background_segm.hpp	/^    int    Lcc;			\/* Quantized levels per 'color co-occurrence' component.  Power of two, typically 16, 32 or 64.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::N1c	/usr/include/opencv2/video/background_segm.hpp	/^    int    N1c;			\/* Number of color vectors used to model normal background color variation at a given pixel.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::N1cc	/usr/include/opencv2/video/background_segm.hpp	/^    int    N1cc;		\/* Number of color co-occurrence vectors used to model normal background color variation at a given pixel.	*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::N2c	/usr/include/opencv2/video/background_segm.hpp	/^    int    N2c;			\/* Number of color vectors retained at given pixel.  Must be > N1c, typically ~ 5\/3 of N1c.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::N2cc	/usr/include/opencv2/video/background_segm.hpp	/^    int    N2cc;		\/* Number of color co-occurrence vectors retained at given pixel.  Must be > N1cc, typically ~ 5\/3 of N1cc.	*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::T	/usr/include/opencv2/video/background_segm.hpp	/^    float  T;			\/* "A percentage value which determines when new features can be recognized as new background." (Typically 0.9).*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::alpha1	/usr/include/opencv2/video/background_segm.hpp	/^    float  alpha1;		\/* How quickly we forget old background pixel values seen.  Typically set to 0.1  				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::alpha2	/usr/include/opencv2/video/background_segm.hpp	/^    float  alpha2;		\/* "Controls speed of feature learning". Depends on T. Typical value circa 0.005. 				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::alpha3	/usr/include/opencv2/video/background_segm.hpp	/^    float  alpha3;		\/* Alternate to alpha2, used (e.g.) for quicker initial convergence. Typical value 0.1.				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::delta	/usr/include/opencv2/video/background_segm.hpp	/^    float  delta;		\/* Affects color and color co-occurrence quantization, typically set to 2.					*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::is_obj_without_holes	/usr/include/opencv2/video/background_segm.hpp	/^    int    is_obj_without_holes;\/* If TRUE we ignore holes within foreground blobs. Defaults to TRUE.						*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::minArea	/usr/include/opencv2/video/background_segm.hpp	/^    float  minArea;		\/* Discard foreground blobs whose bounding box is smaller than this threshold.					*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::perform_morphing	/usr/include/opencv2/video/background_segm.hpp	/^    int    perform_morphing;	\/* Number of erode-dilate-erode foreground-blob cleanup iterations.						*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvFGDetector();$/;"	p	class:CvFGDetector	access:public	signature:()
CvFGDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvFGDetector : public CvVSModule$/;"	c	inherits:CvVSModule
CvFGDetector::CvFGDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvFGDetector();$/;"	p	class:CvFGDetector	access:public	signature:()
CvFGDetector::GetMask	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual IplImage* GetMask() = 0;$/;"	p	class:CvFGDetector	access:public	signature:()
CvFGDetector::Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg) = 0;$/;"	p	class:CvFGDetector	access:public	signature:(IplImage* pImg)
CvFGDetector::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvFGDetector	access:public	signature:()
CvFace	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvFace$/;"	s
CvFace::LeftEyeRect	/usr/include/opencv2/legacy/legacy.hpp	/^    CvRect LeftEyeRect;$/;"	m	struct:CvFace	access:public
CvFace::MouthRect	/usr/include/opencv2/legacy/legacy.hpp	/^    CvRect MouthRect;$/;"	m	struct:CvFace	access:public
CvFace::RightEyeRect	/usr/include/opencv2/legacy/legacy.hpp	/^    CvRect RightEyeRect;$/;"	m	struct:CvFace	access:public
CvFaceData	/usr/include/opencv2/legacy/legacy.hpp	/^} CvFaceData;$/;"	t	typeref:struct:CvFace
CvFaceTracker	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvFaceTracker CvFaceTracker;$/;"	t	typeref:struct:CvFaceTracker
CvFileNode	/usr/include/opencv2/core/types_c.h	/^CvFileNode;$/;"	t	typeref:struct:CvFileNode
CvFileNode	/usr/include/opencv2/core/types_c.h	/^typedef struct CvFileNode$/;"	s
CvFileNode::__anon100::f	/usr/include/opencv2/core/types_c.h	/^        double f; \/* scalar floating-point number *\/$/;"	m	union:CvFileNode::__anon100	access:public
CvFileNode::__anon100::i	/usr/include/opencv2/core/types_c.h	/^        int i;    \/* scalar integer number *\/$/;"	m	union:CvFileNode::__anon100	access:public
CvFileNode::__anon100::map	/usr/include/opencv2/core/types_c.h	/^        CvFileNodeHash* map; \/* map (collection of named file nodes) *\/$/;"	m	union:CvFileNode::__anon100	access:public
CvFileNode::__anon100::seq	/usr/include/opencv2/core/types_c.h	/^        CvSeq* seq; \/* sequence (ordered collection of file nodes) *\/$/;"	m	union:CvFileNode::__anon100	access:public
CvFileNode::__anon100::str	/usr/include/opencv2/core/types_c.h	/^        CvString str; \/* text string *\/$/;"	m	union:CvFileNode::__anon100	access:public
CvFileNode::data	/usr/include/opencv2/core/types_c.h	/^    } data;$/;"	m	struct:CvFileNode	typeref:union:CvFileNode::__anon100	access:public
CvFileNode::info	/usr/include/opencv2/core/types_c.h	/^    struct CvTypeInfo* info; \/* type information$/;"	m	struct:CvFileNode	typeref:struct:CvFileNode::CvTypeInfo	access:public
CvFileNode::tag	/usr/include/opencv2/core/types_c.h	/^    int tag;$/;"	m	struct:CvFileNode	access:public
CvFileNodeHash	/usr/include/opencv2/core/types_c.h	/^typedef struct CvGenericHash CvFileNodeHash;$/;"	t	typeref:struct:CvGenericHash
CvFileStorage	/usr/include/opencv2/core/types_c.h	/^typedef struct CvFileStorage CvFileStorage;$/;"	t	typeref:struct:CvFileStorage
CvFont	/usr/include/opencv2/core/core_c.h	/^CvFont;$/;"	t	typeref:struct:CvFont
CvFont	/usr/include/opencv2/core/core_c.h	/^typedef struct CvFont$/;"	s
CvFont::ascii	/usr/include/opencv2/core/core_c.h	/^    const int*  ascii; 			\/* font data and metrics *\/$/;"	m	struct:CvFont	access:public
CvFont::color	/usr/include/opencv2/core/core_c.h	/^	CvScalar color;				\/\/Qt:ColorFont -> cvScalar(blue_component, green_component, red\\_component[, alpha_component])$/;"	m	struct:CvFont	access:public
CvFont::cyrillic	/usr/include/opencv2/core/core_c.h	/^    const int*  cyrillic;$/;"	m	struct:CvFont	access:public
CvFont::dx	/usr/include/opencv2/core/core_c.h	/^    float       dx; 			\/* horizontal interval between letters *\/$/;"	m	struct:CvFont	access:public
CvFont::font_face	/usr/include/opencv2/core/core_c.h	/^    int         font_face; 		\/\/Qt: bool italic         \/* =CV_FONT_* *\/$/;"	m	struct:CvFont	access:public
CvFont::greek	/usr/include/opencv2/core/core_c.h	/^    const int*  greek;$/;"	m	struct:CvFont	access:public
CvFont::hscale	/usr/include/opencv2/core/core_c.h	/^    float       hscale, vscale;$/;"	m	struct:CvFont	access:public
CvFont::line_type	/usr/include/opencv2/core/core_c.h	/^    int         line_type;		\/\/Qt: PointSize$/;"	m	struct:CvFont	access:public
CvFont::nameFont	/usr/include/opencv2/core/core_c.h	/^	const char* nameFont;		\/\/Qt:nameFont$/;"	m	struct:CvFont	access:public
CvFont::shear	/usr/include/opencv2/core/core_c.h	/^    float       shear; 			\/* slope coefficient: 0 - normal, >0 - italic *\/$/;"	m	struct:CvFont	access:public
CvFont::thickness	/usr/include/opencv2/core/core_c.h	/^    int         thickness; 		\/\/Qt: weight               \/* letters thickness *\/$/;"	m	struct:CvFont	access:public
CvFont::vscale	/usr/include/opencv2/core/core_c.h	/^    float       hscale, vscale;$/;"	m	struct:CvFont	access:public
CvFontFace	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvFontFace;$/;"	t
CvForestERTree	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS CvForestERTree : public CvForestTree$/;"	c	inherits:CvForestTree
CvForestERTree::calc_node_dir	/usr/include/opencv2/ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* node );$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* node )
CvForestERTree::find_split_cat_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvForestERTree::find_split_cat_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvForestERTree::find_split_ord_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvForestERTree::find_split_ord_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvForestERTree::split_node_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void split_node_data( CvDTreeNode* n );$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n )
CvForestTree	/usr/include/opencv2/ml/ml.hpp	/^    CvForestTree();$/;"	p	class:CvForestTree	access:public	signature:()
CvForestTree	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS CvForestTree: public CvDTree$/;"	c	inherits:CvDTree
CvForestTree::CvForestTree	/usr/include/opencv2/ml/ml.hpp	/^    CvForestTree();$/;"	p	class:CvForestTree	access:public	signature:()
CvForestTree::find_best_split	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_best_split( CvDTreeNode* n );$/;"	p	class:CvForestTree	access:protected	signature:( CvDTreeNode* n )
CvForestTree::forest	/usr/include/opencv2/ml/ml.hpp	/^    CvRTrees* forest;$/;"	m	class:CvForestTree	access:protected
CvForestTree::get_var_count	/usr/include/opencv2/ml/ml.hpp	/^    virtual int get_var_count() const {return data ? data->var_count : 0;}$/;"	f	class:CvForestTree	access:public	signature:() const
CvForestTree::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvForestTree::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node, CvRTrees* forest, CvDTreeTrainData* _data );$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvRTrees* forest, CvDTreeTrainData* _data )
CvForestTree::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
CvForestTree::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx );$/;"	p	class:CvForestTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx )
CvForestTree::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx, CvRTrees* forest );$/;"	p	class:CvForestTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx, CvRTrees* forest )
CvForestTree::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvForestTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
CvForestTree::~CvForestTree	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvForestTree();$/;"	p	class:CvForestTree	access:public	signature:()
CvFreeFunc	/usr/include/opencv2/core/core_c.h	/^typedef int (CV_CDECL *CvFreeFunc)(void* pptr, void* userdata);$/;"	t
CvFuncTable	/usr/include/opencv2/core/internal.hpp	/^CvFuncTable;$/;"	t	typeref:struct:CvFuncTable
CvFuncTable	/usr/include/opencv2/core/internal.hpp	/^typedef struct CvFuncTable$/;"	s
CvFuncTable::fn_2d	/usr/include/opencv2/core/internal.hpp	/^    void*   fn_2d[CV_DEPTH_MAX];$/;"	m	struct:CvFuncTable	access:public
CvFuzzyController	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyController();$/;"	p	class:CvFuzzyController	access:public	signature:()
CvFuzzyController	/usr/include/opencv2/contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyController {$/;"	c
CvFuzzyController::CvFuzzyController	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyController();$/;"	p	class:CvFuzzyController	access:public	signature:()
CvFuzzyController::addRule	/usr/include/opencv2/contrib/contrib.hpp	/^    void addRule(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1);$/;"	p	class:CvFuzzyController	access:public	signature:(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1)
CvFuzzyController::calcOutput	/usr/include/opencv2/contrib/contrib.hpp	/^    double calcOutput(double param1, double param2);$/;"	p	class:CvFuzzyController	access:public	signature:(double param1, double param2)
CvFuzzyController::rules	/usr/include/opencv2/contrib/contrib.hpp	/^    std::vector<CvFuzzyRule*> rules;$/;"	m	class:CvFuzzyController	access:private
CvFuzzyController::~CvFuzzyController	/usr/include/opencv2/contrib/contrib.hpp	/^    ~CvFuzzyController();$/;"	p	class:CvFuzzyController	access:public	signature:()
CvFuzzyCurve	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyCurve	/usr/include/opencv2/contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyCurve {$/;"	c
CvFuzzyCurve::CvFuzzyCurve	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyCurve::addPoint	/usr/include/opencv2/contrib/contrib.hpp	/^    void addPoint(double x, double y);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double x, double y)
CvFuzzyCurve::between	/usr/include/opencv2/contrib/contrib.hpp	/^    bool between(double x, double x1, double x2);$/;"	p	class:CvFuzzyCurve	access:private	signature:(double x, double x1, double x2)
CvFuzzyCurve::calcValue	/usr/include/opencv2/contrib/contrib.hpp	/^    double calcValue(double param);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double param)
CvFuzzyCurve::centre	/usr/include/opencv2/contrib/contrib.hpp	/^    double value, centre;$/;"	m	class:CvFuzzyCurve	access:private
CvFuzzyCurve::clear	/usr/include/opencv2/contrib/contrib.hpp	/^    void clear();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyCurve::getCentre	/usr/include/opencv2/contrib/contrib.hpp	/^    double getCentre();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyCurve::getValue	/usr/include/opencv2/contrib/contrib.hpp	/^    double getValue();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyCurve::points	/usr/include/opencv2/contrib/contrib.hpp	/^    std::vector<CvFuzzyPoint> points;$/;"	m	class:CvFuzzyCurve	access:private
CvFuzzyCurve::setCentre	/usr/include/opencv2/contrib/contrib.hpp	/^    void setCentre(double _centre);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double _centre)
CvFuzzyCurve::setValue	/usr/include/opencv2/contrib/contrib.hpp	/^    void setValue(double _value);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double _value)
CvFuzzyCurve::value	/usr/include/opencv2/contrib/contrib.hpp	/^    double value, centre;$/;"	m	class:CvFuzzyCurve	access:private
CvFuzzyCurve::~CvFuzzyCurve	/usr/include/opencv2/contrib/contrib.hpp	/^    ~CvFuzzyCurve();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyFunction	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyFunction();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyFunction	/usr/include/opencv2/contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyFunction {$/;"	c
CvFuzzyFunction::CvFuzzyFunction	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyFunction();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyFunction::addCurve	/usr/include/opencv2/contrib/contrib.hpp	/^    void addCurve(CvFuzzyCurve *curve, double value = 0);$/;"	p	class:CvFuzzyFunction	access:public	signature:(CvFuzzyCurve *curve, double value = 0)
CvFuzzyFunction::calcValue	/usr/include/opencv2/contrib/contrib.hpp	/^    double calcValue();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyFunction::curves	/usr/include/opencv2/contrib/contrib.hpp	/^    std::vector<CvFuzzyCurve> curves;$/;"	m	class:CvFuzzyFunction	access:public
CvFuzzyFunction::newCurve	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve *newCurve();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyFunction::resetValues	/usr/include/opencv2/contrib/contrib.hpp	/^    void resetValues();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyFunction::~CvFuzzyFunction	/usr/include/opencv2/contrib/contrib.hpp	/^    ~CvFuzzyFunction();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyMeanShiftTracker	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyMeanShiftTracker();$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:()
CvFuzzyMeanShiftTracker	/usr/include/opencv2/contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyMeanShiftTracker$/;"	c
CvFuzzyMeanShiftTracker::CvFuzzyMeanShiftTracker	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyMeanShiftTracker();$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:()
CvFuzzyMeanShiftTracker::FuzzyResizer	/usr/include/opencv2/contrib/contrib.hpp	/^    class FuzzyResizer$/;"	c	class:CvFuzzyMeanShiftTracker	access:private
CvFuzzyMeanShiftTracker::FuzzyResizer::FuzzyResizer	/usr/include/opencv2/contrib/contrib.hpp	/^        FuzzyResizer();$/;"	p	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:public	signature:()
CvFuzzyMeanShiftTracker::FuzzyResizer::calcOutput	/usr/include/opencv2/contrib/contrib.hpp	/^        int calcOutput(double edgeDensity, double density);$/;"	p	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:public	signature:(double edgeDensity, double density)
CvFuzzyMeanShiftTracker::FuzzyResizer::fuzzyController	/usr/include/opencv2/contrib/contrib.hpp	/^        CvFuzzyController fuzzyController;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
CvFuzzyMeanShiftTracker::FuzzyResizer::iInput	/usr/include/opencv2/contrib/contrib.hpp	/^        CvFuzzyFunction iInput, iOutput;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
CvFuzzyMeanShiftTracker::FuzzyResizer::iOutput	/usr/include/opencv2/contrib/contrib.hpp	/^        CvFuzzyFunction iInput, iOutput;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
CvFuzzyMeanShiftTracker::MaxMeanShiftIteration	/usr/include/opencv2/contrib/contrib.hpp	/^        MaxMeanShiftIteration   = 5,$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon56
CvFuzzyMeanShiftTracker::MaxSetSizeIteration	/usr/include/opencv2/contrib/contrib.hpp	/^        MaxSetSizeIteration     = 5$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon56
CvFuzzyMeanShiftTracker::MinKernelMass	/usr/include/opencv2/contrib/contrib.hpp	/^        MinKernelMass           = 1000$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon55
CvFuzzyMeanShiftTracker::ResizeMethod	/usr/include/opencv2/contrib/contrib.hpp	/^    enum ResizeMethod {$/;"	g	class:CvFuzzyMeanShiftTracker	access:public
CvFuzzyMeanShiftTracker::SearchWindow	/usr/include/opencv2/contrib/contrib.hpp	/^    class SearchWindow$/;"	c	class:CvFuzzyMeanShiftTracker	access:private
CvFuzzyMeanShiftTracker::SearchWindow::SearchWindow	/usr/include/opencv2/contrib/contrib.hpp	/^        SearchWindow();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
CvFuzzyMeanShiftTracker::SearchWindow::density	/usr/include/opencv2/contrib/contrib.hpp	/^        double density;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::depthHigh	/usr/include/opencv2/contrib/contrib.hpp	/^        unsigned int depthLow, depthHigh;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::depthLow	/usr/include/opencv2/contrib/contrib.hpp	/^        unsigned int depthLow, depthHigh;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ellipseAngle	/usr/include/opencv2/contrib/contrib.hpp	/^        double ellipseAngle;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ellipseHeight	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ellipseWidth	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::extractInfo	/usr/include/opencv2/contrib/contrib.hpp	/^        void extractInfo(IplImage *maskImage, IplImage *depthMap, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap, bool initDepth)
CvFuzzyMeanShiftTracker::SearchWindow::fuzzyResizer	/usr/include/opencv2/contrib/contrib.hpp	/^        FuzzyResizer *fuzzyResizer;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::getResizeAttribsEdgeDensityFuzzy	/usr/include/opencv2/contrib/contrib.hpp	/^        void getResizeAttribsEdgeDensityFuzzy(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
CvFuzzyMeanShiftTracker::SearchWindow::getResizeAttribsEdgeDensityLinear	/usr/include/opencv2/contrib/contrib.hpp	/^        void getResizeAttribsEdgeDensityLinear(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
CvFuzzyMeanShiftTracker::SearchWindow::getResizeAttribsInnerDensity	/usr/include/opencv2/contrib/contrib.hpp	/^        void getResizeAttribsInnerDensity(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
CvFuzzyMeanShiftTracker::SearchWindow::height	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::horizontalEdgeBottom	/usr/include/opencv2/contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::horizontalEdgeTop	/usr/include/opencv2/contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::initDepthValues	/usr/include/opencv2/contrib/contrib.hpp	/^        void initDepthValues(IplImage *maskImage, IplImage *depthMap);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap)
CvFuzzyMeanShiftTracker::SearchWindow::ldh	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ldw	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ldx	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ldy	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m00	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m01	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m02	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m10	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m11	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m20	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::maxHeight	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::maxWidth	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::meanShift	/usr/include/opencv2/contrib/contrib.hpp	/^        bool meanShift(IplImage *maskImage, IplImage *depthMap, int maxIteration, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap, int maxIteration, bool initDepth)
CvFuzzyMeanShiftTracker::SearchWindow::numIters	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::numShifts	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::setSize	/usr/include/opencv2/contrib/contrib.hpp	/^        void setSize(int _x, int _y, int _width, int _height);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int _x, int _y, int _width, int _height)
CvFuzzyMeanShiftTracker::SearchWindow::shift	/usr/include/opencv2/contrib/contrib.hpp	/^        bool shift();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
CvFuzzyMeanShiftTracker::SearchWindow::verticalEdgeLeft	/usr/include/opencv2/contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::verticalEdgeRight	/usr/include/opencv2/contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::width	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::x	/usr/include/opencv2/contrib/contrib.hpp	/^        int x, y;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::xGc	/usr/include/opencv2/contrib/contrib.hpp	/^        int xGc, yGc;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::y	/usr/include/opencv2/contrib/contrib.hpp	/^        int x, y;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::yGc	/usr/include/opencv2/contrib/contrib.hpp	/^        int xGc, yGc;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::~SearchWindow	/usr/include/opencv2/contrib/contrib.hpp	/^        ~SearchWindow();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
CvFuzzyMeanShiftTracker::TrackingState	/usr/include/opencv2/contrib/contrib.hpp	/^    enum TrackingState$/;"	g	class:CvFuzzyMeanShiftTracker	access:public
CvFuzzyMeanShiftTracker::findOptimumSearchWindow	/usr/include/opencv2/contrib/contrib.hpp	/^    void findOptimumSearchWindow(SearchWindow &searchWindow, IplImage *maskImage, IplImage *depthMap, int maxIteration, int resizeMethod, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker	access:private	signature:(SearchWindow &searchWindow, IplImage *maskImage, IplImage *depthMap, int maxIteration, int resizeMethod, bool initDepth)
CvFuzzyMeanShiftTracker::kernel	/usr/include/opencv2/contrib/contrib.hpp	/^    SearchWindow kernel;$/;"	m	class:CvFuzzyMeanShiftTracker	access:public
CvFuzzyMeanShiftTracker::rmEdgeDensityFuzzy	/usr/include/opencv2/contrib/contrib.hpp	/^        rmEdgeDensityFuzzy      = 1,$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
CvFuzzyMeanShiftTracker::rmEdgeDensityLinear	/usr/include/opencv2/contrib/contrib.hpp	/^        rmEdgeDensityLinear     = 0,$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
CvFuzzyMeanShiftTracker::rmInnerDensity	/usr/include/opencv2/contrib/contrib.hpp	/^        rmInnerDensity          = 2$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
CvFuzzyMeanShiftTracker::searchMode	/usr/include/opencv2/contrib/contrib.hpp	/^    int searchMode;$/;"	m	class:CvFuzzyMeanShiftTracker	access:public
CvFuzzyMeanShiftTracker::track	/usr/include/opencv2/contrib/contrib.hpp	/^    void track(IplImage *maskImage, IplImage *depthMap, int resizeMethod, bool resetSearch, int minKernelMass = MinKernelMass);$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:(IplImage *maskImage, IplImage *depthMap, int resizeMethod, bool resetSearch, int minKernelMass = MinKernelMass)
CvFuzzyMeanShiftTracker::tsDisabled	/usr/include/opencv2/contrib/contrib.hpp	/^        tsDisabled      = 10$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
CvFuzzyMeanShiftTracker::tsNone	/usr/include/opencv2/contrib/contrib.hpp	/^        tsNone          = 0,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
CvFuzzyMeanShiftTracker::tsSearching	/usr/include/opencv2/contrib/contrib.hpp	/^        tsSearching     = 1,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
CvFuzzyMeanShiftTracker::tsSetWindow	/usr/include/opencv2/contrib/contrib.hpp	/^        tsSetWindow     = 3,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
CvFuzzyMeanShiftTracker::tsTracking	/usr/include/opencv2/contrib/contrib.hpp	/^        tsTracking      = 2,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
CvFuzzyMeanShiftTracker::~CvFuzzyMeanShiftTracker	/usr/include/opencv2/contrib/contrib.hpp	/^    ~CvFuzzyMeanShiftTracker();$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:()
CvFuzzyPoint	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyPoint(double _x, double _y);$/;"	p	class:CvFuzzyPoint	access:public	signature:(double _x, double _y)
CvFuzzyPoint	/usr/include/opencv2/contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyPoint {$/;"	c
CvFuzzyPoint::CvFuzzyPoint	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyPoint(double _x, double _y);$/;"	p	class:CvFuzzyPoint	access:public	signature:(double _x, double _y)
CvFuzzyPoint::value	/usr/include/opencv2/contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
CvFuzzyPoint::x	/usr/include/opencv2/contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
CvFuzzyPoint::y	/usr/include/opencv2/contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
CvFuzzyRule	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyRule();$/;"	p	class:CvFuzzyRule	access:public	signature:()
CvFuzzyRule	/usr/include/opencv2/contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyRule {$/;"	c
CvFuzzyRule::CvFuzzyRule	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyRule();$/;"	p	class:CvFuzzyRule	access:public	signature:()
CvFuzzyRule::calcValue	/usr/include/opencv2/contrib/contrib.hpp	/^    double calcValue(double param1, double param2);$/;"	p	class:CvFuzzyRule	access:public	signature:(double param1, double param2)
CvFuzzyRule::fuzzyInput1	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyInput1, *fuzzyInput2;$/;"	m	class:CvFuzzyRule	access:private
CvFuzzyRule::fuzzyInput2	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyInput1, *fuzzyInput2;$/;"	m	class:CvFuzzyRule	access:private
CvFuzzyRule::fuzzyOutput	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyOutput;$/;"	m	class:CvFuzzyRule	access:private
CvFuzzyRule::getOutputCurve	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve *getOutputCurve();$/;"	p	class:CvFuzzyRule	access:public	signature:()
CvFuzzyRule::setRule	/usr/include/opencv2/contrib/contrib.hpp	/^    void setRule(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1);$/;"	p	class:CvFuzzyRule	access:public	signature:(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1)
CvFuzzyRule::~CvFuzzyRule	/usr/include/opencv2/contrib/contrib.hpp	/^    ~CvFuzzyRule();$/;"	p	class:CvFuzzyRule	access:public	signature:()
CvGBTrees	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvGBTrees( const cv::Mat& trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvGBTreesParams params=CvGBTreesParams() )
CvGBTrees	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvGBTrees();$/;"	p	class:CvGBTrees	access:public	signature:()
CvGBTrees	/usr/include/opencv2/ml/ml.hpp	/^    CvGBTrees( const CvMat* trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvGBTreesParams params=CvGBTreesParams() )
CvGBTrees	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS_W CvGBTrees : public CvStatModel$/;"	c	inherits:CvStatModel
CvGBTrees::ABSOLUTE_LOSS	/usr/include/opencv2/ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon87
CvGBTrees::CvGBTrees	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvGBTrees( const cv::Mat& trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvGBTreesParams params=CvGBTreesParams() )
CvGBTrees::CvGBTrees	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvGBTrees();$/;"	p	class:CvGBTrees	access:public	signature:()
CvGBTrees::CvGBTrees	/usr/include/opencv2/ml/ml.hpp	/^    CvGBTrees( const CvMat* trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvGBTreesParams params=CvGBTreesParams() )
CvGBTrees::DEVIANCE_LOSS	/usr/include/opencv2/ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon87
CvGBTrees::GetLeaves	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode** GetLeaves( const CvDTree* dtree, int& len );$/;"	p	class:CvGBTrees	access:protected	signature:( const CvDTree* dtree, int& len )
CvGBTrees::HUBER_LOSS	/usr/include/opencv2/ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon87
CvGBTrees::SQUARED_LOSS	/usr/include/opencv2/ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon87
CvGBTrees::base_value	/usr/include/opencv2/ml/ml.hpp	/^    float base_value;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::calc_error	/usr/include/opencv2/ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type,$/;"	p	class:CvGBTrees	access:public	signature:( CvMLData* _data, int type, std::vector<float> *resp = 0 )
CvGBTrees::change_values	/usr/include/opencv2/ml/ml.hpp	/^    virtual void change_values(CvDTree* tree, const int k = 0);$/;"	p	class:CvGBTrees	access:protected	signature:(CvDTree* tree, const int k = 0)
CvGBTrees::class_count	/usr/include/opencv2/ml/ml.hpp	/^    int class_count;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::class_labels	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* class_labels;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvGBTrees	access:public	signature:()
CvGBTrees::data	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::delta	/usr/include/opencv2/ml/ml.hpp	/^    float delta;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::do_subsample	/usr/include/opencv2/ml/ml.hpp	/^    virtual void do_subsample();$/;"	p	class:CvGBTrees	access:protected	signature:()
CvGBTrees::find_gradient	/usr/include/opencv2/ml/ml.hpp	/^    virtual void find_gradient( const int k = 0);$/;"	p	class:CvGBTrees	access:protected	signature:( const int k = 0)
CvGBTrees::find_optimal_value	/usr/include/opencv2/ml/ml.hpp	/^    virtual float find_optimal_value( const CvMat* _Idx );$/;"	p	class:CvGBTrees	access:protected	signature:( const CvMat* _Idx )
CvGBTrees::leaves_get	/usr/include/opencv2/ml/ml.hpp	/^    void leaves_get( CvDTreeNode** leaves, int& count, CvDTreeNode* node );$/;"	p	class:CvGBTrees	access:protected	signature:( CvDTreeNode** leaves, int& count, CvDTreeNode* node )
CvGBTrees::missing	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* missing;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::orig_response	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* orig_response;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::params	/usr/include/opencv2/ml/ml.hpp	/^    CvGBTreesParams params;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(),$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(), const cv::Range& slice = cv::Range::all(), int k=-1 ) const
CvGBTrees::predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing=0,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* sample, const CvMat* missing=0, CvMat* weakResponses=0, CvSlice slice = CV_WHOLE_SEQ, int k=-1 ) const
CvGBTrees::problem_type	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool problem_type() const;$/;"	p	class:CvGBTrees	access:protected	signature:() const
CvGBTrees::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvGBTrees	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvGBTrees::read_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* fnode );$/;"	p	class:CvGBTrees	access:protected	signature:( CvFileStorage* fs, CvFileNode* fnode )
CvGBTrees::rng	/usr/include/opencv2/ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* sample_idx;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::subsample_test	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* subsample_test;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::subsample_train	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* subsample_train;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::sum_response	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* sum_response;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::sum_response_tmp	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* sum_response_tmp;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvGBTreesParams params=CvGBTreesParams(), bool update=false )
CvGBTrees::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvMLData* data,$/;"	p	class:CvGBTrees	access:public	signature:( CvMLData* data, CvGBTreesParams params=CvGBTreesParams(), bool update=false )
CvGBTrees::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvGBTreesParams params=CvGBTreesParams(), bool update=false )
CvGBTrees::weak	/usr/include/opencv2/ml/ml.hpp	/^    CvSeq** weak;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::weak_eval	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* weak_eval;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvGBTrees	access:public	signature:( CvFileStorage* fs, const char* name ) const
CvGBTrees::write_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvGBTrees	access:protected	signature:( CvFileStorage* fs ) const
CvGBTrees::~CvGBTrees	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvGBTrees();$/;"	p	class:CvGBTrees	access:public	signature:()
CvGBTreesParams	/usr/include/opencv2/ml/ml.hpp	/^    CvGBTreesParams( int loss_function_type, int weak_count, float shrinkage,$/;"	p	struct:CvGBTreesParams	access:public	signature:( int loss_function_type, int weak_count, float shrinkage, float subsample_portion, int max_depth, bool use_surrogates )
CvGBTreesParams	/usr/include/opencv2/ml/ml.hpp	/^    CvGBTreesParams();$/;"	p	struct:CvGBTreesParams	access:public	signature:()
CvGBTreesParams	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvGBTreesParams : public CvDTreeParams$/;"	s	inherits:CvDTreeParams
CvGBTreesParams::CvGBTreesParams	/usr/include/opencv2/ml/ml.hpp	/^    CvGBTreesParams( int loss_function_type, int weak_count, float shrinkage,$/;"	p	struct:CvGBTreesParams	access:public	signature:( int loss_function_type, int weak_count, float shrinkage, float subsample_portion, int max_depth, bool use_surrogates )
CvGBTreesParams::CvGBTreesParams	/usr/include/opencv2/ml/ml.hpp	/^    CvGBTreesParams();$/;"	p	struct:CvGBTreesParams	access:public	signature:()
CvGBTreesParams::loss_function_type	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int loss_function_type;$/;"	m	struct:CvGBTreesParams	access:public
CvGBTreesParams::shrinkage	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW float shrinkage;$/;"	m	struct:CvGBTreesParams	access:public
CvGBTreesParams::subsample_portion	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW float subsample_portion;$/;"	m	struct:CvGBTreesParams	access:public
CvGBTreesParams::weak_count	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int weak_count;$/;"	m	struct:CvGBTreesParams	access:public
CvGLCM	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvGLCM CvGLCM;$/;"	t	typeref:struct:CvGLCM
CvGaussBGModel	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvGaussBGModel$/;"	s
CvGaussBGModel	/usr/include/opencv2/video/background_segm.hpp	/^} CvGaussBGModel;$/;"	t	typeref:struct:CvGaussBGModel
CvGaussBGModel::CV_BG_STAT_MODEL_FIELDS	/usr/include/opencv2/video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvGaussBGModel	access:public	signature:()
CvGaussBGModel::countFrames	/usr/include/opencv2/video/background_segm.hpp	/^    int                        countFrames;$/;"	m	struct:CvGaussBGModel	access:public
CvGaussBGModel::g_point	/usr/include/opencv2/video/background_segm.hpp	/^    CvGaussBGPoint*            g_point;    $/;"	m	struct:CvGaussBGModel	access:public
CvGaussBGModel::params	/usr/include/opencv2/video/background_segm.hpp	/^    CvGaussBGStatModelParams   params;    $/;"	m	struct:CvGaussBGModel	access:public
CvGaussBGPoint	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvGaussBGPoint$/;"	s
CvGaussBGPoint	/usr/include/opencv2/video/background_segm.hpp	/^} CvGaussBGPoint;$/;"	t	typeref:struct:CvGaussBGPoint
CvGaussBGPoint::g_values	/usr/include/opencv2/video/background_segm.hpp	/^    CvGaussBGValues* g_values;$/;"	m	struct:CvGaussBGPoint	access:public
CvGaussBGStatModelParams	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvGaussBGStatModelParams$/;"	s
CvGaussBGStatModelParams	/usr/include/opencv2/video/background_segm.hpp	/^}CvGaussBGStatModelParams;$/;"	t	typeref:struct:CvGaussBGStatModelParams
CvGaussBGStatModelParams::bg_threshold	/usr/include/opencv2/video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::minArea	/usr/include/opencv2/video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::n_gauss	/usr/include/opencv2/video/background_segm.hpp	/^    int     n_gauss;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::std_threshold	/usr/include/opencv2/video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::variance_init	/usr/include/opencv2/video/background_segm.hpp	/^    double  weight_init, variance_init;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::weight_init	/usr/include/opencv2/video/background_segm.hpp	/^    double  weight_init, variance_init;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::win_size	/usr/include/opencv2/video/background_segm.hpp	/^    int     win_size;               \/* = 1\/alpha *\/$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGValues	/usr/include/opencv2/video/background_segm.hpp	/^typedef struct CvGaussBGValues$/;"	s
CvGaussBGValues	/usr/include/opencv2/video/background_segm.hpp	/^} CvGaussBGValues;$/;"	t	typeref:struct:CvGaussBGValues
CvGaussBGValues::match_sum	/usr/include/opencv2/video/background_segm.hpp	/^    int         match_sum;$/;"	m	struct:CvGaussBGValues	access:public
CvGaussBGValues::mean	/usr/include/opencv2/video/background_segm.hpp	/^    double      mean[CV_BGFG_MOG_NCOLORS];$/;"	m	struct:CvGaussBGValues	access:public
CvGaussBGValues::variance	/usr/include/opencv2/video/background_segm.hpp	/^    double      variance[CV_BGFG_MOG_NCOLORS];$/;"	m	struct:CvGaussBGValues	access:public
CvGaussBGValues::weight	/usr/include/opencv2/video/background_segm.hpp	/^    double      weight;$/;"	m	struct:CvGaussBGValues	access:public
CvGraph	/usr/include/opencv2/core/types_c.h	/^CvGraph;$/;"	t	typeref:struct:CvGraph
CvGraph	/usr/include/opencv2/core/types_c.h	/^typedef struct CvGraph$/;"	s
CvGraphEdge	/usr/include/opencv2/core/types_c.h	/^CvGraphEdge;$/;"	t	typeref:struct:CvGraphEdge
CvGraphEdge	/usr/include/opencv2/core/types_c.h	/^typedef struct CvGraphEdge$/;"	s
CvGraphScanner	/usr/include/opencv2/core/core_c.h	/^CvGraphScanner;$/;"	t	typeref:struct:CvGraphScanner
CvGraphScanner	/usr/include/opencv2/core/core_c.h	/^typedef struct CvGraphScanner$/;"	s
CvGraphScanner::dst	/usr/include/opencv2/core/core_c.h	/^    CvGraphVtx* dst;       \/* current graph edge destination vertex *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::edge	/usr/include/opencv2/core/core_c.h	/^    CvGraphEdge* edge;     \/* current edge *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::graph	/usr/include/opencv2/core/core_c.h	/^    CvGraph* graph;        \/* the graph *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::index	/usr/include/opencv2/core/core_c.h	/^    int      index;        \/* the lower bound of certainly visited vertices *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::mask	/usr/include/opencv2/core/core_c.h	/^    int      mask;         \/* event mask *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::stack	/usr/include/opencv2/core/core_c.h	/^    CvSeq*   stack;        \/* the graph vertex stack *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::vtx	/usr/include/opencv2/core/core_c.h	/^    CvGraphVtx* vtx;       \/* current graph vertex (or current edge origin) *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphVtx	/usr/include/opencv2/core/types_c.h	/^CvGraphVtx;$/;"	t	typeref:struct:CvGraphVtx
CvGraphVtx	/usr/include/opencv2/core/types_c.h	/^typedef struct CvGraphVtx$/;"	s
CvGraphVtx2D	/usr/include/opencv2/core/types_c.h	/^CvGraphVtx2D;$/;"	t	typeref:struct:CvGraphVtx2D
CvGraphVtx2D	/usr/include/opencv2/core/types_c.h	/^typedef struct CvGraphVtx2D$/;"	s
CvGraphVtx2D::ptr	/usr/include/opencv2/core/types_c.h	/^    CvPoint2D32f* ptr;$/;"	m	struct:CvGraphVtx2D	access:public
CvGraphWeightType	/usr/include/opencv2/legacy/legacy.hpp	/^typedef enum CvGraphWeightType$/;"	g
CvGraphWeightType	/usr/include/opencv2/legacy/legacy.hpp	/^} CvGraphWeightType;$/;"	t	typeref:enum:CvGraphWeightType
CvGraphWeightedEdge	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvGraphWeightedEdge$/;"	s
CvGraphWeightedEdge	/usr/include/opencv2/legacy/legacy.hpp	/^} CvGraphWeightedEdge;$/;"	t	typeref:struct:CvGraphWeightedEdge
CvGraphWeightedVtx	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvGraphWeightedVtx$/;"	s
CvGraphWeightedVtx	/usr/include/opencv2/legacy/legacy.hpp	/^} CvGraphWeightedVtx;$/;"	t	typeref:struct:CvGraphWeightedVtx
CvHaarClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^typedef struct CvHaarClassifier$/;"	s
CvHaarClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^} CvHaarClassifier;$/;"	t	typeref:struct:CvHaarClassifier
CvHaarClassifier::alpha	/usr/include/opencv2/objdetect/objdetect.hpp	/^    float* alpha;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifier::count	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int count;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifier::haar_feature	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvHaarFeature* haar_feature;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifier::left	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int* left;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifier::right	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int* right;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifier::threshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^    float* threshold;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifierCascade	/usr/include/opencv2/objdetect/objdetect.hpp	/^typedef struct CvHaarClassifierCascade$/;"	s
CvHaarClassifierCascade	/usr/include/opencv2/objdetect/objdetect.hpp	/^} CvHaarClassifierCascade;$/;"	t	typeref:struct:CvHaarClassifierCascade
CvHaarClassifierCascade::count	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int  count;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::flags	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int  flags;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::hid_cascade	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvHidHaarClassifierCascade* hid_cascade;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::orig_window_size	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvSize orig_window_size;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::real_window_size	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvSize real_window_size;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::scale	/usr/include/opencv2/objdetect/objdetect.hpp	/^    double scale;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::stage_classifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvHaarStageClassifier* stage_classifier;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarFeature	/usr/include/opencv2/objdetect/objdetect.hpp	/^typedef struct CvHaarFeature$/;"	s
CvHaarFeature	/usr/include/opencv2/objdetect/objdetect.hpp	/^} CvHaarFeature;$/;"	t	typeref:struct:CvHaarFeature
CvHaarFeature::__anon58::r	/usr/include/opencv2/objdetect/objdetect.hpp	/^        CvRect r;$/;"	m	struct:CvHaarFeature::__anon58	access:public
CvHaarFeature::__anon58::weight	/usr/include/opencv2/objdetect/objdetect.hpp	/^        float weight;$/;"	m	struct:CvHaarFeature::__anon58	access:public
CvHaarFeature::rect	/usr/include/opencv2/objdetect/objdetect.hpp	/^    } rect[CV_HAAR_FEATURE_MAX];$/;"	m	struct:CvHaarFeature	typeref:struct:CvHaarFeature::__anon58	access:public
CvHaarFeature::tilted	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int  tilted;$/;"	m	struct:CvHaarFeature	access:public
CvHaarStageClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^typedef struct CvHaarStageClassifier$/;"	s
CvHaarStageClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^} CvHaarStageClassifier;$/;"	t	typeref:struct:CvHaarStageClassifier
CvHaarStageClassifier::child	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int child;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHaarStageClassifier::classifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvHaarClassifier* classifier;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHaarStageClassifier::count	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int  count;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHaarStageClassifier::next	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int next;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHaarStageClassifier::parent	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int parent;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHaarStageClassifier::threshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^    float threshold;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHidHaarClassifierCascade	/usr/include/opencv2/objdetect/objdetect.hpp	/^typedef struct CvHidHaarClassifierCascade CvHidHaarClassifierCascade;$/;"	t	typeref:struct:CvHidHaarClassifierCascade
CvHistType	/usr/include/opencv2/core/types_c.h	/^typedef int CvHistType;$/;"	t
CvHistogram	/usr/include/opencv2/core/types_c.h	/^CvHistogram;$/;"	t	typeref:struct:CvHistogram
CvHistogram	/usr/include/opencv2/core/types_c.h	/^typedef struct CvHistogram$/;"	s
CvHistogram::bins	/usr/include/opencv2/core/types_c.h	/^    CvArr*  bins;$/;"	m	struct:CvHistogram	access:public
CvHistogram::mat	/usr/include/opencv2/core/types_c.h	/^    CvMatND mat;                    \/* Embedded matrix header for array histograms. *\/$/;"	m	struct:CvHistogram	access:public
CvHistogram::thresh	/usr/include/opencv2/core/types_c.h	/^    float   thresh[CV_MAX_DIM][2];  \/* For uniform histograms.                      *\/$/;"	m	struct:CvHistogram	access:public
CvHistogram::thresh2	/usr/include/opencv2/core/types_c.h	/^    float** thresh2;                \/* For non-uniform histograms.                  *\/$/;"	m	struct:CvHistogram	access:public
CvHistogram::type	/usr/include/opencv2/core/types_c.h	/^    int     type;$/;"	m	struct:CvHistogram	access:public
CvHuMoments	/usr/include/opencv2/imgproc/types_c.h	/^CvHuMoments;$/;"	t	typeref:struct:CvHuMoments
CvHuMoments	/usr/include/opencv2/imgproc/types_c.h	/^typedef struct CvHuMoments$/;"	s
CvHuMoments::hu1	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu2	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu3	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu4	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu5	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu6	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu7	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( CvFileStorage* fs, const char* mapname, const char* imgname ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* imgname )
CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( CvFileStorage* fs, const char* seqname, int idx ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( CvSize size, int depth, int channels )$/;"	f	class:CvImage	access:public	signature:( CvSize size, int depth, int channels )
CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( IplImage* img ) : image(img)$/;"	f	class:CvImage	access:public	signature:( IplImage* img )
CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( const CvImage& img ) : image(img.image), refcount(img.refcount)$/;"	f	class:CvImage	access:public	signature:( const CvImage& img )
CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( const char* filename, const char* imgname=0, int color=-1 ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( const char* filename, const char* imgname=0, int color=-1 )
CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage() : image(0), refcount(0) {}$/;"	f	class:CvImage	access:public	signature:()
CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^class CV_EXPORTS CvImage$/;"	c
CvImage::CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( CvFileStorage* fs, const char* mapname, const char* imgname ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* imgname )
CvImage::CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( CvFileStorage* fs, const char* seqname, int idx ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvImage::CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( CvSize size, int depth, int channels )$/;"	f	class:CvImage	access:public	signature:( CvSize size, int depth, int channels )
CvImage::CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( IplImage* img ) : image(img)$/;"	f	class:CvImage	access:public	signature:( IplImage* img )
CvImage::CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( const CvImage& img ) : image(img.image), refcount(img.refcount)$/;"	f	class:CvImage	access:public	signature:( const CvImage& img )
CvImage::CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage( const char* filename, const char* imgname=0, int color=-1 ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( const char* filename, const char* imgname=0, int color=-1 )
CvImage::CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage() : image(0), refcount(0) {}$/;"	f	class:CvImage	access:public	signature:()
CvImage::attach	/usr/include/opencv2/legacy/legacy.hpp	/^    void attach( IplImage* img, bool use_refcount=true )$/;"	f	class:CvImage	access:public	signature:( IplImage* img, bool use_refcount=true )
CvImage::channels	/usr/include/opencv2/legacy/legacy.hpp	/^    int channels() const { return image ? image->nChannels : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::clear	/usr/include/opencv2/legacy/legacy.hpp	/^    void clear() { detach(); }$/;"	f	class:CvImage	access:public	signature:()
CvImage::clone	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage clone() { return CvImage(image ? cvCloneImage(image) : 0); }$/;"	f	class:CvImage	access:public	signature:()
CvImage::coi	/usr/include/opencv2/legacy/legacy.hpp	/^    int coi() const { return !image || !image->roi ? 0 : image->roi->coi; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::create	/usr/include/opencv2/legacy/legacy.hpp	/^    void create( CvSize size, int depth, int channels )$/;"	f	class:CvImage	access:public	signature:( CvSize size, int depth, int channels )
CvImage::data	/usr/include/opencv2/legacy/legacy.hpp	/^    const uchar* data() const { return image ? (const uchar*)image->imageData : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::data	/usr/include/opencv2/legacy/legacy.hpp	/^    uchar* data() { return image ? (uchar*)image->imageData : 0; }$/;"	f	class:CvImage	access:public	signature:()
CvImage::depth	/usr/include/opencv2/legacy/legacy.hpp	/^    int depth() const { return image ? image->depth : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::detach	/usr/include/opencv2/legacy/legacy.hpp	/^    void detach()$/;"	f	class:CvImage	access:public	signature:()
CvImage::height	/usr/include/opencv2/legacy/legacy.hpp	/^    int height() const { return image ? image->height : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::image	/usr/include/opencv2/legacy/legacy.hpp	/^    IplImage* image;$/;"	m	class:CvImage	access:protected
CvImage::is_valid	/usr/include/opencv2/legacy/legacy.hpp	/^    bool is_valid() { return image != 0; }$/;"	f	class:CvImage	access:public	signature:()
CvImage::load	/usr/include/opencv2/legacy/legacy.hpp	/^    bool load( const char* filename, const char* imgname=0, int color=-1 );$/;"	p	class:CvImage	access:public	signature:( const char* filename, const char* imgname=0, int color=-1 )
CvImage::operator =	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage& operator = (const CvImage& img)$/;"	f	class:CvImage	access:public	signature:(const CvImage& img)
CvImage::operator IplImage*	/usr/include/opencv2/legacy/legacy.hpp	/^    operator IplImage* () { return image; }$/;"	f	class:CvImage	access:public	signature:()
CvImage::operator const IplImage*	/usr/include/opencv2/legacy/legacy.hpp	/^    operator const IplImage* () const { return image; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::origin	/usr/include/opencv2/legacy/legacy.hpp	/^    int origin() const { return image ? image->origin : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::pix_size	/usr/include/opencv2/legacy/legacy.hpp	/^    int pix_size() const { return image ? ((image->depth & 255)>>3)*image->nChannels : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::read	/usr/include/opencv2/legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* mapname, const char* imgname );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* imgname )
CvImage::read	/usr/include/opencv2/legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* seqname, int idx );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvImage::refcount	/usr/include/opencv2/legacy/legacy.hpp	/^    int* refcount;$/;"	m	class:CvImage	access:protected
CvImage::release	/usr/include/opencv2/legacy/legacy.hpp	/^    void release() { detach(); }$/;"	f	class:CvImage	access:public	signature:()
CvImage::reset_roi	/usr/include/opencv2/legacy/legacy.hpp	/^    void reset_roi() { cvResetImageROI(image); }$/;"	f	class:CvImage	access:public	signature:()
CvImage::roi	/usr/include/opencv2/legacy/legacy.hpp	/^    CvRect roi() const$/;"	f	class:CvImage	access:public	signature:() const
CvImage::roi_row	/usr/include/opencv2/legacy/legacy.hpp	/^    const uchar* roi_row(int y) const$/;"	f	class:CvImage	access:public	signature:(int y) const
CvImage::roi_row	/usr/include/opencv2/legacy/legacy.hpp	/^    uchar* roi_row(int y)$/;"	f	class:CvImage	access:public	signature:(int y)
CvImage::roi_size	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSize roi_size() const$/;"	f	class:CvImage	access:public	signature:() const
CvImage::save	/usr/include/opencv2/legacy/legacy.hpp	/^    void save( const char* filename, const char* imgname, const int* params=0 );$/;"	p	class:CvImage	access:public	signature:( const char* filename, const char* imgname, const int* params=0 )
CvImage::set_coi	/usr/include/opencv2/legacy/legacy.hpp	/^    void set_coi(int coi) { cvSetImageCOI(image,coi); }$/;"	f	class:CvImage	access:public	signature:(int coi)
CvImage::set_roi	/usr/include/opencv2/legacy/legacy.hpp	/^    void set_roi(CvRect roi) { cvSetImageROI(image,roi); }$/;"	f	class:CvImage	access:public	signature:(CvRect roi)
CvImage::show	/usr/include/opencv2/legacy/legacy.hpp	/^    void show( const char* window_name );$/;"	p	class:CvImage	access:public	signature:( const char* window_name )
CvImage::size	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSize size() const { return image ? cvSize(image->width, image->height) : cvSize(0,0); }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::step	/usr/include/opencv2/legacy/legacy.hpp	/^    int step() const { return image ? image->widthStep : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::width	/usr/include/opencv2/legacy/legacy.hpp	/^    int width() const { return image ? image->width : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::write	/usr/include/opencv2/legacy/legacy.hpp	/^    void write( CvFileStorage* fs, const char* imgname );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* imgname )
CvImage::~CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    ~CvImage()$/;"	f	class:CvImage	access:public	signature:()
CvImageDrawer	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvImageDrawer() : m_image(0) {}$/;"	f	class:CvImageDrawer	access:public	signature:()
CvImageDrawer	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvImageDrawer$/;"	c
CvImageDrawer::CvImageDrawer	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvImageDrawer() : m_image(0) {}$/;"	f	class:CvImageDrawer	access:public	signature:()
CvImageDrawer::Draw	/usr/include/opencv2/legacy/blobtrack.hpp	/^    IplImage* Draw( const CvArr* src, CvBlobSeq* blob_seq = 0, const CvSeq* roi_seq = 0 );$/;"	p	class:CvImageDrawer	access:public	signature:( const CvArr* src, CvBlobSeq* blob_seq = 0, const CvSeq* roi_seq = 0 )
CvImageDrawer::GetImage	/usr/include/opencv2/legacy/blobtrack.hpp	/^    IplImage* GetImage() { return m_image; }$/;"	f	class:CvImageDrawer	access:public	signature:()
CvImageDrawer::SetShapes	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void SetShapes( const CvDrawShape* shapes, int num );$/;"	p	class:CvImageDrawer	access:public	signature:( const CvDrawShape* shapes, int num )
CvImageDrawer::m_image	/usr/include/opencv2/legacy/blobtrack.hpp	/^    IplImage* m_image;$/;"	m	class:CvImageDrawer	access:protected
CvImageDrawer::m_shape	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvDrawShape m_shape[16];$/;"	m	class:CvImageDrawer	access:protected
CvImageDrawer::~CvImageDrawer	/usr/include/opencv2/legacy/blobtrack.hpp	/^    ~CvImageDrawer() { cvReleaseImage( &m_image ); }$/;"	f	class:CvImageDrawer	access:public	signature:()
CvImgObsInfo	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvImgObsInfo$/;"	s
CvImgObsInfo	/usr/include/opencv2/legacy/legacy.hpp	/^} CvImgObsInfo;\/*struct for 1 image*\/$/;"	t	typeref:struct:CvImgObsInfo
CvImgObsInfo::mix	/usr/include/opencv2/legacy/legacy.hpp	/^    int* mix;  \/* number of mixture to which observation belong *\/$/;"	m	struct:CvImgObsInfo	access:public
CvImgObsInfo::obs	/usr/include/opencv2/legacy/legacy.hpp	/^    float* obs;\/\/consequtive observations$/;"	m	struct:CvImgObsInfo	access:public
CvImgObsInfo::obs_size	/usr/include/opencv2/legacy/legacy.hpp	/^    int obs_size;$/;"	m	struct:CvImgObsInfo	access:public
CvImgObsInfo::obs_x	/usr/include/opencv2/legacy/legacy.hpp	/^    int obs_x;$/;"	m	struct:CvImgObsInfo	access:public
CvImgObsInfo::obs_y	/usr/include/opencv2/legacy/legacy.hpp	/^    int obs_y;$/;"	m	struct:CvImgObsInfo	access:public
CvImgObsInfo::state	/usr/include/opencv2/legacy/legacy.hpp	/^    int* state;\/* arr of pairs superstate\/state to which observation belong *\/$/;"	m	struct:CvImgObsInfo	access:public
CvInput	/usr/include/opencv2/legacy/legacy.hpp	/^CvInput;$/;"	t	typeref:union:__anon170
CvIsInstanceFunc	/usr/include/opencv2/core/types_c.h	/^typedef int (CV_CDECL *CvIsInstanceFunc)( const void* struct_ptr );$/;"	t
CvKNearest	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvKNearest( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& sampleIdx=cv::Mat(), bool isRegression=false, int max_k=32 )
CvKNearest	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvKNearest();$/;"	p	class:CvKNearest	access:public	signature:()
CvKNearest	/usr/include/opencv2/ml/ml.hpp	/^    CvKNearest( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* sampleIdx=0, bool isRegression=false, int max_k=32 )
CvKNearest	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS_W CvKNearest : public CvStatModel$/;"	c	inherits:CvStatModel
CvKNearest::CvKNearest	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvKNearest( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& sampleIdx=cv::Mat(), bool isRegression=false, int max_k=32 )
CvKNearest::CvKNearest	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvKNearest();$/;"	p	class:CvKNearest	access:public	signature:()
CvKNearest::CvKNearest	/usr/include/opencv2/ml/ml.hpp	/^    CvKNearest( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* sampleIdx=0, bool isRegression=false, int max_k=32 )
CvKNearest::clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvKNearest	access:public	signature:()
CvKNearest::find_nearest	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float find_nearest( const cv::Mat& samples, int k, CV_OUT cv::Mat& results,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& samples, int k, CV_OUT cv::Mat& results, CV_OUT cv::Mat& neighborResponses, CV_OUT cv::Mat& dists) const
CvKNearest::find_nearest	/usr/include/opencv2/ml/ml.hpp	/^    virtual float find_nearest( const CvMat* samples, int k, CV_OUT CvMat* results=0,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* samples, int k, CV_OUT CvMat* results=0, const float** neighbors=0, CV_OUT CvMat* neighborResponses=0, CV_OUT CvMat* dist=0 ) const
CvKNearest::find_nearest	/usr/include/opencv2/ml/ml.hpp	/^    virtual float find_nearest( const cv::Mat& samples, int k, cv::Mat* results=0,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& samples, int k, cv::Mat* results=0, const float** neighbors=0, cv::Mat* neighborResponses=0, cv::Mat* dist=0 ) const
CvKNearest::find_neighbors_direct	/usr/include/opencv2/ml/ml.hpp	/^    virtual void find_neighbors_direct( const CvMat* _samples, int k, int start, int end,$/;"	p	class:CvKNearest	access:protected	signature:( const CvMat* _samples, int k, int start, int end, float* neighbor_responses, const float** neighbors, float* dist ) const
CvKNearest::get_max_k	/usr/include/opencv2/ml/ml.hpp	/^    int get_max_k() const;$/;"	p	class:CvKNearest	access:public	signature:() const
CvKNearest::get_sample_count	/usr/include/opencv2/ml/ml.hpp	/^    int get_sample_count() const;$/;"	p	class:CvKNearest	access:public	signature:() const
CvKNearest::get_var_count	/usr/include/opencv2/ml/ml.hpp	/^    int get_var_count() const;$/;"	p	class:CvKNearest	access:public	signature:() const
CvKNearest::is_regression	/usr/include/opencv2/ml/ml.hpp	/^    bool is_regression() const;$/;"	p	class:CvKNearest	access:public	signature:() const
CvKNearest::max_k	/usr/include/opencv2/ml/ml.hpp	/^    int max_k, var_count;$/;"	m	class:CvKNearest	access:protected
CvKNearest::regression	/usr/include/opencv2/ml/ml.hpp	/^    bool regression;$/;"	m	class:CvKNearest	access:protected
CvKNearest::samples	/usr/include/opencv2/ml/ml.hpp	/^    CvVectors* samples;$/;"	m	class:CvKNearest	access:protected
CvKNearest::total	/usr/include/opencv2/ml/ml.hpp	/^    int total;$/;"	m	class:CvKNearest	access:protected
CvKNearest::train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& sampleIdx=cv::Mat(), bool isRegression=false, int maxK=32, bool updateBase=false )
CvKNearest::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* sampleIdx=0, bool is_regression=false, int maxK=32, bool updateBase=false )
CvKNearest::var_count	/usr/include/opencv2/ml/ml.hpp	/^    int max_k, var_count;$/;"	m	class:CvKNearest	access:protected
CvKNearest::write_results	/usr/include/opencv2/ml/ml.hpp	/^    virtual float write_results( int k, int k1, int start, int end,$/;"	p	class:CvKNearest	access:protected	signature:( int k, int k1, int start, int end, const float* neighbor_responses, const float* dist, CvMat* _results, CvMat* _neighbor_responses, CvMat* _dist, Cv32suf* sort_buf ) const
CvKNearest::~CvKNearest	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvKNearest();$/;"	p	class:CvKNearest	access:public	signature:()
CvKalman	/usr/include/opencv2/video/tracking.hpp	/^typedef struct CvKalman$/;"	s
CvKalman	/usr/include/opencv2/video/tracking.hpp	/^} CvKalman;$/;"	t	typeref:struct:CvKalman
CvKalman::CP	/usr/include/opencv2/video/tracking.hpp	/^    int CP;                     \/* number of control vector dimensions *\/$/;"	m	struct:CvKalman	access:public
CvKalman::DP	/usr/include/opencv2/video/tracking.hpp	/^    int DP;                     \/* number of state vector dimensions *\/$/;"	m	struct:CvKalman	access:public
CvKalman::DynamMatr	/usr/include/opencv2/video/tracking.hpp	/^    float* DynamMatr;           \/* =transition_matrix->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::KalmGainMatr	/usr/include/opencv2/video/tracking.hpp	/^    float* KalmGainMatr;        \/* =gain->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::MNCovariance	/usr/include/opencv2/video/tracking.hpp	/^    float* MNCovariance;        \/* =measurement_noise_cov->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::MP	/usr/include/opencv2/video/tracking.hpp	/^    int MP;                     \/* number of measurement vector dimensions *\/$/;"	m	struct:CvKalman	access:public
CvKalman::MeasurementMatr	/usr/include/opencv2/video/tracking.hpp	/^    float* MeasurementMatr;     \/* =measurement_matrix->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::PNCovariance	/usr/include/opencv2/video/tracking.hpp	/^    float* PNCovariance;        \/* =process_noise_cov->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::PosterErrorCovariance	/usr/include/opencv2/video/tracking.hpp	/^    float* PosterErrorCovariance;\/* =error_cov_post->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::PosterState	/usr/include/opencv2/video/tracking.hpp	/^    float* PosterState;         \/* =state_pre->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::PriorErrorCovariance	/usr/include/opencv2/video/tracking.hpp	/^    float* PriorErrorCovariance;\/* =error_cov_pre->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::PriorState	/usr/include/opencv2/video/tracking.hpp	/^    float* PriorState;          \/* =state_post->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::Temp1	/usr/include/opencv2/video/tracking.hpp	/^    float* Temp1;               \/* temp1->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::Temp2	/usr/include/opencv2/video/tracking.hpp	/^    float* Temp2;               \/* temp2->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::control_matrix	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* control_matrix;      \/* control matrix (B)$/;"	m	struct:CvKalman	access:public
CvKalman::error_cov_post	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* error_cov_post;      \/* posteriori error estimate covariance matrix (P(k)):$/;"	m	struct:CvKalman	access:public
CvKalman::error_cov_pre	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* error_cov_pre;       \/* priori error estimate covariance matrix (P'(k)):$/;"	m	struct:CvKalman	access:public
CvKalman::gain	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* gain;                \/* Kalman gain matrix (K(k)):$/;"	m	struct:CvKalman	access:public
CvKalman::measurement_matrix	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* measurement_matrix;  \/* measurement matrix (H) *\/$/;"	m	struct:CvKalman	access:public
CvKalman::measurement_noise_cov	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* measurement_noise_cov; \/* measurement noise covariance matrix (R) *\/$/;"	m	struct:CvKalman	access:public
CvKalman::process_noise_cov	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* process_noise_cov;   \/* process noise covariance matrix (Q) *\/$/;"	m	struct:CvKalman	access:public
CvKalman::state_post	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* state_post;          \/* corrected state (x(k)):$/;"	m	struct:CvKalman	access:public
CvKalman::state_pre	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* state_pre;           \/* predicted state (x'(k)):$/;"	m	struct:CvKalman	access:public
CvKalman::temp1	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* temp1;               \/* temporary matrices *\/$/;"	m	struct:CvKalman	access:public
CvKalman::temp2	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* temp2;$/;"	m	struct:CvKalman	access:public
CvKalman::temp3	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* temp3;$/;"	m	struct:CvKalman	access:public
CvKalman::temp4	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* temp4;$/;"	m	struct:CvKalman	access:public
CvKalman::temp5	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* temp5;$/;"	m	struct:CvKalman	access:public
CvKalman::transition_matrix	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* transition_matrix;   \/* state transition matrix (A) *\/$/;"	m	struct:CvKalman	access:public
CvLCMEdge	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvLCMEdge$/;"	s
CvLCMEdge	/usr/include/opencv2/legacy/legacy.hpp	/^} CvLCMEdge;$/;"	t	typeref:struct:CvLCMEdge
CvLCMEdge::chain	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSeq* chain;$/;"	m	struct:CvLCMEdge	access:public
CvLCMEdge::index1	/usr/include/opencv2/legacy/legacy.hpp	/^    int index1;$/;"	m	struct:CvLCMEdge	access:public
CvLCMEdge::index2	/usr/include/opencv2/legacy/legacy.hpp	/^    int index2;$/;"	m	struct:CvLCMEdge	access:public
CvLCMEdge::width	/usr/include/opencv2/legacy/legacy.hpp	/^    float width;$/;"	m	struct:CvLCMEdge	access:public
CvLCMNode	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvLCMNode$/;"	s
CvLCMNode	/usr/include/opencv2/legacy/legacy.hpp	/^} CvLCMNode;$/;"	t	typeref:struct:CvLCMNode
CvLCMNode::contour	/usr/include/opencv2/legacy/legacy.hpp	/^    CvContour* contour; $/;"	m	struct:CvLCMNode	access:public
CvLSHOperations	/usr/include/opencv2/imgproc/imgproc.hpp	/^struct CvLSHOperations$/;"	s
CvLSHOperations::hash_insert	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual void hash_insert(lsh_hash h, int l, int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int i)
CvLSHOperations::hash_lookup	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual int hash_lookup(lsh_hash h, int l, int* ret_i, int ret_i_max) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int* ret_i, int ret_i_max)
CvLSHOperations::hash_remove	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual void hash_remove(lsh_hash h, int l, int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int i)
CvLSHOperations::vector_add	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual int vector_add(const void* data) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(const void* data)
CvLSHOperations::vector_count	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual unsigned int vector_count() = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:()
CvLSHOperations::vector_lookup	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual const void* vector_lookup(int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int i)
CvLSHOperations::vector_remove	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual void vector_remove(int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int i)
CvLSHOperations::vector_reserve	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual void vector_reserve(int n) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int n)
CvLSHOperations::~CvLSHOperations	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual ~CvLSHOperations() {}$/;"	f	struct:CvLSHOperations	access:public	signature:()
CvLSVMFilterObject	/usr/include/opencv2/objdetect/objdetect.hpp	/^} CvLSVMFilterObject;$/;"	t	typeref:struct:__anon60
CvLSVMFilterPosition	/usr/include/opencv2/objdetect/objdetect.hpp	/^} CvLSVMFilterPosition;$/;"	t	typeref:struct:__anon59
CvLatentSvmDetector	/usr/include/opencv2/objdetect/objdetect.hpp	/^CvLatentSvmDetector;$/;"	t	typeref:struct:CvLatentSvmDetector
CvLatentSvmDetector	/usr/include/opencv2/objdetect/objdetect.hpp	/^typedef struct CvLatentSvmDetector$/;"	s
CvLatentSvmDetector::b	/usr/include/opencv2/objdetect/objdetect.hpp	/^	float* b;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLatentSvmDetector::filters	/usr/include/opencv2/objdetect/objdetect.hpp	/^	CvLSVMFilterObject** filters;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLatentSvmDetector::num_components	/usr/include/opencv2/objdetect/objdetect.hpp	/^	int num_components;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLatentSvmDetector::num_filters	/usr/include/opencv2/objdetect/objdetect.hpp	/^	int num_filters;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLatentSvmDetector::num_part_filters	/usr/include/opencv2/objdetect/objdetect.hpp	/^	int* num_part_filters;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLatentSvmDetector::score_threshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^	float score_threshold;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLeeParameters	/usr/include/opencv2/legacy/legacy.hpp	/^typedef enum CvLeeParameters$/;"	g
CvLeeParameters	/usr/include/opencv2/legacy/legacy.hpp	/^} CvLeeParameters;$/;"	t	typeref:enum:CvLeeParameters
CvLevMarq	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvLevMarq( int nparams, int nerrs, CvTermCriteria criteria=$/;"	p	class:CvLevMarq	access:public	signature:( int nparams, int nerrs, CvTermCriteria criteria= cvTermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,30,DBL_EPSILON), bool completeSymmFlag=false )
CvLevMarq	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvLevMarq();$/;"	p	class:CvLevMarq	access:public	signature:()
CvLevMarq	/usr/include/opencv2/calib3d/calib3d.hpp	/^class CV_EXPORTS CvLevMarq$/;"	c
CvLevMarq::CALC_J	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon66
CvLevMarq::CHECK_ERR	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon66
CvLevMarq::CvLevMarq	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvLevMarq( int nparams, int nerrs, CvTermCriteria criteria=$/;"	p	class:CvLevMarq	access:public	signature:( int nparams, int nerrs, CvTermCriteria criteria= cvTermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,30,DBL_EPSILON), bool completeSymmFlag=false )
CvLevMarq::CvLevMarq	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvLevMarq();$/;"	p	class:CvLevMarq	access:public	signature:()
CvLevMarq::DONE	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon66
CvLevMarq::J	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> J;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::JtErr	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtErr;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::JtJ	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJ;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::JtJN	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJN;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::JtJV	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJV;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::JtJW	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJW;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::STARTED	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon66
CvLevMarq::clear	/usr/include/opencv2/calib3d/calib3d.hpp	/^    void clear();$/;"	p	class:CvLevMarq	access:public	signature:()
CvLevMarq::completeSymmFlag	/usr/include/opencv2/calib3d/calib3d.hpp	/^    bool completeSymmFlag;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::criteria	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvTermCriteria criteria;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::err	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> err;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::errNorm	/usr/include/opencv2/calib3d/calib3d.hpp	/^    double prevErrNorm, errNorm;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::init	/usr/include/opencv2/calib3d/calib3d.hpp	/^    void init( int nparams, int nerrs, CvTermCriteria criteria=$/;"	p	class:CvLevMarq	access:public	signature:( int nparams, int nerrs, CvTermCriteria criteria= cvTermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,30,DBL_EPSILON), bool completeSymmFlag=false )
CvLevMarq::iters	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int iters;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::lambdaLg10	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int lambdaLg10;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::mask	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> mask;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::param	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> param;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::prevErrNorm	/usr/include/opencv2/calib3d/calib3d.hpp	/^    double prevErrNorm, errNorm;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::prevParam	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> prevParam;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::state	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int state;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::step	/usr/include/opencv2/calib3d/calib3d.hpp	/^    void step();$/;"	p	class:CvLevMarq	access:public	signature:()
CvLevMarq::update	/usr/include/opencv2/calib3d/calib3d.hpp	/^    bool update( const CvMat*& param, CvMat*& J, CvMat*& err );$/;"	p	class:CvLevMarq	access:public	signature:( const CvMat*& param, CvMat*& J, CvMat*& err )
CvLevMarq::updateAlt	/usr/include/opencv2/calib3d/calib3d.hpp	/^    bool updateAlt( const CvMat*& param, CvMat*& JtJ, CvMat*& JtErr, double*& errNorm );$/;"	p	class:CvLevMarq	access:public	signature:( const CvMat*& param, CvMat*& JtJ, CvMat*& JtErr, double*& errNorm )
CvLevMarq::~CvLevMarq	/usr/include/opencv2/calib3d/calib3d.hpp	/^    ~CvLevMarq();$/;"	p	class:CvLevMarq	access:public	signature:()
CvLineIterator	/usr/include/opencv2/core/types_c.h	/^CvLineIterator;$/;"	t	typeref:struct:CvLineIterator
CvLineIterator	/usr/include/opencv2/core/types_c.h	/^typedef struct CvLineIterator$/;"	s
CvLineIterator::err	/usr/include/opencv2/core/types_c.h	/^    int  err;$/;"	m	struct:CvLineIterator	access:public
CvLineIterator::minus_delta	/usr/include/opencv2/core/types_c.h	/^    int  minus_delta;$/;"	m	struct:CvLineIterator	access:public
CvLineIterator::minus_step	/usr/include/opencv2/core/types_c.h	/^    int  minus_step;$/;"	m	struct:CvLineIterator	access:public
CvLineIterator::plus_delta	/usr/include/opencv2/core/types_c.h	/^    int  plus_delta;$/;"	m	struct:CvLineIterator	access:public
CvLineIterator::plus_step	/usr/include/opencv2/core/types_c.h	/^    int  plus_step;$/;"	m	struct:CvLineIterator	access:public
CvLineIterator::ptr	/usr/include/opencv2/core/types_c.h	/^    uchar* ptr;$/;"	m	struct:CvLineIterator	access:public
CvMLData	/usr/include/opencv2/ml/ml.hpp	/^    CvMLData();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS CvMLData$/;"	c
CvMLData::CvMLData	/usr/include/opencv2/ml/ml.hpp	/^    CvMLData();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData::chahge_var_idx	/usr/include/opencv2/ml/ml.hpp	/^    void chahge_var_idx( int vi, bool state ); \/\/ state == true to set vi-variable as predictor$/;"	p	class:CvMLData	access:public	signature:( int vi, bool state )
CvMLData::change_var_type	/usr/include/opencv2/ml/ml.hpp	/^    void change_var_type( int var_idx, int type); \/\/ type in { CV_VAR_ORDERED, CV_VAR_CATEGORICAL }    $/;"	p	class:CvMLData	access:public	signature:( int var_idx, int type)
CvMLData::class_map	/usr/include/opencv2/ml/ml.hpp	/^    std::map<std::string, int> *class_map;$/;"	m	class:CvMLData	access:protected
CvMLData::clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvMLData	access:protected	signature:()
CvMLData::delimiter	/usr/include/opencv2/ml/ml.hpp	/^    char delimiter;$/;"	m	class:CvMLData	access:protected
CvMLData::free_train_test_idx	/usr/include/opencv2/ml/ml.hpp	/^    void free_train_test_idx();$/;"	p	class:CvMLData	access:protected	signature:()
CvMLData::get_delimiter	/usr/include/opencv2/ml/ml.hpp	/^    char get_delimiter() { return delimiter; };$/;"	f	class:CvMLData	access:public	signature:()
CvMLData::get_miss_ch	/usr/include/opencv2/ml/ml.hpp	/^    char get_miss_ch() { return miss_ch; };$/;"	f	class:CvMLData	access:public	signature:()
CvMLData::get_missing	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_missing(){ return missing; };$/;"	f	class:CvMLData	access:public	signature:()
CvMLData::get_response_idx	/usr/include/opencv2/ml/ml.hpp	/^    int get_response_idx() { return response_idx; }$/;"	f	class:CvMLData	access:public	signature:()
CvMLData::get_responses	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_responses();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData::get_test_sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_test_sample_idx() { return test_sample_idx; };$/;"	f	class:CvMLData	access:public	signature:()
CvMLData::get_train_sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_train_sample_idx() { return train_sample_idx; };$/;"	f	class:CvMLData	access:public	signature:()
CvMLData::get_values	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_values(){ return values; };$/;"	f	class:CvMLData	access:public	signature:()
CvMLData::get_var_idx	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_var_idx();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData::get_var_type	/usr/include/opencv2/ml/ml.hpp	/^    int get_var_type( int var_idx ) { return var_types->data.ptr[var_idx]; };$/;"	f	class:CvMLData	access:public	signature:( int var_idx )
CvMLData::get_var_types	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_var_types();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData::miss_ch	/usr/include/opencv2/ml/ml.hpp	/^    char miss_ch;$/;"	m	class:CvMLData	access:protected
CvMLData::missing	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* missing;$/;"	m	class:CvMLData	access:protected
CvMLData::mix	/usr/include/opencv2/ml/ml.hpp	/^    bool mix;$/;"	m	class:CvMLData	access:protected
CvMLData::mix_train_and_test_idx	/usr/include/opencv2/ml/ml.hpp	/^    void mix_train_and_test_idx();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData::read_csv	/usr/include/opencv2/ml/ml.hpp	/^    int read_csv(const char* filename);$/;"	p	class:CvMLData	access:public	signature:(const char* filename)
CvMLData::response_idx	/usr/include/opencv2/ml/ml.hpp	/^    int response_idx;$/;"	m	class:CvMLData	access:protected
CvMLData::response_out	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* response_out; \/\/ header$/;"	m	class:CvMLData	access:protected
CvMLData::rng	/usr/include/opencv2/ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvMLData	access:protected
CvMLData::sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    int* sample_idx; \/\/ data of train_sample_idx and test_sample_idx$/;"	m	class:CvMLData	access:protected
CvMLData::set_delimiter	/usr/include/opencv2/ml/ml.hpp	/^    void set_delimiter( char ch );$/;"	p	class:CvMLData	access:public	signature:( char ch )
CvMLData::set_miss_ch	/usr/include/opencv2/ml/ml.hpp	/^    void set_miss_ch( char ch );$/;"	p	class:CvMLData	access:public	signature:( char ch )
CvMLData::set_response_idx	/usr/include/opencv2/ml/ml.hpp	/^    void set_response_idx( int idx ); \/\/ old response become predictors, new response_idx = idx$/;"	p	class:CvMLData	access:public	signature:( int idx )
CvMLData::set_train_test_split	/usr/include/opencv2/ml/ml.hpp	/^    void set_train_test_split( const CvTrainTestSplit * spl);$/;"	p	class:CvMLData	access:public	signature:( const CvTrainTestSplit * spl)
CvMLData::set_var_types	/usr/include/opencv2/ml/ml.hpp	/^    void set_var_types( const char* str );  \/\/ str examples:$/;"	p	class:CvMLData	access:public	signature:( const char* str )
CvMLData::str_to_flt_elem	/usr/include/opencv2/ml/ml.hpp	/^    void str_to_flt_elem( const char* token, float& flt_elem, int& type);$/;"	p	class:CvMLData	access:protected	signature:( const char* token, float& flt_elem, int& type)
CvMLData::test_sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* test_sample_idx;$/;"	m	class:CvMLData	access:protected
CvMLData::total_class_count	/usr/include/opencv2/ml/ml.hpp	/^    int total_class_count;$/;"	m	class:CvMLData	access:protected
CvMLData::train_sample_count	/usr/include/opencv2/ml/ml.hpp	/^    int train_sample_count;$/;"	m	class:CvMLData	access:protected
CvMLData::train_sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* train_sample_idx;$/;"	m	class:CvMLData	access:protected
CvMLData::values	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* values;$/;"	m	class:CvMLData	access:protected
CvMLData::var_idx_mask	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_idx_mask;$/;"	m	class:CvMLData	access:protected
CvMLData::var_idx_out	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_idx_out; \/\/ mat$/;"	m	class:CvMLData	access:protected
CvMLData::var_types	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_types;$/;"	m	class:CvMLData	access:protected
CvMLData::var_types_out	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_types_out; \/\/ mat$/;"	m	class:CvMLData	access:protected
CvMLData::~CvMLData	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvMLData();$/;"	p	class:CvMLData	access:public	signature:()
CvMSERParams	/usr/include/opencv2/features2d/features2d.hpp	/^typedef struct CvMSERParams$/;"	s
CvMSERParams	/usr/include/opencv2/features2d/features2d.hpp	/^} CvMSERParams;$/;"	t	typeref:struct:CvMSERParams
CvMSERParams::areaThreshold	/usr/include/opencv2/features2d/features2d.hpp	/^    double areaThreshold;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::delta	/usr/include/opencv2/features2d/features2d.hpp	/^    int delta;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::edgeBlurSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int edgeBlurSize;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::maxArea	/usr/include/opencv2/features2d/features2d.hpp	/^    int maxArea;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::maxEvolution	/usr/include/opencv2/features2d/features2d.hpp	/^    int maxEvolution;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::maxVariation	/usr/include/opencv2/features2d/features2d.hpp	/^    float maxVariation;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::minArea	/usr/include/opencv2/features2d/features2d.hpp	/^    int minArea;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::minDiversity	/usr/include/opencv2/features2d/features2d.hpp	/^    float minDiversity;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::minMargin	/usr/include/opencv2/features2d/features2d.hpp	/^    double minMargin;$/;"	m	struct:CvMSERParams	access:public
CvMat	/usr/include/opencv2/core/types_c.h	/^CvMat;$/;"	t	typeref:struct:CvMat
CvMat	/usr/include/opencv2/core/types_c.h	/^typedef struct CvMat$/;"	s
CvMat::__anon94::db	/usr/include/opencv2/core/types_c.h	/^        double* db;$/;"	m	union:CvMat::__anon94	access:public
CvMat::__anon94::fl	/usr/include/opencv2/core/types_c.h	/^        float* fl;$/;"	m	union:CvMat::__anon94	access:public
CvMat::__anon94::i	/usr/include/opencv2/core/types_c.h	/^        int* i;$/;"	m	union:CvMat::__anon94	access:public
CvMat::__anon94::ptr	/usr/include/opencv2/core/types_c.h	/^        uchar* ptr;$/;"	m	union:CvMat::__anon94	access:public
CvMat::__anon94::s	/usr/include/opencv2/core/types_c.h	/^        short* s;$/;"	m	union:CvMat::__anon94	access:public
CvMat::__anon95::height	/usr/include/opencv2/core/types_c.h	/^        int height;$/;"	m	union:CvMat::__anon95	access:public
CvMat::__anon95::rows	/usr/include/opencv2/core/types_c.h	/^        int rows;$/;"	m	union:CvMat::__anon95	access:public
CvMat::__anon96::cols	/usr/include/opencv2/core/types_c.h	/^        int cols;$/;"	m	union:CvMat::__anon96	access:public
CvMat::__anon96::width	/usr/include/opencv2/core/types_c.h	/^        int width;$/;"	m	union:CvMat::__anon96	access:public
CvMat::cols	/usr/include/opencv2/core/types_c.h	/^    int cols;$/;"	m	struct:CvMat	access:public
CvMat::data	/usr/include/opencv2/core/types_c.h	/^    } data;$/;"	m	struct:CvMat	typeref:union:CvMat::__anon94	access:public
CvMat::hdr_refcount	/usr/include/opencv2/core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvMat	access:public
CvMat::refcount	/usr/include/opencv2/core/types_c.h	/^    int* refcount;$/;"	m	struct:CvMat	access:public
CvMat::rows	/usr/include/opencv2/core/types_c.h	/^    int rows;$/;"	m	struct:CvMat	access:public
CvMat::step	/usr/include/opencv2/core/types_c.h	/^    int step;$/;"	m	struct:CvMat	access:public
CvMat::type	/usr/include/opencv2/core/types_c.h	/^    int type;$/;"	m	struct:CvMat	access:public
CvMatArray	/usr/include/opencv2/legacy/compat.hpp	/^typedef CvMat CvMatArray;$/;"	t
CvMatND	/usr/include/opencv2/core/types_c.h	/^CvMatND;$/;"	t	typeref:struct:CvMatND
CvMatND	/usr/include/opencv2/core/types_c.h	/^typedef struct CvMatND$/;"	s
CvMatND::__anon97::db	/usr/include/opencv2/core/types_c.h	/^        double* db;$/;"	m	union:CvMatND::__anon97	access:public
CvMatND::__anon97::fl	/usr/include/opencv2/core/types_c.h	/^        float* fl;$/;"	m	union:CvMatND::__anon97	access:public
CvMatND::__anon97::i	/usr/include/opencv2/core/types_c.h	/^        int* i;$/;"	m	union:CvMatND::__anon97	access:public
CvMatND::__anon97::ptr	/usr/include/opencv2/core/types_c.h	/^        uchar* ptr;$/;"	m	union:CvMatND::__anon97	access:public
CvMatND::__anon97::s	/usr/include/opencv2/core/types_c.h	/^        short* s;$/;"	m	union:CvMatND::__anon97	access:public
CvMatND::__anon98::size	/usr/include/opencv2/core/types_c.h	/^        int size;$/;"	m	struct:CvMatND::__anon98	access:public
CvMatND::__anon98::step	/usr/include/opencv2/core/types_c.h	/^        int step;$/;"	m	struct:CvMatND::__anon98	access:public
CvMatND::data	/usr/include/opencv2/core/types_c.h	/^    } data;$/;"	m	struct:CvMatND	typeref:union:CvMatND::__anon97	access:public
CvMatND::dim	/usr/include/opencv2/core/types_c.h	/^    dim[CV_MAX_DIM];$/;"	m	struct:CvMatND	typeref:struct:CvMatND::__anon98	access:public
CvMatND::dims	/usr/include/opencv2/core/types_c.h	/^    int dims;$/;"	m	struct:CvMatND	access:public
CvMatND::hdr_refcount	/usr/include/opencv2/core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvMatND	access:public
CvMatND::refcount	/usr/include/opencv2/core/types_c.h	/^    int* refcount;$/;"	m	struct:CvMatND	access:public
CvMatND::type	/usr/include/opencv2/core/types_c.h	/^    int type;$/;"	m	struct:CvMatND	access:public
CvMatType	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvMatType;$/;"	t
CvMatr32f	/usr/include/opencv2/legacy/compat.hpp	/^typedef float*   CvMatr32f;$/;"	t
CvMatr64d	/usr/include/opencv2/legacy/compat.hpp	/^typedef double*  CvMatr64d;$/;"	t
CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( CvFileStorage* fs, const char* mapname, const char* matname ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* matname )
CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( CvFileStorage* fs, const char* seqname, int idx ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( CvMat* m )$/;"	f	class:CvMatrix	access:public	signature:( CvMat* m )
CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( const CvMatrix& m )$/;"	f	class:CvMatrix	access:public	signature:( const CvMatrix& m )
CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( const char* filename, const char* matname=0, int color=-1 ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( const char* filename, const char* matname=0, int color=-1 )
CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type )
CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, CvMat* hdr,$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type, CvMat* hdr, void* data=0, int step=CV_AUTOSTEP )
CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, CvMemStorage* storage, bool alloc_data=true );$/;"	p	class:CvMatrix	access:public	signature:( int rows, int cols, int type, CvMemStorage* storage, bool alloc_data=true )
CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, void* data, int step=CV_AUTOSTEP )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type, void* data, int step=CV_AUTOSTEP )
CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix() : matrix(0) {}$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^class CV_EXPORTS CvMatrix$/;"	c
CvMatrix3	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvMatrix3$/;"	s
CvMatrix3	/usr/include/opencv2/legacy/legacy.hpp	/^} CvMatrix3;    $/;"	t	typeref:struct:CvMatrix3
CvMatrix3::m	/usr/include/opencv2/legacy/legacy.hpp	/^    float m[3][3];$/;"	m	struct:CvMatrix3	access:public
CvMatrix::CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( CvFileStorage* fs, const char* mapname, const char* matname ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* matname )
CvMatrix::CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( CvFileStorage* fs, const char* seqname, int idx ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvMatrix::CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( CvMat* m )$/;"	f	class:CvMatrix	access:public	signature:( CvMat* m )
CvMatrix::CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( const CvMatrix& m )$/;"	f	class:CvMatrix	access:public	signature:( const CvMatrix& m )
CvMatrix::CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( const char* filename, const char* matname=0, int color=-1 ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( const char* filename, const char* matname=0, int color=-1 )
CvMatrix::CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type )
CvMatrix::CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, CvMat* hdr,$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type, CvMat* hdr, void* data=0, int step=CV_AUTOSTEP )
CvMatrix::CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, CvMemStorage* storage, bool alloc_data=true );$/;"	p	class:CvMatrix	access:public	signature:( int rows, int cols, int type, CvMemStorage* storage, bool alloc_data=true )
CvMatrix::CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, void* data, int step=CV_AUTOSTEP )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type, void* data, int step=CV_AUTOSTEP )
CvMatrix::CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix() : matrix(0) {}$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::addref	/usr/include/opencv2/legacy/legacy.hpp	/^    void addref() const$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::channels	/usr/include/opencv2/legacy/legacy.hpp	/^    int channels() const { return matrix ? CV_MAT_CN(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::clear	/usr/include/opencv2/legacy/legacy.hpp	/^    void clear()$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::clone	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix clone() { return CvMatrix(matrix ? cvCloneMat(matrix) : 0); }$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::cols	/usr/include/opencv2/legacy/legacy.hpp	/^    int cols() const { return matrix ? matrix->cols : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::create	/usr/include/opencv2/legacy/legacy.hpp	/^    void create( int rows, int cols, int type )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type )
CvMatrix::data	/usr/include/opencv2/legacy/legacy.hpp	/^    const uchar* data() const { return matrix ? matrix->data.ptr : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::data	/usr/include/opencv2/legacy/legacy.hpp	/^    uchar* data() { return matrix ? matrix->data.ptr : 0; }$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::depth	/usr/include/opencv2/legacy/legacy.hpp	/^    int depth() const { return matrix ? CV_MAT_DEPTH(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::is_valid	/usr/include/opencv2/legacy/legacy.hpp	/^    bool is_valid() { return matrix != 0; }$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::load	/usr/include/opencv2/legacy/legacy.hpp	/^    bool load( const char* filename, const char* matname=0, int color=-1 );$/;"	p	class:CvMatrix	access:public	signature:( const char* filename, const char* matname=0, int color=-1 )
CvMatrix::matrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat* matrix;$/;"	m	class:CvMatrix	access:protected
CvMatrix::operator =	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix& operator = (const CvMatrix& _m)$/;"	f	class:CvMatrix	access:public	signature:(const CvMatrix& _m)
CvMatrix::operator CvMat*	/usr/include/opencv2/legacy/legacy.hpp	/^    operator CvMat* () { return matrix; }$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::operator const CvMat*	/usr/include/opencv2/legacy/legacy.hpp	/^    operator const CvMat* () const { return matrix; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::pix_size	/usr/include/opencv2/legacy/legacy.hpp	/^    int pix_size() const { return matrix ? CV_ELEM_SIZE(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::read	/usr/include/opencv2/legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* mapname, const char* matname );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* matname )
CvMatrix::read	/usr/include/opencv2/legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* seqname, int idx );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvMatrix::release	/usr/include/opencv2/legacy/legacy.hpp	/^    void release()$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::row	/usr/include/opencv2/legacy/legacy.hpp	/^    const uchar* row(int i) const$/;"	f	class:CvMatrix	access:public	signature:(int i) const
CvMatrix::row	/usr/include/opencv2/legacy/legacy.hpp	/^    uchar* row(int i) { return !matrix ? 0 : matrix->data.ptr + i*matrix->step; }$/;"	f	class:CvMatrix	access:public	signature:(int i)
CvMatrix::rows	/usr/include/opencv2/legacy/legacy.hpp	/^    int rows() const { return matrix ? matrix->rows : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::save	/usr/include/opencv2/legacy/legacy.hpp	/^    void save( const char* filename, const char* matname, const int* params=0 );$/;"	p	class:CvMatrix	access:public	signature:( const char* filename, const char* matname, const int* params=0 )
CvMatrix::set	/usr/include/opencv2/legacy/legacy.hpp	/^    void set( CvMat* m, bool add_ref )$/;"	f	class:CvMatrix	access:public	signature:( CvMat* m, bool add_ref )
CvMatrix::set_data	/usr/include/opencv2/legacy/legacy.hpp	/^    void set_data( void* data, int step=CV_AUTOSTEP )$/;"	f	class:CvMatrix	access:public	signature:( void* data, int step=CV_AUTOSTEP )
CvMatrix::show	/usr/include/opencv2/legacy/legacy.hpp	/^    void show( const char* window_name );$/;"	p	class:CvMatrix	access:public	signature:( const char* window_name )
CvMatrix::size	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSize size() const$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::step	/usr/include/opencv2/legacy/legacy.hpp	/^    int step() const { return matrix ? matrix->step : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::type	/usr/include/opencv2/legacy/legacy.hpp	/^    int type() const { return matrix ? CV_MAT_TYPE(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::write	/usr/include/opencv2/legacy/legacy.hpp	/^    void write( CvFileStorage* fs, const char* matname );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* matname )
CvMatrix::~CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    ~CvMatrix()$/;"	f	class:CvMatrix	access:public	signature:()
CvMemBlock	/usr/include/opencv2/core/types_c.h	/^CvMemBlock;$/;"	t	typeref:struct:CvMemBlock
CvMemBlock	/usr/include/opencv2/core/types_c.h	/^typedef struct CvMemBlock$/;"	s
CvMemBlock::next	/usr/include/opencv2/core/types_c.h	/^    struct CvMemBlock*  next;$/;"	m	struct:CvMemBlock	typeref:struct:CvMemBlock::CvMemBlock	access:public
CvMemBlock::prev	/usr/include/opencv2/core/types_c.h	/^    struct CvMemBlock*  prev;$/;"	m	struct:CvMemBlock	typeref:struct:CvMemBlock::CvMemBlock	access:public
CvMemStorage	/usr/include/opencv2/core/types_c.h	/^CvMemStorage;$/;"	t	typeref:struct:CvMemStorage
CvMemStorage	/usr/include/opencv2/core/types_c.h	/^typedef struct CvMemStorage$/;"	s
CvMemStorage::block_size	/usr/include/opencv2/core/types_c.h	/^    int block_size;               \/* Block size.                              *\/$/;"	m	struct:CvMemStorage	access:public
CvMemStorage::bottom	/usr/include/opencv2/core/types_c.h	/^    CvMemBlock* bottom;           \/* First allocated block.                   *\/$/;"	m	struct:CvMemStorage	access:public
CvMemStorage::free_space	/usr/include/opencv2/core/types_c.h	/^    int free_space;               \/* Remaining free space in current block.   *\/$/;"	m	struct:CvMemStorage	access:public
CvMemStorage::parent	/usr/include/opencv2/core/types_c.h	/^    struct  CvMemStorage* parent; \/* We get new blocks from parent as needed. *\/$/;"	m	struct:CvMemStorage	typeref:struct:CvMemStorage::CvMemStorage	access:public
CvMemStorage::signature	/usr/include/opencv2/core/types_c.h	/^    int signature;$/;"	m	struct:CvMemStorage	access:public
CvMemStorage::top	/usr/include/opencv2/core/types_c.h	/^    CvMemBlock* top;              \/* Current memory block - top of the stack. *\/$/;"	m	struct:CvMemStorage	access:public
CvMemStoragePos	/usr/include/opencv2/core/types_c.h	/^CvMemStoragePos;$/;"	t	typeref:struct:CvMemStoragePos
CvMemStoragePos	/usr/include/opencv2/core/types_c.h	/^typedef struct CvMemStoragePos$/;"	s
CvMemStoragePos::free_space	/usr/include/opencv2/core/types_c.h	/^    int free_space;$/;"	m	struct:CvMemStoragePos	access:public
CvMemStoragePos::top	/usr/include/opencv2/core/types_c.h	/^    CvMemBlock* top;$/;"	m	struct:CvMemStoragePos	access:public
CvModule	/usr/include/opencv2/core/core_c.h	/^    CvModule( CvModuleInfo* _info );$/;"	p	struct:CvModule	access:public	signature:( CvModuleInfo* _info )
CvModule	/usr/include/opencv2/core/core_c.h	/^struct CV_EXPORTS CvModule$/;"	s
CvModule::CvModule	/usr/include/opencv2/core/core_c.h	/^    CvModule( CvModuleInfo* _info );$/;"	p	struct:CvModule	access:public	signature:( CvModuleInfo* _info )
CvModule::first	/usr/include/opencv2/core/core_c.h	/^    static CvModuleInfo* first;$/;"	m	struct:CvModule	access:public
CvModule::info	/usr/include/opencv2/core/core_c.h	/^    CvModuleInfo* info;$/;"	m	struct:CvModule	access:public
CvModule::last	/usr/include/opencv2/core/core_c.h	/^    static CvModuleInfo* last;$/;"	m	struct:CvModule	access:public
CvModule::~CvModule	/usr/include/opencv2/core/core_c.h	/^    ~CvModule();$/;"	p	struct:CvModule	access:public	signature:()
CvModuleInfo	/usr/include/opencv2/core/types_c.h	/^CvModuleInfo;$/;"	t	typeref:struct:CvModuleInfo
CvModuleInfo	/usr/include/opencv2/core/types_c.h	/^typedef struct CvModuleInfo$/;"	s
CvModuleInfo::func_tab	/usr/include/opencv2/core/types_c.h	/^    CvPluginFuncInfo* func_tab;$/;"	m	struct:CvModuleInfo	access:public
CvModuleInfo::name	/usr/include/opencv2/core/types_c.h	/^    const char* name;$/;"	m	struct:CvModuleInfo	access:public
CvModuleInfo::next	/usr/include/opencv2/core/types_c.h	/^    struct CvModuleInfo* next;$/;"	m	struct:CvModuleInfo	typeref:struct:CvModuleInfo::CvModuleInfo	access:public
CvModuleInfo::version	/usr/include/opencv2/core/types_c.h	/^    const char* version;$/;"	m	struct:CvModuleInfo	access:public
CvMoments	/usr/include/opencv2/imgproc/types_c.h	/^CvMoments;$/;"	t	typeref:struct:CvMoments
CvMoments	/usr/include/opencv2/imgproc/types_c.h	/^typedef struct CvMoments$/;"	s
CvMoments::inv_sqrt_m00	/usr/include/opencv2/imgproc/types_c.h	/^    double  inv_sqrt_m00; \/* m00 != 0 ? 1\/sqrt(m00) : 0 *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m00	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m01	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m02	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m03	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m10	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m11	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m12	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m20	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m21	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m30	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu02	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu03	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu11	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu12	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu20	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu21	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu30	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMorphOp	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvMorphOp;$/;"	t
CvMouseCallback	/usr/include/opencv2/highgui/highgui_c.h	/^typedef void (CV_CDECL *CvMouseCallback )(int event, int x, int y, int flags, void* param);$/;"	t
CvNArrayIterator	/usr/include/opencv2/core/core_c.h	/^CvNArrayIterator;$/;"	t	typeref:struct:CvNArrayIterator
CvNArrayIterator	/usr/include/opencv2/core/core_c.h	/^typedef struct CvNArrayIterator$/;"	s
CvNArrayIterator::count	/usr/include/opencv2/core/core_c.h	/^    int count; \/* number of arrays *\/$/;"	m	struct:CvNArrayIterator	access:public
CvNArrayIterator::dims	/usr/include/opencv2/core/core_c.h	/^    int dims; \/* number of dimensions to iterate *\/$/;"	m	struct:CvNArrayIterator	access:public
CvNArrayIterator::hdr	/usr/include/opencv2/core/core_c.h	/^    CvMatND* hdr[CV_MAX_ARR]; \/* pointers to the headers of the$/;"	m	struct:CvNArrayIterator	access:public
CvNArrayIterator::ptr	/usr/include/opencv2/core/core_c.h	/^    uchar* ptr[CV_MAX_ARR]; \/* pointers to the array slices *\/$/;"	m	struct:CvNArrayIterator	access:public
CvNArrayIterator::size	/usr/include/opencv2/core/core_c.h	/^    CvSize size; \/* maximal common linear size: { width = size, height = 1 } *\/$/;"	m	struct:CvNArrayIterator	access:public
CvNArrayIterator::stack	/usr/include/opencv2/core/core_c.h	/^    int stack[CV_MAX_DIM]; \/* for internal use *\/$/;"	m	struct:CvNArrayIterator	access:public
CvNextEdgeType	/usr/include/opencv2/imgproc/types_c.h	/^CvNextEdgeType;$/;"	t	typeref:enum:CvNextEdgeType
CvNextEdgeType	/usr/include/opencv2/imgproc/types_c.h	/^typedef enum CvNextEdgeType$/;"	g
CvNormalBayesClassifier	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvNormalBayesClassifier( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat() )
CvNormalBayesClassifier	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvNormalBayesClassifier();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
CvNormalBayesClassifier	/usr/include/opencv2/ml/ml.hpp	/^    CvNormalBayesClassifier( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0 )
CvNormalBayesClassifier	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS_W CvNormalBayesClassifier : public CvStatModel$/;"	c	inherits:CvStatModel
CvNormalBayesClassifier::CvNormalBayesClassifier	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvNormalBayesClassifier( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat() )
CvNormalBayesClassifier::CvNormalBayesClassifier	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvNormalBayesClassifier();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
CvNormalBayesClassifier::CvNormalBayesClassifier	/usr/include/opencv2/ml/ml.hpp	/^    CvNormalBayesClassifier( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0 )
CvNormalBayesClassifier::avg	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** avg;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::c	/usr/include/opencv2/ml/ml.hpp	/^    CvMat*  c;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
CvNormalBayesClassifier::cls_labels	/usr/include/opencv2/ml/ml.hpp	/^    CvMat*  cls_labels;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::count	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** count;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::cov_rotate_mats	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** cov_rotate_mats;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::inv_eigen_values	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** inv_eigen_values;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& samples, CV_OUT cv::Mat* results=0 ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& samples, CV_OUT cv::Mat* results=0 ) const
CvNormalBayesClassifier::predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* samples, CV_OUT CvMat* results=0 ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* samples, CV_OUT CvMat* results=0 ) const
CvNormalBayesClassifier::productsum	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** productsum;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
CvNormalBayesClassifier::sum	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** sum;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx = cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), bool update=false )
CvNormalBayesClassifier::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx = 0, const CvMat* sampleIdx=0, bool update=false )
CvNormalBayesClassifier::var_all	/usr/include/opencv2/ml/ml.hpp	/^    int     var_count, var_all;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::var_count	/usr/include/opencv2/ml/ml.hpp	/^    int     var_count, var_all;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::var_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat*  var_idx;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( CvFileStorage* storage, const char* name ) const
CvNormalBayesClassifier::~CvNormalBayesClassifier	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvNormalBayesClassifier();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
CvObjectDetection	/usr/include/opencv2/objdetect/objdetect.hpp	/^typedef struct CvObjectDetection$/;"	s
CvObjectDetection	/usr/include/opencv2/objdetect/objdetect.hpp	/^} CvObjectDetection;$/;"	t	typeref:struct:CvObjectDetection
CvObjectDetection::rect	/usr/include/opencv2/objdetect/objdetect.hpp	/^	CvRect rect;$/;"	m	struct:CvObjectDetection	access:public
CvObjectDetection::score	/usr/include/opencv2/objdetect/objdetect.hpp	/^	float score;$/;"	m	struct:CvObjectDetection	access:public
CvObjectDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvObjectDetector( const char* \/*detector_file_name*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const char* = 0 )
CvObjectDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvObjectDetector$/;"	c
CvObjectDetector::CvObjectDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvObjectDetector( const char* \/*detector_file_name*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const char* = 0 )
CvObjectDetector::Detect	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void Detect( const CvArr* \/*img*\/, \/* out *\/ CvBlobSeq* \/*detected_blob_seq*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const CvArr* , CvBlobSeq* = 0 )
CvObjectDetector::GetMaxBorderSize	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int GetMaxBorderSize() const;$/;"	p	class:CvObjectDetector	access:public	signature:() const
CvObjectDetector::GetMinWindowSize	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvSize GetMinWindowSize() const;$/;"	p	class:CvObjectDetector	access:public	signature:() const
CvObjectDetector::Load	/usr/include/opencv2/legacy/blobtrack.hpp	/^    bool Load( const char* \/*detector_file_name*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const char* = 0 )
CvObjectDetector::impl	/usr/include/opencv2/legacy/blobtrack.hpp	/^    class CvObjectDetectorImpl* impl;$/;"	m	class:CvObjectDetector	typeref:class:CvObjectDetector::CvObjectDetectorImpl	access:protected
CvObjectDetector::~CvObjectDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^    ~CvObjectDetector();$/;"	p	class:CvObjectDetector	access:public	signature:()
CvOpenGLCallback	/usr/include/opencv2/highgui/highgui_c.h	/^typedef void (CV_CDECL *CvOpenGLCallback)(void* userdata);$/;"	t
CvPOSITObject	/usr/include/opencv2/calib3d/calib3d.hpp	/^typedef struct CvPOSITObject CvPOSITObject;$/;"	t	typeref:struct:CvPOSITObject
CvPair16u32s	/usr/include/opencv2/ml/ml.hpp	/^struct CvPair16u32s$/;"	s
CvPair16u32s::i	/usr/include/opencv2/ml/ml.hpp	/^    int* i;$/;"	m	struct:CvPair16u32s	access:public
CvPair16u32s::u	/usr/include/opencv2/ml/ml.hpp	/^    unsigned short* u;$/;"	m	struct:CvPair16u32s	access:public
CvParamGrid	/usr/include/opencv2/ml/ml.hpp	/^    CvParamGrid( double _min_val, double _max_val, double log_step )$/;"	f	struct:CvParamGrid	access:public	signature:( double _min_val, double _max_val, double log_step )
CvParamGrid	/usr/include/opencv2/ml/ml.hpp	/^    CvParamGrid()$/;"	f	struct:CvParamGrid	access:public	signature:()
CvParamGrid	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvParamGrid$/;"	s
CvParamGrid::CvParamGrid	/usr/include/opencv2/ml/ml.hpp	/^    CvParamGrid( double _min_val, double _max_val, double log_step )$/;"	f	struct:CvParamGrid	access:public	signature:( double _min_val, double _max_val, double log_step )
CvParamGrid::CvParamGrid	/usr/include/opencv2/ml/ml.hpp	/^    CvParamGrid()$/;"	f	struct:CvParamGrid	access:public	signature:()
CvParamGrid::SVM_C	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
CvParamGrid::SVM_COEF	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
CvParamGrid::SVM_DEGREE	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
CvParamGrid::SVM_GAMMA	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
CvParamGrid::SVM_NU	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
CvParamGrid::SVM_P	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
CvParamGrid::check	/usr/include/opencv2/ml/ml.hpp	/^    bool check() const;$/;"	p	struct:CvParamGrid	access:public	signature:() const
CvParamGrid::max_val	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double max_val;$/;"	m	struct:CvParamGrid	access:public
CvParamGrid::min_val	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double min_val;$/;"	m	struct:CvParamGrid	access:public
CvParamGrid::step	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double step;$/;"	m	struct:CvParamGrid	access:public
CvPixelPosition32f	/usr/include/opencv2/legacy/compat.hpp	/^} CvPixelPosition32f;$/;"	t	typeref:struct:_CvPixelPosition32f
CvPixelPosition8s	/usr/include/opencv2/legacy/compat.hpp	/^} CvPixelPosition8s;$/;"	t	typeref:struct:_CvPixelPosition8s
CvPixelPosition8u	/usr/include/opencv2/legacy/compat.hpp	/^} CvPixelPosition8u;$/;"	t	typeref:struct:_CvPixelPosition8u
CvPluginFuncInfo	/usr/include/opencv2/core/types_c.h	/^CvPluginFuncInfo;$/;"	t	typeref:struct:CvPluginFuncInfo
CvPluginFuncInfo	/usr/include/opencv2/core/types_c.h	/^typedef struct CvPluginFuncInfo$/;"	s
CvPluginFuncInfo::default_func_addr	/usr/include/opencv2/core/types_c.h	/^    void* default_func_addr;$/;"	m	struct:CvPluginFuncInfo	access:public
CvPluginFuncInfo::func_addr	/usr/include/opencv2/core/types_c.h	/^    void** func_addr;$/;"	m	struct:CvPluginFuncInfo	access:public
CvPluginFuncInfo::func_names	/usr/include/opencv2/core/types_c.h	/^    const char* func_names;$/;"	m	struct:CvPluginFuncInfo	access:public
CvPluginFuncInfo::loaded_from	/usr/include/opencv2/core/types_c.h	/^    int loaded_from;$/;"	m	struct:CvPluginFuncInfo	access:public
CvPluginFuncInfo::search_modules	/usr/include/opencv2/core/types_c.h	/^    int search_modules;$/;"	m	struct:CvPluginFuncInfo	access:public
CvPoint	/usr/include/opencv2/core/types_c.h	/^CvPoint;$/;"	t	typeref:struct:CvPoint
CvPoint	/usr/include/opencv2/core/types_c.h	/^typedef struct CvPoint$/;"	s
CvPoint2D32f	/usr/include/opencv2/core/types_c.h	/^CvPoint2D32f;$/;"	t	typeref:struct:CvPoint2D32f
CvPoint2D32f	/usr/include/opencv2/core/types_c.h	/^typedef struct CvPoint2D32f$/;"	s
CvPoint2D32f::x	/usr/include/opencv2/core/types_c.h	/^    float x;$/;"	m	struct:CvPoint2D32f	access:public
CvPoint2D32f::y	/usr/include/opencv2/core/types_c.h	/^    float y;$/;"	m	struct:CvPoint2D32f	access:public
CvPoint2D64d	/usr/include/opencv2/legacy/compat.hpp	/^typedef CvPoint2D64f CvPoint2D64d;$/;"	t
CvPoint2D64f	/usr/include/opencv2/core/types_c.h	/^CvPoint2D64f;$/;"	t	typeref:struct:CvPoint2D64f
CvPoint2D64f	/usr/include/opencv2/core/types_c.h	/^typedef struct CvPoint2D64f$/;"	s
CvPoint2D64f::x	/usr/include/opencv2/core/types_c.h	/^    double x;$/;"	m	struct:CvPoint2D64f	access:public
CvPoint2D64f::y	/usr/include/opencv2/core/types_c.h	/^    double y;$/;"	m	struct:CvPoint2D64f	access:public
CvPoint2DSeq	/usr/include/opencv2/core/types_c.h	/^typedef CvContour CvPoint2DSeq;$/;"	t
CvPoint3D32f	/usr/include/opencv2/core/types_c.h	/^CvPoint3D32f;$/;"	t	typeref:struct:CvPoint3D32f
CvPoint3D32f	/usr/include/opencv2/core/types_c.h	/^typedef struct CvPoint3D32f$/;"	s
CvPoint3D32f::x	/usr/include/opencv2/core/types_c.h	/^    float x;$/;"	m	struct:CvPoint3D32f	access:public
CvPoint3D32f::y	/usr/include/opencv2/core/types_c.h	/^    float y;$/;"	m	struct:CvPoint3D32f	access:public
CvPoint3D32f::z	/usr/include/opencv2/core/types_c.h	/^    float z;$/;"	m	struct:CvPoint3D32f	access:public
CvPoint3D64d	/usr/include/opencv2/legacy/compat.hpp	/^typedef CvPoint3D64f CvPoint3D64d;$/;"	t
CvPoint3D64f	/usr/include/opencv2/core/types_c.h	/^CvPoint3D64f;$/;"	t	typeref:struct:CvPoint3D64f
CvPoint3D64f	/usr/include/opencv2/core/types_c.h	/^typedef struct CvPoint3D64f$/;"	s
CvPoint3D64f::x	/usr/include/opencv2/core/types_c.h	/^    double x;$/;"	m	struct:CvPoint3D64f	access:public
CvPoint3D64f::y	/usr/include/opencv2/core/types_c.h	/^    double y;$/;"	m	struct:CvPoint3D64f	access:public
CvPoint3D64f::z	/usr/include/opencv2/core/types_c.h	/^    double z;$/;"	m	struct:CvPoint3D64f	access:public
CvPoint::x	/usr/include/opencv2/core/types_c.h	/^    int x;$/;"	m	struct:CvPoint	access:public
CvPoint::y	/usr/include/opencv2/core/types_c.h	/^    int y;$/;"	m	struct:CvPoint	access:public
CvPolyApproxMethod	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvPolyApproxMethod;$/;"	t
CvProb	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvProb$/;"	c
CvProb::AddFeature	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void AddFeature(float W, int* comps, int x =0, int y = 0) = 0;$/;"	p	class:CvProb	access:public	signature:(float W, int* comps, int x =0, int y = 0)
CvProb::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Release() = 0;$/;"	p	class:CvProb	access:public	signature:()
CvProb::Scale	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Scale(float factor = 0, int x = -1, int y = -1) = 0;$/;"	p	class:CvProb	access:public	signature:(float factor = 0, int x = -1, int y = -1)
CvProb::Value	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual double Value(int* \/*comp*\/, int \/*x*\/ = 0, int \/*y*\/ = 0){return -1;};$/;"	f	class:CvProb	access:public	signature:(int* , int = 0, int = 0)
CvProb::~CvProb	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual ~CvProb() {};$/;"	f	class:CvProb	access:public	signature:()
CvQuadEdge2D	/usr/include/opencv2/imgproc/types_c.h	/^CvQuadEdge2D;$/;"	t	typeref:struct:CvQuadEdge2D
CvQuadEdge2D	/usr/include/opencv2/imgproc/types_c.h	/^typedef struct CvQuadEdge2D$/;"	s
CvRNG	/usr/include/opencv2/core/types_c.h	/^typedef uint64 CvRNG;$/;"	t
CvRTParams	/usr/include/opencv2/ml/ml.hpp	/^    CvRTParams( int _max_depth, int _min_sample_count,$/;"	f	struct:CvRTParams	access:public	signature:( int _max_depth, int _min_sample_count, float _regression_accuracy, bool _use_surrogates, int _max_categories, const float* _priors, bool _calc_var_importance, int _nactive_vars, int max_num_of_trees_in_the_forest, float forest_accuracy, int termcrit_type )
CvRTParams	/usr/include/opencv2/ml/ml.hpp	/^    CvRTParams() : CvDTreeParams( 5, 10, 0, false, 10, 0, false, false, 0 ),$/;"	f	struct:CvRTParams	access:public	signature:()
CvRTParams	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvRTParams : public CvDTreeParams$/;"	s	inherits:CvDTreeParams
CvRTParams::CvRTParams	/usr/include/opencv2/ml/ml.hpp	/^    CvRTParams( int _max_depth, int _min_sample_count,$/;"	f	struct:CvRTParams	access:public	signature:( int _max_depth, int _min_sample_count, float _regression_accuracy, bool _use_surrogates, int _max_categories, const float* _priors, bool _calc_var_importance, int _nactive_vars, int max_num_of_trees_in_the_forest, float forest_accuracy, int termcrit_type )
CvRTParams::CvRTParams	/usr/include/opencv2/ml/ml.hpp	/^    CvRTParams() : CvDTreeParams( 5, 10, 0, false, 10, 0, false, false, 0 ),$/;"	f	struct:CvRTParams	access:public	signature:()
CvRTParams::calc_var_importance	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW bool calc_var_importance; \/\/ true <=> RF processes variable importance$/;"	m	struct:CvRTParams	access:public
CvRTParams::nactive_vars	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int nactive_vars;$/;"	m	struct:CvRTParams	access:public
CvRTParams::term_crit	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvRTParams	access:public
CvRTrees	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvRTrees();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS_W CvRTrees : public CvStatModel$/;"	c	inherits:CvStatModel
CvRTrees::CvRTrees	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvRTrees();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::active_var_mask	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* active_var_mask;$/;"	m	class:CvRTrees	access:protected
CvRTrees::calc_error	/usr/include/opencv2/ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type , std::vector<float> *resp = 0 ); \/\/ type in {CV_TRAIN_ERROR, CV_TEST_ERROR}$/;"	p	class:CvRTrees	access:public	signature:( CvMLData* _data, int type , std::vector<float> *resp = 0 )
CvRTrees::clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::data	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvRTrees	access:protected
CvRTrees::getVarImportance	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual cv::Mat getVarImportance();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::get_active_var_mask	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* get_active_var_mask();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::get_proximity	/usr/include/opencv2/ml/ml.hpp	/^    virtual float get_proximity( const CvMat* sample1, const CvMat* sample2,$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample1, const CvMat* sample2, const CvMat* missing1 = 0, const CvMat* missing2 = 0 ) const
CvRTrees::get_rng	/usr/include/opencv2/ml/ml.hpp	/^    CvRNG* get_rng();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::get_train_error	/usr/include/opencv2/ml/ml.hpp	/^    virtual float get_train_error();    $/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::get_tree	/usr/include/opencv2/ml/ml.hpp	/^    CvForestTree* get_tree(int i) const;$/;"	p	class:CvRTrees	access:public	signature:(int i) const
CvRTrees::get_tree_count	/usr/include/opencv2/ml/ml.hpp	/^    int get_tree_count() const;$/;"	p	class:CvRTrees	access:public	signature:() const
CvRTrees::get_var_importance	/usr/include/opencv2/ml/ml.hpp	/^    virtual const CvMat* get_var_importance();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::grow_forest	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool grow_forest( const CvTermCriteria term_crit );$/;"	p	class:CvRTrees	access:protected	signature:( const CvTermCriteria term_crit )
CvRTrees::nclasses	/usr/include/opencv2/ml/ml.hpp	/^    int nclasses;$/;"	m	class:CvRTrees	access:protected
CvRTrees::nsamples	/usr/include/opencv2/ml/ml.hpp	/^    int nsamples;$/;"	m	class:CvRTrees	access:protected
CvRTrees::ntrees	/usr/include/opencv2/ml/ml.hpp	/^    int ntrees;$/;"	m	class:CvRTrees	access:protected
CvRTrees::oob_error	/usr/include/opencv2/ml/ml.hpp	/^    double oob_error;$/;"	m	class:CvRTrees	access:protected
CvRTrees::predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const;$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const
CvRTrees::predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing = 0 ) const;$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample, const CvMat* missing = 0 ) const
CvRTrees::predict_prob	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict_prob( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const;$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const
CvRTrees::predict_prob	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict_prob( const CvMat* sample, const CvMat* missing = 0 ) const;$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample, const CvMat* missing = 0 ) const
CvRTrees::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvRTrees	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvRTrees::rng	/usr/include/opencv2/ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvRTrees	access:protected
CvRTrees::train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvRTParams params=CvRTParams() )
CvRTrees::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvMLData* data, CvRTParams params=CvRTParams() );$/;"	p	class:CvRTrees	access:public	signature:( CvMLData* data, CvRTParams params=CvRTParams() )
CvRTrees::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvRTParams params=CvRTParams() )
CvRTrees::trees	/usr/include/opencv2/ml/ml.hpp	/^    CvForestTree** trees;$/;"	m	class:CvRTrees	access:protected
CvRTrees::var_importance	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_importance;$/;"	m	class:CvRTrees	access:protected
CvRTrees::write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvRTrees	access:public	signature:( CvFileStorage* fs, const char* name ) const
CvRTrees::~CvRTrees	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvRTrees();$/;"	p	class:CvRTrees	access:public	signature:()
CvRandState	/usr/include/opencv2/legacy/compat.hpp	/^typedef struct CvRandState$/;"	s
CvRandState	/usr/include/opencv2/legacy/compat.hpp	/^} CvRandState;$/;"	t	typeref:struct:CvRandState
CvRandState::disttype	/usr/include/opencv2/legacy/compat.hpp	/^    int       disttype; \/* distribution type *\/$/;"	m	struct:CvRandState	access:public
CvRandState::param	/usr/include/opencv2/legacy/compat.hpp	/^    CvScalar  param[2]; \/* parameters of RNG *\/$/;"	m	struct:CvRandState	access:public
CvRandState::state	/usr/include/opencv2/legacy/compat.hpp	/^    CvRNG     state;    \/* RNG state (the current seed and carry)*\/$/;"	m	struct:CvRandState	access:public
CvReadFunc	/usr/include/opencv2/core/types_c.h	/^typedef void* (CV_CDECL *CvReadFunc)( CvFileStorage* storage, CvFileNode* node );$/;"	t
CvRect	/usr/include/opencv2/core/types_c.h	/^CvRect;$/;"	t	typeref:struct:CvRect
CvRect	/usr/include/opencv2/core/types_c.h	/^typedef struct CvRect$/;"	s
CvRect::height	/usr/include/opencv2/core/types_c.h	/^    int height;$/;"	m	struct:CvRect	access:public
CvRect::width	/usr/include/opencv2/core/types_c.h	/^    int width;$/;"	m	struct:CvRect	access:public
CvRect::x	/usr/include/opencv2/core/types_c.h	/^    int x;$/;"	m	struct:CvRect	access:public
CvRect::y	/usr/include/opencv2/core/types_c.h	/^    int y;$/;"	m	struct:CvRect	access:public
CvReleaseBGStatModel	/usr/include/opencv2/video/background_segm.hpp	/^typedef void (CV_CDECL * CvReleaseBGStatModel)( struct CvBGStatModel** bg_model );$/;"	t
CvReleaseFunc	/usr/include/opencv2/core/types_c.h	/^typedef void (CV_CDECL *CvReleaseFunc)( void** struct_dblptr );$/;"	t
CvRodriguesType	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvRodriguesType;$/;"	t
CvSURFParams	/usr/include/opencv2/features2d/features2d.hpp	/^typedef struct CvSURFParams$/;"	s
CvSURFParams	/usr/include/opencv2/features2d/features2d.hpp	/^} CvSURFParams;$/;"	t	typeref:struct:CvSURFParams
CvSURFParams::extended	/usr/include/opencv2/features2d/features2d.hpp	/^    int extended;$/;"	m	struct:CvSURFParams	access:public
CvSURFParams::hessianThreshold	/usr/include/opencv2/features2d/features2d.hpp	/^    double hessianThreshold;$/;"	m	struct:CvSURFParams	access:public
CvSURFParams::nOctaveLayers	/usr/include/opencv2/features2d/features2d.hpp	/^    int nOctaveLayers;$/;"	m	struct:CvSURFParams	access:public
CvSURFParams::nOctaves	/usr/include/opencv2/features2d/features2d.hpp	/^    int nOctaves;$/;"	m	struct:CvSURFParams	access:public
CvSURFPoint	/usr/include/opencv2/features2d/features2d.hpp	/^typedef struct CvSURFPoint$/;"	s
CvSURFPoint	/usr/include/opencv2/features2d/features2d.hpp	/^} CvSURFPoint;$/;"	t	typeref:struct:CvSURFPoint
CvSURFPoint::dir	/usr/include/opencv2/features2d/features2d.hpp	/^    float dir;$/;"	m	struct:CvSURFPoint	access:public
CvSURFPoint::hessian	/usr/include/opencv2/features2d/features2d.hpp	/^    float hessian;$/;"	m	struct:CvSURFPoint	access:public
CvSURFPoint::laplacian	/usr/include/opencv2/features2d/features2d.hpp	/^    int laplacian;$/;"	m	struct:CvSURFPoint	access:public
CvSURFPoint::pt	/usr/include/opencv2/features2d/features2d.hpp	/^    CvPoint2D32f pt;$/;"	m	struct:CvSURFPoint	access:public
CvSURFPoint::size	/usr/include/opencv2/features2d/features2d.hpp	/^    int size;$/;"	m	struct:CvSURFPoint	access:public
CvSVM	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvSVM( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), CvSVMParams params=CvSVMParams() )
CvSVM	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvSVM();$/;"	p	class:CvSVM	access:public	signature:()
CvSVM	/usr/include/opencv2/ml/ml.hpp	/^    CvSVM( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, CvSVMParams params=CvSVMParams() )
CvSVM	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS_W CvSVM : public CvStatModel$/;"	c	inherits:CvStatModel
CvSVM::C	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
CvSVM::COEF	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
CvSVM::C_SVC	/usr/include/opencv2/ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon78
CvSVM::CvSVM	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvSVM( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), CvSVMParams params=CvSVMParams() )
CvSVM::CvSVM	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP CvSVM();$/;"	p	class:CvSVM	access:public	signature:()
CvSVM::CvSVM	/usr/include/opencv2/ml/ml.hpp	/^    CvSVM( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, CvSVMParams params=CvSVMParams() )
CvSVM::DEGREE	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
CvSVM::EPS_SVR	/usr/include/opencv2/ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon78
CvSVM::GAMMA	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
CvSVM::LINEAR	/usr/include/opencv2/ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon79
CvSVM::NU	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
CvSVM::NU_SVC	/usr/include/opencv2/ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon78
CvSVM::NU_SVR	/usr/include/opencv2/ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon78
CvSVM::ONE_CLASS	/usr/include/opencv2/ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon78
CvSVM::P	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
CvSVM::POLY	/usr/include/opencv2/ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon79
CvSVM::RBF	/usr/include/opencv2/ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon79
CvSVM::SIGMOID	/usr/include/opencv2/ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon79
CvSVM::class_labels	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* class_labels;$/;"	m	class:CvSVM	access:protected
CvSVM::class_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* class_weights;$/;"	m	class:CvSVM	access:protected
CvSVM::clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvSVM	access:public	signature:()
CvSVM::create_kernel	/usr/include/opencv2/ml/ml.hpp	/^    virtual void create_kernel();$/;"	p	class:CvSVM	access:protected	signature:()
CvSVM::create_solver	/usr/include/opencv2/ml/ml.hpp	/^    virtual void create_solver();$/;"	p	class:CvSVM	access:protected	signature:()
CvSVM::decision_func	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMDecisionFunc* decision_func;$/;"	m	class:CvSVM	access:protected
CvSVM::do_train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool do_train( int svm_type, int sample_count, int var_count, const float** samples,$/;"	p	class:CvSVM	access:protected	signature:( int svm_type, int sample_count, int var_count, const float** samples, const CvMat* responses, CvMemStorage* _storage, double* alpha )
CvSVM::get_default_grid	/usr/include/opencv2/ml/ml.hpp	/^    static CvParamGrid get_default_grid( int param_id );$/;"	p	class:CvSVM	access:public	signature:( int param_id )
CvSVM::get_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvSVMParams get_params() const { return params; };$/;"	f	class:CvSVM	access:public	signature:() const
CvSVM::get_support_vector	/usr/include/opencv2/ml/ml.hpp	/^    virtual const float* get_support_vector(int i) const;$/;"	p	class:CvSVM	access:public	signature:(int i) const
CvSVM::get_support_vector_count	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual int get_support_vector_count() const;$/;"	p	class:CvSVM	access:public	signature:() const
CvSVM::get_var_count	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP int get_var_count() const { return var_idx ? var_idx->cols : var_all; }$/;"	f	class:CvSVM	access:public	signature:() const
CvSVM::kernel	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernel* kernel;$/;"	m	class:CvSVM	access:protected
CvSVM::params	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMParams params;$/;"	m	class:CvSVM	access:protected
CvSVM::predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, bool returnDFVal=false ) const;    $/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& sample, bool returnDFVal=false ) const
CvSVM::predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* sample, bool returnDFVal=false ) const;$/;"	p	class:CvSVM	access:public	signature:( const CvMat* sample, bool returnDFVal=false ) const
CvSVM::predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const float* row_sample, int row_len, bool returnDFVal=false ) const;$/;"	p	class:CvSVM	access:protected	signature:( const float* row_sample, int row_len, bool returnDFVal=false ) const
CvSVM::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvSVM	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
CvSVM::read_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvSVM	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
CvSVM::set_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool set_params( const CvSVMParams& params );$/;"	p	class:CvSVM	access:protected	signature:( const CvSVMParams& params )
CvSVM::solver	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMSolver* solver;$/;"	m	class:CvSVM	access:protected
CvSVM::storage	/usr/include/opencv2/ml/ml.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvSVM	access:protected
CvSVM::sv	/usr/include/opencv2/ml/ml.hpp	/^    float** sv;$/;"	m	class:CvSVM	access:protected
CvSVM::sv_total	/usr/include/opencv2/ml/ml.hpp	/^    int sv_total;$/;"	m	class:CvSVM	access:protected
CvSVM::train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), CvSVMParams params=CvSVMParams() )
CvSVM::train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, CvSVMParams params=CvSVMParams() )
CvSVM::train1	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train1( int sample_count, int var_count, const float** samples,$/;"	p	class:CvSVM	access:protected	signature:( int sample_count, int var_count, const float** samples, const void* responses, double Cp, double Cn, CvMemStorage* _storage, double* alpha, double& rho )
CvSVM::train_auto	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train_auto( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx, const cv::Mat& sampleIdx, CvSVMParams params, int k_fold = 10, CvParamGrid Cgrid = CvSVM::get_default_grid(CvSVM::C), CvParamGrid gammaGrid = CvSVM::get_default_grid(CvSVM::GAMMA), CvParamGrid pGrid = CvSVM::get_default_grid(CvSVM::P), CvParamGrid nuGrid = CvSVM::get_default_grid(CvSVM::NU), CvParamGrid coeffGrid = CvSVM::get_default_grid(CvSVM::COEF), CvParamGrid degreeGrid = CvSVM::get_default_grid(CvSVM::DEGREE), bool balanced=false)
CvSVM::train_auto	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train_auto( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, CvSVMParams params, int kfold = 10, CvParamGrid Cgrid = get_default_grid(CvSVM::C), CvParamGrid gammaGrid = get_default_grid(CvSVM::GAMMA), CvParamGrid pGrid = get_default_grid(CvSVM::P), CvParamGrid nuGrid = get_default_grid(CvSVM::NU), CvParamGrid coeffGrid = get_default_grid(CvSVM::COEF), CvParamGrid degreeGrid = get_default_grid(CvSVM::DEGREE), bool balanced=false )
CvSVM::var_all	/usr/include/opencv2/ml/ml.hpp	/^    int var_all;$/;"	m	class:CvSVM	access:protected
CvSVM::var_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_idx;$/;"	m	class:CvSVM	access:protected
CvSVM::write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvSVM	access:public	signature:( CvFileStorage* storage, const char* name ) const
CvSVM::write_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvSVM	access:protected	signature:( CvFileStorage* fs ) const
CvSVM::~CvSVM	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvSVM();$/;"	p	class:CvSVM	access:public	signature:()
CvSVMDecisionFunc	/usr/include/opencv2/ml/ml.hpp	/^struct CvSVMDecisionFunc$/;"	s
CvSVMDecisionFunc::alpha	/usr/include/opencv2/ml/ml.hpp	/^    double* alpha;$/;"	m	struct:CvSVMDecisionFunc	access:public
CvSVMDecisionFunc::rho	/usr/include/opencv2/ml/ml.hpp	/^    double rho;$/;"	m	struct:CvSVMDecisionFunc	access:public
CvSVMDecisionFunc::sv_count	/usr/include/opencv2/ml/ml.hpp	/^    int sv_count;$/;"	m	struct:CvSVMDecisionFunc	access:public
CvSVMDecisionFunc::sv_index	/usr/include/opencv2/ml/ml.hpp	/^    int* sv_index;$/;"	m	struct:CvSVMDecisionFunc	access:public
CvSVMKernel	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernel( const CvSVMParams* params, Calc _calc_func );$/;"	p	struct:CvSVMKernel	access:public	signature:( const CvSVMParams* params, Calc _calc_func )
CvSVMKernel	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernel();$/;"	p	struct:CvSVMKernel	access:public	signature:()
CvSVMKernel	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS CvSVMKernel$/;"	s
CvSVMKernel::Calc	/usr/include/opencv2/ml/ml.hpp	/^    typedef void (CvSVMKernel::*Calc)( int vec_count, int vec_size, const float** vecs,$/;"	t	struct:CvSVMKernel	access:public
CvSVMKernel::CvSVMKernel	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernel( const CvSVMParams* params, Calc _calc_func );$/;"	p	struct:CvSVMKernel	access:public	signature:( const CvSVMParams* params, Calc _calc_func )
CvSVMKernel::CvSVMKernel	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernel();$/;"	p	struct:CvSVMKernel	access:public	signature:()
CvSVMKernel::calc	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc( int vcount, int n, const float** vecs, const float* another, float* results );$/;"	p	struct:CvSVMKernel	access:public	signature:( int vcount, int n, const float** vecs, const float* another, float* results )
CvSVMKernel::calc_func	/usr/include/opencv2/ml/ml.hpp	/^    Calc calc_func;$/;"	m	struct:CvSVMKernel	access:public
CvSVMKernel::calc_linear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_linear( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
CvSVMKernel::calc_non_rbf_base	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_non_rbf_base( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results, double alpha, double beta )
CvSVMKernel::calc_poly	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_poly( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
CvSVMKernel::calc_rbf	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_rbf( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
CvSVMKernel::calc_sigmoid	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_sigmoid( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
CvSVMKernel::clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	struct:CvSVMKernel	access:public	signature:()
CvSVMKernel::create	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool create( const CvSVMParams* params, Calc _calc_func );$/;"	p	struct:CvSVMKernel	access:public	signature:( const CvSVMParams* params, Calc _calc_func )
CvSVMKernel::params	/usr/include/opencv2/ml/ml.hpp	/^    const CvSVMParams* params;$/;"	m	struct:CvSVMKernel	access:public
CvSVMKernel::~CvSVMKernel	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvSVMKernel();$/;"	p	struct:CvSVMKernel	access:public	signature:()
CvSVMKernelRow	/usr/include/opencv2/ml/ml.hpp	/^struct CvSVMKernelRow$/;"	s
CvSVMKernelRow::data	/usr/include/opencv2/ml/ml.hpp	/^    float* data;$/;"	m	struct:CvSVMKernelRow	access:public
CvSVMKernelRow::next	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernelRow* next;$/;"	m	struct:CvSVMKernelRow	access:public
CvSVMKernelRow::prev	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernelRow* prev;$/;"	m	struct:CvSVMKernelRow	access:public
CvSVMParams	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMParams( int _svm_type, int _kernel_type,$/;"	p	struct:CvSVMParams	access:public	signature:( int _svm_type, int _kernel_type, double _degree, double _gamma, double _coef0, double Cvalue, double _nu, double _p, CvMat* _class_weights, CvTermCriteria _term_crit )
CvSVMParams	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMParams();$/;"	p	struct:CvSVMParams	access:public	signature:()
CvSVMParams	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvSVMParams$/;"	s
CvSVMParams::C	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      C;  \/\/ for CV_SVM_C_SVC, CV_SVM_EPS_SVR and CV_SVM_NU_SVR$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::CvSVMParams	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMParams( int _svm_type, int _kernel_type,$/;"	p	struct:CvSVMParams	access:public	signature:( int _svm_type, int _kernel_type, double _degree, double _gamma, double _coef0, double Cvalue, double _nu, double _p, CvMat* _class_weights, CvTermCriteria _term_crit )
CvSVMParams::CvSVMParams	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMParams();$/;"	p	struct:CvSVMParams	access:public	signature:()
CvSVMParams::class_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat*      class_weights; \/\/ for CV_SVM_C_SVC$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::coef0	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      coef0;  \/\/ for poly\/sigmoid$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::degree	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      degree; \/\/ for poly$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::gamma	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      gamma;  \/\/ for poly\/rbf\/sigmoid$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::kernel_type	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int         kernel_type;$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::nu	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      nu; \/\/ for CV_SVM_NU_SVC, CV_SVM_ONE_CLASS, and CV_SVM_NU_SVR$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::p	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      p; \/\/ for CV_SVM_EPS_SVR$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::svm_type	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int         svm_type;$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::term_crit	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit; \/\/ termination criteria$/;"	m	struct:CvSVMParams	access:public
CvSVMSolutionInfo	/usr/include/opencv2/ml/ml.hpp	/^struct CvSVMSolutionInfo$/;"	s
CvSVMSolutionInfo::obj	/usr/include/opencv2/ml/ml.hpp	/^    double obj;$/;"	m	struct:CvSVMSolutionInfo	access:public
CvSVMSolutionInfo::r	/usr/include/opencv2/ml/ml.hpp	/^    double r;   \/\/ for Solver_NU$/;"	m	struct:CvSVMSolutionInfo	access:public
CvSVMSolutionInfo::rho	/usr/include/opencv2/ml/ml.hpp	/^    double rho;$/;"	m	struct:CvSVMSolutionInfo	access:public
CvSVMSolutionInfo::upper_bound_n	/usr/include/opencv2/ml/ml.hpp	/^    double upper_bound_n;$/;"	m	struct:CvSVMSolutionInfo	access:public
CvSVMSolutionInfo::upper_bound_p	/usr/include/opencv2/ml/ml.hpp	/^    double upper_bound_p;$/;"	m	struct:CvSVMSolutionInfo	access:public
CvSVMSolver	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMSolver( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, int alpha_count, double* alpha, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row, SelectWorkingSet select_working_set, CalcRho calc_rho )
CvSVMSolver	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMSolver();$/;"	p	class:CvSVMSolver	access:public	signature:()
CvSVMSolver	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS CvSVMSolver$/;"	c
CvSVMSolver::C	/usr/include/opencv2/ml/ml.hpp	/^    double C[2];  \/\/ C[0] == Cn, C[1] == Cp$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::CalcRho	/usr/include/opencv2/ml/ml.hpp	/^    typedef void (CvSVMSolver::*CalcRho)( double& rho, double& r );$/;"	t	class:CvSVMSolver	access:public
CvSVMSolver::CvSVMSolver	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMSolver( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, int alpha_count, double* alpha, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row, SelectWorkingSet select_working_set, CalcRho calc_rho )
CvSVMSolver::CvSVMSolver	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMSolver();$/;"	p	class:CvSVMSolver	access:public	signature:()
CvSVMSolver::G	/usr/include/opencv2/ml/ml.hpp	/^    double* G;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::GetRow	/usr/include/opencv2/ml/ml.hpp	/^    typedef float* (CvSVMSolver::*GetRow)( int i, float* row, float* dst, bool existed );$/;"	t	class:CvSVMSolver	access:public
CvSVMSolver::SelectWorkingSet	/usr/include/opencv2/ml/ml.hpp	/^    typedef bool (CvSVMSolver::*SelectWorkingSet)( int& i, int& j );$/;"	t	class:CvSVMSolver	access:public
CvSVMSolver::alpha	/usr/include/opencv2/ml/ml.hpp	/^    double* alpha;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::alpha_count	/usr/include/opencv2/ml/ml.hpp	/^    int alpha_count;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::alpha_status	/usr/include/opencv2/ml/ml.hpp	/^    schar* alpha_status;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::b	/usr/include/opencv2/ml/ml.hpp	/^    double* b;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::buf	/usr/include/opencv2/ml/ml.hpp	/^    float* buf[2];$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::cache_line_size	/usr/include/opencv2/ml/ml.hpp	/^    int cache_line_size;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::cache_size	/usr/include/opencv2/ml/ml.hpp	/^    int cache_size;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::calc_rho	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_rho( double& rho, double& r );$/;"	p	class:CvSVMSolver	access:public	signature:( double& rho, double& r )
CvSVMSolver::calc_rho_func	/usr/include/opencv2/ml/ml.hpp	/^    CalcRho calc_rho_func;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::calc_rho_nu_svm	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_rho_nu_svm( double& rho, double& r );$/;"	p	class:CvSVMSolver	access:public	signature:( double& rho, double& r )
CvSVMSolver::clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvSVMSolver	access:public	signature:()
CvSVMSolver::create	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool create( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, int alpha_count, double* alpha, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row, SelectWorkingSet select_working_set, CalcRho calc_rho )
CvSVMSolver::eps	/usr/include/opencv2/ml/ml.hpp	/^    double eps;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::get_row	/usr/include/opencv2/ml/ml.hpp	/^    virtual float* get_row( int i, float* dst );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* dst )
CvSVMSolver::get_row_base	/usr/include/opencv2/ml/ml.hpp	/^    virtual float* get_row_base( int i, bool* _existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, bool* _existed )
CvSVMSolver::get_row_func	/usr/include/opencv2/ml/ml.hpp	/^    GetRow get_row_func;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::get_row_one_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual float* get_row_one_class( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
CvSVMSolver::get_row_svc	/usr/include/opencv2/ml/ml.hpp	/^    virtual float* get_row_svc( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
CvSVMSolver::get_row_svr	/usr/include/opencv2/ml/ml.hpp	/^    virtual float* get_row_svr( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
CvSVMSolver::kernel	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernel* kernel;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::lru_list	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernelRow lru_list;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::max_iter	/usr/include/opencv2/ml/ml.hpp	/^    int max_iter;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::params	/usr/include/opencv2/ml/ml.hpp	/^    const CvSVMParams* params;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::rows	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernelRow* rows;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::sample_count	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::samples	/usr/include/opencv2/ml/ml.hpp	/^    const float** samples;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::select_working_set	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool select_working_set( int& i, int& j );$/;"	p	class:CvSVMSolver	access:public	signature:( int& i, int& j )
CvSVMSolver::select_working_set_func	/usr/include/opencv2/ml/ml.hpp	/^    SelectWorkingSet select_working_set_func;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::select_working_set_nu_svm	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool select_working_set_nu_svm( int& i, int& j );$/;"	p	class:CvSVMSolver	access:public	signature:( int& i, int& j )
CvSVMSolver::solve_c_svc	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_c_svc( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
CvSVMSolver::solve_eps_svr	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_eps_svr( int count, int var_count, const float** samples, const float* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, const float* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
CvSVMSolver::solve_generic	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_generic( CvSVMSolutionInfo& si );$/;"	p	class:CvSVMSolver	access:public	signature:( CvSVMSolutionInfo& si )
CvSVMSolver::solve_nu_svc	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_nu_svc( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
CvSVMSolver::solve_nu_svr	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_nu_svr( int count, int var_count, const float** samples, const float* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, const float* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
CvSVMSolver::solve_one_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_one_class( int count, int var_count, const float** samples,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
CvSVMSolver::storage	/usr/include/opencv2/ml/ml.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::var_count	/usr/include/opencv2/ml/ml.hpp	/^    int var_count;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::y	/usr/include/opencv2/ml/ml.hpp	/^    schar* y;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::~CvSVMSolver	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvSVMSolver();$/;"	p	class:CvSVMSolver	access:public	signature:()
CvScalar	/usr/include/opencv2/core/types_c.h	/^CvScalar;$/;"	t	typeref:struct:CvScalar
CvScalar	/usr/include/opencv2/core/types_c.h	/^typedef struct CvScalar$/;"	s
CvScalar::val	/usr/include/opencv2/core/types_c.h	/^    double val[4];$/;"	m	struct:CvScalar	access:public
CvSeq	/usr/include/opencv2/core/types_c.h	/^CvSeq;$/;"	t	typeref:struct:CvSeq
CvSeq	/usr/include/opencv2/core/types_c.h	/^typedef struct CvSeq$/;"	s
CvSeqBlock	/usr/include/opencv2/core/types_c.h	/^CvSeqBlock;$/;"	t	typeref:struct:CvSeqBlock
CvSeqBlock	/usr/include/opencv2/core/types_c.h	/^typedef struct CvSeqBlock$/;"	s
CvSeqBlock::count	/usr/include/opencv2/core/types_c.h	/^    int    count;             \/* Number of elements in the block.           *\/$/;"	m	struct:CvSeqBlock	access:public
CvSeqBlock::data	/usr/include/opencv2/core/types_c.h	/^    schar* data;              \/* Pointer to the first element of the block. *\/$/;"	m	struct:CvSeqBlock	access:public
CvSeqBlock::next	/usr/include/opencv2/core/types_c.h	/^    struct CvSeqBlock*  next; \/* Next sequence block.                       *\/$/;"	m	struct:CvSeqBlock	typeref:struct:CvSeqBlock::CvSeqBlock	access:public
CvSeqBlock::prev	/usr/include/opencv2/core/types_c.h	/^    struct CvSeqBlock*  prev; \/* Previous sequence block.                   *\/$/;"	m	struct:CvSeqBlock	typeref:struct:CvSeqBlock::CvSeqBlock	access:public
CvSeqBlock::start_index	/usr/include/opencv2/core/types_c.h	/^  int    start_index;         \/* Index of the first element in the block +  *\/$/;"	m	struct:CvSeqBlock	access:public
CvSeqReader	/usr/include/opencv2/core/types_c.h	/^CvSeqReader;$/;"	t	typeref:struct:CvSeqReader
CvSeqReader	/usr/include/opencv2/core/types_c.h	/^typedef struct CvSeqReader$/;"	s
CvSeqWriter	/usr/include/opencv2/core/types_c.h	/^CvSeqWriter;$/;"	t	typeref:struct:CvSeqWriter
CvSeqWriter	/usr/include/opencv2/core/types_c.h	/^typedef struct CvSeqWriter$/;"	s
CvSet	/usr/include/opencv2/core/types_c.h	/^CvSet;$/;"	t	typeref:struct:CvSet
CvSet	/usr/include/opencv2/core/types_c.h	/^typedef struct CvSet$/;"	s
CvSetElem	/usr/include/opencv2/core/types_c.h	/^CvSetElem;$/;"	t	typeref:struct:CvSetElem
CvSetElem	/usr/include/opencv2/core/types_c.h	/^typedef struct CvSetElem$/;"	s
CvSize	/usr/include/opencv2/core/types_c.h	/^CvSize;$/;"	t	typeref:struct:__anon99
CvSize2D32f	/usr/include/opencv2/core/types_c.h	/^CvSize2D32f;$/;"	t	typeref:struct:CvSize2D32f
CvSize2D32f	/usr/include/opencv2/core/types_c.h	/^typedef struct CvSize2D32f$/;"	s
CvSize2D32f::height	/usr/include/opencv2/core/types_c.h	/^    float height;$/;"	m	struct:CvSize2D32f	access:public
CvSize2D32f::width	/usr/include/opencv2/core/types_c.h	/^    float width;$/;"	m	struct:CvSize2D32f	access:public
CvSlice	/usr/include/opencv2/core/types_c.h	/^CvSlice;$/;"	t	typeref:struct:CvSlice
CvSlice	/usr/include/opencv2/core/types_c.h	/^typedef struct CvSlice$/;"	s
CvSlice::end_index	/usr/include/opencv2/core/types_c.h	/^    int  start_index, end_index;$/;"	m	struct:CvSlice	access:public
CvSlice::start_index	/usr/include/opencv2/core/types_c.h	/^    int  start_index, end_index;$/;"	m	struct:CvSlice	access:public
CvSparseMat	/usr/include/opencv2/core/types_c.h	/^CvSparseMat;$/;"	t	typeref:struct:CvSparseMat
CvSparseMat	/usr/include/opencv2/core/types_c.h	/^typedef struct CvSparseMat$/;"	s
CvSparseMat::dims	/usr/include/opencv2/core/types_c.h	/^    int dims;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::hashsize	/usr/include/opencv2/core/types_c.h	/^    int hashsize;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::hashtable	/usr/include/opencv2/core/types_c.h	/^    void** hashtable;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::hdr_refcount	/usr/include/opencv2/core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::heap	/usr/include/opencv2/core/types_c.h	/^    struct CvSet* heap;$/;"	m	struct:CvSparseMat	typeref:struct:CvSparseMat::CvSet	access:public
CvSparseMat::idxoffset	/usr/include/opencv2/core/types_c.h	/^    int idxoffset;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::refcount	/usr/include/opencv2/core/types_c.h	/^    int* refcount;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::size	/usr/include/opencv2/core/types_c.h	/^    int size[CV_MAX_DIM];$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::type	/usr/include/opencv2/core/types_c.h	/^    int type;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::valoffset	/usr/include/opencv2/core/types_c.h	/^    int valoffset;$/;"	m	struct:CvSparseMat	access:public
CvSparseMatIterator	/usr/include/opencv2/core/types_c.h	/^CvSparseMatIterator;$/;"	t	typeref:struct:CvSparseMatIterator
CvSparseMatIterator	/usr/include/opencv2/core/types_c.h	/^typedef struct CvSparseMatIterator$/;"	s
CvSparseMatIterator::curidx	/usr/include/opencv2/core/types_c.h	/^    int curidx;$/;"	m	struct:CvSparseMatIterator	access:public
CvSparseMatIterator::mat	/usr/include/opencv2/core/types_c.h	/^    CvSparseMat* mat;$/;"	m	struct:CvSparseMatIterator	access:public
CvSparseMatIterator::node	/usr/include/opencv2/core/types_c.h	/^    CvSparseNode* node;$/;"	m	struct:CvSparseMatIterator	access:public
CvSparseNode	/usr/include/opencv2/core/types_c.h	/^CvSparseNode;$/;"	t	typeref:struct:CvSparseNode
CvSparseNode	/usr/include/opencv2/core/types_c.h	/^typedef struct CvSparseNode$/;"	s
CvSparseNode::hashval	/usr/include/opencv2/core/types_c.h	/^    unsigned hashval;$/;"	m	struct:CvSparseNode	access:public
CvSparseNode::next	/usr/include/opencv2/core/types_c.h	/^    struct CvSparseNode* next;$/;"	m	struct:CvSparseNode	typeref:struct:CvSparseNode::CvSparseNode	access:public
CvStarDetectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^typedef struct CvStarDetectorParams$/;"	s
CvStarDetectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^} CvStarDetectorParams;$/;"	t	typeref:struct:CvStarDetectorParams
CvStarDetectorParams::lineThresholdBinarized	/usr/include/opencv2/features2d/features2d.hpp	/^    int lineThresholdBinarized;$/;"	m	struct:CvStarDetectorParams	access:public
CvStarDetectorParams::lineThresholdProjected	/usr/include/opencv2/features2d/features2d.hpp	/^    int lineThresholdProjected;$/;"	m	struct:CvStarDetectorParams	access:public
CvStarDetectorParams::maxSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int maxSize;$/;"	m	struct:CvStarDetectorParams	access:public
CvStarDetectorParams::responseThreshold	/usr/include/opencv2/features2d/features2d.hpp	/^    int responseThreshold;$/;"	m	struct:CvStarDetectorParams	access:public
CvStarDetectorParams::suppressNonmaxSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int suppressNonmaxSize;$/;"	m	struct:CvStarDetectorParams	access:public
CvStarKeypoint	/usr/include/opencv2/features2d/features2d.hpp	/^typedef struct CvStarKeypoint$/;"	s
CvStarKeypoint	/usr/include/opencv2/features2d/features2d.hpp	/^} CvStarKeypoint;$/;"	t	typeref:struct:CvStarKeypoint
CvStarKeypoint::pt	/usr/include/opencv2/features2d/features2d.hpp	/^    CvPoint pt;$/;"	m	struct:CvStarKeypoint	access:public
CvStarKeypoint::response	/usr/include/opencv2/features2d/features2d.hpp	/^    float response;$/;"	m	struct:CvStarKeypoint	access:public
CvStarKeypoint::size	/usr/include/opencv2/features2d/features2d.hpp	/^    int size;$/;"	m	struct:CvStarKeypoint	access:public
CvStatModel	/usr/include/opencv2/ml/ml.hpp	/^    CvStatModel();$/;"	p	class:CvStatModel	access:public	signature:()
CvStatModel	/usr/include/opencv2/ml/ml.hpp	/^class CV_EXPORTS_W CvStatModel$/;"	c
CvStatModel::CvStatModel	/usr/include/opencv2/ml/ml.hpp	/^    CvStatModel();$/;"	p	class:CvStatModel	access:public	signature:()
CvStatModel::clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvStatModel	access:public	signature:()
CvStatModel::default_model_name	/usr/include/opencv2/ml/ml.hpp	/^    const char* default_model_name;$/;"	m	class:CvStatModel	access:protected
CvStatModel::load	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void load( const char* filename, const char* name=0 );$/;"	p	class:CvStatModel	access:public	signature:( const char* filename, const char* name=0 )
CvStatModel::read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvStatModel	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
CvStatModel::save	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void save( const char* filename, const char* name=0 ) const;$/;"	p	class:CvStatModel	access:public	signature:( const char* filename, const char* name=0 ) const
CvStatModel::write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvStatModel	access:public	signature:( CvFileStorage* storage, const char* name ) const
CvStatModel::~CvStatModel	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvStatModel();$/;"	p	class:CvStatModel	access:public	signature:()
CvStatus	/usr/include/opencv2/core/internal.hpp	/^CvStatus;$/;"	t	typeref:enum:CvStatus
CvStatus	/usr/include/opencv2/core/internal.hpp	/^typedef enum CvStatus$/;"	g
CvStereoBMState	/usr/include/opencv2/calib3d/calib3d.hpp	/^typedef struct CvStereoBMState$/;"	s
CvStereoBMState	/usr/include/opencv2/calib3d/calib3d.hpp	/^} CvStereoBMState;$/;"	t	typeref:struct:CvStereoBMState
CvStereoBMState::SADWindowSize	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int SADWindowSize; \/\/ ~5x5..21x21$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::cost	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* cost;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::disp	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* disp;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::disp12MaxDiff	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int disp12MaxDiff;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::minDisparity	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int minDisparity;  \/\/ minimum disparity (can be negative)$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::numberOfDisparities	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int numberOfDisparities; \/\/ maximum disparity - minimum disparity (> 0)$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::preFilterCap	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int preFilterCap; \/\/ the output of pre-filtering is clipped by [-preFilterCap,preFilterCap]$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::preFilterSize	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int preFilterSize; \/\/ averaging window size: ~5x5..21x21$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::preFilterType	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int preFilterType; \/\/ =CV_STEREO_BM_NORMALIZED_RESPONSE now$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::preFilteredImg0	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* preFilteredImg0;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::preFilteredImg1	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* preFilteredImg1;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::roi1	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvRect roi1, roi2;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::roi2	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvRect roi1, roi2;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::slidingSumBuf	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* slidingSumBuf;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::speckleRange	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int speckleRange; \/\/ acceptable range of variation in window$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::speckleWindowSize	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int speckleWindowSize; \/\/ disparity variation window$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::textureThreshold	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int textureThreshold;  \/\/ the disparity is only computed for pixels$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::trySmallerWindows	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int trySmallerWindows; \/\/ if 1, the results may be more accurate,$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::uniquenessRatio	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int uniquenessRatio;   \/\/ accept the computed disparity d* only if$/;"	m	struct:CvStereoBMState	access:public
CvStereoCamera	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvStereoCamera$/;"	s
CvStereoCamera	/usr/include/opencv2/legacy/legacy.hpp	/^} CvStereoCamera;$/;"	t	typeref:struct:CvStereoCamera
CvStereoCamera::border	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f border[2][4];$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::camera	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCamera* camera[2]; \/* two individual camera parameters *\/$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::coeffs	/usr/include/opencv2/legacy/legacy.hpp	/^    double coeffs[2][3][3];\/* coefficients for transformation *\/$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::epipole	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint3D32f epipole[2];$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::fundMatr	/usr/include/opencv2/legacy/legacy.hpp	/^    float fundMatr[9]; \/* fundamental matrix *\/$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::lineCoeffs	/usr/include/opencv2/legacy/legacy.hpp	/^    CvStereoLineCoeff* lineCoeffs;$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::needSwapCameras	/usr/include/opencv2/legacy/legacy.hpp	/^    int needSwapCameras;\/* flag set to 1 if need to swap cameras for good reconstruction *\/$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::quad	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f quad[2][4]; \/* coordinates of destination quadrangle after$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::rotMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    float rotMatrix[9];$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::transVector	/usr/include/opencv2/legacy/legacy.hpp	/^    float transVector[3];$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::warpSize	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSize warpSize;$/;"	m	struct:CvStereoCamera	access:public
CvStereoGCState	/usr/include/opencv2/calib3d/calib3d.hpp	/^typedef struct CvStereoGCState$/;"	s
CvStereoGCState	/usr/include/opencv2/calib3d/calib3d.hpp	/^} CvStereoGCState;$/;"	t	typeref:struct:CvStereoGCState
CvStereoGCState::Ithreshold	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int Ithreshold;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::K	/usr/include/opencv2/calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::dispLeft	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* dispLeft;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::dispRight	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* dispRight;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::edgeBuf	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* edgeBuf;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::interactionRadius	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int interactionRadius;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::lambda	/usr/include/opencv2/calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::lambda1	/usr/include/opencv2/calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::lambda2	/usr/include/opencv2/calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::left	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* left;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::maxIters	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int maxIters;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::minDisparity	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int minDisparity;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::numberOfDisparities	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int numberOfDisparities;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::occlusionCost	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int occlusionCost;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::ptrLeft	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* ptrLeft;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::ptrRight	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* ptrRight;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::right	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* right;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::vtxBuf	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* vtxBuf;$/;"	m	struct:CvStereoGCState	access:public
CvStereoLineCoeff	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvStereoLineCoeff$/;"	s
CvStereoLineCoeff	/usr/include/opencv2/legacy/legacy.hpp	/^}CvStereoLineCoeff;$/;"	t	typeref:struct:CvStereoLineCoeff
CvStereoLineCoeff::Xcoef	/usr/include/opencv2/legacy/legacy.hpp	/^    double Xcoef;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::XcoefA	/usr/include/opencv2/legacy/legacy.hpp	/^    double XcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::XcoefAB	/usr/include/opencv2/legacy/legacy.hpp	/^    double XcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::XcoefB	/usr/include/opencv2/legacy/legacy.hpp	/^    double XcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::Ycoef	/usr/include/opencv2/legacy/legacy.hpp	/^    double Ycoef;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::YcoefA	/usr/include/opencv2/legacy/legacy.hpp	/^    double YcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::YcoefAB	/usr/include/opencv2/legacy/legacy.hpp	/^    double YcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::YcoefB	/usr/include/opencv2/legacy/legacy.hpp	/^    double YcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::Zcoef	/usr/include/opencv2/legacy/legacy.hpp	/^    double Zcoef;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::ZcoefA	/usr/include/opencv2/legacy/legacy.hpp	/^    double ZcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::ZcoefAB	/usr/include/opencv2/legacy/legacy.hpp	/^    double ZcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::ZcoefB	/usr/include/opencv2/legacy/legacy.hpp	/^    double ZcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvString	/usr/include/opencv2/core/types_c.h	/^CvString;$/;"	t	typeref:struct:CvString
CvString	/usr/include/opencv2/core/types_c.h	/^typedef struct CvString$/;"	s
CvString::len	/usr/include/opencv2/core/types_c.h	/^    int len;$/;"	m	struct:CvString	access:public
CvString::ptr	/usr/include/opencv2/core/types_c.h	/^    char* ptr;$/;"	m	struct:CvString	access:public
CvStringHashNode	/usr/include/opencv2/core/types_c.h	/^CvStringHashNode;$/;"	t	typeref:struct:CvStringHashNode
CvStringHashNode	/usr/include/opencv2/core/types_c.h	/^typedef struct CvStringHashNode$/;"	s
CvStringHashNode::hashval	/usr/include/opencv2/core/types_c.h	/^    unsigned hashval;$/;"	m	struct:CvStringHashNode	access:public
CvStringHashNode::next	/usr/include/opencv2/core/types_c.h	/^    struct CvStringHashNode* next;$/;"	m	struct:CvStringHashNode	typeref:struct:CvStringHashNode::CvStringHashNode	access:public
CvStringHashNode::str	/usr/include/opencv2/core/types_c.h	/^    CvString str;$/;"	m	struct:CvStringHashNode	access:public
CvSubdiv2D	/usr/include/opencv2/imgproc/types_c.h	/^CvSubdiv2D;$/;"	t	typeref:struct:CvSubdiv2D
CvSubdiv2D	/usr/include/opencv2/imgproc/types_c.h	/^typedef struct CvSubdiv2D$/;"	s
CvSubdiv2DEdge	/usr/include/opencv2/imgproc/types_c.h	/^typedef size_t CvSubdiv2DEdge;$/;"	t
CvSubdiv2DPoint	/usr/include/opencv2/imgproc/types_c.h	/^CvSubdiv2DPoint;$/;"	t	typeref:struct:CvSubdiv2DPoint
CvSubdiv2DPoint	/usr/include/opencv2/imgproc/types_c.h	/^typedef struct CvSubdiv2DPoint$/;"	s
CvSubdiv2DPointLocation	/usr/include/opencv2/imgproc/types_c.h	/^CvSubdiv2DPointLocation;$/;"	t	typeref:enum:CvSubdiv2DPointLocation
CvSubdiv2DPointLocation	/usr/include/opencv2/imgproc/types_c.h	/^typedef enum CvSubdiv2DPointLocation$/;"	g
CvTemplMatchMethod	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvTemplMatchMethod;$/;"	t
CvTermCriteria	/usr/include/opencv2/core/types_c.h	/^CvTermCriteria;$/;"	t	typeref:struct:CvTermCriteria
CvTermCriteria	/usr/include/opencv2/core/types_c.h	/^typedef struct CvTermCriteria$/;"	s
CvTermCriteria::epsilon	/usr/include/opencv2/core/types_c.h	/^    double epsilon;$/;"	m	struct:CvTermCriteria	access:public
CvTermCriteria::max_iter	/usr/include/opencv2/core/types_c.h	/^    int    max_iter;$/;"	m	struct:CvTermCriteria	access:public
CvTermCriteria::type	/usr/include/opencv2/core/types_c.h	/^    int    type;  \/* may be combination of$/;"	m	struct:CvTermCriteria	access:public
CvTestSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^typedef void CvTestSeq;$/;"	t
CvThreshType	/usr/include/opencv2/legacy/compat.hpp	/^typedef int CvThreshType;$/;"	t
CvTrackbarCallback	/usr/include/opencv2/highgui/highgui_c.h	/^typedef void (CV_CDECL *CvTrackbarCallback)(int pos);$/;"	t
CvTrackbarCallback2	/usr/include/opencv2/highgui/highgui_c.h	/^typedef void (CV_CDECL *CvTrackbarCallback2)(int pos, void* userdata);$/;"	t
CvTracksTimePos	/usr/include/opencv2/legacy/blobtrack.hpp	/^struct CvTracksTimePos$/;"	s
CvTracksTimePos::beg1	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int beg1,beg2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::beg2	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int beg1,beg2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::comLen	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int comLen; \/\/common length for two tracks$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::end1	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int end1,end2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::end2	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int end1,end2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::len1	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int len1,len2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::len2	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int len1,len2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::shift1	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int shift1,shift2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::shift2	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int shift1,shift2;$/;"	m	struct:CvTracksTimePos	access:public
CvTrainTestSplit	/usr/include/opencv2/ml/ml.hpp	/^    CvTrainTestSplit( float _train_sample_portion, bool _mix = true);$/;"	p	struct:CvTrainTestSplit	access:public	signature:( float _train_sample_portion, bool _mix = true)
CvTrainTestSplit	/usr/include/opencv2/ml/ml.hpp	/^    CvTrainTestSplit( int _train_sample_count, bool _mix = true);$/;"	p	struct:CvTrainTestSplit	access:public	signature:( int _train_sample_count, bool _mix = true)
CvTrainTestSplit	/usr/include/opencv2/ml/ml.hpp	/^    CvTrainTestSplit();$/;"	p	struct:CvTrainTestSplit	access:public	signature:()
CvTrainTestSplit	/usr/include/opencv2/ml/ml.hpp	/^struct CV_EXPORTS CvTrainTestSplit$/;"	s
CvTrainTestSplit::CvTrainTestSplit	/usr/include/opencv2/ml/ml.hpp	/^    CvTrainTestSplit( float _train_sample_portion, bool _mix = true);$/;"	p	struct:CvTrainTestSplit	access:public	signature:( float _train_sample_portion, bool _mix = true)
CvTrainTestSplit::CvTrainTestSplit	/usr/include/opencv2/ml/ml.hpp	/^    CvTrainTestSplit( int _train_sample_count, bool _mix = true);$/;"	p	struct:CvTrainTestSplit	access:public	signature:( int _train_sample_count, bool _mix = true)
CvTrainTestSplit::CvTrainTestSplit	/usr/include/opencv2/ml/ml.hpp	/^    CvTrainTestSplit();$/;"	p	struct:CvTrainTestSplit	access:public	signature:()
CvTrainTestSplit::__anon91::count	/usr/include/opencv2/ml/ml.hpp	/^        int count;$/;"	m	union:CvTrainTestSplit::__anon91	access:public
CvTrainTestSplit::__anon91::portion	/usr/include/opencv2/ml/ml.hpp	/^        float portion;$/;"	m	union:CvTrainTestSplit::__anon91	access:public
CvTrainTestSplit::__anon92::count	/usr/include/opencv2/ml/ml.hpp	/^        int *count;$/;"	m	union:CvTrainTestSplit::__anon92	access:public
CvTrainTestSplit::__anon92::portion	/usr/include/opencv2/ml/ml.hpp	/^        float *portion;$/;"	m	union:CvTrainTestSplit::__anon92	access:public
CvTrainTestSplit::class_part	/usr/include/opencv2/ml/ml.hpp	/^    } *class_part;$/;"	m	struct:CvTrainTestSplit	typeref:union:CvTrainTestSplit::__anon92	access:public
CvTrainTestSplit::class_part_mode	/usr/include/opencv2/ml/ml.hpp	/^    int class_part_mode;$/;"	m	struct:CvTrainTestSplit	access:public
CvTrainTestSplit::mix	/usr/include/opencv2/ml/ml.hpp	/^    bool mix;    $/;"	m	struct:CvTrainTestSplit	access:public
CvTrainTestSplit::train_sample_part	/usr/include/opencv2/ml/ml.hpp	/^    } train_sample_part;$/;"	m	struct:CvTrainTestSplit	typeref:union:CvTrainTestSplit::__anon91	access:public
CvTrainTestSplit::train_sample_part_mode	/usr/include/opencv2/ml/ml.hpp	/^    int train_sample_part_mode;$/;"	m	struct:CvTrainTestSplit	access:public
CvTreeNodeIterator	/usr/include/opencv2/core/core_c.h	/^CvTreeNodeIterator;$/;"	t	typeref:struct:CvTreeNodeIterator
CvTreeNodeIterator	/usr/include/opencv2/core/core_c.h	/^typedef struct CvTreeNodeIterator$/;"	s
CvTreeNodeIterator::level	/usr/include/opencv2/core/core_c.h	/^    int level;$/;"	m	struct:CvTreeNodeIterator	access:public
CvTreeNodeIterator::max_level	/usr/include/opencv2/core/core_c.h	/^    int max_level;$/;"	m	struct:CvTreeNodeIterator	access:public
CvTreeNodeIterator::node	/usr/include/opencv2/core/core_c.h	/^    const void* node;$/;"	m	struct:CvTreeNodeIterator	access:public
CvType	/usr/include/opencv2/core/core_c.h	/^    CvType( const char* type_name,$/;"	p	struct:CvType	access:public	signature:( const char* type_name, CvIsInstanceFunc is_instance, CvReleaseFunc release=0, CvReadFunc read=0, CvWriteFunc write=0, CvCloneFunc clone=0 )
CvType	/usr/include/opencv2/core/core_c.h	/^struct CV_EXPORTS CvType$/;"	s
CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<char> { static int type() { return CV_8S; } };$/;"	s	namespace:cv::flann
CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<double> { static int type() { return CV_64F; } };$/;"	s	namespace:cv::flann
CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<float> { static int type() { return CV_32F; } };$/;"	s	namespace:cv::flann
CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<int> { static int type() { return CV_32S; } };$/;"	s	namespace:cv::flann
CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<short> { static int type() { return CV_16S; } };$/;"	s	namespace:cv::flann
CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<unsigned char> { static int type() { return CV_8U; } };$/;"	s	namespace:cv::flann
CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<unsigned short> { static int type() { return CV_16U; } };$/;"	s	namespace:cv::flann
CvType	/usr/include/opencv2/flann/flann.hpp	/^template <typename T> struct CvType {};$/;"	s	namespace:cv::flann
CvType::CvType	/usr/include/opencv2/core/core_c.h	/^    CvType( const char* type_name,$/;"	p	struct:CvType	access:public	signature:( const char* type_name, CvIsInstanceFunc is_instance, CvReleaseFunc release=0, CvReadFunc read=0, CvWriteFunc write=0, CvCloneFunc clone=0 )
CvType::first	/usr/include/opencv2/core/core_c.h	/^    static CvTypeInfo* first;$/;"	m	struct:CvType	access:public
CvType::info	/usr/include/opencv2/core/core_c.h	/^    CvTypeInfo* info;$/;"	m	struct:CvType	access:public
CvType::last	/usr/include/opencv2/core/core_c.h	/^    static CvTypeInfo* last;$/;"	m	struct:CvType	access:public
CvType::~CvType	/usr/include/opencv2/core/core_c.h	/^    ~CvType();$/;"	p	struct:CvType	access:public	signature:()
CvTypeInfo	/usr/include/opencv2/core/types_c.h	/^CvTypeInfo;$/;"	t	typeref:struct:CvTypeInfo
CvTypeInfo	/usr/include/opencv2/core/types_c.h	/^typedef struct CvTypeInfo$/;"	s
CvTypeInfo::clone	/usr/include/opencv2/core/types_c.h	/^    CvCloneFunc clone;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::flags	/usr/include/opencv2/core/types_c.h	/^    int flags;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::header_size	/usr/include/opencv2/core/types_c.h	/^    int header_size;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::is_instance	/usr/include/opencv2/core/types_c.h	/^    CvIsInstanceFunc is_instance;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::next	/usr/include/opencv2/core/types_c.h	/^    struct CvTypeInfo* next;$/;"	m	struct:CvTypeInfo	typeref:struct:CvTypeInfo::CvTypeInfo	access:public
CvTypeInfo::prev	/usr/include/opencv2/core/types_c.h	/^    struct CvTypeInfo* prev;$/;"	m	struct:CvTypeInfo	typeref:struct:CvTypeInfo::CvTypeInfo	access:public
CvTypeInfo::read	/usr/include/opencv2/core/types_c.h	/^    CvReadFunc read;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::release	/usr/include/opencv2/core/types_c.h	/^    CvReleaseFunc release;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::type_name	/usr/include/opencv2/core/types_c.h	/^    const char* type_name;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::write	/usr/include/opencv2/core/types_c.h	/^    CvWriteFunc write;$/;"	m	struct:CvTypeInfo	access:public
CvUpdateBGStatModel	/usr/include/opencv2/video/background_segm.hpp	/^typedef int (CV_CDECL * CvUpdateBGStatModel)( IplImage* curr_frame, struct CvBGStatModel* bg_model,$/;"	t
CvVSModule	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvVSModule();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule	/usr/include/opencv2/legacy/blobtrack.hpp	/^class CV_EXPORTS CvVSModule$/;"	c
CvVSModule::AddParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
CvVSModule::AddParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddParam(const char* name, const char** pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, const char** pAddr)
CvVSModule::AddParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddParam(const char* name, double* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, double* pAddr)
CvVSModule::AddParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddParam(const char* name, float* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, float* pAddr)
CvVSModule::AddParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void AddParam(const char* name, int* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, int* pAddr)
CvVSModule::CommentParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void CommentParam(const char* name, const char* pComment);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, const char* pComment)
CvVSModule::CvVSModule	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvVSModule();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::DelParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void DelParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
CvVSModule::FreeParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void    FreeParam(CvDefParam** pp);$/;"	p	class:CvVSModule	access:private	signature:(CvDefParam** pp)
CvVSModule::GetModuleName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*   GetModuleName();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::GetNickName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    const char* GetNickName();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::GetParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    double GetParam(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
CvVSModule::GetParamComment	/usr/include/opencv2/legacy/blobtrack.hpp	/^    const char* GetParamComment(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
CvVSModule::GetParamName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    const char* GetParamName(int index);$/;"	p	class:CvVSModule	access:public	signature:(int index)
CvVSModule::GetParamPtr	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvDefParam* GetParamPtr(const char* name);$/;"	p	class:CvVSModule	access:private	signature:(const char* name)
CvVSModule::GetParamPtr	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvDefParam* GetParamPtr(int index);$/;"	p	class:CvVSModule	access:private	signature:(int index)
CvVSModule::GetParamStr	/usr/include/opencv2/legacy/blobtrack.hpp	/^    const char* GetParamStr(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
CvVSModule::GetTypeName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    const char*   GetTypeName();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::IsModuleName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     IsModuleName(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
CvVSModule::IsModuleTypeName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     IsModuleTypeName(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
CvVSModule::IsParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int  IsParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
CvVSModule::LoadState	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void LoadState(CvFileStorage*, CvFileNode*);$/;"	p	class:CvVSModule	access:public	signature:(CvFileStorage*, CvFileNode*)
CvVSModule::NewParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvDefParam* NewParam(const char* name);$/;"	p	class:CvVSModule	access:private	signature:(const char* name)
CvVSModule::ParamUpdate	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void ParamUpdate();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Release() = 0;$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::SaveState	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void SaveState(CvFileStorage*);$/;"	p	class:CvVSModule	access:public	signature:(CvFileStorage*)
CvVSModule::SetModuleName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void SetModuleName(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
CvVSModule::SetNickName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void SetNickName(const char* pStr);$/;"	p	class:CvVSModule	access:public	signature:(const char* pStr)
CvVSModule::SetParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void   SetParam(const char* name, double val);$/;"	p	class:CvVSModule	access:public	signature:(const char* name, double val)
CvVSModule::SetParamStr	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void   SetParamStr(const char* name, const char* str);$/;"	p	class:CvVSModule	access:public	signature:(const char* name, const char* str)
CvVSModule::SetTypeName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void SetTypeName(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
CvVSModule::TransferParamsFromChild	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void TransferParamsFromChild(CvVSModule* pM, const char* prefix = NULL);$/;"	p	class:CvVSModule	access:public	signature:(CvVSModule* pM, const char* prefix = NULL)
CvVSModule::TransferParamsToChild	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void TransferParamsToChild(CvVSModule* pM, char* prefix = NULL);$/;"	p	class:CvVSModule	access:public	signature:(CvVSModule* pM, char* prefix = NULL)
CvVSModule::m_Wnd	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int         m_Wnd;$/;"	m	class:CvVSModule	access:protected
CvVSModule::m_pModuleName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*       m_pModuleName;$/;"	m	class:CvVSModule	access:private
CvVSModule::m_pModuleTypeName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*       m_pModuleTypeName;$/;"	m	class:CvVSModule	access:private
CvVSModule::m_pNickName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*       m_pNickName;$/;"	m	class:CvVSModule	access:private
CvVSModule::m_pParamList	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvDefParam*   m_pParamList;$/;"	m	class:CvVSModule	access:private
CvVSModule::~CvVSModule	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual ~CvVSModule();$/;"	p	class:CvVSModule	access:public	signature:()
CvVect32f	/usr/include/opencv2/legacy/compat.hpp	/^typedef float*   CvVect32f;$/;"	t
CvVect64d	/usr/include/opencv2/legacy/compat.hpp	/^typedef double*  CvVect64d;$/;"	t
CvVectors	/usr/include/opencv2/ml/ml.hpp	/^struct CvVectors$/;"	s
CvVectors::__anon76::db	/usr/include/opencv2/ml/ml.hpp	/^        double** db;$/;"	m	union:CvVectors::__anon76	access:public
CvVectors::__anon76::fl	/usr/include/opencv2/ml/ml.hpp	/^        float** fl;$/;"	m	union:CvVectors::__anon76	access:public
CvVectors::__anon76::ptr	/usr/include/opencv2/ml/ml.hpp	/^        uchar** ptr;$/;"	m	union:CvVectors::__anon76	access:public
CvVectors::count	/usr/include/opencv2/ml/ml.hpp	/^    int dims, count;$/;"	m	struct:CvVectors	access:public
CvVectors::data	/usr/include/opencv2/ml/ml.hpp	/^    } data;$/;"	m	struct:CvVectors	typeref:union:CvVectors::__anon76	access:public
CvVectors::dims	/usr/include/opencv2/ml/ml.hpp	/^    int dims, count;$/;"	m	struct:CvVectors	access:public
CvVectors::next	/usr/include/opencv2/ml/ml.hpp	/^    CvVectors* next;$/;"	m	struct:CvVectors	access:public
CvVectors::type	/usr/include/opencv2/ml/ml.hpp	/^    int type;$/;"	m	struct:CvVectors	access:public
CvVideoWriter	/usr/include/opencv2/highgui/highgui_c.h	/^typedef struct CvVideoWriter CvVideoWriter;$/;"	t	typeref:struct:CvVideoWriter
CvVoronoiDiagram2D	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvVoronoiDiagram2D$/;"	s
CvVoronoiDiagram2D	/usr/include/opencv2/legacy/legacy.hpp	/^} CvVoronoiDiagram2D;$/;"	t	typeref:struct:CvVoronoiDiagram2D
CvVoronoiEdge2D	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvVoronoiEdge2D$/;"	s
CvVoronoiEdge2D	/usr/include/opencv2/legacy/legacy.hpp	/^} CvVoronoiEdge2D;$/;"	t	typeref:struct:CvVoronoiEdge2D
CvVoronoiNode2D	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvVoronoiNode2D$/;"	s
CvVoronoiNode2D	/usr/include/opencv2/legacy/legacy.hpp	/^} CvVoronoiNode2D;$/;"	t	typeref:struct:CvVoronoiNode2D
CvVoronoiSite2D	/usr/include/opencv2/legacy/legacy.hpp	/^typedef struct CvVoronoiSite2D$/;"	s
CvVoronoiSite2D	/usr/include/opencv2/legacy/legacy.hpp	/^} CvVoronoiSite2D;$/;"	t	typeref:struct:CvVoronoiSite2D
CvVoronoiSite2D::next	/usr/include/opencv2/legacy/legacy.hpp	/^    struct CvVoronoiSite2D *next[2];$/;"	m	struct:CvVoronoiSite2D	typeref:struct:CvVoronoiSite2D::CvVoronoiSite2D	access:public
CvWin32WindowCallback	/usr/include/opencv2/highgui/highgui_c.h	/^typedef int (CV_CDECL * CvWin32WindowCallback)(HWND, UINT, WPARAM, LPARAM, int*);$/;"	t
CvWriteFunc	/usr/include/opencv2/core/types_c.h	/^typedef void (CV_CDECL *CvWriteFunc)( CvFileStorage* storage, const char* name,$/;"	t
Cv_iplAllocateImageData	/usr/include/opencv2/core/core_c.h	/^typedef void (CV_STDCALL* Cv_iplAllocateImageData)(IplImage*,int,int);$/;"	t
Cv_iplCloneImage	/usr/include/opencv2/core/core_c.h	/^typedef IplImage* (CV_STDCALL* Cv_iplCloneImage)(const IplImage*);$/;"	t
Cv_iplCreateImageHeader	/usr/include/opencv2/core/core_c.h	/^typedef IplImage* (CV_STDCALL* Cv_iplCreateImageHeader)$/;"	t
Cv_iplCreateROI	/usr/include/opencv2/core/core_c.h	/^typedef IplROI* (CV_STDCALL* Cv_iplCreateROI)(int,int,int,int,int);$/;"	t
Cv_iplDeallocate	/usr/include/opencv2/core/core_c.h	/^typedef void (CV_STDCALL* Cv_iplDeallocate)(IplImage*,int);$/;"	t
DCT_INVERSE	/usr/include/opencv2/core/core.hpp	/^    DCT_INVERSE = DFT_INVERSE, DCT_ROWS=DFT_ROWS };$/;"	e	enum:cv::__anon108
DCT_ROWS	/usr/include/opencv2/core/core.hpp	/^    DCT_INVERSE = DFT_INVERSE, DCT_ROWS=DFT_ROWS };$/;"	e	enum:cv::__anon108
DECOMP_CHOLESKY	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
DECOMP_EIG	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
DECOMP_LU	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
DECOMP_NORMAL	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
DECOMP_QR	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
DECOMP_SVD	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
DEFAULT	/usr/include/opencv2/features2d/features2d.hpp	/^    enum{ DEFAULT = 0, \/\/ Output image matrix will be created (Mat::create),$/;"	e	enum:cv::DrawMatchesFlags::__anon75
DEFAULT	/usr/include/opencv2/ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon86
DEFAULT_COMPRESSION_METHOD	/usr/include/opencv2/features2d/features2d.hpp	/^        DEFAULT_COMPRESSION_METHOD = COMPRESSION_NONE$/;"	e	enum:cv::FernClassifier::__anon74
DEFAULT_DEPTH	/usr/include/opencv2/features2d/features2d.hpp	/^  static const int DEFAULT_DEPTH = 9;$/;"	m	class:cv::RandomizedTree	access:public
DEFAULT_FIRST_OCTAVE	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int DEFAULT_FIRST_OCTAVE = -1;$/;"	m	struct:cv::SIFT::CommonParams	access:public
DEFAULT_IS_NORMALIZE	/usr/include/opencv2/features2d/features2d.hpp	/^        static const bool DEFAULT_IS_NORMALIZE = true;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
DEFAULT_ITERS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_ITERS    = 8   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon159
DEFAULT_ITERS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_ITERS  = 1 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon164
DEFAULT_ITERS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_ITERS  = 5  };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon156
DEFAULT_LARGE_SIZE	/usr/include/opencv2/contrib/contrib.hpp	/^        enum { DEFAULT_SMALL_SIZE = 5, DEFAULT_LARGE_SIZE = 41,$/;"	e	enum:cv::SelfSimDescriptor::__anon57
DEFAULT_LEVELS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_LEVELS   = 4   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon160
DEFAULT_LEVELS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_LEVELS = 5  };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon157
DEFAULT_NDISP	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NDISP    = 128 };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon158
DEFAULT_NDISP	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NDISP  = 64 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon162
DEFAULT_NDISP	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NDISP  = 64 };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon155
DEFAULT_NDISP	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NDISP = 64, DEFAULT_WINSZ = 19 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon154
DEFAULT_NLEVELS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NLEVELS = 64 };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon166
DEFAULT_NLEVELS	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { DEFAULT_NLEVELS=64 };$/;"	e	enum:cv::HOGDescriptor::__anon65
DEFAULT_NOCTAVES	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int DEFAULT_NOCTAVES = 4;$/;"	m	struct:cv::SIFT::CommonParams	access:public
DEFAULT_NOCTAVE_LAYERS	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int DEFAULT_NOCTAVE_LAYERS = 3;$/;"	m	struct:cv::SIFT::CommonParams	access:public
DEFAULT_NR_PLANE	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NR_PLANE = 4   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon161
DEFAULT_NUM_ANGLES	/usr/include/opencv2/contrib/contrib.hpp	/^            DEFAULT_NUM_ANGLES = 20, DEFAULT_START_DISTANCE_BUCKET = 3,$/;"	e	enum:cv::SelfSimDescriptor::__anon57
DEFAULT_NUM_DISTANCE_BUCKETS	/usr/include/opencv2/contrib/contrib.hpp	/^            DEFAULT_NUM_DISTANCE_BUCKETS = 7 };$/;"	e	enum:cv::SelfSimDescriptor::__anon57
DEFAULT_NUM_QUANT_BITS	/usr/include/opencv2/features2d/features2d.hpp	/^  static const size_t DEFAULT_NUM_QUANT_BITS = 4;$/;"	m	class:cv::RTreeClassifier	access:public
DEFAULT_RADIUS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_RADIUS = 3 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon163
DEFAULT_REDUCED_NUM_DIM	/usr/include/opencv2/features2d/features2d.hpp	/^  static const size_t DEFAULT_REDUCED_NUM_DIM = 176;$/;"	m	class:cv::RandomizedTree	access:public
DEFAULT_SIGNATURE_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^        DEFAULT_SIGNATURE_SIZE = 176,$/;"	e	enum:cv::FernClassifier::__anon74
DEFAULT_SMALL_SIZE	/usr/include/opencv2/contrib/contrib.hpp	/^        enum { DEFAULT_SMALL_SIZE = 5, DEFAULT_LARGE_SIZE = 41,$/;"	e	enum:cv::SelfSimDescriptor::__anon57
DEFAULT_START_DISTANCE_BUCKET	/usr/include/opencv2/contrib/contrib.hpp	/^            DEFAULT_NUM_ANGLES = 20, DEFAULT_START_DISTANCE_BUCKET = 3,$/;"	e	enum:cv::SelfSimDescriptor::__anon57
DEFAULT_STRUCTS	/usr/include/opencv2/features2d/features2d.hpp	/^        DEFAULT_STRUCTS = 50,$/;"	e	enum:cv::FernClassifier::__anon74
DEFAULT_STRUCT_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^        DEFAULT_STRUCT_SIZE = 9,$/;"	e	enum:cv::FernClassifier::__anon74
DEFAULT_TREES	/usr/include/opencv2/features2d/features2d.hpp	/^  static const int DEFAULT_TREES = 48;$/;"	m	class:cv::RTreeClassifier	access:public
DEFAULT_VIEWS	/usr/include/opencv2/features2d/features2d.hpp	/^        DEFAULT_VIEWS = 5000,$/;"	e	enum:cv::FernClassifier::__anon74
DEFAULT_VIEWS	/usr/include/opencv2/features2d/features2d.hpp	/^  static const int DEFAULT_VIEWS = 5000;$/;"	m	class:cv::RandomizedTree	access:public
DEFAULT_WINSZ	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NDISP = 64, DEFAULT_WINSZ = 19 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon154
DEFAULT_WIN_SIGMA	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_WIN_SIGMA = -1 };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon165
DEGREE	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
DEPTH_MASK	/usr/include/opencv2/core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon141
DESCRIPTOR_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int DESCRIPTOR_SIZE = 128;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
DESCR_FORMAT_COL_BY_COL	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DESCR_FORMAT_ROW_BY_ROW, DESCR_FORMAT_COL_BY_COL };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon167
DESCR_FORMAT_ROW_BY_ROW	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DESCR_FORMAT_ROW_BY_ROW, DESCR_FORMAT_COL_BY_COL };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon167
DEVIANCE_LOSS	/usr/include/opencv2/ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon87
DFT_COMPLEX_OUTPUT	/usr/include/opencv2/core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon108
DFT_INVERSE	/usr/include/opencv2/core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon108
DFT_REAL_OUTPUT	/usr/include/opencv2/core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon108
DFT_ROWS	/usr/include/opencv2/core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon108
DFT_SCALE	/usr/include/opencv2/core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon108
DISCRETE	/usr/include/opencv2/ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon85
DISP_SCALE	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DISP_SHIFT=4, DISP_SCALE = (1<<DISP_SHIFT) };$/;"	e	enum:cv::StereoSGBM::__anon72
DISP_SHIFT	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DISP_SHIFT=4, DISP_SCALE = (1<<DISP_SHIFT) };$/;"	e	enum:cv::StereoSGBM::__anon72
DMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    DMatch( int _queryIdx, int _trainIdx, float _distance ) :$/;"	f	struct:cv::DMatch	access:public	signature:( int _queryIdx, int _trainIdx, float _distance )
DMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    DMatch( int _queryIdx, int _trainIdx, int _imgIdx, float _distance ) :$/;"	f	struct:cv::DMatch	access:public	signature:( int _queryIdx, int _trainIdx, int _imgIdx, float _distance )
DMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    DMatch() : queryIdx(-1), trainIdx(-1), imgIdx(-1), distance(std::numeric_limits<float>::max()) {}$/;"	f	struct:cv::DMatch	access:public	signature:()
DMatch	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS DMatch$/;"	s	namespace:cv
DONE	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon66
DO_CANNY_PRUNING	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { DO_CANNY_PRUNING = 1, SCALE_IMAGE = 2,$/;"	e	enum:cv::CascadeClassifier::__anon63
DO_ROUGH_SEARCH	/usr/include/opencv2/objdetect/objdetect.hpp	/^           FIND_BIGGEST_OBJECT = 4, DO_ROUGH_SEARCH = 8 };$/;"	e	enum:cv::CascadeClassifier::__anon63
DP	/usr/include/opencv2/legacy/legacy.hpp	/^    int DP;$/;"	m	struct:CvConDensation	access:public
DP	/usr/include/opencv2/video/tracking.hpp	/^    int DP;                     \/* number of state vector dimensions *\/$/;"	m	struct:CvKalman	access:public
DRAW_OVER_OUTIMG	/usr/include/opencv2/features2d/features2d.hpp	/^          DRAW_OVER_OUTIMG = 1, \/\/ Output image matrix will not be created (Mat::create).$/;"	e	enum:cv::DrawMatchesFlags::__anon75
DRAW_RICH_KEYPOINTS	/usr/include/opencv2/features2d/features2d.hpp	/^          DRAW_RICH_KEYPOINTS = 4 \/\/ For each keypoint the circle around keypoint with keypoint size and$/;"	e	enum:cv::DrawMatchesFlags::__anon75
DTree	/usr/include/opencv2/objdetect/objdetect.hpp	/^    struct CV_EXPORTS DTree$/;"	s	class:cv::CascadeClassifier	access:public
DTreeNode	/usr/include/opencv2/objdetect/objdetect.hpp	/^    struct CV_EXPORTS DTreeNode$/;"	s	class:cv::CascadeClassifier	access:public
DTreeParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvDTreeParams DTreeParams;$/;"	t	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	c	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	c	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	c	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	c	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	c	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	c	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	c	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	c	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	c	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	c	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS DataDepth {};$/;"	c	namespace:cv
DataDepth	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<Range>$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<bool>$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<char>$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<double>$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<float>$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<int>$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<schar>$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<short>$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<uchar>$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<ushort>$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int cn> class DataType<Vec<_Tp, cn> >$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Complex<_Tp> >$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Point3_<_Tp> >$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Point_<_Tp> >$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Rect_<_Tp> >$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Scalar_<_Tp> >$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Size_<_Tp> >$/;"	c	namespace:cv
DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<std::complex<_Tp> >$/;"	c	namespace:cv
Datatype	/usr/include/opencv2/flann/saving.h	/^template <typename T> struct Datatype {};$/;"	s	namespace:cvflann
Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<char> { static flann_datatype_t type() { return INT8; } };$/;"	s	namespace:cvflann
Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<double> { static flann_datatype_t type() { return FLOAT64; } };$/;"	s	namespace:cvflann
Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<float> { static flann_datatype_t type() { return FLOAT32; } };$/;"	s	namespace:cvflann
Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<int> { static flann_datatype_t type() { return INT32; } };$/;"	s	namespace:cvflann
Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<short> { static flann_datatype_t type() { return INT16; } };$/;"	s	namespace:cvflann
Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned char> { static flann_datatype_t type() { return UINT8; } };$/;"	s	namespace:cvflann
Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned int> { static flann_datatype_t type() { return UINT32; } };$/;"	s	namespace:cvflann
Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned short> { static flann_datatype_t type() { return UINT16; } };$/;"	s	namespace:cvflann
DecisionTree	/usr/include/opencv2/ml/ml.hpp	/^typedef CvDTree DecisionTree;$/;"	t	namespace:cv
DefaultRngAuto	/usr/include/opencv2/features2d/features2d.hpp	/^        DefaultRngAuto() : old_state(theRNG().state) { theRNG().state = (uint64)-1; }$/;"	f	struct:cv::DefaultRngAuto	access:public	signature:()
DefaultRngAuto	/usr/include/opencv2/features2d/features2d.hpp	/^    struct CV_EXPORTS DefaultRngAuto$/;"	s	namespace:cv
DelBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    DelBlob(int BlobIndex) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex)
DelBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void DelBlob(int BlobIndex)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobIndex)
DelBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    DelBlobByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
DelBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void DelBlobByID(int BlobID)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobID)
DelBlobTrack	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void DelBlobTrack(int TrackIndex);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackIndex)
DelBlobTrackByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void DelBlobTrackByID(int TrackID);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID)
DelParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void DelParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
DenseFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    DenseFeatureDetector( const DenseFeatureDetector::Params& params=DenseFeatureDetector::Params() );$/;"	p	class:cv::DenseFeatureDetector	access:public	signature:( const DenseFeatureDetector::Params& params=DenseFeatureDetector::Params() )
DenseFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS DenseFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
Depth	/usr/include/opencv2/core/wimage.hpp	/^    int Depth() const;$/;"	p	class:cv::WImage	access:public	signature:() const
Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<double>::Depth() const {return IPL_DEPTH_64F; }$/;"	f	class:cv::WImage	signature:() const
Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<float>::Depth() const {return IPL_DEPTH_32F; }$/;"	f	class:cv::WImage	signature:() const
Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<int>::Depth() const {return IPL_DEPTH_32S; }$/;"	f	class:cv::WImage	signature:() const
Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<short>::Depth() const {return IPL_DEPTH_16S; }$/;"	f	class:cv::WImage	signature:() const
Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<signed char>::Depth() const {return IPL_DEPTH_8S; }$/;"	f	class:cv::WImage	signature:() const
Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<uchar>::Depth() const {return IPL_DEPTH_8U; }$/;"	f	class:cv::WImage	signature:() const
Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<ushort>::Depth() const {return IPL_DEPTH_16U; }$/;"	f	class:cv::WImage	signature:() const
DescriptorCollection	/usr/include/opencv2/features2d/features2d.hpp	/^        DescriptorCollection( const DescriptorCollection& collection );$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( const DescriptorCollection& collection )
DescriptorCollection	/usr/include/opencv2/features2d/features2d.hpp	/^        DescriptorCollection();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
DescriptorCollection	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS DescriptorCollection$/;"	c	class:cv::DescriptorMatcher	access:protected
DescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS DescriptorExtractor$/;"	c	namespace:cv
DescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS DescriptorMatcher$/;"	c	namespace:cv
DescriptorParams	/usr/include/opencv2/features2d/features2d.hpp	/^        DescriptorParams( double _magnification, bool _isNormalize, bool _recalculateAngles );$/;"	p	struct:cv::SIFT::DescriptorParams	access:public	signature:( double _magnification, bool _isNormalize, bool _recalculateAngles )
DescriptorParams	/usr/include/opencv2/features2d/features2d.hpp	/^        DescriptorParams();$/;"	p	struct:cv::SIFT::DescriptorParams	access:public	signature:()
DescriptorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    struct CV_EXPORTS DescriptorParams$/;"	s	class:cv::SIFT	access:public
Detect	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void Detect( const CvArr* \/*img*\/, \/* out *\/ CvBlobSeq* \/*detected_blob_seq*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const CvArr* , CvBlobSeq* = 0 )
DetectNewBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int DetectNewBlob(IplImage* pImg, IplImage* pImgFG, CvBlobSeq* pNewBlobList, CvBlobSeq* pOldBlobList) = 0;$/;"	p	class:CvBlobDetector	access:public	signature:(IplImage* pImg, IplImage* pImgFG, CvBlobSeq* pNewBlobList, CvBlobSeq* pOldBlobList)
DetectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^        DetectorParams( double _threshold, double _edgeThreshold );$/;"	p	struct:cv::SIFT::DetectorParams	access:public	signature:( double _threshold, double _edgeThreshold )
DetectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^        DetectorParams();$/;"	p	struct:cv::SIFT::DetectorParams	access:public	signature:()
DetectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    struct CV_EXPORTS DetectorParams$/;"	s	class:cv::SIFT	access:public
DevMem2D	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef DevMem2D_<unsigned char> DevMem2D;$/;"	t	namespace:cv::gpu
DevMem2D_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            DevMem2D_() : cols(0), rows(0), data(0), step(0) {}$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:()
DevMem2D_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            DevMem2D_(int rows_, int cols_, T *data_, size_t step_)$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int rows_, int cols_, T *data_, size_t step_)
DevMem2D_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            explicit DevMem2D_(const DevMem2D_<U>& d)$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(const DevMem2D_<U>& d)
DevMem2D_	/usr/include/opencv2/gpu/devmem2d.hpp	/^        template <typename T> struct DevMem2D_$/;"	s	namespace:cv::gpu
DevMem2Df	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef DevMem2D_<float> DevMem2Df;$/;"	t	namespace:cv::gpu
DevMem2Di	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef DevMem2D_<int> DevMem2Di;$/;"	t	namespace:cv::gpu
DisparityBilateralFilter	/usr/include/opencv2/gpu/gpu.hpp	/^            DisparityBilateralFilter(int ndisp, int radius, int iters, float edge_threshold, float max_disc_threshold, float sigma_range);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(int ndisp, int radius, int iters, float edge_threshold, float max_disc_threshold, float sigma_range)
DisparityBilateralFilter	/usr/include/opencv2/gpu/gpu.hpp	/^            explicit DisparityBilateralFilter(int ndisp = DEFAULT_NDISP, int radius = DEFAULT_RADIUS, int iters = DEFAULT_ITERS);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(int ndisp = DEFAULT_NDISP, int radius = DEFAULT_RADIUS, int iters = DEFAULT_ITERS)
DisparityBilateralFilter	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS DisparityBilateralFilter$/;"	c	namespace:cv::gpu
DistType	/usr/include/opencv2/flann/general.h	/^struct DistType$/;"	s	namespace:cvflann
DistType	/usr/include/opencv2/flann/general.h	/^struct DistType<int>$/;"	s	namespace:cvflann
DistType	/usr/include/opencv2/flann/general.h	/^struct DistType<unsigned char>$/;"	s	namespace:cvflann
Double	/usr/include/opencv2/legacy/blobtrack.hpp	/^    double              Double;$/;"	m	struct:CvDefParam	access:public
Draw	/usr/include/opencv2/legacy/blobtrack.hpp	/^    IplImage* Draw( const CvArr* src, CvBlobSeq* blob_seq = 0, const CvSeq* roi_seq = 0 );$/;"	p	class:CvImageDrawer	access:public	signature:( const CvArr* src, CvBlobSeq* blob_seq = 0, const CvSeq* roi_seq = 0 )
DrawMatchesFlags	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS DrawMatchesFlags$/;"	s	namespace:cv
DrawPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void DrawPoints( CvMat** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** dst )
DrawPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void DrawPoints( IplImage** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** dst )
DynamMatr	/usr/include/opencv2/legacy/legacy.hpp	/^    float* DynamMatr;       \/* Matrix of the linear Dynamics system  *\/$/;"	m	struct:CvConDensation	access:public
DynamMatr	/usr/include/opencv2/video/tracking.hpp	/^    float* DynamMatr;           \/* =transition_matrix->data.fl *\/$/;"	m	struct:CvKalman	access:public
DynamicAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    DynamicAdaptedFeatureDetector( const Ptr<AdjusterAdapter>& adjaster, int min_features=400, int max_features=500, int max_iters=5 );$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:public	signature:( const Ptr<AdjusterAdapter>& adjaster, int min_features=400, int max_features=500, int max_iters=5 )
DynamicAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS DynamicAdaptedFeatureDetector: public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
ELLIPSE	/usr/include/opencv2/legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	e	enum:CvDrawShape::__anon178
EMPTY	/usr/include/opencv2/core/core.hpp	/^        EMPTY=32, \/\/!< empty structure (sequence or mapping)$/;"	e	enum:cv::FileNode::__anon151
EMParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvEMParams EMParams;$/;"	t	namespace:cv
EPS	/usr/include/opencv2/core/core.hpp	/^        EPS=2 \/\/!< the desired accuracy or change in parameters at which the iterative algorithm stops$/;"	e	enum:cv::TermCriteria::__anon144
EPS_SVR	/usr/include/opencv2/ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon78
ERTree	/usr/include/opencv2/ml/ml.hpp	/^typedef CvForestERTree ERTree;$/;"	t	namespace:cv
ERTreeTRainData	/usr/include/opencv2/ml/ml.hpp	/^typedef CvERTreeTrainData ERTreeTRainData;$/;"	t	namespace:cv
ERTrees	/usr/include/opencv2/ml/ml.hpp	/^typedef CvERTrees ERTrees;$/;"	t	namespace:cv
EUCLIDEAN	/usr/include/opencv2/flann/general.h	/^	EUCLIDEAN = 1,$/;"	e	enum:cvflann::flann_distance_t
EXIT	/usr/include/opencv2/core/internal.hpp	96;"	d
ElemStepTypeCheck	/usr/include/opencv2/gpu/devmem2d.hpp	/^            StaticCheck<256 % sizeof(T) == 0>  ElemStepTypeCheck;$/;"	m	struct:cv::gpu::PtrElemStep_	access:private
EmptyMeshException	/usr/include/opencv2/contrib/contrib.hpp	/^        struct EmptyMeshException {};$/;"	s	class:cv::Mesh3D	access:public
ErrorCallback	/usr/include/opencv2/core/core.hpp	/^typedef int (CV_CDECL *ErrorCallback)( int status, const char* func_name,$/;"	t	namespace:cv
EstimatePose	/usr/include/opencv2/features2d/features2d.hpp	/^    void EstimatePose(IplImage* patch, int& pose_idx, float& distance) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* patch, int& pose_idx, float& distance) const
EstimatePosePCA	/usr/include/opencv2/features2d/features2d.hpp	/^    void EstimatePosePCA(CvArr* patch, int& pose_idx, float& distance, CvMat* avg, CvMat* eigenvalues) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvArr* patch, int& pose_idx, float& distance, CvMat* avg, CvMat* eigenvalues) const
Exception	/usr/include/opencv2/core/core.hpp	/^	Exception(int _code, const string& _err, const string& _func, const string& _file, int _line)$/;"	f	class:cv::Exception	access:public	signature:(int _code, const string& _err, const string& _func, const string& _file, int _line)
Exception	/usr/include/opencv2/core/core.hpp	/^    Exception() { code = 0; line = 0; }$/;"	f	class:cv::Exception	access:public	signature:()
Exception	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS Exception : public std::exception$/;"	c	namespace:cv	inherits:std::exception
ExpectationMaximization	/usr/include/opencv2/ml/ml.hpp	/^typedef CvEM ExpectationMaximization;$/;"	t	namespace:cv
FALSE	/usr/include/opencv2/core/internal.hpp	88;"	d
FAST	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void FAST( const Mat& image, CV_OUT vector<KeyPoint>& keypoints,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int threshold, bool nonmaxSupression=true )
FGTrainFrames	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int                     FGTrainFrames; \/* Number of frames needed for FG (foreground) detector to train.        *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
FIND_BIGGEST_OBJECT	/usr/include/opencv2/objdetect/objdetect.hpp	/^           FIND_BIGGEST_OBJECT = 4, DO_ROUGH_SEARCH = 8 };$/;"	e	enum:cv::CascadeClassifier::__anon63
FIRST_ANGLE	/usr/include/opencv2/features2d/features2d.hpp	/^        enum{ FIRST_ANGLE = 0, AVERAGE_ANGLE = 1 };$/;"	e	enum:cv::SIFT::CommonParams::__anon73
FISH_EYE_PRESET	/usr/include/opencv2/calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon71
FLANNException	/usr/include/opencv2/flann/general.h	/^   FLANNException(const char* message) : std::runtime_error(message) { }$/;"	f	class:cvflann::FLANNException	access:public	signature:(const char* message)
FLANNException	/usr/include/opencv2/flann/general.h	/^   FLANNException(const std::string& message) : std::runtime_error(message) { }$/;"	f	class:cvflann::FLANNException	access:public	signature:(const std::string& message)
FLANNException	/usr/include/opencv2/flann/general.h	/^class FLANNException : public std::runtime_error {$/;"	c	namespace:cvflann	inherits:std::runtime_error
FLANN_SIGNATURE	/usr/include/opencv2/flann/saving.h	/^CV_EXPORTS const char* FLANN_SIGNATURE();$/;"	p	namespace:cvflann	signature:()
FLANN_VERSION	/usr/include/opencv2/flann/saving.h	/^CV_EXPORTS const char* FLANN_VERSION();$/;"	p	namespace:cvflann	signature:()
FLOAT	/usr/include/opencv2/core/core.hpp	/^        FLOAT=REAL, \/\/!< synonym or REAL$/;"	e	enum:cv::FileNode::__anon151
FLOAT32	/usr/include/opencv2/flann/general.h	/^	FLOAT32 = 8,$/;"	e	enum:cvflann::flann_datatype_t
FLOAT64	/usr/include/opencv2/flann/general.h	/^	FLOAT64 = 9$/;"	e	enum:cvflann::flann_datatype_t
FLOODFILL_FIXED_RANGE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { FLOODFILL_FIXED_RANGE = 1 << 16,$/;"	e	enum:cv::__anon48
FLOODFILL_MASK_ONLY	/usr/include/opencv2/imgproc/imgproc.hpp	/^       FLOODFILL_MASK_ONLY = 1 << 17 };$/;"	e	enum:cv::__anon48
FLOW	/usr/include/opencv2/core/core.hpp	/^        FLOW=8, \/\/!< compact representation of a sequence or mapping. Used only by YAML writer$/;"	e	enum:cv::FileNode::__anon151
FM_7POINT	/usr/include/opencv2/calib3d/calib3d.hpp	/^    FM_7POINT = CV_FM_7POINT, \/\/!< 7-point algorithm$/;"	e	enum:cv::__anon70
FM_8POINT	/usr/include/opencv2/calib3d/calib3d.hpp	/^    FM_8POINT = CV_FM_8POINT, \/\/!< 8-point algorithm$/;"	e	enum:cv::__anon70
FM_LMEDS	/usr/include/opencv2/calib3d/calib3d.hpp	/^    FM_LMEDS = CV_FM_LMEDS,  \/\/!< least-median algorithm$/;"	e	enum:cv::__anon70
FM_RANSAC	/usr/include/opencv2/calib3d/calib3d.hpp	/^    FM_RANSAC = CV_FM_RANSAC  \/\/!< RANSAC algorithm$/;"	e	enum:cv::__anon70
FONT_HERSHEY_COMPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_COMPLEX = 3,$/;"	e	enum:cv::__anon147
FONT_HERSHEY_COMPLEX_SMALL	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_COMPLEX_SMALL = 5,$/;"	e	enum:cv::__anon147
FONT_HERSHEY_DUPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_DUPLEX = 2,$/;"	e	enum:cv::__anon147
FONT_HERSHEY_PLAIN	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_PLAIN = 1,$/;"	e	enum:cv::__anon147
FONT_HERSHEY_SCRIPT_COMPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_SCRIPT_COMPLEX = 7,$/;"	e	enum:cv::__anon147
FONT_HERSHEY_SCRIPT_SIMPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_SCRIPT_SIMPLEX = 6,$/;"	e	enum:cv::__anon147
FONT_HERSHEY_SIMPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_SIMPLEX = 0,$/;"	e	enum:cv::__anon147
FONT_HERSHEY_TRIPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_TRIPLEX = 4,$/;"	e	enum:cv::__anon147
FONT_ITALIC	/usr/include/opencv2/core/core.hpp	/^    FONT_ITALIC = 16$/;"	e	enum:cv::__anon147
FULL_UV	/usr/include/opencv2/core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon145
FastAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^	FastAdjuster(int init_thresh = 20, bool nonmax = true);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int init_thresh = 20, bool nonmax = true)
FastAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FastAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
FastFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    FastFeatureDetector( int threshold=10, bool nonmaxSuppression=true );$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( int threshold=10, bool nonmaxSuppression=true )
FastFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FastFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
Fbd	/usr/include/opencv2/video/background_segm.hpp	/^    IplImage*              Fbd;$/;"	m	struct:CvFGDStatModel	access:public
Feature	/usr/include/opencv2/features2d/features2d.hpp	/^        Feature() : x1(0), y1(0), x2(0), y2(0) {}$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:()
Feature	/usr/include/opencv2/features2d/features2d.hpp	/^        Feature(int _x1, int _y1, int _x2, int _y2)$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:(int _x1, int _y1, int _x2, int _y2)
Feature	/usr/include/opencv2/features2d/features2d.hpp	/^    struct Feature$/;"	s	class:cv::FernClassifier	access:public
FeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FeatureDetector$/;"	c	namespace:cv
FeatureEvaluator	/usr/include/opencv2/objdetect/objdetect.hpp	/^class CV_EXPORTS FeatureEvaluator$/;"	c	namespace:cv
FernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    FernClassifier();$/;"	p	class:cv::FernClassifier	access:public	signature:()
FernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    FernClassifier(const FileNode& node);$/;"	p	class:cv::FernClassifier	access:public	signature:(const FileNode& node)
FernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    FernClassifier(const vector<vector<Point2f> >& points,$/;"	p	class:cv::FernClassifier	access:public	signature:(const vector<vector<Point2f> >& points, const vector<Mat>& refimgs, const vector<vector<int> >& labels=vector<vector<int> >(), int _nclasses=0, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
FernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FernClassifier$/;"	c	namespace:cv
FernDescriptorMatch	/usr/include/opencv2/features2d/features2d.hpp	/^typedef FernDescriptorMatcher FernDescriptorMatch;$/;"	t	namespace:cv
FernDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    FernDescriptorMatcher( const Params& params=Params() );$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( const Params& params=Params() )
FernDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FernDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
FileNode	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode();$/;"	p	class:cv::FileNode	access:public	signature:()
FileNode	/usr/include/opencv2/core/core.hpp	/^    FileNode(const CvFileStorage* fs, const CvFileNode* node);$/;"	p	class:cv::FileNode	access:public	signature:(const CvFileStorage* fs, const CvFileNode* node)
FileNode	/usr/include/opencv2/core/core.hpp	/^    FileNode(const FileNode& node);$/;"	p	class:cv::FileNode	access:public	signature:(const FileNode& node)
FileNode	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS FileNode;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
FileNode	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS_W_SIMPLE FileNode$/;"	c	namespace:cv
FileNode	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::FileNode() : fs(0), node(0) {}$/;"	f	class:cv::FileNode	signature:()
FileNode	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::FileNode(const CvFileStorage* _fs, const CvFileNode* _node)$/;"	f	class:cv::FileNode	signature:(const CvFileStorage* _fs, const CvFileNode* _node)
FileNode	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::FileNode(const FileNode& _node) : fs(_node.fs), node(_node.node) {}$/;"	f	class:cv::FileNode	signature:(const FileNode& _node)
FileNodeIterator	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
FileNodeIterator	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator(const CvFileStorage* fs, const CvFileNode* node, size_t ofs=0);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(const CvFileStorage* fs, const CvFileNode* node, size_t ofs=0)
FileNodeIterator	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator(const FileNodeIterator& it);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(const FileNodeIterator& it)
FileNodeIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS FileNodeIterator$/;"	c	namespace:cv
FileNodeIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS FileNodeIterator;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
FileStorage	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileStorage();$/;"	p	class:cv::FileStorage	access:public	signature:()
FileStorage	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileStorage(const string& filename, int flags);$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename, int flags)
FileStorage	/usr/include/opencv2/core/core.hpp	/^    FileStorage(CvFileStorage* fs);$/;"	p	class:cv::FileStorage	access:public	signature:(CvFileStorage* fs)
FileStorage	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS_W FileStorage$/;"	c	namespace:cv
FilterEngine	/usr/include/opencv2/imgproc/imgproc.hpp	/^    FilterEngine();$/;"	p	class:cv::FilterEngine	access:public	signature:()
FilterEngine	/usr/include/opencv2/imgproc/imgproc.hpp	/^    FilterEngine(const Ptr<BaseFilter>& _filter2D,$/;"	p	class:cv::FilterEngine	access:public	signature:(const Ptr<BaseFilter>& _filter2D, const Ptr<BaseRowFilter>& _rowFilter, const Ptr<BaseColumnFilter>& _columnFilter, int srcType, int dstType, int bufType, int _rowBorderType=BORDER_REPLICATE, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
FilterEngine	/usr/include/opencv2/imgproc/imgproc.hpp	/^class CV_EXPORTS FilterEngine$/;"	c	namespace:cv
FilterEngine_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS FilterEngine_GPU$/;"	c	namespace:cv::gpu
FindDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    void FindDescriptor(IplImage* patch, int n, std::vector<int>& desc_idxs, std::vector<int>& pose_idxs,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* patch, int n, std::vector<int>& desc_idxs, std::vector<int>& pose_idxs, std::vector<float>& distances, std::vector<float>& _scales, float* scale_ranges = 0) const
FindDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    void FindDescriptor(IplImage* patch, int& desc_idx, int& pose_idx, float& distance, float* _scale = 0, float* scale_ranges = 0) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* patch, int& desc_idx, int& pose_idx, float& distance, float* _scale = 0, float* scale_ranges = 0) const
FindDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    void FindDescriptor(IplImage* src, cv::Point2f pt, int& desc_idx, int& pose_idx, float& distance) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* src, cv::Point2f pt, int& desc_idx, int& pose_idx, float& distance) const
FindEtalon	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool FindEtalon( CvMat** imgs );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** imgs )
FindEtalon	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool FindEtalon( IplImage** imgs );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** imgs )
FlannBasedMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    FlannBasedMatcher( const Ptr<flann::IndexParams>& indexParams=new flann::KDTreeIndexParams(),$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( const Ptr<flann::IndexParams>& indexParams=new flann::KDTreeIndexParams(), const Ptr<flann::SearchParams>& searchParams=new flann::SearchParams() )
FlannBasedMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FlannBasedMatcher : public DescriptorMatcher$/;"	c	namespace:cv	inherits:DescriptorMatcher
Float	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float               Float;$/;"	m	struct:CvDefParam	access:public
ForestTree	/usr/include/opencv2/ml/ml.hpp	/^typedef CvForestTree ForestTree;$/;"	t	namespace:cv
Formatted	/usr/include/opencv2/core/operations.hpp	/^    Formatted(const Mat& m, const Formatter* fmt,$/;"	p	struct:cv::Formatted	access:public	signature:(const Mat& m, const Formatter* fmt, const int* params=0)
Formatted	/usr/include/opencv2/core/operations.hpp	/^    Formatted(const Mat& m, const Formatter* fmt,$/;"	p	struct:cv::Formatted	access:public	signature:(const Mat& m, const Formatter* fmt, const vector<int>& params)
Formatted	/usr/include/opencv2/core/operations.hpp	/^struct CV_EXPORTS Formatted$/;"	s	namespace:cv
Formatter	/usr/include/opencv2/core/operations.hpp	/^class CV_EXPORTS Formatter$/;"	c	namespace:cv
FreeParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void    FreeParam(CvDefParam** pp);$/;"	p	class:CvVSModule	access:private	signature:(CvDefParam** pp)
Ftd	/usr/include/opencv2/video/background_segm.hpp	/^    IplImage*              Ftd;$/;"	m	struct:CvFGDStatModel	access:public
FuzzyResizer	/usr/include/opencv2/contrib/contrib.hpp	/^        FuzzyResizer();$/;"	p	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:public	signature:()
FuzzyResizer	/usr/include/opencv2/contrib/contrib.hpp	/^    class FuzzyResizer$/;"	c	class:CvFuzzyMeanShiftTracker	access:private
G	/usr/include/opencv2/ml/ml.hpp	/^    double* G;$/;"	m	class:CvSVMSolver	access:public
GAMMA	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
GAUSSIAN	/usr/include/opencv2/ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon89
GC_BGD	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { GC_BGD    = 0,  \/\/!< background$/;"	e	enum:cv::__anon45
GC_EVAL	/usr/include/opencv2/imgproc/imgproc.hpp	/^       GC_EVAL            = 2$/;"	e	enum:cv::__anon46
GC_FGD	/usr/include/opencv2/imgproc/imgproc.hpp	/^       GC_FGD    = 1,  \/\/!< foreground$/;"	e	enum:cv::__anon45
GC_INIT_WITH_MASK	/usr/include/opencv2/imgproc/imgproc.hpp	/^       GC_INIT_WITH_MASK  = 1,$/;"	e	enum:cv::__anon46
GC_INIT_WITH_RECT	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { GC_INIT_WITH_RECT  = 0,$/;"	e	enum:cv::__anon46
GC_PR_BGD	/usr/include/opencv2/imgproc/imgproc.hpp	/^       GC_PR_BGD = 2,  \/\/!< most probably background$/;"	e	enum:cv::__anon45
GC_PR_FGD	/usr/include/opencv2/imgproc/imgproc.hpp	/^       GC_PR_FGD = 3   \/\/!< most probably foreground $/;"	e	enum:cv::__anon45
GEMM_1_T	/usr/include/opencv2/core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon107
GEMM_2_T	/usr/include/opencv2/core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon107
GEMM_3_T	/usr/include/opencv2/core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon107
GENTLE	/usr/include/opencv2/ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon85
GET_DEFAULT_EDGE_THRESHOLD	/usr/include/opencv2/features2d/features2d.hpp	/^        static double GET_DEFAULT_EDGE_THRESHOLD() { return 10.0; }$/;"	f	struct:cv::SIFT::DetectorParams	access:public	signature:()
GET_DEFAULT_MAGNIFICATION	/usr/include/opencv2/features2d/features2d.hpp	/^        static double GET_DEFAULT_MAGNIFICATION() { return 3.0; }$/;"	f	struct:cv::SIFT::DescriptorParams	access:public	signature:()
GET_DEFAULT_THRESHOLD	/usr/include/opencv2/features2d/features2d.hpp	/^        static double GET_DEFAULT_THRESHOLD() { return 0.04 \/ SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS \/ 2.0; }$/;"	f	struct:cv::SIFT::DetectorParams	access:public	signature:()
GET_LOWER_QUANT_PERC	/usr/include/opencv2/features2d/features2d.hpp	/^  static float GET_LOWER_QUANT_PERC() { return .03f; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
GET_MAX_SCALE	/usr/include/opencv2/features2d/features2d.hpp	/^        static float GET_MAX_SCALE() { return 1.5f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
GET_MIN_SCALE	/usr/include/opencv2/features2d/features2d.hpp	/^        static float GET_MIN_SCALE() { return 0.7f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
GET_STEP_SCALE	/usr/include/opencv2/features2d/features2d.hpp	/^        static float GET_STEP_SCALE() { return 1.2f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
GET_UPPER_QUANT_PERC	/usr/include/opencv2/features2d/features2d.hpp	/^  static float GET_UPPER_QUANT_PERC() { return .92f; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
GINI	/usr/include/opencv2/ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon86
GSD_HUE_LT	/usr/include/opencv2/contrib/contrib.hpp	/^        GSD_HUE_LT = 3,$/;"	e	enum:CvAdaptiveSkinDetector::__anon52
GSD_HUE_UT	/usr/include/opencv2/contrib/contrib.hpp	/^        GSD_HUE_UT = 33,$/;"	e	enum:CvAdaptiveSkinDetector::__anon52
GSD_INTENSITY_LT	/usr/include/opencv2/contrib/contrib.hpp	/^        GSD_INTENSITY_LT = 15,$/;"	e	enum:CvAdaptiveSkinDetector::__anon52
GSD_INTENSITY_UT	/usr/include/opencv2/contrib/contrib.hpp	/^        GSD_INTENSITY_UT = 250$/;"	e	enum:CvAdaptiveSkinDetector::__anon52
GaussianBlur	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void GaussianBlur(const GpuMat& src, GpuMat& dst, Size ksize, double sigma1, double sigma2 = 0);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size ksize, double sigma1, double sigma2 = 0)
GaussianBlur	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(gaussianBlur) void GaussianBlur( const Mat& src, CV_OUT Mat& dst, Size ksize,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, Size ksize, double sigma1, double sigma2=0, int borderType=BORDER_DEFAULT )
GeneratePCA	/usr/include/opencv2/features2d/features2d.hpp	/^    void GeneratePCA(const char* img_path, const char* images_list, int pose_count=500);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* img_path, const char* images_list, int pose_count=500)
GenerateSamples	/usr/include/opencv2/features2d/features2d.hpp	/^    void GenerateSamples(int pose_count, IplImage* frontal, int norm = 0);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, int norm = 0)
GenerateSamplesFast	/usr/include/opencv2/features2d/features2d.hpp	/^    void GenerateSamplesFast(IplImage* frontal, CvMat* pca_hr_avg,$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* frontal, CvMat* pca_hr_avg, CvMat* pca_hr_eigenvectors, OneWayDescriptor* pca_descriptors)
GenericDescriptorMatch	/usr/include/opencv2/features2d/features2d.hpp	/^typedef GenericDescriptorMatcher GenericDescriptorMatch;$/;"	t	namespace:cv
GenericDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    GenericDescriptorMatcher();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
GenericDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS GenericDescriptorMatcher$/;"	c	namespace:cv
GetBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob*     GetBlob(int index) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int index)
GetBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int BlobIndex) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex)
GetBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int BlobIndex)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobIndex)
GetBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int index) = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:(int index)
GetBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob*     GetBlobByID(int ID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int ID)
GetBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobID)
GetBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID)$/;"	f	class:CvBlobTrackPostProc	access:public	signature:(int BlobID)
GetBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
GetBlobHyp	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobHyp(int BlobIndex, int \/*hypothesis*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex, int )
GetBlobHypNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetBlobHypNum(int \/*BlobIdx*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int )
GetBlobIndexByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetBlobIndexByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
GetBlobNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int         GetBlobNum() = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:()
GetBlobNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetBlobNum() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
GetBlobNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetBlobNum() = 0;$/;"	p	class:CvBlobTracker	access:public	signature:()
GetBlobNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int GetBlobNum()$/;"	f	class:CvBlobSeq	access:public	signature:()
GetBlobTrack	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlobTrack* GetBlobTrack(int TrackIndex);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackIndex)
GetBlobTrackByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlobTrack* GetBlobTrackByID(int TrackID);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID)
GetBlobTrackNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int GetBlobTrackNum();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
GetCameraCount	/usr/include/opencv2/legacy/legacy.hpp	/^    int GetCameraCount() const { return cameraCount; }$/;"	f	class:CvCalibFilter	access:public	signature:() const
GetCameraParams	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual const CvCamera* GetCameraParams( int idx = 0 ) const;$/;"	p	class:CvCalibFilter	access:public	signature:( int idx = 0 ) const
GetCenter	/usr/include/opencv2/features2d/features2d.hpp	/^    CvPoint GetCenter() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
GetConfidence	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual double  GetConfidence(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* , IplImage* , IplImage* = NULL)
GetConfidence	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual double GetConfidence(CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/,$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL, IplImage* = NULL)
GetConfidenceList	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual double GetConfidenceList(CvBlobSeq* pBlobList, IplImage* pImg, IplImage* pImgFG = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(CvBlobSeq* pBlobList, IplImage* pImg, IplImage* pImgFG = NULL)
GetDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    const OneWayDescriptor* GetDescriptor(int desc_idx) const {return &m_descriptors[desc_idx];};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx) const
GetDescriptorCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetDescriptorCount() const {return m_train_feature_count;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetDescriptorPart	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetDescriptorPart(int desc_idx) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int desc_idx) const
GetEtalon	/usr/include/opencv2/legacy/legacy.hpp	/^        GetEtalon( int* paramCount = 0, const double** etalonParams = 0,$/;"	p	class:CvCalibFilter	access:public	signature:( int* paramCount = 0, const double** etalonParams = 0, int* pointCount = 0, const CvPoint2D32f** etalonPoints = 0 ) const
GetFGMask	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual IplImage*   GetFGMask(){return NULL;};$/;"	f	class:CvBlobTrackerAuto	access:public	signature:()
GetFV	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float*  GetFV(int index, int* pFVID) = 0; \/* Returns pointer to FV, if return 0 then FV not created *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(int index, int* pFVID)
GetFVMax	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float*  GetFVMax() = 0; \/* Returns pointer to array of maximal values of FV, if returns 0 then FVrange does not exist *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
GetFVMin	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float*  GetFVMin() = 0; \/* Returns pointer to array of minimal values of FV, if returns 0 then FVrange does not exist *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
GetFVNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetFVNum() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
GetFVSize	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     GetFVSize() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
GetFVVar	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float*  GetFVVar(){return NULL;}; \/* Returns pointer to array of variation of values of FV, if returns 0 then FVVar does not exist. *\/$/;"	f	class:CvBlobTrackFVGen	access:public	signature:()
GetFeatureName	/usr/include/opencv2/features2d/features2d.hpp	/^    const char* GetFeatureName() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
GetFrameCount	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual int GetFrameCount( int* framesTotal = 0 ) const;$/;"	p	class:CvCalibFilter	access:public	signature:( int* framesTotal = 0 ) const
GetHeight	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual double  GetHeight(CvBlob* pB) = 0;$/;"	p	class:CvBlobTrackAnalysisHeight	access:public	signature:(CvBlob* pB)
GetImage	/usr/include/opencv2/legacy/blobtrack.hpp	/^    IplImage* GetImage() { return m_image; }$/;"	f	class:CvImageDrawer	access:public	signature:()
GetInputPatchSize	/usr/include/opencv2/features2d/features2d.hpp	/^    CvSize GetInputPatchSize() const$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
GetLabeledFeatures	/usr/include/opencv2/features2d/features2d.hpp	/^    const vector<cv::KeyPoint>& GetLabeledFeatures() const {return m_train_features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:() const
GetLabeledFeatures	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<cv::KeyPoint>& GetLabeledFeatures() {return m_train_features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:()
GetLatestPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool GetLatestPoints( int idx, CvPoint2D32f** pts,$/;"	p	class:CvCalibFilter	access:public	signature:( int idx, CvPoint2D32f** pts, int* count, bool* found )
GetLeaves	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode** GetLeaves( const CvDTree* dtree, int& len );$/;"	p	class:CvGBTrees	access:protected	signature:( const CvDTree* dtree, int& len )
GetLowPCA	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetLowPCA(CvMat** avg, CvMat** eigenvectors)$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat** avg, CvMat** eigenvectors)
GetMask	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual IplImage* GetMask() = 0;$/;"	p	class:CvFGDetector	access:public	signature:()
GetMaxBorderSize	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int GetMaxBorderSize() const;$/;"	p	class:CvObjectDetector	access:public	signature:() const
GetMinWindowSize	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvSize GetMinWindowSize() const;$/;"	p	class:CvObjectDetector	access:public	signature:() const
GetModuleName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*   GetModuleName();$/;"	p	class:CvVSModule	access:public	signature:()
GetNickName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    const char* GetNickName();$/;"	p	class:CvVSModule	access:public	signature:()
GetObjectFeatureCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetObjectFeatureCount() const {return m_object_feature_count;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:() const
GetPCACoeffs	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat** GetPCACoeffs() const {return m_pca_coeffs;}$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
GetPCADimHigh	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPCADimHigh() const {return m_pca_dim_high;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetPCADimHigh	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPCADimHigh() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
GetPCADimLow	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPCADimLow() const {return m_pca_dim_low;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetPCADimLow	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPCADimLow() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
GetPCAFilename	/usr/include/opencv2/features2d/features2d.hpp	/^    static string GetPCAFilename () { return "pca.yml"; }$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:()
GetParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    double GetParam(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
GetParamComment	/usr/include/opencv2/legacy/blobtrack.hpp	/^    const char* GetParamComment(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
GetParamName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    const char* GetParamName(int index);$/;"	p	class:CvVSModule	access:public	signature:(int index)
GetParamPtr	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvDefParam* GetParamPtr(const char* name);$/;"	p	class:CvVSModule	access:private	signature:(const char* name)
GetParamPtr	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvDefParam* GetParamPtr(int index);$/;"	p	class:CvVSModule	access:private	signature:(int index)
GetParamStr	/usr/include/opencv2/legacy/blobtrack.hpp	/^    const char* GetParamStr(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
GetPatch	/usr/include/opencv2/features2d/features2d.hpp	/^    IplImage* GetPatch(int index);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int index)
GetPatchSize	/usr/include/opencv2/features2d/features2d.hpp	/^    CvSize GetPatchSize() const {return m_patch_size;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetPatchSize	/usr/include/opencv2/features2d/features2d.hpp	/^    CvSize GetPatchSize() const$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
GetPose	/usr/include/opencv2/features2d/features2d.hpp	/^    CvAffinePose GetPose(int index) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int index) const
GetPoseCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPoseCount() const {return m_pose_count;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetPyrLevels	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPyrLevels() const {return m_pyr_levels;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetRow	/usr/include/opencv2/ml/ml.hpp	/^    typedef float* (CvSVMSolver::*GetRow)( int i, float* row, float* dst, bool existed );$/;"	t	class:CvSVMSolver	access:public
GetState	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float       GetState(int BlobID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int BlobID)
GetState	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual float   GetState(int BlobID) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(int BlobID)
GetStateDesc	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual const char*       GetStateDesc(int BlobID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int BlobID)
GetStateDesc	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual const char*   GetStateDesc(int \/*BlobID*\/){return NULL;};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:(int )
GetStereoParams	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual const CvStereoCamera* GetStereoParams() const;$/;"	p	class:CvCalibFilter	access:public	signature:() const
GetTypeName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    const char*   GetTypeName();$/;"	p	class:CvVSModule	access:public	signature:()
GoodFeaturesToTrackDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    GoodFeaturesToTrackDetector( const GoodFeaturesToTrackDetector::Params& params=GoodFeaturesToTrackDetector::Params() );$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( const GoodFeaturesToTrackDetector::Params& params=GoodFeaturesToTrackDetector::Params() )
GoodFeaturesToTrackDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    GoodFeaturesToTrackDetector( int maxCorners, double qualityLevel, double minDistance,$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( int maxCorners, double qualityLevel, double minDistance, int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
GoodFeaturesToTrackDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS GoodFeaturesToTrackDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(Size size, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type)
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(Size size, int type, const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type, const Scalar& s)
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(Size size, int type, void* data, size_t step = Mat::AUTO_STEP);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type, void* data, size_t step = Mat::AUTO_STEP)
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(const GpuMat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m)
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(const GpuMat& m, const Range& rowRange, const Range& colRange);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m, const Range& rowRange, const Range& colRange)
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(const GpuMat& m, const Rect& roi);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m, const Rect& roi)
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(int rows, int cols, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type)
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(int rows, int cols, int type, const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type, const Scalar& s)
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(int rows, int cols, int type, void* data, size_t step = Mat::AUTO_STEP);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type, void* data, size_t step = Mat::AUTO_STEP)
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            explicit GpuMat (const Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Mat& m)
GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS GpuMat$/;"	c	namespace:cv::gpu
GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat() : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0) {}$/;"	f	class:cv::gpu::GpuMat	signature:()
GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(Size _size, int _type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0)$/;"	f	class:cv::gpu::GpuMat	signature:(Size _size, int _type)
GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(Size _size, int _type, const Scalar& _s)$/;"	f	class:cv::gpu::GpuMat	signature:(Size _size, int _type, const Scalar& _s)
GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(Size _size, int _type, void* _data, size_t _step)$/;"	f	class:cv::gpu::GpuMat	signature:(Size _size, int _type, void* _data, size_t _step)
GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(const GpuMat& m)$/;"	f	class:cv::gpu::GpuMat	signature:(const GpuMat& m)
GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(const GpuMat& m, const Range& rowRange, const Range& colRange)$/;"	f	class:cv::gpu::GpuMat	signature:(const GpuMat& m, const Range& rowRange, const Range& colRange)
GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(const GpuMat& m, const Rect& roi)$/;"	f	class:cv::gpu::GpuMat	signature:(const GpuMat& m, const Rect& roi)
GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(const Mat& m)$/;"	f	class:cv::gpu::GpuMat	signature:(const Mat& m)
GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(int _rows, int _cols, int _type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0)$/;"	f	class:cv::gpu::GpuMat	signature:(int _rows, int _cols, int _type)
GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(int _rows, int _cols, int _type, const Scalar& _s)$/;"	f	class:cv::gpu::GpuMat	signature:(int _rows, int _cols, int _type, const Scalar& _s)
GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(int _rows, int _cols, int _type, void* _data, size_t _step)$/;"	f	class:cv::gpu::GpuMat	signature:(int _rows, int _cols, int _type, void* _data, size_t _step)
GradientBoostingTreeParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvGBTreesParams GradientBoostingTreeParams;$/;"	t	namespace:cv
GradientBoostingTrees	/usr/include/opencv2/ml/ml.hpp	/^typedef CvGBTrees GradientBoostingTrees;$/;"	t	namespace:cv
Graph	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(int) cvReleaseLinearContorModelStorage(CvGraph** Graph);$/;"	v
GreaterEq	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS GreaterEq$/;"	c	namespace:cv
GreaterEqIdx	/usr/include/opencv2/core/operations.hpp	/^    GreaterEqIdx( const _Tp* _arr ) : arr(_arr) {}$/;"	f	class:cv::GreaterEqIdx	access:public	signature:( const _Tp* _arr )
GreaterEqIdx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS GreaterEqIdx$/;"	c	namespace:cv
GridAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    GridAdaptedFeatureDetector( const Ptr<FeatureDetector>& detector, int maxTotalKeypoints=1000,$/;"	p	class:cv::GridAdaptedFeatureDetector	access:public	signature:( const Ptr<FeatureDetector>& detector, int maxTotalKeypoints=1000, int gridRows=4, int gridCols=4 )
GridAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS GridAdaptedFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
H	/usr/include/opencv2/objdetect/objdetect.hpp	/^    float *H;$/;"	m	struct:__anon60	access:public
HAAR	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { HAAR = 0, LBP = 1 };$/;"	e	enum:cv::FeatureEvaluator::__anon61
HASH_BIT	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon148
HASH_SCALE	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon148
HAVE_IPL	/usr/include/opencv2/core/types_c.h	95;"	d
HAVE_TBB	/usr/include/opencv2/core/internal.hpp	133;"	d
HELLINGER	/usr/include/opencv2/flann/general.h	/^	HELLINGER = 6,$/;"	e	enum:cvflann::flann_distance_t
HG_AUTOSIZE	/usr/include/opencv2/highgui/highgui_c.h	392;"	d
HIK	/usr/include/opencv2/flann/general.h	/^	HIK       = 5,$/;"	e	enum:cvflann::flann_distance_t
HOGDescriptor	/usr/include/opencv2/gpu/gpu.hpp	/^            HOGDescriptor(Size win_size=Size(64, 128), Size block_size=Size(16, 16), $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(Size win_size=Size(64, 128), Size block_size=Size(16, 16), Size block_stride=Size(8, 8), Size cell_size=Size(8, 8), int nbins=9, double win_sigma=DEFAULT_WIN_SIGMA, double threshold_L2hys=0.2, bool gamma_correction=true, int nlevels=DEFAULT_NLEVELS)
HOGDescriptor	/usr/include/opencv2/gpu/gpu.hpp	/^        struct CV_EXPORTS HOGDescriptor$/;"	s	namespace:cv::gpu
HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor() : winSize(64,128), blockSize(16,16), blockStride(8,8),$/;"	f	struct:cv::HOGDescriptor	access:public	signature:()
HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride,$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture=1, double _winSigma=-1, int _histogramNormType=HOGDescriptor::L2Hys, double _L2HysThreshold=0.2, bool _gammaCorrection=false, int _nlevels=HOGDescriptor::DEFAULT_NLEVELS)
HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor(const String& filename)$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(const String& filename)
HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^    HOGDescriptor(const HOGDescriptor& d)$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(const HOGDescriptor& d)
HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^struct CV_EXPORTS_W HOGDescriptor$/;"	s	namespace:cv
HUBER_LOSS	/usr/include/opencv2/ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon87
Hamming	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS Hamming$/;"	s	namespace:cv
HammingLUT	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS HammingLUT$/;"	s	namespace:cv
Hdr	/usr/include/opencv2/core/core.hpp	/^        Hdr(int _dims, const int* _sizes, int _type);$/;"	p	struct:cv::SparseMat::Hdr	access:public	signature:(int _dims, const int* _sizes, int _type)
Hdr	/usr/include/opencv2/core/core.hpp	/^    struct CV_EXPORTS Hdr$/;"	s	class:cv::SparseMat	access:public
Hdr	/usr/include/opencv2/core/operations.hpp	/^        Hdr() : data(0), datastart(0), refcount(0), size(0), capacity(0) {};$/;"	f	struct:cv::Vector::Hdr	access:public	signature:()
Hdr	/usr/include/opencv2/core/operations.hpp	/^    struct CV_EXPORTS Hdr$/;"	s	class:cv::Vector	access:public
Heap	/usr/include/opencv2/flann/heap.h	/^	Heap(int size)$/;"	f	class:cvflann::Heap	access:public	signature:(int size)
Heap	/usr/include/opencv2/flann/heap.h	/^class Heap {$/;"	c	namespace:cvflann
Height	/usr/include/opencv2/core/wimage.hpp	/^    int Height() const {return image_->height; }$/;"	f	class:cv::WImage	access:public	signature:() const
HistType	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     HistType; \/* see Prob.h *\/$/;"	m	struct:CvBlobTrackerParamLH	access:public
Histogram	/usr/include/opencv2/contrib/contrib.hpp	/^        Histogram();$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:()
Histogram	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS Histogram$/;"	c	class:CvAdaptiveSkinDetector	access:private
HistogramSize	/usr/include/opencv2/contrib/contrib.hpp	/^            HistogramSize = (GSD_HUE_UT - GSD_HUE_LT + 1)$/;"	e	enum:CvAdaptiveSkinDetector::Histogram::__anon53
HoughCircles	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(houghCircles) void HoughCircles( const Mat& image, CV_OUT vector<Vec3f>& circles,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT vector<Vec3f>& circles, int method, double dp, double minDist, double param1=100, double param2=100, int minRadius=0, int maxRadius=0 )
HoughLines	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(houghLines) void HoughLines( const Mat& image, CV_OUT vector<Vec2f>& lines,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT vector<Vec2f>& lines, double rho, double theta, int threshold, double srn=0, double stn=0 )
HoughLinesP	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(houghLinesP) void HoughLinesP( Mat& image, CV_OUT vector<Vec4i>& lines,$/;"	p	namespace:cv	signature:( Mat& image, CV_OUT vector<Vec4i>& lines, double rho, double theta, int threshold, double minLineLength=0, double maxLineGap=0 )
HuMoments	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void HuMoments( const Moments& moments, double hu[7] );$/;"	p	namespace:cv	signature:( const Moments& moments, double hu[7] )
ID	/usr/include/opencv2/core/types_c.h	/^    int  ID;                \/* version (=0)*\/$/;"	m	struct:_IplImage	access:public
ID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     ID;  \/* blob ID         *\/$/;"	m	struct:CvBlob	access:public
IDENTITY	/usr/include/opencv2/ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon89
INPAINT_NS	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INPAINT_NS=0, \/\/ Navier-Stokes algorithm$/;"	e	enum:cv::__anon47
INPAINT_TELEA	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INPAINT_TELEA=1 \/\/ A. Telea algorithm$/;"	e	enum:cv::__anon47
INSIDE_MAP	/usr/include/opencv2/core/core.hpp	/^        INSIDE_MAP=4$/;"	e	enum:cv::FileStorage::__anon150
INT	/usr/include/opencv2/core/core.hpp	/^        INT=1, \/\/!< an integer$/;"	e	enum:cv::FileNode::__anon151
INT16	/usr/include/opencv2/flann/general.h	/^	INT16 = 1,$/;"	e	enum:cvflann::flann_datatype_t
INT32	/usr/include/opencv2/flann/general.h	/^	INT32 = 2,$/;"	e	enum:cvflann::flann_datatype_t
INT64	/usr/include/opencv2/flann/general.h	/^	INT64 = 3,$/;"	e	enum:cvflann::flann_datatype_t
INT8	/usr/include/opencv2/flann/general.h	/^	INT8 = 0,$/;"	e	enum:cvflann::flann_datatype_t
INTER_AREA	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_AREA=3, \/\/!< area-based (or super) interpolation$/;"	e	enum:cv::__anon40
INTER_BITS	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { INTER_BITS=5, INTER_BITS2=INTER_BITS*2,$/;"	e	enum:cv::__anon41
INTER_BITS2	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { INTER_BITS=5, INTER_BITS2=INTER_BITS*2,$/;"	e	enum:cv::__anon41
INTER_CUBIC	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_CUBIC=2, \/\/!< bicubic interpolation$/;"	e	enum:cv::__anon40
INTER_LANCZOS4	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_LANCZOS4=4, \/\/!< Lanczos interpolation over 8x8 neighborhood$/;"	e	enum:cv::__anon40
INTER_LINEAR	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_LINEAR=1, \/\/!< bilinear interpolation$/;"	e	enum:cv::__anon40
INTER_MAX	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_MAX=7,$/;"	e	enum:cv::__anon40
INTER_NEAREST	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_NEAREST=0, \/\/!< nearest neighbor interpolation$/;"	e	enum:cv::__anon40
INTER_TAB_SIZE	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_TAB_SIZE=(1<<INTER_BITS),$/;"	e	enum:cv::__anon41
INTER_TAB_SIZE2	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_TAB_SIZE2=INTER_TAB_SIZE*INTER_TAB_SIZE };    $/;"	e	enum:cv::__anon41
IPL2CV_DEPTH	/usr/include/opencv2/core/types_c.h	699;"	d
IPL_ALIGN_16BYTES	/usr/include/opencv2/core/types_c.h	429;"	d
IPL_ALIGN_32BYTES	/usr/include/opencv2/core/types_c.h	430;"	d
IPL_ALIGN_4BYTES	/usr/include/opencv2/core/types_c.h	427;"	d
IPL_ALIGN_8BYTES	/usr/include/opencv2/core/types_c.h	428;"	d
IPL_ALIGN_DWORD	/usr/include/opencv2/core/types_c.h	432;"	d
IPL_ALIGN_QWORD	/usr/include/opencv2/core/types_c.h	433;"	d
IPL_BORDER_CONSTANT	/usr/include/opencv2/core/types_c.h	435;"	d
IPL_BORDER_REFLECT	/usr/include/opencv2/core/types_c.h	437;"	d
IPL_BORDER_REFLECT_101	/usr/include/opencv2/core/types_c.h	515;"	d
IPL_BORDER_REPLICATE	/usr/include/opencv2/core/types_c.h	436;"	d
IPL_BORDER_TRANSPARENT	/usr/include/opencv2/core/types_c.h	516;"	d
IPL_BORDER_WRAP	/usr/include/opencv2/core/types_c.h	438;"	d
IPL_DATA_ORDER_PIXEL	/usr/include/opencv2/core/types_c.h	421;"	d
IPL_DATA_ORDER_PLANE	/usr/include/opencv2/core/types_c.h	422;"	d
IPL_DEPTH_16S	/usr/include/opencv2/core/types_c.h	418;"	d
IPL_DEPTH_16U	/usr/include/opencv2/core/types_c.h	414;"	d
IPL_DEPTH_1U	/usr/include/opencv2/core/types_c.h	412;"	d
IPL_DEPTH_32F	/usr/include/opencv2/core/types_c.h	415;"	d
IPL_DEPTH_32S	/usr/include/opencv2/core/types_c.h	419;"	d
IPL_DEPTH_64F	/usr/include/opencv2/core/types_c.h	529;"	d
IPL_DEPTH_8S	/usr/include/opencv2/core/types_c.h	417;"	d
IPL_DEPTH_8U	/usr/include/opencv2/core/types_c.h	413;"	d
IPL_DEPTH_SIGN	/usr/include/opencv2/core/types_c.h	410;"	d
IPL_GAUSSIAN_5x5	/usr/include/opencv2/legacy/compat.hpp	/^    IPL_GAUSSIAN_5x5 = 7$/;"	e	enum:__anon180
IPL_IMAGE_DATA	/usr/include/opencv2/core/types_c.h	509;"	d
IPL_IMAGE_HEADER	/usr/include/opencv2/core/types_c.h	508;"	d
IPL_IMAGE_MAGIC_VAL	/usr/include/opencv2/core/types_c.h	518;"	d
IPL_IMAGE_ROI	/usr/include/opencv2/core/types_c.h	510;"	d
IPL_ORIGIN_BL	/usr/include/opencv2/core/types_c.h	425;"	d
IPL_ORIGIN_TL	/usr/include/opencv2/core/types_c.h	424;"	d
IPPI_CALL	/usr/include/opencv2/core/internal.hpp	123;"	d
ImageData	/usr/include/opencv2/core/wimage.hpp	/^    T* ImageData() { return reinterpret_cast<T*>(image_->imageData); }$/;"	f	class:cv::WImage	access:public	signature:()
ImageData	/usr/include/opencv2/core/wimage.hpp	/^    const T* ImageData() const {$/;"	f	class:cv::WImage	access:public	signature:() const
Index	/usr/include/opencv2/flann/flann.hpp	/^typedef Index_<float> Index;$/;"	t	namespace:cv::flann
Index	/usr/include/opencv2/flann/flann_base.hpp	/^	Index(const Matrix<T>& features, const IndexParams& params);$/;"	p	class:cvflann::Index	access:public	signature:(const Matrix<T>& features, const IndexParams& params)
Index	/usr/include/opencv2/flann/flann_base.hpp	/^Index<T>::Index(const Matrix<T>& dataset, const IndexParams& params)$/;"	f	class:cvflann::Index	signature:(const Matrix<T>& dataset, const IndexParams& params)
Index	/usr/include/opencv2/flann/flann_base.hpp	/^class CV_EXPORTS Index {$/;"	c	namespace:cvflann
IndexHeader	/usr/include/opencv2/flann/saving.h	/^struct CV_EXPORTS IndexHeader$/;"	s	namespace:cvflann
IndexParams	/usr/include/opencv2/flann/general.h	/^	IndexParams(flann_algorithm_t algorithm_) : algorithm(algorithm_) {};$/;"	f	struct:cvflann::IndexParams	access:protected	signature:(flann_algorithm_t algorithm_)
IndexParams	/usr/include/opencv2/flann/general.h	/^struct CV_EXPORTS IndexParams {$/;"	s	namespace:cvflann
Index_	/usr/include/opencv2/flann/flann.hpp	/^	Index_(const Mat& features, const IndexParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& features, const IndexParams& params)
Index_	/usr/include/opencv2/flann/flann.hpp	/^Index_<T>::Index_(const Mat& dataset, const IndexParams& params)$/;"	f	class:cv::flann::Index_	signature:(const Mat& dataset, const IndexParams& params)
Index_	/usr/include/opencv2/flann/flann.hpp	/^class CV_EXPORTS Index_ {$/;"	c	namespace:cv::flann
Init	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Init(CvBlob* pBlobInit, IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:(CvBlob* pBlobInit, IplImage* pImg, IplImage* pImgFG = NULL)
Initialize	/usr/include/opencv2/features2d/features2d.hpp	/^    void Initialize(int pose_count, IplImage* frontal, const char* feature_name = 0, int norm = 0);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, const char* feature_name = 0, int norm = 0)
InitializeDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeDescriptor(int desc_idx, IplImage* train_image, const char* feature_label);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx, IplImage* train_image, const char* feature_label)
InitializeDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeDescriptor(int desc_idx, IplImage* train_image, const cv::KeyPoint& keypoint, const char* feature_label);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx, IplImage* train_image, const cv::KeyPoint& keypoint, const char* feature_label)
InitializeDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeDescriptors(IplImage* train_image, const vector<cv::KeyPoint>& features,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* train_image, const vector<cv::KeyPoint>& features, const char* feature_label = , int desc_start_idx = 0)
InitializeFast	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeFast(int pose_count, IplImage* frontal, const char* feature_name,$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, const char* feature_name, CvMat* pca_hr_avg, CvMat* pca_hr_eigenvectors, OneWayDescriptor* pca_descriptors)
InitializeObjectDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeObjectDescriptors(IplImage* train_image, const vector<cv::KeyPoint>& features,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(IplImage* train_image, const vector<cv::KeyPoint>& features, const char* feature_label, int desc_start_idx = 0, float scale = 1.0f, int is_background = 0)
InitializePCACoeffs	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializePCACoeffs(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
InitializePoseTransforms	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializePoseTransforms();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
InitializePoses	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializePoses();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
InitializeTransformsFromPoses	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeTransformsFromPoses();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
Int	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int                 Int;$/;"	m	struct:CvDefParam	access:public
Ipl	/usr/include/opencv2/core/wimage.hpp	/^    IplImage* Ipl() {return image_; }$/;"	f	class:cv::WImage	access:public	signature:()
Ipl	/usr/include/opencv2/core/wimage.hpp	/^    const IplImage* Ipl() const {return image_; }$/;"	f	class:cv::WImage	access:public	signature:() const
IplConvKernel	/usr/include/opencv2/core/types_c.h	/^IplConvKernel;$/;"	t	typeref:struct:_IplConvKernel
IplConvKernelFP	/usr/include/opencv2/core/types_c.h	/^IplConvKernelFP;$/;"	t	typeref:struct:_IplConvKernelFP
IplImage	/usr/include/opencv2/core/types_c.h	/^IplImage;$/;"	t	typeref:struct:_IplImage
IplROI	/usr/include/opencv2/core/types_c.h	/^IplROI;$/;"	t	typeref:struct:_IplROI
IplTileInfo	/usr/include/opencv2/core/types_c.h	/^typedef struct _IplTileInfo IplTileInfo;$/;"	t	typeref:struct:_IplTileInfo
IsCalibrated	/usr/include/opencv2/legacy/legacy.hpp	/^    bool IsCalibrated() const { return isCalibrated; }$/;"	f	class:CvCalibFilter	access:public	signature:() const
IsDescriptorObject	/usr/include/opencv2/features2d/features2d.hpp	/^    int IsDescriptorObject(int desc_idx) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int desc_idx) const
IsModuleName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     IsModuleName(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
IsModuleTypeName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     IsModuleTypeName(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
IsNull	/usr/include/opencv2/core/wimage.hpp	/^    bool IsNull() const {return WImage<T>::image_ == NULL; }$/;"	f	class:cv::WImageBuffer	access:public	signature:() const
IsNull	/usr/include/opencv2/core/wimage.hpp	/^    bool IsNull() const {return WImage<T>::image_ == NULL; }$/;"	f	class:cv::WImageBufferC	access:public	signature:() const
IsParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int  IsParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
Item	/usr/include/opencv2/flann/result_set.h	/^	struct Item {$/;"	s	class:cvflann::RadiusResultSet	access:private
Iterator	/usr/include/opencv2/flann/object_factory.h	/^   typedef typename std::map<UniqueIdType, CreateObjectFunc>::iterator Iterator;$/;"	t	class:cvflann::ObjectFactory	access:public
Ithreshold	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int Ithreshold;$/;"	m	struct:CvStereoGCState	access:public
J	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> J;$/;"	m	class:CvLevMarq	access:public
JtErr	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtErr;$/;"	m	class:CvLevMarq	access:public
JtJ	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJ;$/;"	m	class:CvLevMarq	access:public
JtJN	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJN;$/;"	m	class:CvLevMarq	access:public
JtJV	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJV;$/;"	m	class:CvLevMarq	access:public
JtJW	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJW;$/;"	m	class:CvLevMarq	access:public
JtJ_diag	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* JtJ_diag; \/\/diagonal of JtJ,  used to backup diagonal elements before augmentation$/;"	m	class:cv::LevMarqSparse	access:protected
K	/usr/include/opencv2/calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
KDTREE	/usr/include/opencv2/flann/general.h	/^	KDTREE = 1,$/;"	e	enum:cvflann::flann_algorithm_t
KDTree	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP KDTree();$/;"	p	class:cv::KDTree	access:public	signature:()
KDTree	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP KDTree(const Mat& _points, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(const Mat& _points, bool copyAndReorderPoints=false)
KDTree	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP KDTree(const Mat& _points, const Mat& _labels, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(const Mat& _points, const Mat& _labels, bool copyAndReorderPoints=false)
KDTree	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS_W KDTree$/;"	c	namespace:cv
KDTreeCostData	/usr/include/opencv2/flann/autotuned_index.h	/^    typedef pair<CostData, KDTreeIndexParams> KDTreeCostData;$/;"	t	class:cvflann::AutotunedIndex	access:private
KDTreeIndex	/usr/include/opencv2/flann/kdtree_index.h	/^	KDTreeIndex(const Matrix<ELEM_TYPE>& inputData, const KDTreeIndexParams& params = KDTreeIndexParams() ) :$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(const Matrix<ELEM_TYPE>& inputData, const KDTreeIndexParams& params = KDTreeIndexParams() )
KDTreeIndex	/usr/include/opencv2/flann/kdtree_index.h	/^class KDTreeIndex : public NNIndex<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:NNIndex
KDTreeIndexParams	/usr/include/opencv2/flann/kdtree_index.h	/^	KDTreeIndexParams(int trees_ = 4) : IndexParams(KDTREE), trees(trees_) {};$/;"	f	struct:cvflann::KDTreeIndexParams	access:public	signature:(int trees_ = 4)
KDTreeIndexParams	/usr/include/opencv2/flann/kdtree_index.h	/^struct CV_EXPORTS KDTreeIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
KERNEL_ASYMMETRICAL	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon37
KERNEL_GENERAL	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon37
KERNEL_INTEGER	/usr/include/opencv2/imgproc/imgproc.hpp	/^       KERNEL_SMOOTH=4, KERNEL_INTEGER=8 };$/;"	e	enum:cv::__anon37
KERNEL_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^    static const int KERNEL_SIZE = 9;$/;"	m	class:cv::BriefDescriptorExtractor	access:public
KERNEL_SMOOTH	/usr/include/opencv2/imgproc/imgproc.hpp	/^       KERNEL_SMOOTH=4, KERNEL_INTEGER=8 };$/;"	e	enum:cv::__anon37
KERNEL_SYMMETRICAL	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon37
KL	/usr/include/opencv2/flann/general.h	/^	KL        = 8,$/;"	e	enum:cvflann::flann_distance_t
KMEANS	/usr/include/opencv2/flann/general.h	/^	KMEANS = 2,$/;"	e	enum:cvflann::flann_algorithm_t
KMEANS_PP_CENTERS	/usr/include/opencv2/core/core.hpp	/^    KMEANS_PP_CENTERS=2,     \/\/ Uses k-Means++ algorithm for initialization$/;"	e	enum:cv::__anon146
KMEANS_RANDOM_CENTERS	/usr/include/opencv2/core/core.hpp	/^    KMEANS_RANDOM_CENTERS=0, \/\/ Chooses random centers for k-Means initialization$/;"	e	enum:cv::__anon146
KMEANS_USE_INITIAL_LABELS	/usr/include/opencv2/core/core.hpp	/^    KMEANS_USE_INITIAL_LABELS=1 \/\/ Uses the user-provided labels for K-Means initialization$/;"	e	enum:cv::__anon146
KMeansCostData	/usr/include/opencv2/flann/autotuned_index.h	/^    typedef pair<CostData, KMeansIndexParams> KMeansCostData;$/;"	t	class:cvflann::AutotunedIndex	access:private
KMeansIndex	/usr/include/opencv2/flann/kmeans_index.h	/^	KMeansIndex(const Matrix<ELEM_TYPE>& inputData, const KMeansIndexParams& params = KMeansIndexParams() )$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(const Matrix<ELEM_TYPE>& inputData, const KMeansIndexParams& params = KMeansIndexParams() )
KMeansIndex	/usr/include/opencv2/flann/kmeans_index.h	/^class KMeansIndex : public NNIndex<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:NNIndex
KMeansIndexParams	/usr/include/opencv2/flann/kmeans_index.h	/^	KMeansIndexParams(int branching_ = 32, int iterations_ = 11,$/;"	f	struct:cvflann::KMeansIndexParams	access:public	signature:(int branching_ = 32, int iterations_ = 11, flann_centers_init_t centers_init_ = CENTERS_RANDOM, float cb_index_ = 0.2 )
KMeansIndexParams	/usr/include/opencv2/flann/kmeans_index.h	/^struct CV_EXPORTS KMeansIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
KMeansNode	/usr/include/opencv2/flann/kmeans_index.h	/^    typedef KMeansNodeSt* KMeansNode;$/;"	t	class:cvflann::KMeansIndex	access:private
KMeansNodeSt	/usr/include/opencv2/flann/kmeans_index.h	/^	struct KMeansNodeSt	{$/;"	s	class:cvflann::KMeansIndex	access:private
KNNResultSet	/usr/include/opencv2/flann/result_set.h	/^	KNNResultSet(int capacity_, ELEM_TYPE* target_ = NULL, int veclen_ = 0 ) :$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(int capacity_, ELEM_TYPE* target_ = NULL, int veclen_ = 0 )
KNNResultSet	/usr/include/opencv2/flann/result_set.h	/^class KNNResultSet : public ResultSet<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:ResultSet
KNearest	/usr/include/opencv2/ml/ml.hpp	/^typedef CvKNearest KNearest;$/;"	t	namespace:cv
KULLBACK_LEIBLER	/usr/include/opencv2/flann/general.h	/^	KULLBACK_LEIBLER        = 8$/;"	e	enum:cvflann::flann_distance_t
KalmGainMatr	/usr/include/opencv2/video/tracking.hpp	/^    float* KalmGainMatr;        \/* =gain->data.fl *\/$/;"	m	struct:CvKalman	access:public
KalmanFilter	/usr/include/opencv2/video/tracking.hpp	/^    CV_WRAP KalmanFilter();$/;"	p	class:cv::KalmanFilter	access:public	signature:()
KalmanFilter	/usr/include/opencv2/video/tracking.hpp	/^    CV_WRAP KalmanFilter(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F);$/;"	p	class:cv::KalmanFilter	access:public	signature:(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F)
KalmanFilter	/usr/include/opencv2/video/tracking.hpp	/^class CV_EXPORTS_W KalmanFilter$/;"	c	namespace:cv
KeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP KeyPoint() : pt(0,0), size(0), angle(-1), response(0), octave(0), class_id(-1) {}$/;"	f	class:cv::KeyPoint	access:public	signature:()
KeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP KeyPoint(float x, float y, float _size, float _angle=-1,$/;"	f	class:cv::KeyPoint	access:public	signature:(float x, float y, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1)
KeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^    KeyPoint(Point2f _pt, float _size, float _angle=-1,$/;"	f	class:cv::KeyPoint	access:public	signature:(Point2f _pt, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1)
KeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS_W_SIMPLE KeyPoint$/;"	c	namespace:cv
KeyPointCollection	/usr/include/opencv2/features2d/features2d.hpp	/^        KeyPointCollection( const KeyPointCollection& collection );$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( const KeyPointCollection& collection )
KeyPointCollection	/usr/include/opencv2/features2d/features2d.hpp	/^        KeyPointCollection();$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:()
KeyPointCollection	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS KeyPointCollection$/;"	c	class:cv::GenericDescriptorMatcher	access:protected
L1	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS L1$/;"	s	namespace:cv
L2	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS L2$/;"	s	namespace:cv
L2Hys	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { L2Hys=0 };$/;"	e	enum:cv::HOGDescriptor::__anon64
L2HysThreshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP double L2HysThreshold;$/;"	m	struct:cv::HOGDescriptor	access:public
LBP	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { HAAR = 0, LBP = 1 };$/;"	e	enum:cv::FeatureEvaluator::__anon61
LDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    LDetector();$/;"	p	class:cv::LDetector	access:public	signature:()
LDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    LDetector(int _radius, int _threshold, int _nOctaves,$/;"	p	class:cv::LDetector	access:public	signature:(int _radius, int _threshold, int _nOctaves, int _nViews, double _baseFeatureSize, double _clusteringDistance)
LDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS LDetector$/;"	c	namespace:cv
LINEAR	/usr/include/opencv2/flann/general.h	/^	LINEAR = 0,$/;"	e	enum:cvflann::flann_algorithm_t
LINEAR	/usr/include/opencv2/ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon79
LMEDS	/usr/include/opencv2/calib3d/calib3d.hpp	/^    LMEDS=CV_LMEDS, \/\/!< least-median algorithm$/;"	e	enum:cv::__anon67
LOGIT	/usr/include/opencv2/ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon85
LOG_ERROR	/usr/include/opencv2/flann/general.h	/^	LOG_ERROR = 2,$/;"	e	enum:cvflann::flann_log_level_t
LOG_FATAL	/usr/include/opencv2/flann/general.h	/^	LOG_FATAL = 1,$/;"	e	enum:cvflann::flann_log_level_t
LOG_INFO	/usr/include/opencv2/flann/general.h	/^	LOG_INFO = 4$/;"	e	enum:cvflann::flann_log_level_t
LOG_NONE	/usr/include/opencv2/flann/general.h	/^	LOG_NONE = 0,$/;"	e	enum:cvflann::flann_log_level_t
LOG_WARN	/usr/include/opencv2/flann/general.h	/^	LOG_WARN = 3,$/;"	e	enum:cvflann::flann_log_level_t
LU	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS int LU(double* A, int m, double* b, int n);$/;"	p	namespace:cv	signature:(double* A, int m, double* b, int n)
LU	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS int LU(float* A, int m, float* b, int n);$/;"	p	namespace:cv	signature:(float* A, int m, float* b, int n)
LUT	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void LUT(const Mat& src, const Mat& lut, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, const Mat& lut, CV_OUT Mat& dst)
LUT	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void LUT(const GpuMat& src, const Mat& lut, GpuMat& dst);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const Mat& lut, GpuMat& dst)
Laplacian	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void Laplacian(const GpuMat& src, GpuMat& dst, int ddepth, int ksize = 1, double scale = 1);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int ksize = 1, double scale = 1)
Laplacian	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(laplacian) void Laplacian( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, int ksize=1, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
Lc	/usr/include/opencv2/video/background_segm.hpp	/^    int    Lc;			\/* Quantized levels per 'color' component. Power of two, typically 32, 64 or 128.				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
Lcc	/usr/include/opencv2/video/background_segm.hpp	/^    int    Lcc;			\/* Quantized levels per 'color co-occurrence' component.  Power of two, typically 16, 32 or 64.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
LeftEyeRect	/usr/include/opencv2/legacy/legacy.hpp	/^    CvRect LeftEyeRect;$/;"	m	struct:CvFace	access:public
LessThan	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS LessThan$/;"	c	namespace:cv
LessThanIdx	/usr/include/opencv2/core/operations.hpp	/^    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}$/;"	f	class:cv::LessThanIdx	access:public	signature:( const _Tp* _arr )
LessThanIdx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS LessThanIdx$/;"	c	namespace:cv
LevMarqSparse	/usr/include/opencv2/contrib/contrib.hpp	/^        LevMarqSparse();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
LevMarqSparse	/usr/include/opencv2/contrib/contrib.hpp	/^        LevMarqSparse(int npoints, \/\/ number of points$/;"	p	class:cv::LevMarqSparse	access:public	signature:(int npoints, int ncameras, int nPointParams, int nCameraParams, int nErrParams, Mat& visibility, Mat& P0, Mat& X, TermCriteria criteria, void (CV_CDECL * fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data), void (CV_CDECL * func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data), void* data )
LevMarqSparse	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS LevMarqSparse$/;"	c	namespace:cv
LineIterator	/usr/include/opencv2/core/core.hpp	/^    LineIterator( const Mat& img, Point pt1, Point pt2,$/;"	p	class:cv::LineIterator	access:public	signature:( const Mat& img, Point pt1, Point pt2, int connectivity=8, bool leftToRight=false )
LineIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS LineIterator$/;"	c	namespace:cv
LinearIndex	/usr/include/opencv2/flann/linear_index.h	/^	LinearIndex(const Matrix<ELEM_TYPE>& inputData, const LinearIndexParams& params = LinearIndexParams() ) :$/;"	f	class:cvflann::LinearIndex	access:public	signature:(const Matrix<ELEM_TYPE>& inputData, const LinearIndexParams& params = LinearIndexParams() )
LinearIndex	/usr/include/opencv2/flann/linear_index.h	/^class LinearIndex : public NNIndex<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:NNIndex
LinearIndexParams	/usr/include/opencv2/flann/linear_index.h	/^	LinearIndexParams() : IndexParams(LINEAR) {};$/;"	f	struct:cvflann::LinearIndexParams	access:public	signature:()
LinearIndexParams	/usr/include/opencv2/flann/linear_index.h	/^struct CV_EXPORTS LinearIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
Load	/usr/include/opencv2/legacy/blobtrack.hpp	/^    bool Load( const char* \/*detector_file_name*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const char* = 0 )
Load	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Load(CvFileStorage* fs, CvFileNode* node)$/;"	f	class:CvBlobSeq	access:public	signature:(CvFileStorage* fs, CvFileNode* node)
LoadCameraParams	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool LoadCameraParams( const char* filename );$/;"	p	class:CvCalibFilter	access:public	signature:( const char* filename )
LoadPCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    int LoadPCADescriptors(const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const FileNode &fn)
LoadPCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    int LoadPCADescriptors(const char* filename);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* filename)
LoadPCAall	/usr/include/opencv2/features2d/features2d.hpp	/^    void LoadPCAall (const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:protected	signature:(const FileNode &fn)
LoadState	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void LoadState(CvFileStorage*, CvFileNode*);$/;"	p	class:CvVSModule	access:public	signature:(CvFileStorage*, CvFileNode*)
Logger	/usr/include/opencv2/flann/logger.h	/^    Logger() : stream(stdout), logLevel(LOG_WARN) {};$/;"	f	class:cvflann::Logger	access:public	signature:()
Logger	/usr/include/opencv2/flann/logger.h	/^class CV_EXPORTS Logger$/;"	c	namespace:cvflann
MAGIC_MASK	/usr/include/opencv2/core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon141
MAGIC_VAL	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon148
MAGIC_VAL	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon142
MANHATTAN	/usr/include/opencv2/flann/general.h	/^	MANHATTAN = 2,$/;"	e	enum:cvflann::flann_distance_t
MAP	/usr/include/opencv2/core/core.hpp	/^        MAP=6, \/\/!< mapping$/;"	e	enum:cv::FileNode::__anon151
MAX	/usr/include/opencv2/core/types_c.h	267;"	d
MAX_CAMERAS	/usr/include/opencv2/legacy/legacy.hpp	/^    enum { MAX_CAMERAS = 3 };$/;"	e	enum:CvCalibFilter::__anon177
MAX_DIM	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon148
MAX_DIST	/usr/include/opencv2/flann/general.h	/^	MAX_DIST   = 4,$/;"	e	enum:cvflann::flann_distance_t
MAX_ITER	/usr/include/opencv2/core/core.hpp	/^        MAX_ITER=COUNT, \/\/!< ditto$/;"	e	enum:cv::TermCriteria::__anon144
MIN	/usr/include/opencv2/core/types_c.h	263;"	d
MINKOWSKI	/usr/include/opencv2/flann/general.h	/^	MINKOWSKI = 3,$/;"	e	enum:cvflann::flann_distance_t
MISCLASS	/usr/include/opencv2/ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon86
MNCovariance	/usr/include/opencv2/video/tracking.hpp	/^    float* MNCovariance;        \/* =measurement_noise_cov->data.fl *\/$/;"	m	struct:CvKalman	access:public
MODIFY_A	/usr/include/opencv2/core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon145
MORPHING_METHOD_ERODE	/usr/include/opencv2/contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE = 1,$/;"	e	enum:CvAdaptiveSkinDetector::__anon54
MORPHING_METHOD_ERODE_DILATE	/usr/include/opencv2/contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE_DILATE = 3$/;"	e	enum:CvAdaptiveSkinDetector::__anon54
MORPHING_METHOD_ERODE_ERODE	/usr/include/opencv2/contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE_ERODE = 2,$/;"	e	enum:CvAdaptiveSkinDetector::__anon54
MORPHING_METHOD_NONE	/usr/include/opencv2/contrib/contrib.hpp	/^        MORPHING_METHOD_NONE = 0,$/;"	e	enum:CvAdaptiveSkinDetector::__anon54
MORPH_BLACKHAT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       MORPH_GRADIENT=4, MORPH_TOPHAT=5, MORPH_BLACKHAT=6 };$/;"	e	enum:cv::__anon38
MORPH_CLOSE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_ERODE=0, MORPH_DILATE=1, MORPH_OPEN=2, MORPH_CLOSE=3,$/;"	e	enum:cv::__anon38
MORPH_CROSS	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon39
MORPH_DILATE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_ERODE=0, MORPH_DILATE=1, MORPH_OPEN=2, MORPH_CLOSE=3,$/;"	e	enum:cv::__anon38
MORPH_ELLIPSE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon39
MORPH_ERODE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_ERODE=0, MORPH_DILATE=1, MORPH_OPEN=2, MORPH_CLOSE=3,$/;"	e	enum:cv::__anon38
MORPH_GRADIENT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       MORPH_GRADIENT=4, MORPH_TOPHAT=5, MORPH_BLACKHAT=6 };$/;"	e	enum:cv::__anon38
MORPH_OPEN	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_ERODE=0, MORPH_DILATE=1, MORPH_OPEN=2, MORPH_CLOSE=3,$/;"	e	enum:cv::__anon38
MORPH_RECT	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon39
MORPH_TOPHAT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       MORPH_GRADIENT=4, MORPH_TOPHAT=5, MORPH_BLACKHAT=6 };$/;"	e	enum:cv::__anon38
MP	/usr/include/opencv2/legacy/legacy.hpp	/^    int MP;$/;"	m	struct:CvConDensation	access:public
MP	/usr/include/opencv2/video/tracking.hpp	/^    int MP;                     \/* number of measurement vector dimensions *\/$/;"	m	struct:CvKalman	access:public
MSER	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP MSER( int _delta, int _min_area, int _max_area,$/;"	p	class:cv::MSER	access:public	signature:( int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold, double _min_margin, int _edge_blur_size )
MSER	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP MSER();$/;"	p	class:cv::MSER	access:public	signature:()
MSER	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS_W MSER : public CvMSERParams$/;"	c	namespace:cv	inherits:CvMSERParams
MSize	/usr/include/opencv2/core/core.hpp	/^        MSize(int* _p);$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int* _p)
MSize	/usr/include/opencv2/core/core.hpp	/^    struct CV_EXPORTS MSize$/;"	s	class:cv::Mat	access:public
MSize	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MSize::MSize(int* _p) : p(_p) {}$/;"	f	class:cv::Mat::MSize	signature:(int* _p)
MStep	/usr/include/opencv2/core/core.hpp	/^        MStep();$/;"	p	struct:cv::Mat::MStep	access:public	signature:()
MStep	/usr/include/opencv2/core/core.hpp	/^        MStep(size_t s);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(size_t s)
MStep	/usr/include/opencv2/core/core.hpp	/^    struct CV_EXPORTS MStep$/;"	s	class:cv::Mat	access:public
MStep	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MStep::MStep() { p = buf; p[0] = p[1] = 0; }$/;"	f	class:cv::Mat::MStep	signature:()
MStep	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MStep::MStep(size_t s) { p = buf; p[0] = s; p[1] = 0; }$/;"	f	class:cv::Mat::MStep	signature:(size_t s)
Mahalanobis	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double Mahalanobis(const Mat& v1, const Mat& v2, const Mat& icovar);$/;"	p	namespace:cv	signature:(const Mat& v1, const Mat& v2, const Mat& icovar)
Mahalonobis	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS double Mahalonobis(const Mat& v1, const Mat& v2, const Mat& icovar);$/;"	p	namespace:cv	signature:(const Mat& v1, const Mat& v2, const Mat& icovar)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat();$/;"	p	class:cv::Mat	access:public	signature:()
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(Size _size, int _type);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(Size _size, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type, const Scalar& _s)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(Size _size, int _type, void* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type, void* _data, size_t _step=AUTO_STEP)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const CvMat* m, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const CvMat* m, bool copyData=false)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const CvMatND* m, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const CvMatND* m, bool copyData=false)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const IplImage* img, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const IplImage* img, bool copyData=false)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const Mat& m, const Range& rowRange, const Range& colRange=Range::all());$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Range& rowRange, const Range& colRange=Range::all())
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const Mat& m, const Range* ranges);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Range* ranges)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const Mat& m, const Rect& roi);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Rect& roi)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type, const Scalar& _s)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type, void* _data, const size_t* _steps=0);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type, void* _data, const size_t* _steps=0)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _rows, int _cols, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _rows, int _cols, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type, const Scalar& _s)
Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _rows, int _cols, int _type, void* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type, void* _data, size_t _step=AUTO_STEP)
Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int m, int n> explicit Mat(const Matx<_Tp, m, n>& mtx,$/;"	p	class:cv::Mat	access:public	signature:(const Matx<_Tp, m, n>& mtx, bool copyData=true)
Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> explicit Mat(const Vec<_Tp, n>& vec,$/;"	p	class:cv::Mat	access:public	signature:(const Vec<_Tp, n>& vec, bool copyData=true)
Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> explicit Mat(const MatCommaInitializer_<_Tp>& commaInitializer);$/;"	p	class:cv::Mat	access:public	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> explicit Mat(const Point3_<_Tp>& pt, bool copyData=true);$/;"	p	class:cv::Mat	access:public	signature:(const Point3_<_Tp>& pt, bool copyData=true)
Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> explicit Mat(const Point_<_Tp>& pt, bool copyData=true);$/;"	p	class:cv::Mat	access:public	signature:(const Point_<_Tp>& pt, bool copyData=true)
Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> explicit Mat(const vector<_Tp>& vec, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const vector<_Tp>& vec, bool copyData=false)
Mat	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS Mat$/;"	c	namespace:cv
Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat()$/;"	f	class:cv::Mat	signature:()
Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type)
Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type, const Scalar& _s)
Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type, void* _data, size_t _step)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type, void* _data, size_t _step)
Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(const CvMat* m, bool copyData)$/;"	f	class:cv::Mat	signature:(const CvMat* m, bool copyData)
Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(const Mat& m)$/;"	f	class:cv::Mat	signature:(const Mat& m)
Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(int _dims, const int* _sz, int _type)$/;"	f	class:cv::Mat	signature:(int _dims, const int* _sz, int _type)
Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(int _dims, const int* _sz, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(int _dims, const int* _sz, int _type, const Scalar& _s)
Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type)
Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type, const Scalar& _s)
Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type, void* _data, size_t _step)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type, void* _data, size_t _step)
Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp, int m, int n> inline Mat::Mat(const Matx<_Tp,m,n>& M, bool copyData)$/;"	f	class:cv::Mat	signature:(const Matx<_Tp,m,n>& M, bool copyData)
Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp, int n> inline Mat::Mat(const Vec<_Tp, n>& vec, bool copyData)$/;"	f	class:cv::Mat	signature:(const Vec<_Tp, n>& vec, bool copyData)
Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const MatCommaInitializer_<_Tp>& commaInitializer)$/;"	f	class:cv::Mat	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const Point3_<_Tp>& pt, bool copyData)$/;"	f	class:cv::Mat	signature:(const Point3_<_Tp>& pt, bool copyData)
Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const Point_<_Tp>& pt, bool copyData)$/;"	f	class:cv::Mat	signature:(const Point_<_Tp>& pt, bool copyData)
Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const vector<_Tp>& vec, bool copyData)$/;"	f	class:cv::Mat	signature:(const vector<_Tp>& vec, bool copyData)
Mat1b	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<uchar> Mat1b;$/;"	t	namespace:cv
Mat1d	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<double> Mat1d;$/;"	t	namespace:cv
Mat1f	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<float> Mat1f;$/;"	t	namespace:cv
Mat1i	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<int>   Mat1i;$/;"	t	namespace:cv
Mat1s	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<short> Mat1s;$/;"	t	namespace:cv
Mat1w	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<ushort> Mat1w;$/;"	t	namespace:cv
Mat2b	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2b> Mat2b;$/;"	t	namespace:cv
Mat2d	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2d> Mat2d;$/;"	t	namespace:cv
Mat2f	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2f> Mat2f;$/;"	t	namespace:cv
Mat2i	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2i> Mat2i;$/;"	t	namespace:cv
Mat2s	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2s> Mat2s;$/;"	t	namespace:cv
Mat2w	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2w> Mat2w;$/;"	t	namespace:cv
Mat3b	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3b> Mat3b;$/;"	t	namespace:cv
Mat3d	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3d> Mat3d;$/;"	t	namespace:cv
Mat3f	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3f> Mat3f;$/;"	t	namespace:cv
Mat3i	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3i> Mat3i;$/;"	t	namespace:cv
Mat3s	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3s> Mat3s;$/;"	t	namespace:cv
Mat3w	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3w> Mat3w;$/;"	t	namespace:cv
Mat4b	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4b> Mat4b;$/;"	t	namespace:cv
Mat4d	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4d> Mat4d;$/;"	t	namespace:cv
Mat4f	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4f> Mat4f;$/;"	t	namespace:cv
Mat4i	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4i> Mat4i;$/;"	t	namespace:cv
Mat4s	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4s> Mat4s;$/;"	t	namespace:cv
Mat4w	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4w> Mat4w;$/;"	t	namespace:cv
MatAllocator	/usr/include/opencv2/core/core.hpp	/^    MatAllocator() {}$/;"	f	class:cv::MatAllocator	access:public	signature:()
MatAllocator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatAllocator$/;"	c	namespace:cv
MatArg	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatArg;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatCommaInitializer_	/usr/include/opencv2/core/core.hpp	/^    MatCommaInitializer_(Mat_<_Tp>* _m);$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:(Mat_<_Tp>* _m)
MatCommaInitializer_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatCommaInitializer_$/;"	c	namespace:cv
MatCommaInitializer_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatCommaInitializer_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatCommaInitializer_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatCommaInitializer_<_Tp>::MatCommaInitializer_(Mat_<_Tp>* _m) : it(_m) {}$/;"	f	class:cv::MatCommaInitializer_	signature:(Mat_<_Tp>* _m)
MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator(const Mat* _m);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m)
MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator(const Mat* _m, Point _pt);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, Point _pt)
MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator(const Mat* _m, const int* _idx);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, const int* _idx)
MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator(const Mat* _m, int _row, int _col=0);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, int _row, int _col=0)
MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator(const MatConstIterator& it);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const MatConstIterator& it)
MatConstIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatConstIterator$/;"	c	namespace:cv
MatConstIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatConstIterator;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator::MatConstIterator()$/;"	f	class:cv::MatConstIterator	signature:()
MatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m)
MatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m, Point _pt)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m, Point _pt)
MatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m, int _row, int _col)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m, int _row, int _col)
MatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const MatConstIterator& it)$/;"	f	class:cv::MatConstIterator	signature:(const MatConstIterator& it)
MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_(const MatConstIterator_& it);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const MatConstIterator_& it)
MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m)
MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, Point _pt)
MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, const int* _idx);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, const int* _idx)
MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col=0);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, int _row, int _col=0)
MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatConstIterator_ : public MatConstIterator$/;"	c	namespace:cv	inherits:MatConstIterator
MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatConstIterator_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^    MatConstIterator_(const MatConstIterator_& it)$/;"	f	class:cv::MatConstIterator_	signature:(const MatConstIterator_& it)
MatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m, Point _pt)
MatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m, int _row, int _col)
MatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_() {}$/;"	f	class:cv::MatConstIterator_	signature:()
MatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m)
MatExpr	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatExpr;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatExpr	/usr/include/opencv2/core/mat.hpp	/^    MatExpr() : op(0), flags(0), a(Mat()), b(Mat()), c(Mat()), alpha(0), beta(0), s(Scalar()) {}$/;"	f	class:cv::MatExpr	access:public	signature:()
MatExpr	/usr/include/opencv2/core/mat.hpp	/^    MatExpr(const MatOp* _op, int _flags, const Mat& _a=Mat(), const Mat& _b=Mat(),$/;"	f	class:cv::MatExpr	access:public	signature:(const MatOp* _op, int _flags, const Mat& _a=Mat(), const Mat& _b=Mat(), const Mat& _c=Mat(), double _alpha=1, double _beta=1, const Scalar& _s=Scalar())
MatExpr	/usr/include/opencv2/core/mat.hpp	/^    explicit MatExpr(const Mat& m);$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m)
MatExpr	/usr/include/opencv2/core/mat.hpp	/^class CV_EXPORTS MatExpr$/;"	c	namespace:cv
MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_();$/;"	p	class:cv::MatIterator_	access:public	signature:()
MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_(Mat_<_Tp>* _m);$/;"	p	class:cv::MatIterator_	access:public	signature:(Mat_<_Tp>* _m)
MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_(Mat_<_Tp>* _m, int _row, int _col=0);$/;"	p	class:cv::MatIterator_	access:public	signature:(Mat_<_Tp>* _m, int _row, int _col=0)
MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_(const MatIterator_& it);$/;"	p	class:cv::MatIterator_	access:public	signature:(const MatIterator_& it)
MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_(const Mat_<_Tp>* _m, Point _pt);$/;"	p	class:cv::MatIterator_	access:public	signature:(const Mat_<_Tp>* _m, Point _pt)
MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_(const Mat_<_Tp>* _m, const int* _idx);$/;"	p	class:cv::MatIterator_	access:public	signature:(const Mat_<_Tp>* _m, const int* _idx)
MatIterator_	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatIterator_ : public MatConstIterator_<_Tp>$/;"	c	namespace:cv	inherits:MatConstIterator_
MatIterator_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatIterator_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_() : MatConstIterator_<_Tp>() {}$/;"	f	class:cv::MatIterator_	signature:()
MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m)$/;"	f	class:cv::MatIterator_	signature:(Mat_<_Tp>* _m)
MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, int _row, int _col)$/;"	f	class:cv::MatIterator_	signature:(Mat_<_Tp>* _m, int _row, int _col)
MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const MatIterator_& it)$/;"	f	class:cv::MatIterator_	signature:(const MatIterator_& it)
MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, Point _pt)$/;"	f	class:cv::MatIterator_	signature:(const Mat_<_Tp>* _m, Point _pt)
MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, const int* _idx)$/;"	f	class:cv::MatIterator_	signature:(const Mat_<_Tp>* _m, const int* _idx)
MatND	/usr/include/opencv2/core/core.hpp	/^typedef Mat MatND;$/;"	t	namespace:cv
MatOp	/usr/include/opencv2/core/mat.hpp	/^    MatOp() {};$/;"	f	class:cv::MatOp	access:public	signature:()
MatOp	/usr/include/opencv2/core/mat.hpp	/^class CV_EXPORTS MatOp$/;"	c	namespace:cv
MatOp_Base	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatOp_Base;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatOp_Iter_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatOp_Iter_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_();$/;"	p	class:cv::Mat_	access:public	signature:()
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(Size _size, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size, const _Tp& value)
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(const Mat& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat& m)
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(const Mat_& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m)
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(const Mat_& m, const Range& rowRange, const Range& colRange=Range::all());$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Range& rowRange, const Range& colRange=Range::all())
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(const Mat_& m, const Range* ranges);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Range* ranges)
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(const Mat_& m, const Rect& roi);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Rect& roi)
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0)
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _ndims, const int* _sizes, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes, const _Tp& value)
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _rows, int _cols);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols)
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP)
Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _rows, int _cols, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols, const _Tp& value)
Mat_	/usr/include/opencv2/core/core.hpp	/^    explicit Mat_(Size _size);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size)
Mat_	/usr/include/opencv2/core/core.hpp	/^    explicit Mat_(const MatCommaInitializer_<_Tp>& commaInitializer);$/;"	p	class:cv::Mat_	access:public	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
Mat_	/usr/include/opencv2/core/core.hpp	/^    explicit Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true)
Mat_	/usr/include/opencv2/core/core.hpp	/^    explicit Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true)
Mat_	/usr/include/opencv2/core/core.hpp	/^    explicit Mat_(const vector<_Tp>& vec, bool copyData=false);$/;"	p	class:cv::Mat_	access:public	signature:(const vector<_Tp>& vec, bool copyData=false)
Mat_	/usr/include/opencv2/core/core.hpp	/^    template<int m, int n> explicit Mat_(const Matx<typename DataType<_Tp>::channel_type, m, n>& mtx, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Matx<typename DataType<_Tp>::channel_type, m, n>& mtx, bool copyData=true)
Mat_	/usr/include/opencv2/core/core.hpp	/^    template<int n> explicit Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData=true)
Mat_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Mat_ : public Mat$/;"	c	namespace:cv	inherits:Mat
Mat_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Mat_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Mat_	/usr/include/opencv2/core/mat.hpp	/^    Mat_<_Tp>::Mat_(const Matx<typename DataType<_Tp>::channel_type,m,n>& M, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Matx<typename DataType<_Tp>::channel_type,m,n>& M, bool copyData)
Mat_	/usr/include/opencv2/core/mat.hpp	/^    Mat_<_Tp>::Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_()$/;"	f	class:cv::Mat_	signature:()
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz)$/;"	f	class:cv::Mat_	signature:(Size _sz)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz, const _Tp& value)$/;"	f	class:cv::Mat_	signature:(Size _sz, const _Tp& value)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat& m)$/;"	f	class:cv::Mat_	signature:(const Mat& m)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const MatCommaInitializer_<_Tp>& commaInitializer)$/;"	f	class:cv::Mat_	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m)$/;"	f	class:cv::Mat_	signature:(const Mat_& m)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Range& rowRange, const Range& colRange)$/;"	f	class:cv::Mat_	signature:(const Mat_& m, const Range& rowRange, const Range& colRange)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Rect& roi)$/;"	f	class:cv::Mat_	signature:(const Mat_& m, const Rect& roi)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const Range* ranges)$/;"	f	class:cv::Mat_	signature:(const Mat_<_Tp>& m, const Range* ranges)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const vector<_Tp>& vec, bool copyData)$/;"	f	class:cv::Mat_	signature:(const vector<_Tp>& vec, bool copyData)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz, const _Tp& _s)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz, const _Tp& _s)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, _Tp* _data, size_t steps)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols, _Tp* _data, size_t steps)
Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, const _Tp& value)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols, const _Tp& value)
MatchPointToPart	/usr/include/opencv2/features2d/features2d.hpp	/^    int MatchPointToPart(CvPoint pt) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvPoint pt) const
Matrix	/usr/include/opencv2/flann/matrix.h	/^    Matrix() : rows(0), cols(0), data(NULL)$/;"	f	class:cvflann::Matrix	access:public	signature:()
Matrix	/usr/include/opencv2/flann/matrix.h	/^    Matrix(T* data_, long rows_, long cols_) :$/;"	f	class:cvflann::Matrix	access:public	signature:(T* data_, long rows_, long cols_)
Matrix	/usr/include/opencv2/flann/matrix.h	/^class Matrix {$/;"	c	namespace:cvflann
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx();$/;"	p	class:cv::Matx	access:public	signature:()
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0); \/\/!< 1x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1); \/\/!< 1x2 or 2x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2); \/\/!< 1x3 or 3x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3); \/\/!< 1x4, 2x2 or 4x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); \/\/!< 1x5 or 5x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); \/\/!< 1x6, 2x3, 3x2 or 6x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); \/\/!< 1x7 or 7x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); \/\/!< 1x8, 2x4, 4x2 or 8x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); \/\/!< 1x9, 3x3 or 9x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); \/\/!< 1x10, 2x5 or 5x2 or 10x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)
Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(const Matx<_Tp, n, m>& a, Matx_TOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, n, m>& a, Matx_TOp)
Matx	/usr/include/opencv2/core/core.hpp	/^    explicit Matx(const _Tp* vals); \/\/!< initialize from a plain array$/;"	p	class:cv::Matx	access:public	signature:(const _Tp* vals)
Matx	/usr/include/opencv2/core/core.hpp	/^    template<int l> Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)
Matx	/usr/include/opencv2/core/core.hpp	/^    template<typename _T2> Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)
Matx	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS Matx$/;"	c	namespace:cv
Matx	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS Matx;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)
Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)
Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)
Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)
Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)
Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, n, m>& a, Matx_TOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, n, m>& a, Matx_TOp)
Matx	/usr/include/opencv2/core/operations.hpp	/^inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11)
Matx	/usr/include/opencv2/core/operations.hpp	/^inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15)
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx()$/;"	f	class:cv::Matx	signature:()
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0)$/;"	f	class:cv::Matx	signature:(_Tp v0)
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1)
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2)
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(const _Tp* values)$/;"	f	class:cv::Matx	signature:(const _Tp* values)
Matx12d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 1, 2> Matx12d;$/;"	t	namespace:cv
Matx12f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 1, 2> Matx12f;$/;"	t	namespace:cv
Matx13d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 1, 3> Matx13d;$/;"	t	namespace:cv
Matx13f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 1, 3> Matx13f;$/;"	t	namespace:cv
Matx14d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 1, 4> Matx14d;$/;"	t	namespace:cv
Matx14f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 1, 4> Matx14f;$/;"	t	namespace:cv
Matx16d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 1, 6> Matx16d;$/;"	t	namespace:cv
Matx16f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 1, 6> Matx16f;$/;"	t	namespace:cv
Matx21d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 2, 1> Matx21d;$/;"	t	namespace:cv
Matx21f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 2, 1> Matx21f;$/;"	t	namespace:cv
Matx22d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 2, 2> Matx22d;$/;"	t	namespace:cv
Matx22f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 2, 2> Matx22f;$/;"	t	namespace:cv
Matx23d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 2, 3> Matx23d;$/;"	t	namespace:cv
Matx23f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 2, 3> Matx23f;$/;"	t	namespace:cv
Matx31d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 3, 1> Matx31d;$/;"	t	namespace:cv
Matx31f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 3, 1> Matx31f;$/;"	t	namespace:cv
Matx32d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 3, 2> Matx32d;$/;"	t	namespace:cv
Matx32f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 3, 2> Matx32f;$/;"	t	namespace:cv
Matx33d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 3, 3> Matx33d;$/;"	t	namespace:cv
Matx33f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 3, 3> Matx33f;$/;"	t	namespace:cv
Matx34d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 3, 4> Matx34d;$/;"	t	namespace:cv
Matx34f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 3, 4> Matx34f;$/;"	t	namespace:cv
Matx41d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 4, 1> Matx41d;$/;"	t	namespace:cv
Matx41f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 4, 1> Matx41f;$/;"	t	namespace:cv
Matx43d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 4, 3> Matx43d;$/;"	t	namespace:cv
Matx43f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 4, 3> Matx43f;$/;"	t	namespace:cv
Matx44d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 4, 4> Matx44d;$/;"	t	namespace:cv
Matx44f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 4, 4> Matx44f;$/;"	t	namespace:cv
Matx61d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 6, 1> Matx61d;$/;"	t	namespace:cv
Matx61f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 6, 1> Matx61f;$/;"	t	namespace:cv
Matx66d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 6, 6> Matx66d;    $/;"	t	namespace:cv
Matx66f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 6, 6> Matx66f;$/;"	t	namespace:cv
MatxCommaInitializer	/usr/include/opencv2/core/core.hpp	/^    MatxCommaInitializer(Matx<_Tp, m, n>* _mtx);$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:(Matx<_Tp, m, n>* _mtx)
MatxCommaInitializer	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS MatxCommaInitializer$/;"	c	namespace:cv
MatxCommaInitializer	/usr/include/opencv2/core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n>::MatxCommaInitializer(Matx<_Tp, m, n>* _mtx)$/;"	f	class:cv::MatxCommaInitializer	signature:(Matx<_Tp, m, n>* _mtx)
Matx_AddOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_AddOp {};$/;"	s	namespace:cv
Matx_DetOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m> struct CV_EXPORTS Matx_DetOp$/;"	s	namespace:cv
Matx_DetOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 1>$/;"	s	namespace:cv
Matx_DetOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 2>$/;"	s	namespace:cv
Matx_DetOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 3>$/;"	s	namespace:cv
Matx_FastInvOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m> struct CV_EXPORTS Matx_FastInvOp$/;"	s	namespace:cv
Matx_FastInvOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastInvOp<_Tp, 2>$/;"	s	namespace:cv
Matx_FastInvOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastInvOp<_Tp, 3>$/;"	s	namespace:cv
Matx_FastSolveOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> struct CV_EXPORTS Matx_FastSolveOp$/;"	s	namespace:cv
Matx_FastSolveOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastSolveOp<_Tp, 2, 1>$/;"	s	namespace:cv
Matx_FastSolveOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastSolveOp<_Tp, 3, 1>$/;"	s	namespace:cv
Matx_MatMulOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_MatMulOp {};$/;"	s	namespace:cv
Matx_MulOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_MulOp {};$/;"	s	namespace:cv
Matx_ScaleOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_ScaleOp {};$/;"	s	namespace:cv
Matx_SubOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_SubOp {};$/;"	s	namespace:cv
Matx_TOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_TOp {};$/;"	s	namespace:cv
MaxMeanShiftIteration	/usr/include/opencv2/contrib/contrib.hpp	/^        MaxMeanShiftIteration   = 5,$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon56
MaxSetSizeIteration	/usr/include/opencv2/contrib/contrib.hpp	/^        MaxSetSizeIteration     = 5$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon56
MeasurementMatr	/usr/include/opencv2/video/tracking.hpp	/^    float* MeasurementMatr;     \/* =measurement_matrix->data.fl *\/$/;"	m	struct:CvKalman	access:public
MemStorage	/usr/include/opencv2/core/core.hpp	/^typedef Ptr<CvMemStorage> MemStorage;$/;"	t	namespace:cv
Mesh3D	/usr/include/opencv2/contrib/contrib.hpp	/^        Mesh3D();$/;"	p	class:cv::Mesh3D	access:public	signature:()
Mesh3D	/usr/include/opencv2/contrib/contrib.hpp	/^        Mesh3D(const vector<Point3f>& vtx);$/;"	p	class:cv::Mesh3D	access:public	signature:(const vector<Point3f>& vtx)
Mesh3D	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS Mesh3D$/;"	c	namespace:cv
MinKernelMass	/usr/include/opencv2/contrib/contrib.hpp	/^        MinKernelMass           = 1000$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon55
Moments	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Moments( const CvMoments& moments );$/;"	p	class:cv::Moments	access:public	signature:( const CvMoments& moments )
Moments	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Moments();$/;"	p	class:cv::Moments	access:public	signature:()
Moments	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Moments(double m00, double m10, double m01, double m20, double m11,$/;"	p	class:cv::Moments	access:public	signature:(double m00, double m10, double m01, double m20, double m11, double m02, double m30, double m21, double m12, double m03 )
Moments	/usr/include/opencv2/imgproc/imgproc.hpp	/^class CV_EXPORTS_W_MAP Moments$/;"	c	namespace:cv
MouseCallback	/usr/include/opencv2/highgui/highgui.hpp	/^typedef void (*MouseCallback )(int event, int x, int y, int flags, void* param);$/;"	t	namespace:cv
MouthRect	/usr/include/opencv2/legacy/legacy.hpp	/^    CvRect MouthRect;$/;"	m	struct:CvFace	access:public
MserFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    MserFeatureDetector( CvMSERParams params=cvMSERParams() );$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( CvMSERParams params=cvMSERParams() )
MserFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    MserFeatureDetector( int delta, int minArea, int maxArea, double maxVariation, double minDiversity,$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( int delta, int minArea, int maxArea, double maxVariation, double minDiversity, int maxEvolution, double areaThreshold, double minMargin, int edgeBlurSize )
MserFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS MserFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
N	/usr/include/opencv2/legacy/legacy.hpp	/^    int N; \/\/graph size$/;"	m	struct:CvCliqueFinder	access:public
N1c	/usr/include/opencv2/video/background_segm.hpp	/^    int    N1c;			\/* Number of color vectors used to model normal background color variation at a given pixel.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
N1cc	/usr/include/opencv2/video/background_segm.hpp	/^    int    N1cc;		\/* Number of color co-occurrence vectors used to model normal background color variation at a given pixel.	*\/$/;"	m	struct:CvFGDStatModelParams	access:public
N2c	/usr/include/opencv2/video/background_segm.hpp	/^    int    N2c;			\/* Number of color vectors retained at given pixel.  Must be > N1c, typically ~ 5\/3 of N1c.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
N2cc	/usr/include/opencv2/video/background_segm.hpp	/^    int    N2cc;		\/* Number of color co-occurrence vectors retained at given pixel.  Must be > N1cc, typically ~ 5\/3 of N1cc.	*\/$/;"	m	struct:CvFGDStatModelParams	access:public
NAMED	/usr/include/opencv2/core/core.hpp	/^        NAMED=64 \/\/!< the node has a name (i.e. it is element of a mapping)$/;"	e	enum:cv::FileNode::__anon151
NAME_EXPECTED	/usr/include/opencv2/core/core.hpp	/^        NAME_EXPECTED=2,$/;"	e	enum:cv::FileStorage::__anon150
NARROW_PRESET	/usr/include/opencv2/calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon71
NAryMatIterator	/usr/include/opencv2/core/core.hpp	/^    NAryMatIterator();$/;"	p	class:cv::NAryMatIterator	access:public	signature:()
NAryMatIterator	/usr/include/opencv2/core/core.hpp	/^    NAryMatIterator(const Mat** arrays, Mat* planes, int narrays=-1);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(const Mat** arrays, Mat* planes, int narrays=-1)
NAryMatIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS NAryMatIterator$/;"	c	namespace:cv
NNIndex	/usr/include/opencv2/flann/nn_index.h	/^class NNIndex$/;"	c	namespace:cvflann
NONE	/usr/include/opencv2/core/core.hpp	/^        NONE=0, \/\/!< empty node$/;"	e	enum:cv::FileNode::__anon151
NORMAL	/usr/include/opencv2/core/core.hpp	/^    enum { A=4164903690U, UNIFORM=0, NORMAL=1 };$/;"	e	enum:cv::RNG::__anon143
NORM_INF	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
NORM_L1	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
NORM_L2	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
NORM_MINMAX	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
NORM_RELATIVE	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
NORM_TYPE_MASK	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
NOT_DRAW_SINGLE_POINTS	/usr/include/opencv2/features2d/features2d.hpp	/^          NOT_DRAW_SINGLE_POINTS = 2, \/\/ Single keypoints will not be drawn.$/;"	e	enum:cv::DrawMatchesFlags::__anon75
NO_INPUT_SCALE	/usr/include/opencv2/ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon90
NO_OUTPUT_SCALE	/usr/include/opencv2/ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon90
NO_UV	/usr/include/opencv2/core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon145
NU	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
NU_SVC	/usr/include/opencv2/ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon78
NU_SVR	/usr/include/opencv2/ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon78
NeuralNet_MLP	/usr/include/opencv2/ml/ml.hpp	/^typedef CvANN_MLP NeuralNet_MLP;$/;"	t	namespace:cv
NewParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvDefParam* NewParam(const char* name);$/;"	p	class:CvVSModule	access:private	signature:(const char* name)
Node	/usr/include/opencv2/contrib/contrib.hpp	/^            Node() {}$/;"	f	struct:cv::Octree::Node	access:public	signature:()
Node	/usr/include/opencv2/contrib/contrib.hpp	/^        struct Node$/;"	s	class:cv::Octree	access:public
Node	/usr/include/opencv2/core/core.hpp	/^        Node() : idx(-1), left(-1), right(-1), boundary(0.f) {}$/;"	f	struct:cv::KDTree::Node	access:public	signature:()
Node	/usr/include/opencv2/core/core.hpp	/^        Node(int _idx, int _left, int _right, float _boundary)$/;"	f	struct:cv::KDTree::Node	access:public	signature:(int _idx, int _left, int _right, float _boundary)
Node	/usr/include/opencv2/core/core.hpp	/^    struct CV_EXPORTS Node$/;"	s	class:cv::SparseMat	access:public
Node	/usr/include/opencv2/core/core.hpp	/^    struct Node$/;"	s	class:cv::KDTree	access:public
NormalBayesClassifier	/usr/include/opencv2/ml/ml.hpp	/^typedef CvNormalBayesClassifier NormalBayesClassifier;$/;"	t	namespace:cv
ONE_CLASS	/usr/include/opencv2/ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon78
OPENCV_ASSERT	/usr/include/opencv2/core/core_c.h	1786;"	d
OPENCV_CALL	/usr/include/opencv2/core/core_c.h	1792;"	d
OPENCV_ERRCHK	/usr/include/opencv2/core/core_c.h	1782;"	d
OPENCV_ERROR	/usr/include/opencv2/core/core_c.h	1779;"	d
OPENCV_RSTERR	/usr/include/opencv2/core/core_c.h	1790;"	d
OPTFLOW_FARNEBACK_GAUSSIAN	/usr/include/opencv2/video/tracking.hpp	/^enum { OPTFLOW_USE_INITIAL_FLOW=4, OPTFLOW_FARNEBACK_GAUSSIAN=256 };$/;"	e	enum:cv::__anon183
OPTFLOW_USE_INITIAL_FLOW	/usr/include/opencv2/video/tracking.hpp	/^enum { OPTFLOW_USE_INITIAL_FLOW=4, OPTFLOW_FARNEBACK_GAUSSIAN=256 };$/;"	e	enum:cv::__anon183
ObjectFactory	/usr/include/opencv2/flann/object_factory.h	/^class ObjectFactory$/;"	c	namespace:cvflann
Octree	/usr/include/opencv2/contrib/contrib.hpp	/^        Octree( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 );$/;"	p	class:cv::Octree	access:public	signature:( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 )
Octree	/usr/include/opencv2/contrib/contrib.hpp	/^        Octree();$/;"	p	class:cv::Octree	access:public	signature:()
Octree	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS Octree$/;"	c	namespace:cv
OneWayDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptor();$/;"	p	class:cv::OneWayDescriptor	access:public	signature:()
OneWayDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptor$/;"	c	namespace:cv
OneWayDescriptorBase	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptorBase(CvSize patch_size, int pose_count, const char* train_path = 0, const char* pca_config = 0,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvSize patch_size, int pose_count, const char* train_path = 0, const char* pca_config = 0, const char* pca_hr_config = 0, const char* pca_desc_config = 0, int pyr_levels = 1, int pca_dim_high = 100, int pca_dim_low = 100)
OneWayDescriptorBase	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptorBase(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string(), const string &images_list = string(),$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string(), const string &images_list = string(), float _scale_min = 0.7f, float _scale_max=1.5f, float _scale_step=1.2f, int pyr_levels = 1, int pca_dim_high = 100, int pca_dim_low = 100)
OneWayDescriptorBase	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorBase$/;"	c	namespace:cv
OneWayDescriptorMatch	/usr/include/opencv2/features2d/features2d.hpp	/^typedef OneWayDescriptorMatcher OneWayDescriptorMatch;$/;"	t	namespace:cv
OneWayDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptorMatcher( const Params& params=Params() );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const Params& params=Params() )
OneWayDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
OneWayDescriptorObject	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptorObject(CvSize patch_size, int pose_count, const char* train_path, const char* pca_config,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvSize patch_size, int pose_count, const char* train_path, const char* pca_config, const char* pca_hr_config = 0, const char* pca_desc_config = 0, int pyr_levels = 1)
OneWayDescriptorObject	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptorObject(CvSize patch_size, int pose_count, const string &pca_filename,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string (), const string &images_list = string (), float _scale_min = 0.7f, float _scale_max=1.5f, float _scale_step=1.2f, int pyr_levels = 1)
OneWayDescriptorObject	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorObject : public OneWayDescriptorBase$/;"	c	namespace:cv	inherits:OneWayDescriptorBase
OpenGLCallback	/usr/include/opencv2/highgui/highgui.hpp	/^typedef void (CV_CDECL *OpenGLCallback)(void* userdata);$/;"	t	namespace:cv
OpponentColorDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    OpponentColorDescriptorExtractor( const Ptr<DescriptorExtractor>& descriptorExtractor );$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( const Ptr<DescriptorExtractor>& descriptorExtractor )
OpponentColorDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS OpponentColorDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
P	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* P; \/\/ parameters used to evaluate function with new params$/;"	m	class:cv::LevMarqSparse	access:protected
P	/usr/include/opencv2/ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon80
P1	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int P1;$/;"	m	class:cv::StereoSGBM	access:public
P2	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int P2;$/;"	m	class:cv::StereoSGBM	access:public
PATCH_HEIGHT	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int PATCH_HEIGHT = 24;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
PATCH_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^        PATCH_SIZE = 31,$/;"	e	enum:cv::FernClassifier::__anon74
PATCH_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^    static const int PATCH_SIZE = 48;$/;"	m	class:cv::BriefDescriptorExtractor	access:public
PATCH_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^  static const uchar PATCH_SIZE = 32;$/;"	m	class:cv::RandomizedTree	access:public
PATCH_WIDTH	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int PATCH_WIDTH = 24;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
PCA	/usr/include/opencv2/core/core.hpp	/^    PCA();$/;"	p	class:cv::PCA	access:public	signature:()
PCA	/usr/include/opencv2/core/core.hpp	/^    PCA(const Mat& data, const Mat& mean, int flags, int maxComponents=0);$/;"	p	class:cv::PCA	access:public	signature:(const Mat& data, const Mat& mean, int flags, int maxComponents=0)
PCA	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS PCA$/;"	c	namespace:cv
PNCovariance	/usr/include/opencv2/video/tracking.hpp	/^    float* PNCovariance;        \/* =process_noise_cov->data.fl *\/$/;"	m	struct:CvKalman	access:public
POLY	/usr/include/opencv2/ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon79
POSE_COUNT	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int POSE_COUNT = 500;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
PREFILTER_NORMALIZED_RESPONSE	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { PREFILTER_NORMALIZED_RESPONSE = 0, PREFILTER_XSOBEL = 1,$/;"	e	enum:cv::StereoBM::__anon71
PREFILTER_XSOBEL	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { PREFILTER_NORMALIZED_RESPONSE = 0, PREFILTER_XSOBEL = 1,$/;"	e	enum:cv::StereoBM::__anon71
PREFILTER_XSOBEL	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { BASIC_PRESET = 0, PREFILTER_XSOBEL = 1 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon153
PROFILE_DOG	/usr/include/opencv2/legacy/blobtrack.hpp	536;"	d
PROFILE_EPANECHNIKOV	/usr/include/opencv2/legacy/blobtrack.hpp	535;"	d
PROJ_SPHERICAL_EQRECT	/usr/include/opencv2/imgproc/imgproc.hpp	/^    PROJ_SPHERICAL_EQRECT = 1$/;"	e	enum:cv::__anon44
PROJ_SPHERICAL_ORTHO	/usr/include/opencv2/imgproc/imgproc.hpp	/^    PROJ_SPHERICAL_ORTHO = 0,$/;"	e	enum:cv::__anon44
ParamGrid	/usr/include/opencv2/ml/ml.hpp	/^typedef CvParamGrid ParamGrid;$/;"	t	namespace:cv
ParamUpdate	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void ParamUpdate();$/;"	p	class:CvVSModule	access:public	signature:()
Params	/usr/include/opencv2/features2d/features2d.hpp	/^        Params( const string& filename );$/;"	p	class:cv::FernDescriptorMatcher::Params	access:public	signature:( const string& filename )
Params	/usr/include/opencv2/features2d/features2d.hpp	/^        Params( float initFeatureScale=1.f, int featureScaleLevels=1, float featureScaleMul=0.1f,$/;"	p	class:cv::DenseFeatureDetector::Params	access:public	signature:( float initFeatureScale=1.f, int featureScaleLevels=1, float featureScaleMul=0.1f, int initXyStep=6, int initImgBound=0, bool varyXyStepWithScale=true, bool varyImgBoundWithScale=false )
Params	/usr/include/opencv2/features2d/features2d.hpp	/^        Params( int maxCorners=1000, double qualityLevel=0.01, double minDistance=1.,$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( int maxCorners=1000, double qualityLevel=0.01, double minDistance=1., int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
Params	/usr/include/opencv2/features2d/features2d.hpp	/^        Params( int nclasses=0,$/;"	p	class:cv::FernDescriptorMatcher::Params	access:public	signature:( int nclasses=0, int patchSize=FernClassifier::PATCH_SIZE, int signatureSize=FernClassifier::DEFAULT_SIGNATURE_SIZE, int nstructs=FernClassifier::DEFAULT_STRUCTS, int structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int nviews=FernClassifier::DEFAULT_VIEWS, int compressionMethod=FernClassifier::COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator() )
Params	/usr/include/opencv2/features2d/features2d.hpp	/^        Params( int poseCount = POSE_COUNT,$/;"	p	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:( int poseCount = POSE_COUNT, Size patchSize = Size(PATCH_WIDTH, PATCH_HEIGHT), string pcaFilename = string(), string trainPath = string(), string trainImagesList = string(), float minScale = GET_MIN_SCALE(), float maxScale = GET_MAX_SCALE(), float stepScale = GET_STEP_SCALE() )
Params	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::DenseFeatureDetector	access:public
Params	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::FernDescriptorMatcher	access:public
Params	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::GoodFeaturesToTrackDetector	access:public
Params	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::OneWayDescriptorMatcher	access:public
ParamsFactory	/usr/include/opencv2/flann/general.h	/^typedef ObjectFactory<IndexParams, flann_algorithm_t> ParamsFactory;$/;"	t	namespace:cvflann
ParamsFactory_instance	/usr/include/opencv2/flann/general.h	/^CV_EXPORTS ParamsFactory& ParamsFactory_instance();$/;"	p	namespace:cvflann	signature:()
PatchGenerator	/usr/include/opencv2/features2d/features2d.hpp	/^    PatchGenerator();$/;"	p	class:cv::PatchGenerator	access:public	signature:()
PatchGenerator	/usr/include/opencv2/features2d/features2d.hpp	/^    PatchGenerator(double _backgroundMin, double _backgroundMax,$/;"	p	class:cv::PatchGenerator	access:public	signature:(double _backgroundMin, double _backgroundMax, double _noiseRange, bool _randomBlur=true, double _lambdaMin=0.6, double _lambdaMax=1.5, double _thetaMin=-CV_PI, double _thetaMax=CV_PI, double _phiMin=-CV_PI, double _phiMax=CV_PI )
PatchGenerator	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS PatchGenerator$/;"	c	namespace:cv
Pbc	/usr/include/opencv2/video/background_segm.hpp	/^    float                 Pbc;$/;"	m	struct:CvBGPixelStat	access:public
Pbcc	/usr/include/opencv2/video/background_segm.hpp	/^    float                 Pbcc;$/;"	m	struct:CvBGPixelStat	access:public
PixelSize	/usr/include/opencv2/core/wimage.hpp	/^    int PixelSize() const {return Channels() * ChannelSize(); }$/;"	f	class:cv::WImage	access:public	signature:() const
PixelTestFn	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef void(*PixelTestFn)(const Mat&, const std::vector<KeyPoint>&, Mat&);$/;"	t	class:cv::BriefDescriptorExtractor	access:protected
PlanarObjectDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    PlanarObjectDetector();$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:()
PlanarObjectDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    PlanarObjectDetector(const FileNode& node);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const FileNode& node)
PlanarObjectDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    PlanarObjectDetector(const vector<Mat>& pyr, int _npoints=300,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, int _npoints=300, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
PlanarObjectDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS PlanarObjectDetector$/;"	c	namespace:cv
Point	/usr/include/opencv2/core/core.hpp	/^typedef Point2i Point;$/;"	t	namespace:cv
Point2d	/usr/include/opencv2/core/core.hpp	/^typedef Point_<double> Point2d;$/;"	t	namespace:cv
Point2f	/usr/include/opencv2/core/core.hpp	/^typedef Point_<float> Point2f;$/;"	t	namespace:cv
Point2i	/usr/include/opencv2/core/core.hpp	/^typedef Point_<int> Point2i;$/;"	t	namespace:cv
Point3_	/usr/include/opencv2/core/core.hpp	/^	explicit Point3_(const Point_<_Tp>& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point_<_Tp>& pt)
Point3_	/usr/include/opencv2/core/core.hpp	/^    Point3_();$/;"	p	class:cv::Point3_	access:public	signature:()
Point3_	/usr/include/opencv2/core/core.hpp	/^    Point3_(_Tp _x, _Tp _y, _Tp _z);$/;"	p	class:cv::Point3_	access:public	signature:(_Tp _x, _Tp _y, _Tp _z)
Point3_	/usr/include/opencv2/core/core.hpp	/^    Point3_(const CvPoint3D32f& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const CvPoint3D32f& pt)
Point3_	/usr/include/opencv2/core/core.hpp	/^    Point3_(const Point3_& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt)
Point3_	/usr/include/opencv2/core/core.hpp	/^    Point3_(const Vec<_Tp, 3>& v);$/;"	p	class:cv::Point3_	access:public	signature:(const Vec<_Tp, 3>& v)
Point3_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point3_$/;"	c	namespace:cv
Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_() : x(0), y(0), z(0) {}$/;"	f	class:cv::Point3_	signature:()
Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(_Tp _x, _Tp _y, _Tp _z) : x(_x), y(_y), z(_z) {}$/;"	f	class:cv::Point3_	signature:(_Tp _x, _Tp _y, _Tp _z)
Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const CvPoint3D32f& pt) :$/;"	f	class:cv::Point3_	signature:(const CvPoint3D32f& pt)
Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point3_& pt) : x(pt.x), y(pt.y), z(pt.z) {}$/;"	f	class:cv::Point3_	signature:(const Point3_& pt)
Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point_<_Tp>& pt) : x(pt.x), y(pt.y), z(_Tp()) {}$/;"	f	class:cv::Point3_	signature:(const Point_<_Tp>& pt)
Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Vec<_Tp, 3>& v) : x(v[0]), y(v[1]), z(v[2]) {}$/;"	f	class:cv::Point3_	signature:(const Vec<_Tp, 3>& v)
Point3d	/usr/include/opencv2/core/core.hpp	/^typedef Point3_<double> Point3d;$/;"	t	namespace:cv
Point3f	/usr/include/opencv2/core/core.hpp	/^typedef Point3_<float> Point3f;$/;"	t	namespace:cv
Point3i	/usr/include/opencv2/core/core.hpp	/^typedef Point3_<int> Point3i;$/;"	t	namespace:cv
Point_	/usr/include/opencv2/core/core.hpp	/^    Point_();$/;"	p	class:cv::Point_	access:public	signature:()
Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(_Tp _x, _Tp _y);$/;"	p	class:cv::Point_	access:public	signature:(_Tp _x, _Tp _y)
Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(const CvPoint& pt);$/;"	p	class:cv::Point_	access:public	signature:(const CvPoint& pt)
Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(const CvPoint2D32f& pt);$/;"	p	class:cv::Point_	access:public	signature:(const CvPoint2D32f& pt)
Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(const Point_& pt);$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt)
Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(const Size_<_Tp>& sz);$/;"	p	class:cv::Point_	access:public	signature:(const Size_<_Tp>& sz)
Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(const Vec<_Tp, 2>& v);$/;"	p	class:cv::Point_	access:public	signature:(const Vec<_Tp, 2>& v)
Point_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point_$/;"	c	namespace:cv
Point_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_() : x(0), y(0) {}$/;"	f	class:cv::Point_	signature:()
Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(_Tp _x, _Tp _y) : x(_x), y(_y) {}$/;"	f	class:cv::Point_	signature:(_Tp _x, _Tp _y)
Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint& pt) : x((_Tp)pt.x), y((_Tp)pt.y) {}$/;"	f	class:cv::Point_	signature:(const CvPoint& pt)
Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint2D32f& pt)$/;"	f	class:cv::Point_	signature:(const CvPoint2D32f& pt)
Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Point_& pt) : x(pt.x), y(pt.y) {}$/;"	f	class:cv::Point_	signature:(const Point_& pt)
Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Size_<_Tp>& sz) : x(sz.width), y(sz.height) {}$/;"	f	class:cv::Point_	signature:(const Size_<_Tp>& sz)
Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Vec<_Tp,2>& v) : x(v[0]), y(v[1]) {}$/;"	f	class:cv::Point_	signature:(const Vec<_Tp,2>& v)
PooledAllocator	/usr/include/opencv2/flann/allocator.h	/^	PooledAllocator(int blocksize = BLOCKSIZE)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(int blocksize = BLOCKSIZE)
PooledAllocator	/usr/include/opencv2/flann/allocator.h	/^class CV_EXPORTS PooledAllocator$/;"	c	namespace:cvflann
PosterErrorCovariance	/usr/include/opencv2/video/tracking.hpp	/^    float* PosterErrorCovariance;\/* =error_cov_post->data.fl *\/$/;"	m	struct:CvKalman	access:public
PosterState	/usr/include/opencv2/video/tracking.hpp	/^    float* PosterState;         \/* =state_pre->data.fl *\/$/;"	m	struct:CvKalman	access:public
Predict	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* Predict() = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:()
PriorErrorCovariance	/usr/include/opencv2/video/tracking.hpp	/^    float* PriorErrorCovariance;\/* =error_cov_pre->data.fl *\/$/;"	m	struct:CvKalman	access:public
PriorState	/usr/include/opencv2/video/tracking.hpp	/^    float* PriorState;          \/* =state_post->data.fl *\/$/;"	m	struct:CvKalman	access:public
Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* Process(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPostProcOne	access:public	signature:(CvBlob* pBlob)
Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual CvBlob* Process(CvBlob* pBlobPrev, IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:(CvBlob* pBlobPrev, IplImage* pImg, IplImage* pImgFG = NULL)
Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual int     Process(CvBlob* pBlob, IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackAnalysisOne	access:public	signature:(CvBlob* pBlob, IplImage* pImg, IplImage* pFG)
Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void        Process(IplImage* pImg, IplImage* pMask = NULL) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(IplImage* pImg, IplImage* pMask = NULL)
Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg = NULL, IplImage* pFG = NULL) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(IplImage* pImg = NULL, IplImage* pFG = NULL)
Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg) = 0;$/;"	p	class:CvFGDetector	access:public	signature:(IplImage* pImg)
Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(IplImage* pImg, IplImage* pFG)
Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(IplImage* pImg, IplImage* pFG)
Process	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(IplImage* pImg, IplImage* pImgFG = NULL)
ProcessBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void ProcessBlob(int BlobIndex, CvBlob* pBlob, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex, CvBlob* pBlob, IplImage* , IplImage* = NULL)
ProjectPCASample	/usr/include/opencv2/features2d/features2d.hpp	/^    void ProjectPCASample(IplImage* patch, CvMat* avg, CvMat* eigenvectors, CvMat* pca_coeffs) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* patch, CvMat* avg, CvMat* eigenvectors, CvMat* pca_coeffs) const
Ptr	/usr/include/opencv2/core/core.hpp	/^    Ptr();$/;"	p	class:cv::Ptr	access:public	signature:()
Ptr	/usr/include/opencv2/core/core.hpp	/^    Ptr(_Tp* _obj);$/;"	p	class:cv::Ptr	access:public	signature:(_Tp* _obj)
Ptr	/usr/include/opencv2/core/core.hpp	/^    Ptr(const Ptr& ptr);$/;"	p	class:cv::Ptr	access:public	signature:(const Ptr& ptr)
Ptr	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Ptr$/;"	c	namespace:cv
Ptr	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr() : obj(0), refcount(0) {}$/;"	f	class:cv::Ptr	signature:()
Ptr	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr(_Tp* _obj) : obj(_obj)$/;"	f	class:cv::Ptr	signature:(_Tp* _obj)
Ptr	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr(const Ptr<_Tp>& ptr)$/;"	f	class:cv::Ptr	signature:(const Ptr<_Tp>& ptr)
PtrElemStep	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrElemStep_<unsigned char> PtrElemStep;$/;"	t	namespace:cv::gpu
PtrElemStep_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            PtrElemStep_(const DevMem2D_<T>& mem) : PtrStep_<T>(mem) $/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(const DevMem2D_<T>& mem)
PtrElemStep_	/usr/include/opencv2/gpu/devmem2d.hpp	/^        template<typename T> struct PtrElemStep_ : public PtrStep_<T>$/;"	s	namespace:cv::gpu	inherits:PtrStep_
PtrElemStepf	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrElemStep_<float> PtrElemStepf;$/;"	t	namespace:cv::gpu
PtrElemStepi	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrElemStep_<int> PtrElemStepi;$/;"	t	namespace:cv::gpu
PtrStep	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrStep_<unsigned char> PtrStep;$/;"	t	namespace:cv::gpu
PtrStep_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            PtrStep_() : data(0), step(0) {}            $/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:()
PtrStep_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            PtrStep_(const DevMem2D_<T>& mem) : data(mem.data), step(mem.step) {}$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(const DevMem2D_<T>& mem)
PtrStep_	/usr/include/opencv2/gpu/devmem2d.hpp	/^        template<typename T> struct PtrStep_$/;"	s	namespace:cv::gpu
PtrStepf	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrStep_<float> PtrStepf;$/;"	t	namespace:cv::gpu
PtrStepi	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrStep_<int> PtrStepi;$/;"	t	namespace:cv::gpu
Push	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool Push( const CvPoint2D32f** points = 0 );$/;"	p	class:CvCalibFilter	access:public	signature:( const CvPoint2D32f** points = 0 )
Pv	/usr/include/opencv2/video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCCStatTable	access:public
Pv	/usr/include/opencv2/video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCStatTable	access:public
Pvb	/usr/include/opencv2/video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCCStatTable	access:public
Pvb	/usr/include/opencv2/video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCStatTable	access:public
PyramidAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    PyramidAdaptedFeatureDetector( const Ptr<FeatureDetector>& detector, int levels=2 );$/;"	p	class:cv::PyramidAdaptedFeatureDetector	access:public	signature:( const Ptr<FeatureDetector>& detector, int levels=2 )
PyramidAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS PyramidAdaptedFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
RAND_DIM	/usr/include/opencv2/flann/kdtree_index.h	/^		RAND_DIM=5$/;"	e	enum:cvflann::KDTreeIndex::__anon185
RANSAC	/usr/include/opencv2/calib3d/calib3d.hpp	/^    RANSAC=CV_RANSAC \/\/!< RANSAC algorithm$/;"	e	enum:cv::__anon67
RBF	/usr/include/opencv2/ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon79
READ	/usr/include/opencv2/core/core.hpp	/^        READ=0, \/\/! read mode$/;"	e	enum:cv::FileStorage::__anon149
REAL	/usr/include/opencv2/core/core.hpp	/^        REAL=2, \/\/!< floating-point number$/;"	e	enum:cv::FileNode::__anon151
REAL	/usr/include/opencv2/ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon85
RECT	/usr/include/opencv2/legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	e	enum:CvDrawShape::__anon178
REF	/usr/include/opencv2/core/core.hpp	/^        REF=4, \/\/!< integer of size size_t. Typically used for storing complex dynamic structures where some elements reference the others $/;"	e	enum:cv::FileNode::__anon151
RETR_CCOMP	/usr/include/opencv2/imgproc/imgproc.hpp	/^    RETR_CCOMP=2, \/\/!< retrieve the connected components (that can possibly be nested)$/;"	e	enum:cv::__anon50
RETR_EXTERNAL	/usr/include/opencv2/imgproc/imgproc.hpp	/^    RETR_EXTERNAL=0, \/\/!< retrieve only the most external (top-level) contours$/;"	e	enum:cv::__anon50
RETR_LIST	/usr/include/opencv2/imgproc/imgproc.hpp	/^    RETR_LIST=1, \/\/!< retrieve all the contours without any hierarchical information$/;"	e	enum:cv::__anon50
RETR_TREE	/usr/include/opencv2/imgproc/imgproc.hpp	/^    RETR_TREE=3 \/\/!< retrieve all the contours and the whole hierarchy$/;"	e	enum:cv::__anon50
RNG	/usr/include/opencv2/core/core.hpp	/^    RNG();$/;"	p	class:cv::RNG	access:public	signature:()
RNG	/usr/include/opencv2/core/core.hpp	/^    RNG(uint64 _state);$/;"	p	class:cv::RNG	access:public	signature:(uint64 _state)
RNG	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS RNG$/;"	c	namespace:cv
RNG	/usr/include/opencv2/core/operations.hpp	/^inline RNG::RNG() { state = 0xffffffff; }$/;"	f	class:cv::RNG	signature:()
RNG	/usr/include/opencv2/core/operations.hpp	/^inline RNG::RNG(uint64 _state) { state = _state ? _state : 0xffffffff; }$/;"	f	class:cv::RNG	signature:(uint64 _state)
RPROP	/usr/include/opencv2/ml/ml.hpp	/^    enum { BACKPROP=0, RPROP=1 };$/;"	e	enum:CvANN_MLP_TrainParams::__anon88
RQDecomp3x3	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void RQDecomp3x3( const Mat& M, Mat& R, Mat& Q );$/;"	p	namespace:cv	signature:( const Mat& M, Mat& R, Mat& Q )
RQDecomp3x3	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Vec3d RQDecomp3x3( const Mat& M, Mat& R, Mat& Q,$/;"	p	namespace:cv	signature:( const Mat& M, Mat& R, Mat& Q, CV_OUT Mat& Qx, CV_OUT Mat& Qy, CV_OUT Mat& Qz )
RTTIImpl	/usr/include/opencv2/core/operations.hpp	/^template<typename _ClsName> struct CV_EXPORTS RTTIImpl$/;"	s	namespace:cv
RTreeClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^  RTreeClassifier();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
RTreeClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS RTreeClassifier$/;"	c	namespace:cv
RTreeNode	/usr/include/opencv2/features2d/features2d.hpp	/^  RTreeNode() {}$/;"	f	struct:cv::RTreeNode	access:public	signature:()
RTreeNode	/usr/include/opencv2/features2d/features2d.hpp	/^  RTreeNode(uchar x1, uchar y1, uchar x2, uchar y2)$/;"	f	struct:cv::RTreeNode	access:public	signature:(uchar x1, uchar y1, uchar x2, uchar y2)
RTreeNode	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS RTreeNode$/;"	s	namespace:cv
RadiusResultSet	/usr/include/opencv2/flann/result_set.h	/^	RadiusResultSet(float radius_) :$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:(float radius_)
RadiusResultSet	/usr/include/opencv2/flann/result_set.h	/^class RadiusResultSet : public ResultSet<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:ResultSet
RandS	/usr/include/opencv2/legacy/legacy.hpp	/^    struct CvRandState* RandS; \/* Array of structures to generate random vectors *\/$/;"	m	struct:CvConDensation	typeref:struct:CvConDensation::CvRandState	access:public
RandomSample	/usr/include/opencv2/legacy/legacy.hpp	/^    float* RandomSample;    \/* RandomVector to update sample set     *\/$/;"	m	struct:CvConDensation	access:public
RandomTreeParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvRTParams RandomTreeParams;$/;"	t	namespace:cv
RandomTrees	/usr/include/opencv2/ml/ml.hpp	/^typedef CvRTrees RandomTrees;$/;"	t	namespace:cv
RandomizedTree	/usr/include/opencv2/features2d/features2d.hpp	/^  RandomizedTree();$/;"	p	class:cv::RandomizedTree	access:public	signature:()
RandomizedTree	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS RandomizedTree$/;"	c	namespace:cv
Range	/usr/include/opencv2/core/core.hpp	/^    Range();$/;"	p	class:cv::Range	access:public	signature:()
Range	/usr/include/opencv2/core/core.hpp	/^    Range(const CvSlice& slice);$/;"	p	class:cv::Range	access:public	signature:(const CvSlice& slice)
Range	/usr/include/opencv2/core/core.hpp	/^    Range(int _start, int _end);$/;"	p	class:cv::Range	access:public	signature:(int _start, int _end)
Range	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS Range$/;"	c	namespace:cv
Range	/usr/include/opencv2/core/operations.hpp	/^inline Range::Range() : start(0), end(0) {}$/;"	f	class:cv::Range	signature:()
Range	/usr/include/opencv2/core/operations.hpp	/^inline Range::Range(const CvSlice& slice) : start(slice.start_index), end(slice.end_index)$/;"	f	class:cv::Range	signature:(const CvSlice& slice)
Range	/usr/include/opencv2/core/operations.hpp	/^inline Range::Range(int _start, int _end) : start(_start), end(_end) {}$/;"	f	class:cv::Range	signature:(int _start, int _end)
Read	/usr/include/opencv2/features2d/features2d.hpp	/^    void Read (const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const FileNode &fn)
ReadByName	/usr/include/opencv2/features2d/features2d.hpp	/^    int ReadByName(CvFileStorage* fs, CvFileNode* parent, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvFileStorage* fs, CvFileNode* parent, const char* name)
ReadByName	/usr/include/opencv2/features2d/features2d.hpp	/^    int ReadByName(const FileNode &parent, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(const FileNode &parent, const char* name)
Rect	/usr/include/opencv2/core/core.hpp	/^typedef Rect_<int> Rect;$/;"	t	namespace:cv
Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_();$/;"	p	class:cv::Rect_	access:public	signature:()
Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);$/;"	p	class:cv::Rect_	access:public	signature:(_Tp _x, _Tp _y, _Tp _width, _Tp _height)
Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_(const CvRect& r);$/;"	p	class:cv::Rect_	access:public	signature:(const CvRect& r)
Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& org, const Size_<_Tp>& sz)
Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_(const Rect_& r);$/;"	p	class:cv::Rect_	access:public	signature:(const Rect_& r)
Rect_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Rect_$/;"	c	namespace:cv
Rect_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Rect_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_() : x(0), y(0), width(0), height(0) {}$/;"	f	class:cv::Rect_	signature:()
Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height) : x(_x), y(_y), width(_width), height(_height) {}$/;"	f	class:cv::Rect_	signature:(_Tp _x, _Tp _y, _Tp _width, _Tp _height)
Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const CvRect& r) : x((_Tp)r.x), y((_Tp)r.y), width((_Tp)r.width), height((_Tp)r.height) {}$/;"	f	class:cv::Rect_	signature:(const CvRect& r)
Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz) :$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& org, const Size_<_Tp>& sz)
Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Rect_<_Tp>& r) : x(r.x), y(r.y), width(r.width), height(r.height) {}$/;"	f	class:cv::Rect_	signature:(const Rect_<_Tp>& r)
Rectify	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool Rectify( CvMat** srcarr, CvMat** dstarr );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** srcarr, CvMat** dstarr )
Rectify	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool Rectify( IplImage** srcarr, IplImage** dstarr );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** srcarr, IplImage** dstarr )
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackAnalysisOne	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPostProcOne	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTracker	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvFGDetector	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Release() =  0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Release() = 0;$/;"	p	class:CvProb	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Release() = 0;$/;"	p	class:CvVSModule	access:public	signature:()
Release	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Release()=0;$/;"	p	class:CvBlobDetector	access:public	signature:()
ReleaseImage	/usr/include/opencv2/core/wimage.hpp	/^    void ReleaseImage() {$/;"	f	class:cv::WImageBuffer	access:public	signature:()
ReleaseImage	/usr/include/opencv2/core/wimage.hpp	/^    void ReleaseImage() {$/;"	f	class:cv::WImageBufferC	access:public	signature:()
ResizeMethod	/usr/include/opencv2/contrib/contrib.hpp	/^    enum ResizeMethod {$/;"	g	class:CvFuzzyMeanShiftTracker	access:public
ResultSet	/usr/include/opencv2/flann/result_set.h	/^class ResultSet$/;"	c	namespace:cvflann
ResultType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef int ResultType;$/;"	t	struct:cv::Hamming	access:public
ResultType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef int ResultType;$/;"	t	struct:cv::HammingLUT	access:public
ResultType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cv::L1	access:public
ResultType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cv::L2	access:public
RightEyeRect	/usr/include/opencv2/legacy/legacy.hpp	/^    CvRect RightEyeRect;$/;"	m	struct:CvFace	access:public
Rodrigues	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_AS(RodriguesJ) void Rodrigues(const Mat& src, CV_OUT Mat& dst, CV_OUT Mat& jacobian);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, CV_OUT Mat& jacobian)
Rodrigues	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void Rodrigues(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
RotatedRect	/usr/include/opencv2/core/core.hpp	/^    RotatedRect();$/;"	p	class:cv::RotatedRect	access:public	signature:()
RotatedRect	/usr/include/opencv2/core/core.hpp	/^    RotatedRect(const CvBox2D& box);$/;"	p	class:cv::RotatedRect	access:public	signature:(const CvBox2D& box)
RotatedRect	/usr/include/opencv2/core/core.hpp	/^    RotatedRect(const Point2f& _center, const Size2f& _size, float _angle);$/;"	p	class:cv::RotatedRect	access:public	signature:(const Point2f& _center, const Size2f& _size, float _angle)
RotatedRect	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS RotatedRect$/;"	c	namespace:cv
RotatedRect	/usr/include/opencv2/core/operations.hpp	/^inline RotatedRect::RotatedRect() { angle = 0; }$/;"	f	class:cv::RotatedRect	signature:()
RotatedRect	/usr/include/opencv2/core/operations.hpp	/^inline RotatedRect::RotatedRect(const CvBox2D& box)$/;"	f	class:cv::RotatedRect	signature:(const CvBox2D& box)
RotatedRect	/usr/include/opencv2/core/operations.hpp	/^inline RotatedRect::RotatedRect(const Point2f& _center, const Size2f& _size, float _angle)$/;"	f	class:cv::RotatedRect	signature:(const Point2f& _center, const Size2f& _size, float _angle)
Row	/usr/include/opencv2/core/wimage.hpp	/^    inline T* Row(int r) {$/;"	f	class:cv::WImage	access:public	signature:(int r)
Row	/usr/include/opencv2/core/wimage.hpp	/^    inline const T* Row(int r) const {$/;"	f	class:cv::WImage	access:public	signature:(int r) const
S	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* S; \/\/big matrix of block Sjk  , each block has size num_cam_params x num_cam_params$/;"	m	class:cv::LevMarqSparse	access:protected
SADWindowSize	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int SADWindowSize;$/;"	m	class:cv::StereoSGBM	access:public
SADWindowSize	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int SADWindowSize; \/\/ ~5x5..21x21$/;"	m	struct:CvStereoBMState	access:public
SAMPLE_MEAN	/usr/include/opencv2/flann/kdtree_index.h	/^		SAMPLE_MEAN = 100,$/;"	e	enum:cvflann::KDTreeIndex::__anon185
SAVED	/usr/include/opencv2/flann/general.h	/^	SAVED = 254,$/;"	e	enum:cvflann::flann_algorithm_t
SCALE_IMAGE	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { DO_CANNY_PRUNING = 1, SCALE_IMAGE = 2,$/;"	e	enum:cv::CascadeClassifier::__anon63
SEQ	/usr/include/opencv2/core/core.hpp	/^        SEQ=5, \/\/!< sequence$/;"	e	enum:cv::FileNode::__anon151
SIFT	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT( const CommonParams& _commParams,$/;"	p	class:cv::SIFT	access:public	signature:( const CommonParams& _commParams, const DetectorParams& _detectorParams = DetectorParams(), const DescriptorParams& _descriptorParams = DescriptorParams() )
SIFT	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT( double _magnification, bool _isNormalize=true,$/;"	p	class:cv::SIFT	access:public	signature:( double _magnification, bool _isNormalize=true, bool _recalculateAngles = true, int _nOctaves=CommonParams::DEFAULT_NOCTAVES, int _nOctaveLayers=CommonParams::DEFAULT_NOCTAVE_LAYERS, int _firstOctave=CommonParams::DEFAULT_FIRST_OCTAVE, int _angleMode=CommonParams::FIRST_ANGLE )
SIFT	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT( double _threshold, double _edgeThreshold,$/;"	p	class:cv::SIFT	access:public	signature:( double _threshold, double _edgeThreshold, int _nOctaves=CommonParams::DEFAULT_NOCTAVES, int _nOctaveLayers=CommonParams::DEFAULT_NOCTAVE_LAYERS, int _firstOctave=CommonParams::DEFAULT_FIRST_OCTAVE, int _angleMode=CommonParams::FIRST_ANGLE )
SIFT	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT();$/;"	p	class:cv::SIFT	access:public	signature:()
SIFT	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SIFT$/;"	c	namespace:cv
SIGMOID	/usr/include/opencv2/ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon79
SIGMOID_SYM	/usr/include/opencv2/ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon89
SQERR	/usr/include/opencv2/ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon86
SQUARED_LOSS	/usr/include/opencv2/ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon87
SSD	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void SSD(const Mat& img, Point pt, Mat& ssd) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const Mat& img, Point pt, Mat& ssd) const
STARTED	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon66
START_AUTO_STEP	/usr/include/opencv2/ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon82
START_E_STEP	/usr/include/opencv2/ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon82
START_M_STEP	/usr/include/opencv2/ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon82
STR	/usr/include/opencv2/core/core.hpp	/^        STR=3, \/\/!< text string in UTF-8 encoding$/;"	e	enum:cv::FileNode::__anon151
STRING	/usr/include/opencv2/core/core.hpp	/^        STRING=STR, \/\/!< synonym for STR$/;"	e	enum:cv::FileNode::__anon151
SUBMATRIX_FLAG	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon142
SURF	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP SURF();$/;"	p	class:cv::SURF	access:public	signature:()
SURF	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP SURF(double _hessianThreshold, int _nOctaves=4,$/;"	p	class:cv::SURF	access:public	signature:(double _hessianThreshold, int _nOctaves=4, int _nOctaveLayers=2, bool _extended=false)
SURF	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS_W SURF : public CvSURFParams$/;"	c	namespace:cv	inherits:CvSURFParams
SVD	/usr/include/opencv2/core/core.hpp	/^    SVD( const Mat& src, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( const Mat& src, int flags=0 )
SVD	/usr/include/opencv2/core/core.hpp	/^    SVD();$/;"	p	class:cv::SVD	access:public	signature:()
SVD	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS SVD$/;"	c	namespace:cv
SVD	/usr/include/opencv2/core/mat.hpp	/^inline SVD::SVD( const Mat& m, int flags ) { operator ()(m, flags); }$/;"	f	class:cv::SVD	signature:( const Mat& m, int flags )
SVD	/usr/include/opencv2/core/mat.hpp	/^inline SVD::SVD() {}$/;"	f	class:cv::SVD	signature:()
SVM	/usr/include/opencv2/ml/ml.hpp	/^typedef CvSVM SVM;$/;"	t	namespace:cv
SVMKernel	/usr/include/opencv2/ml/ml.hpp	/^typedef CvSVMKernel SVMKernel;$/;"	t	namespace:cv
SVMParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvSVMParams SVMParams;$/;"	t	namespace:cv
SVMSolver	/usr/include/opencv2/ml/ml.hpp	/^typedef CvSVMSolver SVMSolver;$/;"	t	namespace:cv
SVM_C	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
SVM_COEF	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
SVM_DEGREE	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
SVM_GAMMA	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
SVM_NU	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
SVM_P	/usr/include/opencv2/ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon77
SamplesNum	/usr/include/opencv2/legacy/legacy.hpp	/^    int SamplesNum;         \/* Number of the Samples                 *\/$/;"	m	struct:CvConDensation	access:public
Save	/usr/include/opencv2/features2d/features2d.hpp	/^    void Save(const char* path);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(const char* path)
SaveCameraParams	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool SaveCameraParams( const char* filename );$/;"	p	class:CvCalibFilter	access:public	signature:( const char* filename )
SavePCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void SavePCADescriptors(CvFileStorage* fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvFileStorage* fs) const
SavePCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void SavePCADescriptors(const char* filename);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* filename)
SavePCAall	/usr/include/opencv2/features2d/features2d.hpp	/^    void SavePCAall (FileStorage &fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:protected	signature:(FileStorage &fs) const
SaveState	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void SaveState(CvFileStorage*);$/;"	p	class:CvVSModule	access:public	signature:(CvFileStorage*)
SavedIndexParams	/usr/include/opencv2/flann/flann_base.hpp	/^	SavedIndexParams(std::string filename_) : IndexParams(SAVED), filename(filename_) {}$/;"	f	struct:cvflann::SavedIndexParams	access:public	signature:(std::string filename_)
SavedIndexParams	/usr/include/opencv2/flann/flann_base.hpp	/^struct CV_EXPORTS SavedIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
Scalar	/usr/include/opencv2/core/core.hpp	/^typedef Scalar_<double> Scalar;$/;"	t	namespace:cv
Scalar_	/usr/include/opencv2/core/core.hpp	/^    Scalar_();$/;"	p	class:cv::Scalar_	access:public	signature:()
Scalar_	/usr/include/opencv2/core/core.hpp	/^    Scalar_(_Tp v0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0)
Scalar_	/usr/include/opencv2/core/core.hpp	/^    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0)
Scalar_	/usr/include/opencv2/core/core.hpp	/^    Scalar_(const CvScalar& s);$/;"	p	class:cv::Scalar_	access:public	signature:(const CvScalar& s)
Scalar_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Scalar_ : public Vec<_Tp, 4>$/;"	c	namespace:cv	inherits:Vec
Scalar_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_()$/;"	f	class:cv::Scalar_	signature:()
Scalar_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0)$/;"	f	class:cv::Scalar_	signature:(_Tp v0)
Scalar_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Scalar_	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
Scalar_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(const CvScalar& s)$/;"	f	class:cv::Scalar_	signature:(const CvScalar& s)
Scale	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Scale(float factor = 0, int x = -1, int y = -1) = 0;$/;"	p	class:CvProb	access:public	signature:(float factor = 0, int x = -1, int y = -1)
ScaleAfter	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     ScaleAfter;$/;"	m	struct:CvBlobTrackerParamLH	access:public
Scharr	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void Scharr(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, double scale = 1);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, double scale = 1)
Scharr	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(scharr) void Scharr( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, int dx, int dy, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
SearchParams	/usr/include/opencv2/flann/general.h	/^	SearchParams(int checks_ = 32) :$/;"	f	struct:cvflann::SearchParams	access:public	signature:(int checks_ = 32)
SearchParams	/usr/include/opencv2/flann/general.h	/^struct CV_EXPORTS SearchParams {$/;"	s	namespace:cvflann
SearchWindow	/usr/include/opencv2/contrib/contrib.hpp	/^        SearchWindow();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
SearchWindow	/usr/include/opencv2/contrib/contrib.hpp	/^    class SearchWindow$/;"	c	class:CvFuzzyMeanShiftTracker	access:private
SelectWorkingSet	/usr/include/opencv2/ml/ml.hpp	/^    typedef bool (CvSVMSolver::*SelectWorkingSet)( int& i, int& j );$/;"	t	class:CvSVMSolver	access:public
SelfSimDescriptor	/usr/include/opencv2/contrib/contrib.hpp	/^        SelfSimDescriptor();$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:()
SelfSimDescriptor	/usr/include/opencv2/contrib/contrib.hpp	/^        SelfSimDescriptor(const SelfSimDescriptor& ss);$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const SelfSimDescriptor& ss)
SelfSimDescriptor	/usr/include/opencv2/contrib/contrib.hpp	/^        SelfSimDescriptor(int _ssize, int _lsize,$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(int _ssize, int _lsize, int _startDistanceBucket=DEFAULT_START_DISTANCE_BUCKET, int _numberOfDistanceBuckets=DEFAULT_NUM_DISTANCE_BUCKETS, int _nangles=DEFAULT_NUM_ANGLES)
SelfSimDescriptor	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS SelfSimDescriptor$/;"	c	namespace:cv
Seq	/usr/include/opencv2/core/core.hpp	/^    Seq();$/;"	p	class:cv::Seq	access:public	signature:()
Seq	/usr/include/opencv2/core/core.hpp	/^    Seq(MemStorage& storage, int headerSize = sizeof(CvSeq));$/;"	p	class:cv::Seq	access:public	signature:(MemStorage& storage, int headerSize = sizeof(CvSeq))
Seq	/usr/include/opencv2/core/core.hpp	/^    Seq(const CvSeq* seq);$/;"	p	class:cv::Seq	access:public	signature:(const CvSeq* seq)
Seq	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Seq$/;"	c	namespace:cv
Seq	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq( MemStorage& storage,$/;"	f	class:cv::Seq	signature:( MemStorage& storage, int headerSize )
Seq	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq( const CvSeq* _seq ) : seq((CvSeq*)_seq)$/;"	f	class:cv::Seq	signature:( const CvSeq* _seq )
Seq	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq() : seq(0) {}$/;"	f	class:cv::Seq	signature:()
SeqIterator	/usr/include/opencv2/core/core.hpp	/^    SeqIterator();$/;"	p	class:cv::SeqIterator	access:public	signature:()
SeqIterator	/usr/include/opencv2/core/core.hpp	/^    SeqIterator(const Seq<_Tp>& seq, bool seekEnd=false);$/;"	p	class:cv::SeqIterator	access:public	signature:(const Seq<_Tp>& seq, bool seekEnd=false)
SeqIterator	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SeqIterator : public CvSeqReader$/;"	c	namespace:cv	inherits:CvSeqReader
SeqIterator	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator()$/;"	f	class:cv::SeqIterator	signature:()
SeqIterator	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator(const Seq<_Tp>& seq, bool seekEnd)$/;"	f	class:cv::SeqIterator	signature:(const Seq<_Tp>& seq, bool seekEnd)
SetBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    SetBlob(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* )
SetBlobByID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    SetBlobByID(int BlobID, CvBlob* pBlob);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID, CvBlob* pBlob)
SetBlobHyp	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    SetBlobHyp(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* )
SetCameraCount	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void SetCameraCount( int cameraCount );$/;"	p	class:CvCalibFilter	access:public	signature:( int cameraCount )
SetCameraParams	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool SetCameraParams( CvCamera* params );$/;"	p	class:CvCalibFilter	access:public	signature:( CvCamera* params )
SetCollision	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void SetCollision(int \/*CollisionFlag*\/){}; \/* call in case of blob collision situation*\/$/;"	f	class:CvBlobTrackerOne	access:public	signature:(int )
SetEtalon	/usr/include/opencv2/legacy/legacy.hpp	/^        SetEtalon( CvCalibEtalonType etalonType, double* etalonParams,$/;"	p	class:CvCalibFilter	access:public	signature:( CvCalibEtalonType etalonType, double* etalonParams, int pointCount = 0, CvPoint2D32f* points = 0 )
SetFileName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    SetFileName(char* \/*DataBaseName*\/){};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:(char* )
SetFileName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    SetFileName(char* pFileName) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(char* pFileName)
SetFrames	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool SetFrames( int totalFrames );$/;"	p	class:CvCalibFilter	access:public	signature:( int totalFrames )
SetIpl	/usr/include/opencv2/core/wimage.hpp	/^    void SetIpl(IplImage* image) {$/;"	f	class:cv::WImage	access:protected	signature:(IplImage* image)
SetIpl	/usr/include/opencv2/core/wimage.hpp	/^    void SetIpl(IplImage* image) {$/;"	f	class:cv::WImageC	access:protected	signature:(IplImage* image)
SetIpl	/usr/include/opencv2/core/wimage.hpp	/^    void SetIpl(IplImage* img) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(IplImage* img)
SetIpl	/usr/include/opencv2/core/wimage.hpp	/^    void SetIpl(IplImage* img) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(IplImage* img)
SetLabeledFeatures	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetLabeledFeatures(const vector<cv::KeyPoint>& features) {m_train_features = features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:(const vector<cv::KeyPoint>& features)
SetModuleName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void SetModuleName(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
SetNickName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void SetNickName(const char* pStr);$/;"	p	class:CvVSModule	access:public	signature:(const char* pStr)
SetPCADimHigh	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetPCADimHigh(int pca_dim_high) {m_pca_dim_high = pca_dim_high;};$/;"	f	class:cv::OneWayDescriptor	access:public	signature:(int pca_dim_high)
SetPCADimLow	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetPCADimLow(int pca_dim_low) {m_pca_dim_low = pca_dim_low;};$/;"	f	class:cv::OneWayDescriptor	access:public	signature:(int pca_dim_low)
SetPCAHigh	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetPCAHigh(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
SetPCALow	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetPCALow(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
SetParam	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void   SetParam(const char* name, double val);$/;"	p	class:CvVSModule	access:public	signature:(const char* name, double val)
SetParamStr	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void   SetParamStr(const char* name, const char* str);$/;"	p	class:CvVSModule	access:public	signature:(const char* name, const char* str)
SetShapes	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void SetShapes( const CvDrawShape* shapes, int num );$/;"	p	class:CvImageDrawer	access:public	signature:( const CvDrawShape* shapes, int num )
SetTransforms	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetTransforms(CvAffinePose* poses, CvMat** transforms);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvAffinePose* poses, CvMat** transforms)
SetTypeName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void SetTypeName(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
SetZero	/usr/include/opencv2/core/wimage.hpp	/^    void SetZero() { cvSetZero(image_); }$/;"	f	class:cv::WImage	access:public	signature:()
SiftDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    SiftDescriptorExtractor( const SIFT::DescriptorParams& descriptorParams=SIFT::DescriptorParams(),$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( const SIFT::DescriptorParams& descriptorParams=SIFT::DescriptorParams(), const SIFT::CommonParams& commonParams=SIFT::CommonParams() )
SiftDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    SiftDescriptorExtractor( double magnification, bool isNormalize=true, bool recalculateAngles=true,$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( double magnification, bool isNormalize=true, bool recalculateAngles=true, int nOctaves=SIFT::CommonParams::DEFAULT_NOCTAVES, int nOctaveLayers=SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS, int firstOctave=SIFT::CommonParams::DEFAULT_FIRST_OCTAVE, int angleMode=SIFT::CommonParams::FIRST_ANGLE )
SiftDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SiftDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
SiftFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    SiftFeatureDetector( const SIFT::DetectorParams& detectorParams=SIFT::DetectorParams(),$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( const SIFT::DetectorParams& detectorParams=SIFT::DetectorParams(), const SIFT::CommonParams& commonParams=SIFT::CommonParams() )
SiftFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    SiftFeatureDetector( double threshold, double edgeThreshold,$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( double threshold, double edgeThreshold, int nOctaves=SIFT::CommonParams::DEFAULT_NOCTAVES, int nOctaveLayers=SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS, int firstOctave=SIFT::CommonParams::DEFAULT_FIRST_OCTAVE, int angleMode=SIFT::CommonParams::FIRST_ANGLE )
SiftFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SiftFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
Size	/usr/include/opencv2/core/core.hpp	/^typedef Size2i Size;$/;"	t	namespace:cv
Size2f	/usr/include/opencv2/core/core.hpp	/^typedef Size_<float> Size2f;$/;"	t	namespace:cv
Size2i	/usr/include/opencv2/core/core.hpp	/^typedef Size_<int> Size2i;$/;"	t	namespace:cv
Size_	/usr/include/opencv2/core/core.hpp	/^    Size_();$/;"	p	class:cv::Size_	access:public	signature:()
Size_	/usr/include/opencv2/core/core.hpp	/^    Size_(_Tp _width, _Tp _height);$/;"	p	class:cv::Size_	access:public	signature:(_Tp _width, _Tp _height)
Size_	/usr/include/opencv2/core/core.hpp	/^    Size_(const CvSize& sz);$/;"	p	class:cv::Size_	access:public	signature:(const CvSize& sz)
Size_	/usr/include/opencv2/core/core.hpp	/^    Size_(const CvSize2D32f& sz);$/;"	p	class:cv::Size_	access:public	signature:(const CvSize2D32f& sz)
Size_	/usr/include/opencv2/core/core.hpp	/^    Size_(const Point_<_Tp>& pt);$/;"	p	class:cv::Size_	access:public	signature:(const Point_<_Tp>& pt)
Size_	/usr/include/opencv2/core/core.hpp	/^    Size_(const Size_& sz);$/;"	p	class:cv::Size_	access:public	signature:(const Size_& sz)
Size_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Size_$/;"	c	namespace:cv
Size_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Size_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_()$/;"	f	class:cv::Size_	signature:()
Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(_Tp _width, _Tp _height)$/;"	f	class:cv::Size_	signature:(_Tp _width, _Tp _height)
Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize& sz)$/;"	f	class:cv::Size_	signature:(const CvSize& sz)
Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize2D32f& sz)$/;"	f	class:cv::Size_	signature:(const CvSize2D32f& sz)
Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const Point_<_Tp>& pt) : width(pt.x), height(pt.y) {}$/;"	f	class:cv::Size_	signature:(const Point_<_Tp>& pt)
Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const Size_& sz)$/;"	f	class:cv::Size_	signature:(const Size_& sz)
SkipProcess	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void SkipProcess(CvBlob* \/*pBlobPrev*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL){};$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL)
Sobel	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void Sobel(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1)
Sobel	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(sobel) void Sobel( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, int dx, int dy, int ksize=3, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
SparseMat	/usr/include/opencv2/core/core.hpp	/^    SparseMat();$/;"	p	class:cv::SparseMat	access:public	signature:()
SparseMat	/usr/include/opencv2/core/core.hpp	/^    SparseMat(const CvSparseMat* m);$/;"	p	class:cv::SparseMat	access:public	signature:(const CvSparseMat* m)
SparseMat	/usr/include/opencv2/core/core.hpp	/^    SparseMat(const Mat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const Mat& m)
SparseMat	/usr/include/opencv2/core/core.hpp	/^    SparseMat(const SparseMat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const SparseMat& m)
SparseMat	/usr/include/opencv2/core/core.hpp	/^    SparseMat(int dims, const int* _sizes, int _type);$/;"	p	class:cv::SparseMat	access:public	signature:(int dims, const int* _sizes, int _type)
SparseMat	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS SparseMat$/;"	c	namespace:cv
SparseMat	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::SparseMat()$/;"	f	class:cv::SparseMat	signature:()
SparseMat	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::SparseMat(const SparseMat& m)$/;"	f	class:cv::SparseMat	signature:(const SparseMat& m)
SparseMat	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::SparseMat(int _dims, const int* _sizes, int _type)$/;"	f	class:cv::SparseMat	signature:(int _dims, const int* _sizes, int _type)
SparseMatConstIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
SparseMatConstIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator(const SparseMat* _m);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMat* _m)
SparseMatConstIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator(const SparseMatConstIterator& it);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMatConstIterator& it)
SparseMatConstIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS SparseMatConstIterator$/;"	c	namespace:cv
SparseMatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator::SparseMatConstIterator()$/;"	f	class:cv::SparseMatConstIterator	signature:()
SparseMatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator::SparseMatConstIterator(const SparseMatConstIterator& it)$/;"	f	class:cv::SparseMatConstIterator	signature:(const SparseMatConstIterator& it)
SparseMatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_();$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:()
SparseMatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_(const SparseMatConstIterator_& it);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMatConstIterator_& it)
SparseMatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_(const SparseMat_<_Tp>* _m);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMat_<_Tp>* _m)
SparseMatConstIterator_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMatConstIterator_ : public SparseMatConstIterator$/;"	c	namespace:cv	inherits:SparseMatConstIterator
SparseMatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_()$/;"	f	class:cv::SparseMatConstIterator_	signature:()
SparseMatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMatConstIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMatConstIterator_<_Tp>& it)
SparseMatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat_<_Tp>* _m)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMat_<_Tp>* _m)
SparseMatIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator();$/;"	p	class:cv::SparseMatIterator	access:public	signature:()
SparseMatIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator(SparseMat* _m);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(SparseMat* _m)
SparseMatIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator(SparseMat* _m, const int* idx);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(SparseMat* _m, const int* idx)
SparseMatIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator(const SparseMatIterator& it);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(const SparseMatIterator& it)
SparseMatIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS SparseMatIterator : public SparseMatConstIterator$/;"	c	namespace:cv	inherits:SparseMatConstIterator
SparseMatIterator	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator()$/;"	f	class:cv::SparseMatIterator	signature:()
SparseMatIterator	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator(SparseMat* _m)$/;"	f	class:cv::SparseMatIterator	signature:(SparseMat* _m)
SparseMatIterator	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator(const SparseMatIterator& it)$/;"	f	class:cv::SparseMatIterator	signature:(const SparseMatIterator& it)
SparseMatIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_();$/;"	p	class:cv::SparseMatIterator_	access:public	signature:()
SparseMatIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_(SparseMat_<_Tp>* _m);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(SparseMat_<_Tp>* _m)
SparseMatIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_(const SparseMatIterator_& it);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(const SparseMatIterator_& it)
SparseMatIterator_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMatIterator_ : public SparseMatConstIterator_<_Tp>$/;"	c	namespace:cv	inherits:SparseMatConstIterator_
SparseMatIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_()$/;"	f	class:cv::SparseMatIterator_	signature:()
SparseMatIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat_<_Tp>* _m)$/;"	f	class:cv::SparseMatIterator_	signature:(SparseMat_<_Tp>* _m)
SparseMatIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_(const SparseMatIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatIterator_	signature:(const SparseMatIterator_<_Tp>& it)
SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_();$/;"	p	class:cv::SparseMat_	access:public	signature:()
SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_(const CvSparseMat* m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const CvSparseMat* m)
SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_(const Mat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const Mat& m)
SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_(const SparseMat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat& m)
SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_(const SparseMat_& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat_& m)
SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_(int dims, const int* _sizes);$/;"	p	class:cv::SparseMat_	access:public	signature:(int dims, const int* _sizes)
SparseMat_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMat_ : public SparseMat$/;"	c	namespace:cv	inherits:SparseMat
SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_()$/;"	f	class:cv::SparseMat_	signature:()
SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const CvSparseMat* m)$/;"	f	class:cv::SparseMat_	signature:(const CvSparseMat* m)
SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const Mat& m)$/;"	f	class:cv::SparseMat_	signature:(const Mat& m)
SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat& m)
SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat_<_Tp>& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat_<_Tp>& m)
SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(int _dims, const int* _sizes)$/;"	f	class:cv::SparseMat_	signature:(int _dims, const int* _sizes)
SpinImageModel	/usr/include/opencv2/contrib/contrib.hpp	/^        SpinImageModel();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
SpinImageModel	/usr/include/opencv2/contrib/contrib.hpp	/^        explicit SpinImageModel(const Mesh3D& mesh);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Mesh3D& mesh)
SpinImageModel	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS SpinImageModel$/;"	c	namespace:cv
Split	/usr/include/opencv2/core/internal.hpp	/^        typedef tbb::split Split;$/;"	t	namespace:cv
Stage	/usr/include/opencv2/objdetect/objdetect.hpp	/^    struct CV_EXPORTS Stage$/;"	s	class:cv::CascadeClassifier	access:public
StarAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^	StarAdjuster(double initial_thresh = 30.0);$/;"	p	class:cv::StarAdjuster	access:public	signature:(double initial_thresh = 30.0)
StarAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS StarAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
StarDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP StarDetector();$/;"	p	class:cv::StarDetector	access:public	signature:()
StarDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP StarDetector(int _maxSize, int _responseThreshold,$/;"	p	class:cv::StarDetector	access:public	signature:(int _maxSize, int _responseThreshold, int _lineThresholdProjected, int _lineThresholdBinarized, int _suppressNonmaxSize)
StarDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS_W StarDetector : public CvStarDetectorParams$/;"	c	namespace:cv	inherits:CvStarDetectorParams
StarFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    StarFeatureDetector( const CvStarDetectorParams& params=cvStarDetectorParams() );$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( const CvStarDetectorParams& params=cvStarDetectorParams() )
StarFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    StarFeatureDetector( int maxSize, int responseThreshold=30, int lineThresholdProjected = 10,$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( int maxSize, int responseThreshold=30, int lineThresholdProjected = 10, int lineThresholdBinarized=8, int suppressNonmaxSize=5 )
StarFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS StarFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
StartFrame	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int         StartFrame;$/;"	m	struct:CvBlobTrack	access:public
StartStopTimer	/usr/include/opencv2/flann/timer.h	/^    StartStopTimer()$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
StartStopTimer	/usr/include/opencv2/flann/timer.h	/^class CV_EXPORTS StartStopTimer$/;"	c	namespace:cvflann
StatModel	/usr/include/opencv2/ml/ml.hpp	/^typedef CvStatModel StatModel;$/;"	t	namespace:cv
State	/usr/include/opencv2/legacy/legacy.hpp	/^    float* State;           \/* Vector of State                       *\/$/;"	m	struct:CvConDensation	access:public
StaticCheck	/usr/include/opencv2/gpu/devmem2d.hpp	/^        template <> struct StaticCheck<true>{};            $/;"	s	namespace:cv::gpu
StereoBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP StereoBM();$/;"	p	class:cv::StereoBM	access:public	signature:()
StereoBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP StereoBM(int preset, int ndisparities=0, int SADWindowSize=21);$/;"	p	class:cv::StereoBM	access:public	signature:(int preset, int ndisparities=0, int SADWindowSize=21)
StereoBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^class CV_EXPORTS_W StereoBM$/;"	c	namespace:cv
StereoBM_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            StereoBM_GPU();$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:()
StereoBM_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            StereoBM_GPU(int preset, int ndisparities = DEFAULT_NDISP, int winSize = DEFAULT_WINSZ);$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:(int preset, int ndisparities = DEFAULT_NDISP, int winSize = DEFAULT_WINSZ)
StereoBM_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS StereoBM_GPU$/;"	c	namespace:cv::gpu
StereoBeliefPropagation	/usr/include/opencv2/gpu/gpu.hpp	/^            StereoBeliefPropagation(int ndisp, int iters, int levels,$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int ndisp, int iters, int levels, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int msg_type = CV_32F)
StereoBeliefPropagation	/usr/include/opencv2/gpu/gpu.hpp	/^            explicit StereoBeliefPropagation(int ndisp  = DEFAULT_NDISP,$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int ndisp = DEFAULT_NDISP, int iters = DEFAULT_ITERS, int levels = DEFAULT_LEVELS, int msg_type = CV_32F)
StereoBeliefPropagation	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS StereoBeliefPropagation$/;"	c	namespace:cv::gpu
StereoConstantSpaceBP	/usr/include/opencv2/gpu/gpu.hpp	/^            StereoConstantSpaceBP(int ndisp, int iters, int levels, int nr_plane,$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int ndisp, int iters, int levels, int nr_plane, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int min_disp_th = 0, int msg_type = CV_32F)
StereoConstantSpaceBP	/usr/include/opencv2/gpu/gpu.hpp	/^            explicit StereoConstantSpaceBP(int ndisp    = DEFAULT_NDISP,$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int ndisp = DEFAULT_NDISP, int iters = DEFAULT_ITERS, int levels = DEFAULT_LEVELS, int nr_plane = DEFAULT_NR_PLANE, int msg_type = CV_32F)
StereoConstantSpaceBP	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS StereoConstantSpaceBP$/;"	c	namespace:cv::gpu
StereoSGBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP StereoSGBM();$/;"	p	class:cv::StereoSGBM	access:public	signature:()
StereoSGBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP StereoSGBM(int minDisparity, int numDisparities, int SADWindowSize,$/;"	p	class:cv::StereoSGBM	access:public	signature:(int minDisparity, int numDisparities, int SADWindowSize, int P1=0, int P2=0, int disp12MaxDiff=0, int preFilterCap=0, int uniquenessRatio=0, int speckleWindowSize=0, int speckleRange=0, bool fullDP=false)
StereoSGBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^class CV_EXPORTS_W StereoSGBM$/;"	c	namespace:cv
Stop	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void Stop( bool calibrate = false );$/;"	p	class:CvCalibFilter	access:public	signature:( bool calibrate = false )
Str	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*               Str;$/;"	m	struct:CvDefParam	access:public
Stream	/usr/include/opencv2/gpu/gpu.hpp	/^            Stream();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
Stream	/usr/include/opencv2/gpu/gpu.hpp	/^            Stream(const Stream&);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Stream&)
Stream	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS Stream$/;"	c	namespace:cv::gpu
StreamAccessor	/usr/include/opencv2/gpu/stream_accessor.hpp	/^        struct StreamAccessor$/;"	s	namespace:cv::gpu
String	/usr/include/opencv2/core/core.hpp	/^typedef std::string String;$/;"	t	namespace:cv
SurfAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^    SurfAdjuster();$/;"	p	class:cv::SurfAdjuster	access:public	signature:()
SurfAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SurfAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
SurfDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    SurfDescriptorExtractor( int nOctaves=4, int nOctaveLayers=2, bool extended=false );$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( int nOctaves=4, int nOctaveLayers=2, bool extended=false )
SurfDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SurfDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
SurfFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    SurfFeatureDetector( double hessianThreshold=400., int octaves=3, int octaveLayers=4 );$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( double hessianThreshold=400., int octaves=3, int octaveLayers=4 )
SurfFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SurfFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
T	/usr/include/opencv2/video/background_segm.hpp	/^    float  T;			\/* "A percentage value which determines when new features can be recognized as new background." (Typically 0.9).*\/$/;"	m	struct:CvFGDStatModelParams	access:public
THRESH_BINARY	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { THRESH_BINARY=0, THRESH_BINARY_INV=1, THRESH_TRUNC=2, THRESH_TOZERO=3,$/;"	e	enum:cv::__anon42
THRESH_BINARY_INV	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { THRESH_BINARY=0, THRESH_BINARY_INV=1, THRESH_TRUNC=2, THRESH_TOZERO=3,$/;"	e	enum:cv::__anon42
THRESH_MASK	/usr/include/opencv2/imgproc/imgproc.hpp	/^       THRESH_TOZERO_INV=4, THRESH_MASK=7, THRESH_OTSU=8 };$/;"	e	enum:cv::__anon42
THRESH_OTSU	/usr/include/opencv2/imgproc/imgproc.hpp	/^       THRESH_TOZERO_INV=4, THRESH_MASK=7, THRESH_OTSU=8 };$/;"	e	enum:cv::__anon42
THRESH_TOZERO	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { THRESH_BINARY=0, THRESH_BINARY_INV=1, THRESH_TRUNC=2, THRESH_TOZERO=3,$/;"	e	enum:cv::__anon42
THRESH_TOZERO_INV	/usr/include/opencv2/imgproc/imgproc.hpp	/^       THRESH_TOZERO_INV=4, THRESH_MASK=7, THRESH_OTSU=8 };$/;"	e	enum:cv::__anon42
THRESH_TRUNC	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { THRESH_BINARY=0, THRESH_BINARY_INV=1, THRESH_TRUNC=2, THRESH_TOZERO=3,$/;"	e	enum:cv::__anon42
TM_CCOEFF	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
TM_CCOEFF_NORMED	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
TM_CCORR	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
TM_CCORR_NORMED	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
TM_SQDIFF	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
TM_SQDIFF_NORMED	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
TRUE	/usr/include/opencv2/core/internal.hpp	91;"	d
TYPE_MASK	/usr/include/opencv2/core/core.hpp	/^        TYPE_MASK=7,$/;"	e	enum:cv::FileNode::__anon151
TYPE_MASK	/usr/include/opencv2/core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon141
T_GeometriccConsistency	/usr/include/opencv2/contrib/contrib.hpp	/^        float T_GeometriccConsistency;$/;"	m	class:cv::SpinImageModel	access:public
T_GroupingCorespondances	/usr/include/opencv2/contrib/contrib.hpp	/^        float T_GroupingCorespondances;$/;"	m	class:cv::SpinImageModel	access:public
Temp	/usr/include/opencv2/legacy/legacy.hpp	/^    float* Temp;            \/* Temporary vector                      *\/$/;"	m	struct:CvConDensation	access:public
Temp1	/usr/include/opencv2/video/tracking.hpp	/^    float* Temp1;               \/* temp1->data.fl *\/$/;"	m	struct:CvKalman	access:public
Temp2	/usr/include/opencv2/video/tracking.hpp	/^    float* Temp2;               \/* temp2->data.fl *\/$/;"	m	struct:CvKalman	access:public
TermCriteria	/usr/include/opencv2/core/core.hpp	/^    TermCriteria();$/;"	p	class:cv::TermCriteria	access:public	signature:()
TermCriteria	/usr/include/opencv2/core/core.hpp	/^    TermCriteria(const CvTermCriteria& criteria);$/;"	p	class:cv::TermCriteria	access:public	signature:(const CvTermCriteria& criteria)
TermCriteria	/usr/include/opencv2/core/core.hpp	/^    TermCriteria(int _type, int _maxCount, double _epsilon);$/;"	p	class:cv::TermCriteria	access:public	signature:(int _type, int _maxCount, double _epsilon)
TermCriteria	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS TermCriteria$/;"	c	namespace:cv
TermCriteria	/usr/include/opencv2/core/operations.hpp	/^inline TermCriteria::TermCriteria() : type(0), maxCount(0), epsilon(0) {}$/;"	f	class:cv::TermCriteria	signature:()
TermCriteria	/usr/include/opencv2/core/operations.hpp	/^inline TermCriteria::TermCriteria(const CvTermCriteria& criteria)$/;"	f	class:cv::TermCriteria	signature:(const CvTermCriteria& criteria)
TermCriteria	/usr/include/opencv2/core/operations.hpp	/^inline TermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon)$/;"	f	class:cv::TermCriteria	signature:(int _type, int _maxCount, double _epsilon)
TickMeter	/usr/include/opencv2/contrib/contrib.hpp	/^        TickMeter();$/;"	p	class:cv::TickMeter	access:public	signature:()
TickMeter	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS TickMeter$/;"	c	namespace:cv
Tn	/usr/include/opencv2/ml/ml.hpp	/^    int Tn;$/;"	m	struct:CvDTreeNode	access:public
TrackID	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int         TrackID;$/;"	m	struct:CvBlobTrack	access:public
TrackbarCallback	/usr/include/opencv2/highgui/highgui.hpp	/^typedef void (CV_CDECL *TrackbarCallback)(int pos, void* userdata);$/;"	t	namespace:cv
TrackingState	/usr/include/opencv2/contrib/contrib.hpp	/^    enum TrackingState$/;"	g	class:CvFuzzyMeanShiftTracker	access:public
TrainData	/usr/include/opencv2/ml/ml.hpp	/^typedef CvMLData TrainData;$/;"	t	namespace:cv
TransferParamsFromChild	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void TransferParamsFromChild(CvVSModule* pM, const char* prefix = NULL);$/;"	p	class:CvVSModule	access:public	signature:(CvVSModule* pM, const char* prefix = NULL)
TransferParamsToChild	/usr/include/opencv2/legacy/blobtrack.hpp	/^    void TransferParamsToChild(CvVSModule* pM, char* prefix = NULL);$/;"	p	class:CvVSModule	access:public	signature:(CvVSModule* pM, char* prefix = NULL)
Tree	/usr/include/opencv2/flann/kdtree_index.h	/^	typedef TreeSt* Tree;$/;"	t	class:cvflann::KDTreeIndex	access:private
TreeSt	/usr/include/opencv2/flann/kdtree_index.h	/^	struct TreeSt {$/;"	s	class:cvflann::KDTreeIndex	access:private
Type	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef T Type;$/;"	t	struct:cv::Accumulator	access:public
Type	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<char>   { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
Type	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<short>  { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
Type	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<unsigned char>  { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
Type	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<unsigned short> { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
U	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** U; \/\/size of array is equal to number of cameras$/;"	m	class:cv::LevMarqSparse	access:protected
UINT16	/usr/include/opencv2/flann/general.h	/^	UINT16 = 5,$/;"	e	enum:cvflann::flann_datatype_t
UINT32	/usr/include/opencv2/flann/general.h	/^	UINT32 = 6,$/;"	e	enum:cvflann::flann_datatype_t
UINT64	/usr/include/opencv2/flann/general.h	/^	UINT64 = 7,$/;"	e	enum:cvflann::flann_datatype_t
UINT8	/usr/include/opencv2/flann/general.h	/^	UINT8 = 4,$/;"	e	enum:cvflann::flann_datatype_t
UNDEFINED	/usr/include/opencv2/core/core.hpp	/^        UNDEFINED=0, $/;"	e	enum:cv::FileStorage::__anon150
UNIFORM	/usr/include/opencv2/core/core.hpp	/^    enum { A=4164903690U, UNIFORM=0, NORMAL=1 };$/;"	e	enum:cv::RNG::__anon143
UPDATE_WEIGHTS	/usr/include/opencv2/ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon90
USER	/usr/include/opencv2/core/core.hpp	/^        USER=16, \/\/!< a registered object (e.g. a matrix)$/;"	e	enum:cv::FileNode::__anon151
Undistort	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool Undistort( CvMat** src, CvMat** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** src, CvMat** dst )
Undistort	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool Undistort( IplImage** src, IplImage** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** src, IplImage** dst )
UniqueRandom	/usr/include/opencv2/flann/random.h	/^	UniqueRandom(int n) : vals(NULL) {$/;"	f	class:cvflann::UniqueRandom	access:public	signature:(int n)
UniqueRandom	/usr/include/opencv2/flann/random.h	/^class CV_EXPORTS UniqueRandom$/;"	c	namespace:cvflann
UntypedMatrix	/usr/include/opencv2/flann/matrix.h	/^    UntypedMatrix(void* data_, long rows_, long cols_) :$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:(void* data_, long rows_, long cols_)
UntypedMatrix	/usr/include/opencv2/flann/matrix.h	/^class UntypedMatrix$/;"	c	namespace:cvflann
Update	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void    Update(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:(CvBlob* pBlob)
Update	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Update(CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL){};$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL)
Update	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Update(IplImage* pImg, IplImage* pImgFG = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(IplImage* pImg, IplImage* pImgFG = NULL)
UpdateBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void UpdateBlob(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* , IplImage* , IplImage* = NULL)
UsePPData	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int                     UsePPData;$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
V	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** V; \/\/size of array is equal to number of points$/;"	m	class:cv::LevMarqSparse	access:protected
V	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvLSVMFilterPosition V;$/;"	m	struct:__anon60	access:public
VALUE_EXPECTED	/usr/include/opencv2/core/core.hpp	/^        VALUE_EXPECTED=1,$/;"	e	enum:cv::FileStorage::__anon150
Value	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual double Value(int* \/*comp*\/, int \/*x*\/ = 0, int \/*y*\/ = 0){return -1;};$/;"	f	class:CvProb	access:public	signature:(int* , int = 0, int = 0)
ValueType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef T ValueType;$/;"	t	struct:cv::L1	access:public
ValueType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef T ValueType;$/;"	t	struct:cv::L2	access:public
ValueType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef unsigned char ValueType;$/;"	t	struct:cv::Hamming	access:public
ValueType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef unsigned char ValueType;$/;"	t	struct:cv::HammingLUT	access:public
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec();$/;"	p	class:cv::Vec	access:public	signature:()
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0); \/\/!< 1-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0)
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1); \/\/!< 2-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1)
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2); \/\/!< 3-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2)
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3); \/\/!< 4-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); \/\/!< 5-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); \/\/!< 6-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); \/\/!< 7-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); \/\/!< 8-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); \/\/!< 9-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); \/\/!< 10-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(const Vec<_Tp, cn>& v);$/;"	p	class:cv::Vec	access:public	signature:(const Vec<_Tp, cn>& v)
Vec	/usr/include/opencv2/core/core.hpp	/^    explicit Vec(const _Tp* values);$/;"	p	class:cv::Vec	access:public	signature:(const _Tp* values)
Vec	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int cn> class CV_EXPORTS Vec : public Matx<_Tp, cn, 1>$/;"	c	namespace:cv	inherits:Matx
Vec	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int cn> class CV_EXPORTS Vec;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec()$/;"	f	class:cv::Vec	signature:()
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0)$/;"	f	class:cv::Vec	signature:(_Tp v0)
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1)
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2)
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const Vec<_Tp, cn>& v)$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& v)
Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const _Tp* values)$/;"	f	class:cv::Vec	signature:(const _Tp* values)
Vec2b	/usr/include/opencv2/core/core.hpp	/^typedef Vec<uchar, 2> Vec2b;$/;"	t	namespace:cv
Vec2d	/usr/include/opencv2/core/core.hpp	/^typedef Vec<double, 2> Vec2d;$/;"	t	namespace:cv
Vec2f	/usr/include/opencv2/core/core.hpp	/^typedef Vec<float, 2> Vec2f;$/;"	t	namespace:cv
Vec2i	/usr/include/opencv2/core/core.hpp	/^typedef Vec<int, 2> Vec2i;$/;"	t	namespace:cv
Vec2s	/usr/include/opencv2/core/core.hpp	/^typedef Vec<short, 2> Vec2s;$/;"	t	namespace:cv
Vec2w	/usr/include/opencv2/core/core.hpp	/^typedef Vec<ushort, 2> Vec2w;$/;"	t	namespace:cv
Vec3b	/usr/include/opencv2/core/core.hpp	/^typedef Vec<uchar, 3> Vec3b;$/;"	t	namespace:cv
Vec3d	/usr/include/opencv2/core/core.hpp	/^typedef Vec<double, 3> Vec3d;$/;"	t	namespace:cv
Vec3f	/usr/include/opencv2/core/core.hpp	/^typedef Vec<float, 3> Vec3f;$/;"	t	namespace:cv
Vec3i	/usr/include/opencv2/core/core.hpp	/^typedef Vec<int, 3> Vec3i;$/;"	t	namespace:cv
Vec3s	/usr/include/opencv2/core/core.hpp	/^typedef Vec<short, 3> Vec3s;$/;"	t	namespace:cv
Vec3w	/usr/include/opencv2/core/core.hpp	/^typedef Vec<ushort, 3> Vec3w;$/;"	t	namespace:cv
Vec4b	/usr/include/opencv2/core/core.hpp	/^typedef Vec<uchar, 4> Vec4b;$/;"	t	namespace:cv
Vec4d	/usr/include/opencv2/core/core.hpp	/^typedef Vec<double, 4> Vec4d;$/;"	t	namespace:cv
Vec4f	/usr/include/opencv2/core/core.hpp	/^typedef Vec<float, 4> Vec4f;$/;"	t	namespace:cv
Vec4i	/usr/include/opencv2/core/core.hpp	/^typedef Vec<int, 4> Vec4i;$/;"	t	namespace:cv
Vec4s	/usr/include/opencv2/core/core.hpp	/^typedef Vec<short, 4> Vec4s;$/;"	t	namespace:cv
Vec4w	/usr/include/opencv2/core/core.hpp	/^typedef Vec<ushort, 4> Vec4w;    $/;"	t	namespace:cv
Vec6d	/usr/include/opencv2/core/core.hpp	/^typedef Vec<double, 6> Vec6d;$/;"	t	namespace:cv
Vec6f	/usr/include/opencv2/core/core.hpp	/^typedef Vec<float, 6> Vec6f;$/;"	t	namespace:cv
VecCommaInitializer	/usr/include/opencv2/core/core.hpp	/^    VecCommaInitializer(Vec<_Tp, m>* _vec);$/;"	p	class:cv::VecCommaInitializer	access:public	signature:(Vec<_Tp, m>* _vec)
VecCommaInitializer	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int m> class CV_EXPORTS VecCommaInitializer : public MatxCommaInitializer<_Tp, m, 1>$/;"	c	namespace:cv	inherits:MatxCommaInitializer
VecCommaInitializer	/usr/include/opencv2/core/operations.hpp	/^VecCommaInitializer<_Tp, cn>::VecCommaInitializer(Vec<_Tp, cn>* _vec)$/;"	f	class:cv::VecCommaInitializer	signature:(Vec<_Tp, cn>* _vec)
VecReaderProxy	/usr/include/opencv2/core/operations.hpp	/^    VecReaderProxy( FileNodeIterator* _it ) : it(_it) {}$/;"	f	class:cv::VecReaderProxy	access:public	signature:( FileNodeIterator* _it )
VecReaderProxy	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int numflag> class CV_EXPORTS VecReaderProxy$/;"	c	namespace:cv
VecReaderProxy	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS VecReaderProxy<_Tp,1>$/;"	c	namespace:cv
VecWriterProxy	/usr/include/opencv2/core/operations.hpp	/^    VecWriterProxy( FileStorage* _fs ) : fs(_fs) {}$/;"	f	class:cv::VecWriterProxy	access:public	signature:( FileStorage* _fs )
VecWriterProxy	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int numflag> class CV_EXPORTS VecWriterProxy$/;"	c	namespace:cv
VecWriterProxy	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS VecWriterProxy<_Tp,1>$/;"	c	namespace:cv
Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector() {}$/;"	f	class:cv::Vector	access:public	signature:()
Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(_Tp* _data, size_t _size, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(_Tp* _data, size_t _size, bool _copyData=false)
Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(const Vector& d) { *this = d; }$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d)
Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(const Vector& d, const Range& r_)$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d, const Range& r_)
Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(const std::vector<_Tp>& vec, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(const std::vector<_Tp>& vec, bool _copyData=false)
Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(size_t _size)  { resize(_size); }$/;"	f	class:cv::Vector	access:public	signature:(size_t _size)
Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(size_t _size, const _Tp& val)$/;"	f	class:cv::Vector	access:public	signature:(size_t _size, const _Tp& val)
Vector	/usr/include/opencv2/core/operations.hpp	/^    template<int n> Vector(const Vec<_Tp, n>& vec)$/;"	f	class:cv::Vector	access:public	signature:(const Vec<_Tp, n>& vec)
Vector	/usr/include/opencv2/core/operations.hpp	/^template <typename _Tp> class CV_EXPORTS Vector$/;"	c	namespace:cv
VectorDescriptorMatch	/usr/include/opencv2/features2d/features2d.hpp	/^typedef VectorDescriptorMatcher VectorDescriptorMatch;$/;"	t	namespace:cv
VectorDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    VectorDescriptorMatcher( const Ptr<DescriptorExtractor>& extractor, const Ptr<DescriptorMatcher>& matcher );$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const Ptr<DescriptorExtractor>& extractor, const Ptr<DescriptorMatcher>& matcher )
VectorDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS VectorDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
VideoCapture	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP VideoCapture();$/;"	p	class:cv::VideoCapture	access:public	signature:()
VideoCapture	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP VideoCapture(const string& filename);$/;"	p	class:cv::VideoCapture	access:public	signature:(const string& filename)
VideoCapture	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP VideoCapture(int device);$/;"	p	class:cv::VideoCapture	access:public	signature:(int device)
VideoCapture	/usr/include/opencv2/highgui/highgui.hpp	/^class CV_EXPORTS_W VideoCapture$/;"	c	namespace:cv
VideoWriter	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP VideoWriter();$/;"	p	class:cv::VideoWriter	access:public	signature:()
VideoWriter	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP VideoWriter(const string& filename, int fourcc, double fps,$/;"	p	class:cv::VideoWriter	access:public	signature:(const string& filename, int fourcc, double fps, Size frameSize, bool isColor=true)
VideoWriter	/usr/include/opencv2/highgui/highgui.hpp	/^class CV_EXPORTS_W VideoWriter$/;"	c	namespace:cv
View	/usr/include/opencv2/core/wimage.hpp	/^    WImageView<T> View(int c, int r, int width, int height);$/;"	p	class:cv::WImage	access:public	signature:(int c, int r, int width, int height)
View	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC<T, C> View(int c, int r, int width, int height);$/;"	p	class:cv::WImageC	access:public	signature:(int c, int r, int width, int height)
View	/usr/include/opencv2/core/wimage.hpp	/^WImageView<T> WImage<T>::View(int c, int r, int width, int height) {$/;"	f	class:cv::WImage	signature:(int c, int r, int width, int height)
View	/usr/include/opencv2/core/wimage.hpp	/^WImageViewC<T, C> WImageC<T, C>::View(int c, int r, int width, int height) {$/;"	f	class:cv::WImageC	signature:(int c, int r, int width, int height)
Vis_index	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* Vis_index; \/\/ matrix which element is index of measurement for point i and camera j$/;"	m	class:cv::LevMarqSparse	access:protected
W	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* W;$/;"	m	class:cv::LevMarqSparse	access:protected
WARP_INVERSE_MAP	/usr/include/opencv2/imgproc/imgproc.hpp	/^    WARP_INVERSE_MAP=16$/;"	e	enum:cv::__anon40
WIN32	/usr/include/opencv2/core/internal.hpp	55;"	d
WIN32	/usr/include/opencv2/core/internal.hpp	77;"	d
WINDOW_AUTOSIZE	/usr/include/opencv2/highgui/highgui.hpp	/^enum { WINDOW_AUTOSIZE=1 };$/;"	e	enum:cv::__anon1
WImage	/usr/include/opencv2/core/wimage.hpp	/^    WImage(const WImage&);$/;"	p	class:cv::WImage	access:protected	signature:(const WImage&)
WImage	/usr/include/opencv2/core/wimage.hpp	/^    explicit WImage(IplImage* img) : image_(img) {$/;"	f	class:cv::WImage	access:protected	signature:(IplImage* img)
WImage	/usr/include/opencv2/core/wimage.hpp	/^class WImage$/;"	c	namespace:cv
WImage1_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<short, 1>        WImage1_16s;$/;"	t	namespace:cv
WImage1_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<ushort, 1>        WImage1_16u;$/;"	t	namespace:cv
WImage1_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<uchar, 1>        WImage1_b;$/;"	t	namespace:cv
WImage1_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<float, 1>        WImage1_f;$/;"	t	namespace:cv
WImage3_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<short, 3>        WImage3_16s;$/;"	t	namespace:cv
WImage3_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<ushort, 3>        WImage3_16u;$/;"	t	namespace:cv
WImage3_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<uchar, 3>        WImage3_b;$/;"	t	namespace:cv
WImage3_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<float, 3>        WImage3_f;$/;"	t	namespace:cv
WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^    WImageBuffer() : WImage<T>(0) {}$/;"	f	class:cv::WImageBuffer	access:public	signature:()
WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^    WImageBuffer(const WImageBuffer&);$/;"	p	class:cv::WImageBuffer	access:private	signature:(const WImageBuffer&)
WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^    WImageBuffer(int width, int height, int nchannels) : WImage<T>(0) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(int width, int height, int nchannels)
WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^    explicit WImageBuffer(IplImage* img) : WImage<T>(img) {}$/;"	f	class:cv::WImageBuffer	access:public	signature:(IplImage* img)
WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^class WImageBuffer : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
WImageBuffer1_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<short, 1>  WImageBuffer1_16s;$/;"	t	namespace:cv
WImageBuffer1_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<ushort, 1>  WImageBuffer1_16u;$/;"	t	namespace:cv
WImageBuffer1_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<uchar, 1>  WImageBuffer1_b;$/;"	t	namespace:cv
WImageBuffer1_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<float, 1>  WImageBuffer1_f;$/;"	t	namespace:cv
WImageBuffer3_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<short, 3>  WImageBuffer3_16s;$/;"	t	namespace:cv
WImageBuffer3_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<ushort, 3>  WImageBuffer3_16u;$/;"	t	namespace:cv
WImageBuffer3_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<uchar, 3>  WImageBuffer3_b;$/;"	t	namespace:cv
WImageBuffer3_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<float, 3>  WImageBuffer3_f;$/;"	t	namespace:cv
WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^    WImageBufferC() : WImageC<T, C>(0) {}$/;"	f	class:cv::WImageBufferC	access:public	signature:()
WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^    WImageBufferC(const WImageBufferC&);$/;"	p	class:cv::WImageBufferC	access:private	signature:(const WImageBufferC&)
WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^    WImageBufferC(int width, int height) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(int width, int height)
WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^    explicit WImageBufferC(IplImage* img) : WImageC<T, C>(img) {}$/;"	f	class:cv::WImageBufferC	access:public	signature:(IplImage* img)
WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^class WImageBufferC : public WImageC<T, C>$/;"	c	namespace:cv	inherits:WImageC
WImageBuffer_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBuffer<short>      WImageBuffer_16s;$/;"	t	namespace:cv
WImageBuffer_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBuffer<ushort>      WImageBuffer_16u;$/;"	t	namespace:cv
WImageBuffer_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBuffer<uchar>      WImageBuffer_b;$/;"	t	namespace:cv
WImageBuffer_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBuffer<float>      WImageBuffer_f;$/;"	t	namespace:cv
WImageC	/usr/include/opencv2/core/wimage.hpp	/^    WImageC(const WImageC&);$/;"	p	class:cv::WImageC	access:protected	signature:(const WImageC&)
WImageC	/usr/include/opencv2/core/wimage.hpp	/^    explicit WImageC(IplImage* img) : WImage<T>(img) {$/;"	f	class:cv::WImageC	access:public	signature:(IplImage* img)
WImageC	/usr/include/opencv2/core/wimage.hpp	/^class WImageC : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
WImageView	/usr/include/opencv2/core/wimage.hpp	/^    WImageView(IplImage* img) : WImage<T>(img) {}$/;"	f	class:cv::WImageView	access:public	signature:(IplImage* img)
WImageView	/usr/include/opencv2/core/wimage.hpp	/^    WImageView(T* data, int width, int height, int channels, int width_step = -1);$/;"	p	class:cv::WImageView	access:public	signature:(T* data, int width, int height, int channels, int width_step = -1)
WImageView	/usr/include/opencv2/core/wimage.hpp	/^    WImageView(WImage<T>* img, int c, int r, int width, int height);$/;"	p	class:cv::WImageView	access:public	signature:(WImage<T>* img, int c, int r, int width, int height)
WImageView	/usr/include/opencv2/core/wimage.hpp	/^    WImageView(const WImage<T>& img) : WImage<T>(0) {$/;"	f	class:cv::WImageView	access:public	signature:(const WImage<T>& img)
WImageView	/usr/include/opencv2/core/wimage.hpp	/^WImageView<T>::WImageView(T* data, int width, int height, int nchannels, int width_step)$/;"	f	class:cv::WImageView	signature:(T* data, int width, int height, int nchannels, int width_step)
WImageView	/usr/include/opencv2/core/wimage.hpp	/^WImageView<T>::WImageView(WImage<T>* img, int c, int r, int width, int height)$/;"	f	class:cv::WImageView	signature:(WImage<T>* img, int c, int r, int width, int height)
WImageView	/usr/include/opencv2/core/wimage.hpp	/^class WImageView : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
WImageView1_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<short, 1>    WImageView1_16s;$/;"	t	namespace:cv
WImageView1_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<ushort, 1>    WImageView1_16u;$/;"	t	namespace:cv
WImageView1_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<uchar, 1>    WImageView1_b;$/;"	t	namespace:cv
WImageView1_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<float, 1>    WImageView1_f;$/;"	t	namespace:cv
WImageView3_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<short, 3>    WImageView3_16s;$/;"	t	namespace:cv
WImageView3_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<ushort, 3>    WImageView3_16u;$/;"	t	namespace:cv
WImageView3_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<uchar, 3>    WImageView3_b;$/;"	t	namespace:cv
WImageView3_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<float, 3>    WImageView3_f;$/;"	t	namespace:cv
WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC();$/;"	p	class:cv::WImageViewC	access:public	signature:()
WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC(IplImage* img) : WImageC<T, C>(img) {}$/;"	f	class:cv::WImageViewC	access:public	signature:(IplImage* img)
WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC(T* data, int width, int height, int width_step = -1);$/;"	p	class:cv::WImageViewC	access:public	signature:(T* data, int width, int height, int width_step = -1)
WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC(WImageC<T, C>* img,$/;"	p	class:cv::WImageViewC	access:public	signature:(WImageC<T, C>* img, int c, int r, int width, int height)
WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC(const WImageC<T, C>& img) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageC<T, C>& img)
WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC(const WImageViewC<T, C>& img) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageViewC<T, C>& img)
WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC() : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	signature:()
WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC(T* data, int width, int height, int width_step)$/;"	f	class:cv::WImageViewC	signature:(T* data, int width, int height, int width_step)
WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC(WImageC<T, C>* img, int c, int r, int width, int height)$/;"	f	class:cv::WImageViewC	signature:(WImageC<T, C>* img, int c, int r, int width, int height)
WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^class WImageViewC : public WImageC<T, C>$/;"	c	namespace:cv	inherits:WImageC
WImageView_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageView<short>        WImageView_16s;$/;"	t	namespace:cv
WImageView_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageView<ushort>        WImageView_16u;$/;"	t	namespace:cv
WImageView_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageView<uchar>        WImageView_b;$/;"	t	namespace:cv
WImageView_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageView<float>        WImageView_f;$/;"	t	namespace:cv
WImage_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImage<short>            WImage_16s;$/;"	t	namespace:cv
WImage_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImage<ushort>            WImage_16u;$/;"	t	namespace:cv
WImage_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImage<uchar>            WImage_b;$/;"	t	namespace:cv
WImage_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImage<float>            WImage_f;$/;"	t	namespace:cv
WORDSIZE	/usr/include/opencv2/flann/allocator.h	/^const size_t     WORDSIZE=16;$/;"	m	namespace:cvflann
WRITE	/usr/include/opencv2/core/core.hpp	/^        WRITE=1, \/\/! write mode$/;"	e	enum:cv::FileStorage::__anon149
WString	/usr/include/opencv2/core/core.hpp	/^typedef std::basic_string<wchar_t> WString;$/;"	t	namespace:cv
Width	/usr/include/opencv2/core/wimage.hpp	/^    int Width() const {return image_->width; }$/;"	f	class:cv::WImage	access:public	signature:() const
WidthStep	/usr/include/opencv2/core/wimage.hpp	/^    int WidthStep() const {return image_->widthStep; }$/;"	f	class:cv::WImage	access:public	signature:() const
Write	/usr/include/opencv2/features2d/features2d.hpp	/^    void Write (FileStorage &fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(FileStorage &fs) const
Write	/usr/include/opencv2/features2d/features2d.hpp	/^    void Write(CvFileStorage* fs, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvFileStorage* fs, const char* name)
Write	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual void Write(CvFileStorage* fs, const char* name)$/;"	f	class:CvBlobSeq	access:public	signature:(CvFileStorage* fs, const char* name)
WriteStructContext	/usr/include/opencv2/core/operations.hpp	/^    WriteStructContext(FileStorage& _fs, const string& name,$/;"	p	class:cv::WriteStructContext	access:public	signature:(FileStorage& _fs, const string& name, int flags, const string& typeName=string())
WriteStructContext	/usr/include/opencv2/core/operations.hpp	/^class CV_EXPORTS WriteStructContext$/;"	c	namespace:cv
X	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* X; \/\/measurement$/;"	m	class:cv::LevMarqSparse	access:protected
Xcoef	/usr/include/opencv2/legacy/legacy.hpp	/^    double Xcoef;$/;"	m	struct:CvStereoLineCoeff	access:public
XcoefA	/usr/include/opencv2/legacy/legacy.hpp	/^    double XcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
XcoefAB	/usr/include/opencv2/legacy/legacy.hpp	/^    double XcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
XcoefB	/usr/include/opencv2/legacy/legacy.hpp	/^    double XcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
YAPE	/usr/include/opencv2/features2d/features2d.hpp	/^typedef LDetector YAPE;$/;"	t	namespace:cv
Ycoef	/usr/include/opencv2/legacy/legacy.hpp	/^    double Ycoef;$/;"	m	struct:CvStereoLineCoeff	access:public
YcoefA	/usr/include/opencv2/legacy/legacy.hpp	/^    double YcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
YcoefAB	/usr/include/opencv2/legacy/legacy.hpp	/^    double YcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
YcoefB	/usr/include/opencv2/legacy/legacy.hpp	/^    double YcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
Yj	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** Yj; \/\/length of array is i = num_points$/;"	m	class:cv::LevMarqSparse	access:protected
Zcoef	/usr/include/opencv2/legacy/legacy.hpp	/^    double Zcoef;$/;"	m	struct:CvStereoLineCoeff	access:public
ZcoefA	/usr/include/opencv2/legacy/legacy.hpp	/^    double ZcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
ZcoefAB	/usr/include/opencv2/legacy/legacy.hpp	/^    double ZcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
ZcoefB	/usr/include/opencv2/legacy/legacy.hpp	/^    double ZcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
ZeroIterator	/usr/include/opencv2/flann/dist.h	/^struct ZeroIterator {$/;"	s	namespace:cvflann
_CRT_SECURE_NO_DEPRECATE	/usr/include/opencv2/core/types_c.h	47;"	d
_CV_ALWAYS_NO_PROFILE_	/usr/include/opencv2/core/internal.hpp	84;"	d
_CV_ALWAYS_PROFILE_	/usr/include/opencv2/core/internal.hpp	83;"	d
_CvPixelPosition32f	/usr/include/opencv2/legacy/compat.hpp	/^typedef struct _CvPixelPosition32f$/;"	s
_CvPixelPosition32f::bottomline	/usr/include/opencv2/legacy/compat.hpp	/^    float*  bottomline;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::currline	/usr/include/opencv2/legacy/compat.hpp	/^    float*  currline;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::height	/usr/include/opencv2/legacy/compat.hpp	/^    int     height;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::step	/usr/include/opencv2/legacy/compat.hpp	/^    int     step;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::step_arr	/usr/include/opencv2/legacy/compat.hpp	/^    int     step_arr[3];$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::topline	/usr/include/opencv2/legacy/compat.hpp	/^    float*  topline;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::width	/usr/include/opencv2/legacy/compat.hpp	/^    int     width;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::x	/usr/include/opencv2/legacy/compat.hpp	/^    int     x;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition8s	/usr/include/opencv2/legacy/compat.hpp	/^typedef struct _CvPixelPosition8s$/;"	s
_CvPixelPosition8s::bottomline	/usr/include/opencv2/legacy/compat.hpp	/^    schar*  bottomline;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::currline	/usr/include/opencv2/legacy/compat.hpp	/^    schar*  currline;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::height	/usr/include/opencv2/legacy/compat.hpp	/^    int     height;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::step	/usr/include/opencv2/legacy/compat.hpp	/^    int     step;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::step_arr	/usr/include/opencv2/legacy/compat.hpp	/^    int     step_arr[3];$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::topline	/usr/include/opencv2/legacy/compat.hpp	/^    schar*  topline;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::width	/usr/include/opencv2/legacy/compat.hpp	/^    int     width;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::x	/usr/include/opencv2/legacy/compat.hpp	/^    int     x;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8u	/usr/include/opencv2/legacy/compat.hpp	/^typedef struct _CvPixelPosition8u$/;"	s
_CvPixelPosition8u::bottomline	/usr/include/opencv2/legacy/compat.hpp	/^    uchar*  bottomline;    \/* pointer to the start of the first line           *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::currline	/usr/include/opencv2/legacy/compat.hpp	/^    uchar*  currline;      \/* pointer to the start of the current pixel line   *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::height	/usr/include/opencv2/legacy/compat.hpp	/^    int     height;                 \/* height of the image  ( in pixels )               *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::step	/usr/include/opencv2/legacy/compat.hpp	/^    int     step;                   \/* distance between lines ( in elements of single   *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::step_arr	/usr/include/opencv2/legacy/compat.hpp	/^    int     step_arr[3];            \/* array: ( 0, -step, step ). It is used for        *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::topline	/usr/include/opencv2/legacy/compat.hpp	/^    uchar*  topline;       \/* pointer to the start of the top pixel line       *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::width	/usr/include/opencv2/legacy/compat.hpp	/^    int     width;                  \/* width of the image  ( in pixels )                *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::x	/usr/include/opencv2/legacy/compat.hpp	/^    int     x;                      \/* current x coordinate ( in pixels )               *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_GetLabeledFeatures	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<cv::KeyPoint> _GetLabeledFeatures() const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:() const
_IplConvKernel	/usr/include/opencv2/core/types_c.h	/^typedef struct _IplConvKernel$/;"	s
_IplConvKernel::anchorX	/usr/include/opencv2/core/types_c.h	/^    int  anchorX;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernel::anchorY	/usr/include/opencv2/core/types_c.h	/^    int  anchorY;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernel::nCols	/usr/include/opencv2/core/types_c.h	/^    int  nCols;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernel::nRows	/usr/include/opencv2/core/types_c.h	/^    int  nRows;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernel::nShiftR	/usr/include/opencv2/core/types_c.h	/^    int  nShiftR;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernel::values	/usr/include/opencv2/core/types_c.h	/^    int *values;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernelFP	/usr/include/opencv2/core/types_c.h	/^typedef struct _IplConvKernelFP$/;"	s
_IplConvKernelFP::anchorX	/usr/include/opencv2/core/types_c.h	/^    int  anchorX;$/;"	m	struct:_IplConvKernelFP	access:public
_IplConvKernelFP::anchorY	/usr/include/opencv2/core/types_c.h	/^    int  anchorY;$/;"	m	struct:_IplConvKernelFP	access:public
_IplConvKernelFP::nCols	/usr/include/opencv2/core/types_c.h	/^    int  nCols;$/;"	m	struct:_IplConvKernelFP	access:public
_IplConvKernelFP::nRows	/usr/include/opencv2/core/types_c.h	/^    int  nRows;$/;"	m	struct:_IplConvKernelFP	access:public
_IplConvKernelFP::values	/usr/include/opencv2/core/types_c.h	/^    float *values;$/;"	m	struct:_IplConvKernelFP	access:public
_IplImage	/usr/include/opencv2/core/types_c.h	/^typedef struct _IplImage$/;"	s
_IplImage::BorderConst	/usr/include/opencv2/core/types_c.h	/^    int  BorderConst[4];    \/* Ditto.                                 *\/$/;"	m	struct:_IplImage	access:public
_IplImage::BorderMode	/usr/include/opencv2/core/types_c.h	/^    int  BorderMode[4];     \/* Ignored by OpenCV.                     *\/$/;"	m	struct:_IplImage	access:public
_IplImage::ID	/usr/include/opencv2/core/types_c.h	/^    int  ID;                \/* version (=0)*\/$/;"	m	struct:_IplImage	access:public
_IplImage::align	/usr/include/opencv2/core/types_c.h	/^    int  align;             \/* Alignment of image rows (4 or 8).$/;"	m	struct:_IplImage	access:public
_IplImage::alphaChannel	/usr/include/opencv2/core/types_c.h	/^    int  alphaChannel;      \/* Ignored by OpenCV *\/$/;"	m	struct:_IplImage	access:public
_IplImage::channelSeq	/usr/include/opencv2/core/types_c.h	/^    char channelSeq[4];     \/* ditto *\/$/;"	m	struct:_IplImage	access:public
_IplImage::colorModel	/usr/include/opencv2/core/types_c.h	/^    char colorModel[4];     \/* Ignored by OpenCV *\/$/;"	m	struct:_IplImage	access:public
_IplImage::dataOrder	/usr/include/opencv2/core/types_c.h	/^    int  dataOrder;         \/* 0 - interleaved color channels, 1 - separate color channels.$/;"	m	struct:_IplImage	access:public
_IplImage::depth	/usr/include/opencv2/core/types_c.h	/^    int  depth;             \/* Pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16S,$/;"	m	struct:_IplImage	access:public
_IplImage::height	/usr/include/opencv2/core/types_c.h	/^    int  height;            \/* Image height in pixels.                          *\/$/;"	m	struct:_IplImage	access:public
_IplImage::imageData	/usr/include/opencv2/core/types_c.h	/^    char *imageData;        \/* Pointer to aligned image data.         *\/$/;"	m	struct:_IplImage	access:public
_IplImage::imageDataOrigin	/usr/include/opencv2/core/types_c.h	/^    char *imageDataOrigin;  \/* Pointer to very origin of image data$/;"	m	struct:_IplImage	access:public
_IplImage::imageId	/usr/include/opencv2/core/types_c.h	/^    void  *imageId;                 \/* "           " *\/$/;"	m	struct:_IplImage	access:public
_IplImage::imageSize	/usr/include/opencv2/core/types_c.h	/^    int  imageSize;         \/* Image data size in bytes$/;"	m	struct:_IplImage	access:public
_IplImage::maskROI	/usr/include/opencv2/core/types_c.h	/^    struct _IplImage *maskROI;      \/* Must be NULL. *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplImage	access:public
_IplImage::nChannels	/usr/include/opencv2/core/types_c.h	/^    int  nChannels;         \/* Most of OpenCV functions support 1,2,3 or 4 channels *\/$/;"	m	struct:_IplImage	access:public
_IplImage::nSize	/usr/include/opencv2/core/types_c.h	/^    int  nSize;             \/* sizeof(IplImage) *\/$/;"	m	struct:_IplImage	access:public
_IplImage::origin	/usr/include/opencv2/core/types_c.h	/^    int  origin;            \/* 0 - top-left origin,$/;"	m	struct:_IplImage	access:public
_IplImage::roi	/usr/include/opencv2/core/types_c.h	/^    struct _IplROI *roi;    \/* Image ROI. If NULL, the whole image is selected. *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplROI	access:public
_IplImage::tileInfo	/usr/include/opencv2/core/types_c.h	/^    struct _IplTileInfo *tileInfo;  \/* "           " *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplTileInfo	access:public
_IplImage::width	/usr/include/opencv2/core/types_c.h	/^    int  width;             \/* Image width in pixels.                           *\/$/;"	m	struct:_IplImage	access:public
_IplImage::widthStep	/usr/include/opencv2/core/types_c.h	/^    int  widthStep;         \/* Size of aligned image row in bytes.    *\/$/;"	m	struct:_IplImage	access:public
_IplROI	/usr/include/opencv2/core/types_c.h	/^typedef struct _IplROI$/;"	s
_IplROI::coi	/usr/include/opencv2/core/types_c.h	/^    int  coi; \/* 0 - no COI (all channels are selected), 1 - 0th channel is selected ...*\/$/;"	m	struct:_IplROI	access:public
_IplROI::height	/usr/include/opencv2/core/types_c.h	/^    int  height;$/;"	m	struct:_IplROI	access:public
_IplROI::width	/usr/include/opencv2/core/types_c.h	/^    int  width;$/;"	m	struct:_IplROI	access:public
_IplROI::xOffset	/usr/include/opencv2/core/types_c.h	/^    int  xOffset;$/;"	m	struct:_IplROI	access:public
_IplROI::yOffset	/usr/include/opencv2/core/types_c.h	/^    int  yOffset;$/;"	m	struct:_IplROI	access:public
_OPENCV_ALLOCATOR_H_	/usr/include/opencv2/flann/allocator.h	32;"	d
_OPENCV_ALL_INDICES_H_	/usr/include/opencv2/flann/all_indices.h	31;"	d
_OPENCV_AUTOTUNEDINDEX_H_	/usr/include/opencv2/flann/autotuned_index.h	32;"	d
_OPENCV_COMPOSITETREE_H_	/usr/include/opencv2/flann/composite_index.h	32;"	d
_OPENCV_DATASET_H_	/usr/include/opencv2/flann/matrix.h	32;"	d
_OPENCV_DIST_H_	/usr/include/opencv2/flann/dist.h	32;"	d
_OPENCV_FLANN_BASE_HPP_	/usr/include/opencv2/flann/flann_base.hpp	32;"	d
_OPENCV_FLANN_HPP_	/usr/include/opencv2/flann/flann.hpp	44;"	d
_OPENCV_GENERAL_H_	/usr/include/opencv2/flann/general.h	32;"	d
_OPENCV_GROUND_TRUTH_H_	/usr/include/opencv2/flann/ground_truth.h	32;"	d
_OPENCV_HDF5_H_	/usr/include/opencv2/flann/hdf5.h	31;"	d
_OPENCV_HEAP_H_	/usr/include/opencv2/flann/heap.h	32;"	d
_OPENCV_KDTREE_H_	/usr/include/opencv2/flann/kdtree_index.h	32;"	d
_OPENCV_KMEANSTREE_H_	/usr/include/opencv2/flann/kmeans_index.h	32;"	d
_OPENCV_LINEARSEARCH_H_	/usr/include/opencv2/flann/linear_index.h	32;"	d
_OPENCV_LOGGER_H_	/usr/include/opencv2/flann/logger.h	32;"	d
_OPENCV_NNINDEX_H_	/usr/include/opencv2/flann/nn_index.h	32;"	d
_OPENCV_OBJECT_FACTORY_H_	/usr/include/opencv2/flann/object_factory.h	32;"	d
_OPENCV_RANDOM_H_	/usr/include/opencv2/flann/random.h	32;"	d
_OPENCV_RESULTSET_H_	/usr/include/opencv2/flann/result_set.h	32;"	d
_OPENCV_SAMPLING_H_	/usr/include/opencv2/flann/sampling.h	31;"	d
_OPENCV_SAVING_H_	/usr/include/opencv2/flann/saving.h	30;"	d
_OPENCV_SIMPLEX_DOWNHILL_H_	/usr/include/opencv2/flann/simplex_downhill.h	32;"	d
_OPENCV_TESTING_H_	/usr/include/opencv2/flann/index_testing.h	32;"	d
_OPENCV_TIMER_H_	/usr/include/opencv2/flann/timer.h	32;"	d
_WIN32	/usr/include/opencv2/core/internal.hpp	58;"	d
_WIN32	/usr/include/opencv2/core/internal.hpp	80;"	d
_WIN32_WINNT	/usr/include/opencv2/core/internal.hpp	64;"	d
__BEGIN__	/usr/include/opencv2/core/internal.hpp	94;"	d
__CV_BEGIN__	/usr/include/opencv2/core/core_c.h	1853;"	d
__CV_END__	/usr/include/opencv2/core/core_c.h	1854;"	d
__CV_EXIT__	/usr/include/opencv2/core/core_c.h	1855;"	d
__CV_GPU_HOST_DEVICE__	/usr/include/opencv2/gpu/devmem2d.hpp	126;"	d
__CV_GPU_HOST_DEVICE__	/usr/include/opencv2/gpu/devmem2d.hpp	54;"	d
__END__	/usr/include/opencv2/core/internal.hpp	95;"	d
__OPENCV_ALL_HPP__	/usr/include/opencv2/opencv.hpp	44;"	d
__OPENCV_BACKGROUND_SEGM_HPP__	/usr/include/opencv2/video/background_segm.hpp	44;"	d
__OPENCV_CALIB3D_HPP__	/usr/include/opencv2/calib3d/calib3d.hpp	44;"	d
__OPENCV_COMPAT_HPP__	/usr/include/opencv2/legacy/compat.hpp	51;"	d
__OPENCV_CONTRIB_HPP__	/usr/include/opencv2/contrib/contrib.hpp	44;"	d
__OPENCV_CORE_C_H__	/usr/include/opencv2/core/core_c.h	45;"	d
__OPENCV_CORE_EIGEN_HPP__	/usr/include/opencv2/core/eigen.hpp	44;"	d
__OPENCV_CORE_HPP__	/usr/include/opencv2/core/core.hpp	47;"	d
__OPENCV_CORE_INTERNAL_HPP__	/usr/include/opencv2/core/internal.hpp	49;"	d
__OPENCV_CORE_MATRIX_OPERATIONS_HPP__	/usr/include/opencv2/core/mat.hpp	44;"	d
__OPENCV_CORE_OPERATIONS_HPP__	/usr/include/opencv2/core/operations.hpp	44;"	d
__OPENCV_CORE_TYPES_H__	/usr/include/opencv2/core/types_c.h	44;"	d
__OPENCV_CORE_WIMAGE_HPP__	/usr/include/opencv2/core/wimage.hpp	101;"	d
__OPENCV_CVSTREAMS_H__	/usr/include/opencv2/legacy/streams.hpp	43;"	d
__OPENCV_FEATURES_2D_HPP__	/usr/include/opencv2/features2d/features2d.hpp	44;"	d
__OPENCV_GPU_DEVMEM2D_HPP__	/usr/include/opencv2/gpu/devmem2d.hpp	44;"	d
__OPENCV_GPU_HPP__	/usr/include/opencv2/gpu/gpu.hpp	44;"	d
__OPENCV_GPU_MATRIX_OPERATIONS_HPP__	/usr/include/opencv2/gpu/matrix_operations.hpp	44;"	d
__OPENCV_GPU_STREAM_ACCESSOR_HPP__	/usr/include/opencv2/gpu/stream_accessor.hpp	44;"	d
__OPENCV_HIGHGUI_HPP__	/usr/include/opencv2/highgui/highgui.hpp	44;"	d
__OPENCV_HIGHGUI_H__	/usr/include/opencv2/highgui/highgui_c.h	43;"	d
__OPENCV_IMGPROC_HPP__	/usr/include/opencv2/imgproc/imgproc.hpp	48;"	d
__OPENCV_IMGPROC_IMGPROC_C_H__	/usr/include/opencv2/imgproc/imgproc_c.h	44;"	d
__OPENCV_IMGPROC_TYPES_C_H__	/usr/include/opencv2/imgproc/types_c.h	44;"	d
__OPENCV_LEGACY_HPP__	/usr/include/opencv2/legacy/legacy.hpp	43;"	d
__OPENCV_ML_HPP__	/usr/include/opencv2/ml/ml.hpp	42;"	d
__OPENCV_OBJDETECT_HPP__	/usr/include/opencv2/objdetect/objdetect.hpp	44;"	d
__OPENCV_TRACKING_HPP__	/usr/include/opencv2/video/tracking.hpp	48;"	d
__OPENCV_VERSION_HPP__	/usr/include/opencv2/core/version.hpp	48;"	d
__OPENCV_VIDEOSURVEILLANCE_H__	/usr/include/opencv2/legacy/blobtrack.hpp	44;"	d
__anon170::callback	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCallback callback;$/;"	m	union:__anon170	access:public
__anon170::data	/usr/include/opencv2/legacy/legacy.hpp	/^    void* data;$/;"	m	union:__anon170	access:public
__anon173::id	/usr/include/opencv2/legacy/legacy.hpp	/^    int id;$/;"	m	struct:__anon173	access:public
__anon173::p	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f p; \/\/ pgruebele: So we do not loose precision, this needs to be float$/;"	m	struct:__anon173	access:public
__anon174::id	/usr/include/opencv2/legacy/legacy.hpp	/^    int id;$/;"	m	struct:__anon174	access:public
__anon174::p	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint3D32f p;             \/\/ location of the tracked object$/;"	m	struct:__anon174	access:public
__anon175::mat	/usr/include/opencv2/legacy/legacy.hpp	/^    float mat[4][4];              \/* maps camera coordinates to world coordinates *\/$/;"	m	struct:__anon175	access:public
__anon175::principal_point	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f principal_point; \/* copied from intrinsics so this structure *\/$/;"	m	struct:__anon175	access:public
__anon175::valid	/usr/include/opencv2/legacy/legacy.hpp	/^    CvBool valid;$/;"	m	struct:__anon175	access:public
__anon176::distortion	/usr/include/opencv2/legacy/legacy.hpp	/^    float distortion[4];$/;"	m	struct:__anon176	access:public
__anon176::focal_length	/usr/include/opencv2/legacy/legacy.hpp	/^    float focal_length[2];$/;"	m	struct:__anon176	access:public
__anon176::principal_point	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f principal_point;$/;"	m	struct:__anon176	access:public
__anon59::l	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int l;$/;"	m	struct:__anon59	access:public
__anon59::x	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int x;$/;"	m	struct:__anon59	access:public
__anon59::y	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int y;$/;"	m	struct:__anon59	access:public
__anon60::H	/usr/include/opencv2/objdetect/objdetect.hpp	/^    float *H;$/;"	m	struct:__anon60	access:public
__anon60::V	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvLSVMFilterPosition V;$/;"	m	struct:__anon60	access:public
__anon60::fineFunction	/usr/include/opencv2/objdetect/objdetect.hpp	/^    float fineFunction[4];$/;"	m	struct:__anon60	access:public
__anon60::p	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int p;$/;"	m	struct:__anon60	access:public
__anon60::sizeX	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int sizeX;$/;"	m	struct:__anon60	access:public
__anon60::sizeY	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int sizeY;$/;"	m	struct:__anon60	access:public
__anon60::xp	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int xp;$/;"	m	struct:__anon60	access:public
__anon99::height	/usr/include/opencv2/core/types_c.h	/^    int height;$/;"	m	struct:__anon99	access:public
__anon99::width	/usr/include/opencv2/core/types_c.h	/^    int width;$/;"	m	struct:__anon99	access:public
a	/usr/include/opencv2/core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
abs	/usr/include/opencv2/core/core.hpp	70;"	d
abs	/usr/include/opencv2/core/mat.hpp	/^    virtual void abs(const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, MatExpr& res) const
abs	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr abs(const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
abs	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr abs(const MatExpr& e);$/;"	p	namespace:cv	signature:(const MatExpr& e)
abs	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr abs(const Mat_<_Tp>& m)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& m)
abs	/usr/include/opencv2/core/operations.hpp	/^double abs(const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a)
absdiff	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void absdiff(const Mat& src1, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst)
absdiff	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void absdiff(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst)
absdiff	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void absdiff(const GpuMat& a, const GpuMat& b, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c)
absdiff	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void absdiff(const GpuMat& a, const Scalar& s, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& s, GpuMat& c)
accumulate	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulate( const Mat& src, CV_IN_OUT Mat& dst, const Mat& mask=Mat() );$/;"	p	namespace:cv	signature:( const Mat& src, CV_IN_OUT Mat& dst, const Mat& mask=Mat() )
accumulateProduct	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateProduct( const Mat& src1, const Mat& src2,$/;"	p	namespace:cv	signature:( const Mat& src1, const Mat& src2, CV_IN_OUT Mat& dst, const Mat& mask=Mat() )
accumulateSquare	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateSquare( const Mat& src, CV_IN_OUT Mat& dst, const Mat& mask=Mat() );$/;"	p	namespace:cv	signature:( const Mat& src, CV_IN_OUT Mat& dst, const Mat& mask=Mat() )
accumulateWeighted	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateWeighted( const Mat& src, CV_IN_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_IN_OUT Mat& dst, double alpha, const Mat& mask=Mat() )
activ_func	/usr/include/opencv2/ml/ml.hpp	/^    int activ_func;$/;"	m	class:CvANN_MLP	access:protected
active_var_mask	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* active_var_mask;$/;"	m	class:CvRTrees	access:protected
active_vars	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* active_vars;$/;"	m	class:CvBoost	access:protected
active_vars_abs	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* active_vars_abs;$/;"	m	class:CvBoost	access:protected
adaptiveFilter	/usr/include/opencv2/contrib/contrib.hpp	/^    void adaptiveFilter();$/;"	p	class:CvAdaptiveSkinDetector	access:protected	signature:()
adaptiveThreshold	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void adaptiveThreshold( const Mat& src, CV_OUT Mat& dst, double maxValue,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C )
add	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void add(const Mat& src1, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst)
add	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void add(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask CV_WRAP_DEFAULT(Mat()));$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask CV_WRAP_DEFAULT(Mat()))
add	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void add(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
add	/usr/include/opencv2/core/mat.hpp	/^    virtual void add(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
add	/usr/include/opencv2/core/mat.hpp	/^    virtual void add(const MatExpr& expr1, const Scalar& s, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const Scalar& s, MatExpr& res) const
add	/usr/include/opencv2/features2d/features2d.hpp	/^        void add( const vector<Mat>& images, const vector<vector<KeyPoint> >& keypoints );$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( const vector<Mat>& images, const vector<vector<KeyPoint> >& keypoints )
add	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& descriptors );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const vector<Mat>& descriptors )
add	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& descriptors );$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( const vector<Mat>& descriptors )
add	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& images,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints )
add	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& imgCollection,$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const vector<Mat>& imgCollection, vector<vector<KeyPoint> >& pointCollection )
add	/usr/include/opencv2/features2d/features2d.hpp	/^    void add( const Mat& descriptors );$/;"	p	class:cv::BOWTrainer	access:public	signature:( const Mat& descriptors )
add	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void add(const GpuMat& a, const GpuMat& b, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c)
add	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void add(const GpuMat& a, const Scalar& sc, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c)
addCurve	/usr/include/opencv2/contrib/contrib.hpp	/^    void addCurve(CvFuzzyCurve *curve, double value = 0);$/;"	p	class:CvFuzzyFunction	access:public	signature:(CvFuzzyCurve *curve, double value = 0)
addExample	/usr/include/opencv2/features2d/features2d.hpp	/^  void addExample(int class_id, uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int class_id, uchar* patch_data)
addPoint	/usr/include/opencv2/contrib/contrib.hpp	/^    void addPoint(double x, double y);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double x, double y)
addPoint	/usr/include/opencv2/flann/result_set.h	/^	bool addPoint(const ELEM_TYPE* point, int index)$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(const ELEM_TYPE* point, int index)
addPoint	/usr/include/opencv2/flann/result_set.h	/^	bool addPoint(const ELEM_TYPE* point, int index)$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:(const ELEM_TYPE* point, int index)
addPoint	/usr/include/opencv2/flann/result_set.h	/^	virtual bool addPoint(const ELEM_TYPE* point, int index) = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:(const ELEM_TYPE* point, int index)
addRule	/usr/include/opencv2/contrib/contrib.hpp	/^    void addRule(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1);$/;"	p	class:CvFuzzyController	access:public	signature:(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1)
addText	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void addText( const Mat& img, const string& text, Point org, CvFont font);$/;"	p	namespace:cv	signature:( const Mat& img, const string& text, Point org, CvFont font)
addValue	/usr/include/opencv2/flann/simplex_downhill.h	/^void addValue(int pos, float val, float* vals, T* point, T* points, int n)$/;"	f	namespace:cvflann	signature:(int pos, float val, float* vals, T* point, T* points, int n)
addWeighted	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void addWeighted(const Mat& src1, double alpha, const Mat& src2,$/;"	p	namespace:cv	signature:(const Mat& src1, double alpha, const Mat& src2, double beta, double gamma, CV_OUT Mat& dst)
addedDescCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int addedDescCount;$/;"	m	class:cv::FlannBasedMatcher	access:protected
addref	/usr/include/opencv2/core/core.hpp	/^    void addref();$/;"	p	class:cv::Mat	access:public	signature:()
addref	/usr/include/opencv2/core/core.hpp	/^    void addref();$/;"	p	class:cv::Ptr	access:public	signature:()
addref	/usr/include/opencv2/core/core.hpp	/^    void addref();$/;"	p	class:cv::SparseMat	access:public	signature:()
addref	/usr/include/opencv2/core/mat.hpp	/^inline void Mat::addref()$/;"	f	class:cv::Mat	signature:()
addref	/usr/include/opencv2/core/mat.hpp	/^inline void SparseMat::addref()$/;"	f	class:cv::SparseMat	signature:()
addref	/usr/include/opencv2/core/operations.hpp	/^    void addref() { if( hdr.refcount ) CV_XADD(hdr.refcount, 1); }$/;"	f	class:cv::Vector	access:public	signature:()
addref	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::addref()$/;"	f	class:cv::Ptr	signature:()
addref	/usr/include/opencv2/legacy/legacy.hpp	/^    void addref() const$/;"	f	class:CvMatrix	access:public	signature:() const
address	/usr/include/opencv2/core/core.hpp	/^    const_pointer address(const_reference r) { return &r; }$/;"	f	class:cv::Allocator	access:public	signature:(const_reference r)
address	/usr/include/opencv2/core/core.hpp	/^    pointer address(reference r) { return &r; }$/;"	f	class:cv::Allocator	access:public	signature:(reference r)
adj_matr	/usr/include/opencv2/legacy/legacy.hpp	/^    int**    adj_matr;$/;"	m	struct:CvCliqueFinder	access:public
adjustROI	/usr/include/opencv2/core/core.hpp	/^    Mat& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::Mat	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
adjustROI	/usr/include/opencv2/core/core.hpp	/^    Mat_& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::Mat_	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
adjustROI	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::adjustROI( int dtop, int dbottom, int dleft, int dright )$/;"	f	class:cv::Mat_	signature:( int dtop, int dbottom, int dleft, int dright )
adjustROI	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
adjustROI	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat& GpuMat::adjustROI( int dtop, int dbottom, int dleft, int dright )$/;"	f	class:cv::gpu::GpuMat	signature:( int dtop, int dbottom, int dleft, int dright )
adjuster_	/usr/include/opencv2/features2d/features2d.hpp	/^	Ptr<AdjusterAdapter> adjuster_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
algorithm	/usr/include/opencv2/flann/general.h	/^	flann_algorithm_t algorithm;$/;"	m	struct:cvflann::IndexParams	access:public
align	/usr/include/opencv2/core/types_c.h	/^    int  align;             \/* Alignment of image rows (4 or 8).$/;"	m	struct:_IplImage	access:public
alignPtr	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> static inline _Tp* alignPtr(_Tp* ptr, int n=(int)sizeof(_Tp))$/;"	f	namespace:cv	signature:(_Tp* ptr, int n=(int)sizeof(_Tp))
alignSize	/usr/include/opencv2/core/core.hpp	/^static inline size_t alignSize(size_t sz, int n)$/;"	f	namespace:cv	signature:(size_t sz, int n)
all	/usr/include/opencv2/core/core.hpp	/^    static Matx all(_Tp alpha);$/;"	p	class:cv::Matx	access:public	signature:(_Tp alpha)
all	/usr/include/opencv2/core/core.hpp	/^    static Range all();$/;"	p	class:cv::Range	access:public	signature:()
all	/usr/include/opencv2/core/core.hpp	/^    static Scalar_<_Tp> all(_Tp v0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0)
all	/usr/include/opencv2/core/core.hpp	/^    static Vec all(_Tp alpha);$/;"	p	class:cv::Vec	access:public	signature:(_Tp alpha)
all	/usr/include/opencv2/core/operations.hpp	/^inline Range Range::all() { return Range(INT_MIN, INT_MAX); }$/;"	f	class:cv::Range	signature:()
all	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::all(_Tp alpha)$/;"	f	class:cv::Vec	signature:(_Tp alpha)
all	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n> Matx<_Tp, m, n>::all(_Tp alpha)$/;"	f	class:cv::Matx	signature:(_Tp alpha)
all	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::all(_Tp v0)$/;"	f	class:cv::Scalar_	signature:(_Tp v0)
allocPosteriorsAligned	/usr/include/opencv2/features2d/features2d.hpp	/^  void allocPosteriorsAligned(int num_leaves, int num_classes);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_leaves, int num_classes)
alloc_type	/usr/include/opencv2/gpu/gpu.hpp	/^            int alloc_type;$/;"	m	class:cv::gpu::CudaMem	access:public
alloca	/usr/include/opencv2/core/internal.hpp	266;"	d
alloca	/usr/include/opencv2/core/internal.hpp	267;"	d
allocate	/usr/include/opencv2/core/core.hpp	/^    pointer allocate(size_type count, const void* =0)$/;"	f	class:cv::Allocator	access:public	signature:(size_type count, const void* =0)
allocate	/usr/include/opencv2/core/core.hpp	/^    virtual void allocate(int dims, const int* sizes, int type, int*& refcount,$/;"	p	class:cv::MatAllocator	access:public	signature:(int dims, const int* sizes, int type, int*& refcount, uchar*& datastart, uchar*& data, size_t* step)
allocate	/usr/include/opencv2/core/core.hpp	/^    void allocate(size_t _size);$/;"	p	class:cv::AutoBuffer	access:public	signature:(size_t _size)
allocate	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> static inline _Tp* allocate(size_t n)$/;"	f	namespace:cv	signature:(size_t n)
allocate	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::allocate(size_t _size)$/;"	f	class:cv::AutoBuffer	signature:(size_t _size)
allocate	/usr/include/opencv2/flann/allocator.h	/^	T* allocate(size_t count = 1)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(size_t count = 1)
allocate	/usr/include/opencv2/flann/allocator.h	/^T* allocate(size_t count = 1)$/;"	f	namespace:cvflann	signature:(size_t count = 1)
allocateBytes	/usr/include/opencv2/flann/allocator.h	/^	void* allocateBytes(int size)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(int size)
allocator	/usr/include/opencv2/core/core.hpp	/^    MatAllocator* allocator;$/;"	m	class:cv::Mat	access:public
allzero	/usr/include/opencv2/contrib/contrib.hpp	/^        const static Point3f allzero;$/;"	m	class:cv::Mesh3D	access:public
alpha	/usr/include/opencv2/core/mat.hpp	/^    double alpha, beta;$/;"	m	class:cv::MatExpr	access:public
alpha	/usr/include/opencv2/ml/ml.hpp	/^    double alpha;$/;"	m	struct:CvDTreeNode	access:public
alpha	/usr/include/opencv2/ml/ml.hpp	/^    double* alpha;$/;"	m	class:CvSVMSolver	access:public
alpha	/usr/include/opencv2/ml/ml.hpp	/^    double* alpha;$/;"	m	struct:CvSVMDecisionFunc	access:public
alpha	/usr/include/opencv2/objdetect/objdetect.hpp	/^    float* alpha;$/;"	m	struct:CvHaarClassifier	access:public
alpha1	/usr/include/opencv2/video/background_segm.hpp	/^    float  alpha1;		\/* How quickly we forget old background pixel values seen.  Typically set to 0.1  				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
alpha2	/usr/include/opencv2/video/background_segm.hpp	/^    float  alpha2;		\/* "Controls speed of feature learning". Depends on T. Typical value circa 0.005. 				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
alpha3	/usr/include/opencv2/video/background_segm.hpp	/^    float  alpha3;		\/* Alternate to alpha2, used (e.g.) for quicker initial convergence. Typical value 0.1.				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
alphaChannel	/usr/include/opencv2/core/types_c.h	/^    int  alphaChannel;      \/* Ignored by OpenCV *\/$/;"	m	struct:_IplImage	access:public
alpha_count	/usr/include/opencv2/ml/ml.hpp	/^    int alpha_count;$/;"	m	class:CvSVMSolver	access:public
alpha_status	/usr/include/opencv2/ml/ml.hpp	/^    schar* alpha_status;$/;"	m	class:CvSVMSolver	access:public
anchor	/usr/include/opencv2/gpu/gpu.hpp	/^            Point anchor;$/;"	m	class:cv::gpu::BaseFilter_GPU	access:public
anchor	/usr/include/opencv2/gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseColumnFilter_GPU	access:public
anchor	/usr/include/opencv2/gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseRowFilter_GPU	access:public
anchor	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Point anchor;$/;"	m	class:cv::BaseFilter	access:public
anchor	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Point anchor;$/;"	m	class:cv::FilterEngine	access:public
anchor	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseColumnFilter	access:public
anchor	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseRowFilter	access:public
anchorX	/usr/include/opencv2/core/types_c.h	/^    int  anchorX;$/;"	m	struct:_IplConvKernel	access:public
anchorX	/usr/include/opencv2/core/types_c.h	/^    int  anchorX;$/;"	m	struct:_IplConvKernelFP	access:public
anchorY	/usr/include/opencv2/core/types_c.h	/^    int  anchorY;$/;"	m	struct:_IplConvKernel	access:public
anchorY	/usr/include/opencv2/core/types_c.h	/^    int  anchorY;$/;"	m	struct:_IplConvKernelFP	access:public
angle	/usr/include/opencv2/core/core.hpp	/^    float angle;    \/\/< the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle. $/;"	m	class:cv::RotatedRect	access:public
angle	/usr/include/opencv2/core/types_c.h	/^    float angle;          \/* Angle between the horizontal axis           *\/$/;"	m	struct:CvBox2D	access:public
angle	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW float angle; \/\/!< computed orientation of the keypoint (-1 if not applicable)$/;"	m	class:cv::KeyPoint	access:public
angleMode	/usr/include/opencv2/features2d/features2d.hpp	/^        int angleMode;$/;"	m	struct:cv::SIFT::CommonParams	access:public
appearance_profile	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     appearance_profile;$/;"	m	struct:CvBlobTrackerParamMS	access:public
apply	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual void apply(const GpuMat& src, GpuMat& dst, Rect roi = Rect(0,0,-1,-1)) = 0;$/;"	p	class:cv::gpu::FilterEngine_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst, Rect roi = Rect(0,0,-1,-1))
apply	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void apply( const Mat& src, Mat& dst,$/;"	p	class:cv::FilterEngine	access:public	signature:( const Mat& src, Mat& dst, const Rect& srcRoi=Rect(0,0,-1,-1), Point dstOfs=Point(0,0), bool isolated=false)
applyQuantization	/usr/include/opencv2/features2d/features2d.hpp	/^  inline void applyQuantization(int num_quant_bits) { makePosteriors2(num_quant_bits); }$/;"	f	class:cv::RandomizedTree	access:public	signature:(int num_quant_bits)
approxPolyDP	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void approxPolyDP( const Mat& curve,$/;"	p	namespace:cv	signature:( const Mat& curve, CV_OUT vector<Point2f>& approxCurve, double epsilon, bool closed )
approxPolyDP	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void approxPolyDP( const Mat& curve,$/;"	p	namespace:cv	signature:( const Mat& curve, CV_OUT vector<Point>& approxCurve, double epsilon, bool closed )
arcLength	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double arcLength( const Mat& curve, bool closed );$/;"	p	namespace:cv	signature:( const Mat& curve, bool closed )
area	/usr/include/opencv2/core/core.hpp	/^    _Tp area() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
area	/usr/include/opencv2/core/core.hpp	/^    _Tp area() const;$/;"	p	class:cv::Size_	access:public	signature:() const
area	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp Rect_<_Tp>::area() const { return width*height; }$/;"	f	class:cv::Rect_	signature:() const
area	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp Size_<_Tp>::area() const { return width*height; }$/;"	f	class:cv::Size_	signature:() const
area	/usr/include/opencv2/imgproc/types_c.h	/^    double area;    \/* area of the connected component  *\/$/;"	m	struct:CvConnectedComp	access:public
areaThreshold	/usr/include/opencv2/features2d/features2d.hpp	/^    double areaThreshold;$/;"	m	struct:CvMSERParams	access:public
arr	/usr/include/opencv2/core/core_c.h	/^CVAPI(CvScalar)  cvSum( const CvArr* arr );$/;"	v
arr	/usr/include/opencv2/core/core_c.h	/^CVAPI(CvSize) cvGetSize( const CvArr* arr );$/;"	v
arr	/usr/include/opencv2/core/core_c.h	/^CVAPI(int)  cvCountNonZero( const CvArr* arr );$/;"	v
arr	/usr/include/opencv2/core/core_c.h	/^CVAPI(int) cvGetElemType( const CvArr* arr );$/;"	v
arr	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvCreateData( CvArr* arr );$/;"	v
arr	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvReleaseData( CvArr* arr );$/;"	v
arr	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvSetZero( CvArr* arr );$/;"	v
arr	/usr/include/opencv2/core/operations.hpp	/^    const _Tp* arr;$/;"	m	class:cv::GreaterEqIdx	access:public
arr	/usr/include/opencv2/core/operations.hpp	/^    const _Tp* arr;$/;"	m	class:cv::LessThanIdx	access:public
array_iterator	/usr/include/opencv2/core/core_c.h	/^CVAPI(int) cvNextNArraySlice( CvNArrayIterator* array_iterator );$/;"	v
arrays	/usr/include/opencv2/core/core.hpp	/^    const Mat** arrays;$/;"	m	class:cv::NAryMatIterator	access:public
as	/usr/include/opencv2/flann/matrix.h	/^    Matrix<T> as()$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:()
ascii	/usr/include/opencv2/core/core_c.h	/^    const int*  ascii; 			\/* font data and metrics *\/$/;"	m	struct:CvFont	access:public
ask_for_proj	/usr/include/opencv2/contrib/contrib.hpp	/^        void ask_for_proj();$/;"	p	class:cv::LevMarqSparse	access:protected	signature:()
ask_for_projac	/usr/include/opencv2/contrib/contrib.hpp	/^        void ask_for_projac();$/;"	p	class:cv::LevMarqSparse	access:protected	signature:()
assign	/usr/include/opencv2/core/mat.hpp	/^    virtual void assign(const MatExpr& expr, Mat& m, int type=-1) const = 0;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m, int type=-1) const
assignTo	/usr/include/opencv2/core/core.hpp	/^    void assignTo( Mat& m, int type=-1 ) const;$/;"	p	class:cv::Mat	access:public	signature:( Mat& m, int type=-1 ) const
assignTo	/usr/include/opencv2/core/core.hpp	/^    void assignTo( SparseMat& m, int type=-1 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m, int type=-1 ) const
assignTo	/usr/include/opencv2/core/mat.hpp	/^inline void Mat::assignTo( Mat& m, int type ) const$/;"	f	class:cv::Mat	signature:( Mat& m, int type ) const
assignTo	/usr/include/opencv2/core/mat.hpp	/^inline void SparseMat::assignTo( SparseMat& m, int type ) const$/;"	f	class:cv::SparseMat	signature:( SparseMat& m, int type ) const
assignTo	/usr/include/opencv2/gpu/gpu.hpp	/^            void assignTo( GpuMat& m, int type=-1 ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, int type=-1 ) const
assignTo	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline void GpuMat::assignTo( GpuMat& m, int type ) const$/;"	f	class:cv::gpu::GpuMat	signature:( GpuMat& m, int type ) const
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> _Tp& at(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> const _Tp& at(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& at(Point pt);$/;"	p	class:cv::Mat	access:public	signature:(Point pt)
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& at(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& at(Point pt) const;$/;"	p	class:cv::Mat	access:public	signature:(Point pt) const
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& at(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(Point pt)$/;"	f	class:cv::Mat	signature:(Point pt)
at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(const int* idx)$/;"	f	class:cv::Mat	signature:(const int* idx)
at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0)$/;"	f	class:cv::Mat	signature:(int i0)
at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0, int i1)$/;"	f	class:cv::Mat	signature:(int i0, int i1)
at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0, int i1, int i2)$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2)
at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(Point pt) const$/;"	f	class:cv::Mat	signature:(Point pt) const
at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(const int* idx) const$/;"	f	class:cv::Mat	signature:(const int* idx) const
at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0) const$/;"	f	class:cv::Mat	signature:(int i0) const
at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1) const$/;"	f	class:cv::Mat	signature:(int i0, int i1) const
at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1, int i2) const$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2) const
attach	/usr/include/opencv2/legacy/legacy.hpp	/^    void attach( IplImage* img, bool use_refcount=true )$/;"	f	class:CvImage	access:public	signature:( IplImage* img, bool use_refcount=true )
attempts	/usr/include/opencv2/features2d/features2d.hpp	/^    int attempts;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
attr	/usr/include/opencv2/core/types_c.h	/^    const char** attr;         \/* NULL-terminated array of (attribute_name,attribute_value) pairs. *\/$/;"	m	struct:CvAttrList	access:public
augAssignAdd	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignAdd(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignAnd	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignAnd(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignDivide	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignDivide(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignMultiply	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignMultiply(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignOr	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignOr(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignSubtract	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignSubtract(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignXor	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignXor(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
avergeTexThreshold	/usr/include/opencv2/gpu/gpu.hpp	/^            float avergeTexThreshold;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
avg	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** avg;$/;"	m	class:CvNormalBayesClassifier	access:protected
b	/usr/include/opencv2/core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
b	/usr/include/opencv2/ml/ml.hpp	/^    double* b;$/;"	m	class:CvSVMSolver	access:public
b	/usr/include/opencv2/objdetect/objdetect.hpp	/^	float* b;$/;"	m	struct:CvLatentSvmDetector	access:public
back	/usr/include/opencv2/core/core.hpp	/^    _Tp& back();$/;"	p	class:cv::Seq	access:public	signature:()
back	/usr/include/opencv2/core/core.hpp	/^    const _Tp& back() const;$/;"	p	class:cv::Seq	access:public	signature:() const
back	/usr/include/opencv2/core/operations.hpp	/^    _Tp& back() { CV_DbgAssert(!empty()); return hdr.data[hdr.size-1]; }$/;"	f	class:cv::Vector	access:public	signature:()
back	/usr/include/opencv2/core/operations.hpp	/^    const _Tp& back() const { CV_DbgAssert(!empty()); return hdr.data[hdr.size-1]; }$/;"	f	class:cv::Vector	access:public	signature:() const
back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::back()$/;"	f	class:cv::Seq	signature:()
back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::back() const$/;"	f	class:cv::Seq	signature:() const
backProject	/usr/include/opencv2/core/core.hpp	/^    Mat backProject(const Mat& vec) const;$/;"	p	class:cv::PCA	access:public	signature:(const Mat& vec) const
backProject	/usr/include/opencv2/core/core.hpp	/^    void backProject(const Mat& vec, CV_OUT Mat& result) const;$/;"	p	class:cv::PCA	access:public	signature:(const Mat& vec, CV_OUT Mat& result) const
backSubst	/usr/include/opencv2/core/core.hpp	/^    static void backSubst( const Mat& w, const Mat& u, const Mat& vt,$/;"	p	class:cv::SVD	access:public	signature:( const Mat& w, const Mat& u, const Mat& vt, const Mat& rhs, CV_OUT Mat& dst )
backSubst	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int m, int n, int nm, int nb> static void backSubst( const Matx<_Tp, nm, 1>& w,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u, const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs, Matx<_Tp, n, nb>& dst )
backSubst	/usr/include/opencv2/core/core.hpp	/^    void backSubst( const Mat& rhs, CV_OUT Mat& dst ) const;$/;"	p	class:cv::SVD	access:public	signature:( const Mat& rhs, CV_OUT Mat& dst ) const
backSubst	/usr/include/opencv2/core/mat.hpp	/^SVD::backSubst( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u,$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u, const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs, Matx<_Tp, n, nb>& dst )
backgroundMax	/usr/include/opencv2/features2d/features2d.hpp	/^    double backgroundMin, backgroundMax;$/;"	m	class:cv::PatchGenerator	access:public
backgroundMin	/usr/include/opencv2/features2d/features2d.hpp	/^    double backgroundMin, backgroundMax;$/;"	m	class:cv::PatchGenerator	access:public
backgroundRatio	/usr/include/opencv2/video/background_segm.hpp	/^    double backgroundRatio;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
base	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<OneWayDescriptorBase> base;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
base	/usr/include/opencv2/flann/allocator.h	/^	void*	base;     \/* Pointer to base of current block of storage. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
baseFeatureSize	/usr/include/opencv2/features2d/features2d.hpp	/^    double baseFeatureSize;$/;"	m	class:cv::LDetector	access:public
base_value	/usr/include/opencv2/ml/ml.hpp	/^    float base_value;$/;"	m	class:CvGBTrees	access:protected
beg1	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int beg1,beg2;$/;"	m	struct:CvTracksTimePos	access:public
beg2	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int beg1,beg2;$/;"	m	struct:CvTracksTimePos	access:public
begin	/usr/include/opencv2/contrib/contrib.hpp	/^            int begin, end;$/;"	m	struct:cv::Octree::Node	access:public
begin	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator begin() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
begin	/usr/include/opencv2/core/core.hpp	/^    SeqIterator<_Tp> begin() const;$/;"	p	class:cv::Seq	access:public	signature:() const
begin	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator begin() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
begin	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
begin	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator begin();$/;"	p	class:cv::SparseMat	access:public	signature:()
begin	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_<_Tp> begin();$/;"	p	class:cv::SparseMat_	access:public	signature:()
begin	/usr/include/opencv2/core/core.hpp	/^    const_iterator begin() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
begin	/usr/include/opencv2/core/core.hpp	/^    iterator begin();$/;"	p	class:cv::Mat_	access:public	signature:()
begin	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> MatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::Mat	access:public	signature:() const
begin	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> MatIterator_<_Tp> begin();$/;"	p	class:cv::Mat	access:public	signature:()
begin	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> SparseMatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
begin	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> SparseMatIterator_<_Tp> begin();$/;"	p	class:cv::SparseMat	access:public	signature:()
begin	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator SparseMat::begin() const$/;"	f	class:cv::SparseMat	signature:() const
begin	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator SparseMat::begin()$/;"	f	class:cv::SparseMat	signature:()
begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat::begin() const$/;"	f	class:cv::Mat	signature:() const
begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::begin() const$/;"	f	class:cv::Mat_	signature:() const
begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat::begin()$/;"	f	class:cv::Mat	signature:()
begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::begin()$/;"	f	class:cv::Mat_	signature:()
begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::begin() const$/;"	f	class:cv::SparseMat	signature:() const
begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::begin() const$/;"	f	class:cv::SparseMat_	signature:() const
begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::begin()$/;"	f	class:cv::SparseMat	signature:()
begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::begin()$/;"	f	class:cv::SparseMat_	signature:()
begin	/usr/include/opencv2/core/operations.hpp	/^    _Tp* begin() { return hdr.data; }$/;"	f	class:cv::Vector	access:public	signature:()
begin	/usr/include/opencv2/core/operations.hpp	/^    const _Tp* begin() const { return hdr.data; }$/;"	f	class:cv::Vector	access:public	signature:() const
begin	/usr/include/opencv2/core/operations.hpp	/^inline FileNodeIterator FileNode::begin() const$/;"	f	class:cv::FileNode	signature:() const
begin	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::begin() const$/;"	f	class:cv::Seq	signature:() const
bestIndex	/usr/include/opencv2/flann/autotuned_index.h	/^	NNIndex<ELEM_TYPE>* bestIndex;$/;"	m	class:cvflann::AutotunedIndex	access:private
bestParams	/usr/include/opencv2/flann/autotuned_index.h	/^	IndexParams* bestParams;$/;"	m	class:cvflann::AutotunedIndex	access:private
bestSearchParams	/usr/include/opencv2/flann/autotuned_index.h	/^	SearchParams bestSearchParams;$/;"	m	class:cvflann::AutotunedIndex	access:private
best_score	/usr/include/opencv2/legacy/legacy.hpp	/^    int best_score;$/;"	m	struct:CvCliqueFinder	access:public
best_weight	/usr/include/opencv2/legacy/legacy.hpp	/^    float best_weight;$/;"	m	struct:CvCliqueFinder	access:public
beta	/usr/include/opencv2/core/mat.hpp	/^    double alpha, beta;$/;"	m	class:cv::MatExpr	access:public
between	/usr/include/opencv2/contrib/contrib.hpp	/^    bool between(double x, double x1, double x2);$/;"	p	class:CvFuzzyCurve	access:private	signature:(double x, double x1, double x2)
bg_model	/usr/include/opencv2/video/background_segm.hpp	/^CVAPI(void) cvReleaseBGStatModel( CvBGStatModel** bg_model );$/;"	v
bg_threshold	/usr/include/opencv2/video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
bgmodel	/usr/include/opencv2/video/background_segm.hpp	/^    Mat bgmodel;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
bilateralFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void bilateralFilter( const Mat& src, CV_OUT Mat& dst, int d,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int d, double sigmaColor, double sigmaSpace, int borderType=BORDER_DEFAULT )
binSize	/usr/include/opencv2/contrib/contrib.hpp	/^        float binSize;$/;"	m	class:cv::SpinImageModel	access:public
bins	/usr/include/opencv2/core/types_c.h	/^    CvArr*  bins;$/;"	m	struct:CvHistogram	access:public
bitwise_and	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_and(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
bitwise_and	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_and(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
bitwise_and	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_and(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream)
bitwise_and	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_and(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat())
bitwise_not	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_not(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
bitwise_not	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_not(const GpuMat& src, GpuMat& dst, const GpuMat& mask, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const GpuMat& mask, const Stream& stream)
bitwise_not	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_not(const GpuMat& src, GpuMat& dst, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const GpuMat& mask=GpuMat())
bitwise_or	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_or(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
bitwise_or	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_or(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
bitwise_or	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_or(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream)
bitwise_or	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_or(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat())
bitwise_xor	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_xor(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
bitwise_xor	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_xor(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
bitwise_xor	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_xor(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream)
bitwise_xor	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_xor(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat())
blockSize	/usr/include/opencv2/features2d/features2d.hpp	/^        int blockSize;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
blockSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP Size blockSize;$/;"	m	struct:cv::HOGDescriptor	access:public
blockStride	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP Size blockStride;$/;"	m	struct:cv::HOGDescriptor	access:public
block_hists	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat block_hists;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
block_size	/usr/include/opencv2/core/types_c.h	/^    int block_size;               \/* Block size.                              *\/$/;"	m	struct:CvMemStorage	access:public
block_size	/usr/include/opencv2/gpu/gpu.hpp	/^            Size block_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
block_stride	/usr/include/opencv2/gpu/gpu.hpp	/^            Size block_stride;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
blocksize	/usr/include/opencv2/flann/allocator.h	/^	int 	blocksize;$/;"	m	class:cvflann::PooledAllocator	access:private
blur	/usr/include/opencv2/gpu/gpu.hpp	/^        static inline void blur(const GpuMat& src, GpuMat& dst, Size ksize, Point anchor = Point(-1,-1)) { boxFilter(src, dst, -1, ksize, anchor); }$/;"	f	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size ksize, Point anchor = Point(-1,-1))
blur	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void blur( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT )
boost_type	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int boost_type;$/;"	m	struct:CvBoostParams	access:public
border	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f border[2][4];$/;"	m	struct:CvStereoCamera	access:public
borderElemSize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int borderElemSize;$/;"	m	class:cv::FilterEngine	access:public
borderInterpolate	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W int borderInterpolate( int p, int len, int borderType );$/;"	p	namespace:cv	signature:( int p, int len, int borderType )
borderTab	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<int> borderTab;$/;"	m	class:cv::FilterEngine	access:public
bottom	/usr/include/opencv2/core/types_c.h	/^    CvMemBlock* bottom;           \/* First allocated block.                   *\/$/;"	m	struct:CvMemStorage	access:public
bottomline	/usr/include/opencv2/legacy/compat.hpp	/^    float*  bottomline;$/;"	m	struct:_CvPixelPosition32f	access:public
bottomline	/usr/include/opencv2/legacy/compat.hpp	/^    schar*  bottomline;$/;"	m	struct:_CvPixelPosition8s	access:public
bottomline	/usr/include/opencv2/legacy/compat.hpp	/^    uchar*  bottomline;    \/* pointer to the start of the first line           *\/$/;"	m	struct:_CvPixelPosition8u	access:public
boundary	/usr/include/opencv2/core/core.hpp	/^        float boundary;$/;"	m	struct:cv::KDTree::Node	access:public
boundingRect	/usr/include/opencv2/core/core.hpp	/^    Rect boundingRect() const;$/;"	p	class:cv::RotatedRect	access:public	signature:() const
boundingRect	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Rect boundingRect( const Mat& points );$/;"	p	namespace:cv	signature:( const Mat& points )
boxFilter	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void boxFilter(const GpuMat& src, GpuMat& dst, int ddepth, Size ksize, Point anchor = Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, Size ksize, Point anchor = Point(-1,-1))
boxFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void boxFilter( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, Size ksize, Point anchor=Point(-1,-1), bool normalize=true, int borderType=BORDER_DEFAULT )
boxMax	/usr/include/opencv2/video/background_segm.hpp	/^    uchar boxMax[3];$/;"	m	struct:CvBGCodeBookElem	access:public
boxMin	/usr/include/opencv2/video/background_segm.hpp	/^    uchar boxMin[3];$/;"	m	struct:CvBGCodeBookElem	access:public
bp_dw_scale	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double bp_dw_scale, bp_moment_scale;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
bp_moment_scale	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double bp_dw_scale, bp_moment_scale;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
br	/usr/include/opencv2/core/core.hpp	/^    Point_<_Tp> br() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
br	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::br() const { return Point_<_Tp>(x+width, y+height); }$/;"	f	class:cv::Rect_	signature:() const
branching	/usr/include/opencv2/flann/composite_index.h	/^	int branching;             \/\/ branching factor (for kmeans tree)$/;"	m	struct:cvflann::CompositeIndexParams	access:public
branching	/usr/include/opencv2/flann/kmeans_index.h	/^	int branching;             \/\/ branching factor (for kmeans tree)$/;"	m	struct:cvflann::KMeansIndexParams	access:public
branching	/usr/include/opencv2/flann/kmeans_index.h	/^	int branching;$/;"	m	class:cvflann::KMeansIndex	access:private
buf	/usr/include/opencv2/core/core.hpp	/^        size_t buf[2];$/;"	m	struct:cv::Mat::MStep	access:public
buf	/usr/include/opencv2/core/core.hpp	/^    _Tp buf[fixed_size];$/;"	m	class:cv::AutoBuffer	access:protected
buf	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* buf;$/;"	m	struct:CvDTreeTrainData	access:public
buf	/usr/include/opencv2/ml/ml.hpp	/^    float* buf[2];$/;"	m	class:CvSVMSolver	access:public
bufStep	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
bufType	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
buf_count	/usr/include/opencv2/ml/ml.hpp	/^    int buf_count, buf_size;$/;"	m	struct:CvDTreeTrainData	access:public
buf_idx	/usr/include/opencv2/ml/ml.hpp	/^    int buf_idx;$/;"	m	struct:CvDTreeNode	access:public
buf_size	/usr/include/opencv2/ml/ml.hpp	/^    int buf_count, buf_size;$/;"	m	struct:CvDTreeTrainData	access:public
buffer	/usr/include/opencv2/calib3d/calib3d.hpp	/^    Mat buffer;$/;"	m	class:cv::StereoSGBM	access:protected
build	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP void build(const Mat& _points, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(const Mat& _points, bool copyAndReorderPoints=false)
build	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP void build(const Mat& _points, const Mat& _labels, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(const Mat& _points, const Mat& _labels, bool copyAndReorderPoints=false)
buildIndex	/usr/include/opencv2/flann/autotuned_index.h	/^	virtual void buildIndex()$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:()
buildIndex	/usr/include/opencv2/flann/composite_index.h	/^	void buildIndex()$/;"	f	class:cvflann::CompositeIndex	access:public	signature:()
buildIndex	/usr/include/opencv2/flann/flann_base.hpp	/^	void buildIndex();$/;"	p	class:cvflann::Index	access:public	signature:()
buildIndex	/usr/include/opencv2/flann/flann_base.hpp	/^void Index<T>::buildIndex()$/;"	f	class:cvflann::Index	signature:()
buildIndex	/usr/include/opencv2/flann/kdtree_index.h	/^	void buildIndex()$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:()
buildIndex	/usr/include/opencv2/flann/kmeans_index.h	/^	void buildIndex()$/;"	f	class:cvflann::KMeansIndex	access:public	signature:()
buildIndex	/usr/include/opencv2/flann/linear_index.h	/^	void buildIndex()$/;"	f	class:cvflann::LinearIndex	access:public	signature:()
buildIndex	/usr/include/opencv2/flann/nn_index.h	/^	virtual void buildIndex() = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:()
buildNext	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void buildNext(size_t node_ind);$/;"	p	class:cv::Octree	access:private	signature:(size_t node_ind)
buildOctree	/usr/include/opencv2/contrib/contrib.hpp	/^        void buildOctree();$/;"	p	class:cv::Mesh3D	access:public	signature:()
buildPyramid	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void buildPyramid( const Mat& src, CV_OUT vector<Mat>& dst, int maxlevel );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT vector<Mat>& dst, int maxlevel )
buildTimeCost	/usr/include/opencv2/flann/autotuned_index.h	/^        float buildTimeCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
buildTree	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void buildTree( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 );$/;"	p	class:cv::Octree	access:public	signature:( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 )
build_weight	/usr/include/opencv2/flann/autotuned_index.h	/^	float build_weight;        \/\/ build tree time weighting factor$/;"	m	struct:cvflann::AutotunedIndexParams	access:public
built	/usr/include/opencv2/flann/flann_base.hpp	/^    bool built;$/;"	m	class:cvflann::Index	access:private
bundleAdjust	/usr/include/opencv2/contrib/contrib.hpp	/^        static void bundleAdjust(vector<Point3d>& points, \/\/positions of points in global coordinate system (input and output)$/;"	p	class:cv::LevMarqSparse	access:public	signature:(vector<Point3d>& points, const vector<vector<Point2d> >& imagePoints, const vector<vector<int> >& visibility, vector<Mat>& cameraMatrix, vector<Mat>& R, vector<Mat>& T, vector<Mat>& distCoeffs, const TermCriteria& criteria= TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, DBL_EPSILON))
byteBitsLookUp	/usr/include/opencv2/features2d/features2d.hpp	/^    static unsigned char byteBitsLookUp(unsigned char b);$/;"	p	struct:cv::HammingLUT	access:public	signature:(unsigned char b)
bytes_	/usr/include/opencv2/features2d/features2d.hpp	/^    int bytes_;$/;"	m	class:cv::BriefDescriptorExtractor	access:protected
c	/usr/include/opencv2/core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
c	/usr/include/opencv2/ml/ml.hpp	/^            float c;$/;"	m	struct:CvDTreeSplit::__anon83::__anon84	access:public
c	/usr/include/opencv2/ml/ml.hpp	/^    CvMat*  c;$/;"	m	class:CvNormalBayesClassifier	access:protected
cache_line_size	/usr/include/opencv2/ml/ml.hpp	/^    int cache_line_size;$/;"	m	class:CvSVMSolver	access:public
cache_size	/usr/include/opencv2/ml/ml.hpp	/^    int cache_size;$/;"	m	class:CvSVMSolver	access:public
calc	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc( int vcount, int n, const float** vecs, const float* another, float* results );$/;"	p	struct:CvSVMKernel	access:public	signature:( int vcount, int n, const float** vecs, const float* another, float* results )
calcBackProject	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void calcBackProject( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, const Mat& hist, Mat& backProject, const float** ranges, double scale=1, bool uniform=true )
calcBackProject	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void calcBackProject( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, const SparseMat& hist, Mat& backProject, const float** ranges, double scale=1, bool uniform=true )
calcBestProbAndMatchIdx	/usr/include/opencv2/features2d/features2d.hpp	/^    void calcBestProbAndMatchIdx( const Mat& image, const Point2f& pt,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& image, const Point2f& pt, float& bestProb, int& bestMatchIdx, vector<float>& signature )
calcCat	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual int calcCat(int featureIdx) const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int featureIdx) const
calcCovarMatrix	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void calcCovarMatrix( const Mat* samples, int nsamples, Mat& covar, Mat& mean,$/;"	p	namespace:cv	signature:( const Mat* samples, int nsamples, Mat& covar, Mat& mean, int flags, int ctype=CV_64F)
calcCovarMatrix	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void calcCovarMatrix( const Mat& samples, CV_OUT Mat& covar, CV_OUT Mat& mean,$/;"	p	namespace:cv	signature:( const Mat& samples, CV_OUT Mat& covar, CV_OUT Mat& mean, int flags, int ctype=CV_64F)
calcGlobalOrientation	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W double calcGlobalOrientation( const Mat& orientation, const Mat& mask,$/;"	p	namespace:cv	signature:( const Mat& orientation, const Mat& mask, const Mat& mhi, double timestamp, double duration )
calcHist	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void calcHist( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, const Mat& mask, Mat& hist, int dims, const int* histSize, const float** ranges, bool uniform=true, bool accumulate=false )
calcHist	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void calcHist( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, const Mat& mask, SparseMat& hist, int dims, const int* histSize, const float** ranges, bool uniform=true, bool accumulate=false )
calcMotionGradient	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W void calcMotionGradient( const Mat& mhi, CV_OUT Mat& mask,$/;"	p	namespace:cv	signature:( const Mat& mhi, CV_OUT Mat& mask, CV_OUT Mat& orientation, double delta1, double delta2, int apertureSize=3 )
calcOpticalFlowFarneback	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W void calcOpticalFlowFarneback( const Mat& prev, const Mat& next,$/;"	p	namespace:cv	signature:( const Mat& prev, const Mat& next, CV_OUT Mat& flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags )
calcOpticalFlowPyrLK	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W void calcOpticalFlowPyrLK( const Mat& prevImg, const Mat& nextImg,$/;"	p	namespace:cv	signature:( const Mat& prevImg, const Mat& nextImg, const vector<Point2f>& prevPts, CV_OUT vector<Point2f>& nextPts, CV_OUT vector<uchar>& status, CV_OUT vector<float>& err, Size winSize=Size(15,15), int maxLevel=3, TermCriteria criteria=TermCriteria( TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), double derivLambda=0.5, int flags=0 )
calcOrd	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual double calcOrd(int featureIdx) const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int featureIdx) const
calcOutput	/usr/include/opencv2/contrib/contrib.hpp	/^        int calcOutput(double edgeDensity, double density);$/;"	p	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:public	signature:(double edgeDensity, double density)
calcOutput	/usr/include/opencv2/contrib/contrib.hpp	/^    double calcOutput(double param1, double param2);$/;"	p	class:CvFuzzyController	access:public	signature:(double param1, double param2)
calcSpinMapCoo	/usr/include/opencv2/contrib/contrib.hpp	/^        static Point2f calcSpinMapCoo(const Point3f& point, const Point3f& vertex, const Point3f& normal);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& point, const Point3f& vertex, const Point3f& normal)
calcValue	/usr/include/opencv2/contrib/contrib.hpp	/^    double calcValue();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
calcValue	/usr/include/opencv2/contrib/contrib.hpp	/^    double calcValue(double param);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double param)
calcValue	/usr/include/opencv2/contrib/contrib.hpp	/^    double calcValue(double param1, double param2);$/;"	p	class:CvFuzzyRule	access:public	signature:(double param1, double param2)
calc_activ_func	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_activ_func( CvMat* xf, const double* bias ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( CvMat* xf, const double* bias ) const
calc_activ_func_deriv	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_activ_func_deriv( CvMat* xf, CvMat* deriv, const double* bias ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( CvMat* xf, CvMat* deriv, const double* bias ) const
calc_error	/usr/include/opencv2/ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type , std::vector<float> *resp = 0 ); \/\/ type in {CV_TRAIN_ERROR, CV_TEST_ERROR}$/;"	p	class:CvBoost	access:public	signature:( CvMLData* _data, int type , std::vector<float> *resp = 0 )
calc_error	/usr/include/opencv2/ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type , std::vector<float> *resp = 0 ); \/\/ type in {CV_TRAIN_ERROR, CV_TEST_ERROR}$/;"	p	class:CvRTrees	access:public	signature:( CvMLData* _data, int type , std::vector<float> *resp = 0 )
calc_error	/usr/include/opencv2/ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type,$/;"	p	class:CvGBTrees	access:public	signature:( CvMLData* _data, int type, std::vector<float> *resp = 0 )
calc_error	/usr/include/opencv2/ml/ml.hpp	/^    virtual float calc_error( CvMLData* trainData, int type, std::vector<float> *resp = 0 );$/;"	p	class:CvDTree	access:public	signature:( CvMLData* trainData, int type, std::vector<float> *resp = 0 )
calc_func	/usr/include/opencv2/ml/ml.hpp	/^    Calc calc_func;$/;"	m	struct:CvSVMKernel	access:public
calc_input_scale	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_input_scale( const CvVectors* vecs, int flags );$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvVectors* vecs, int flags )
calc_linear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_linear( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
calc_node_dir	/usr/include/opencv2/ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
calc_node_dir	/usr/include/opencv2/ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
calc_node_dir	/usr/include/opencv2/ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* node );$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* node )
calc_node_value	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_node_value( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
calc_node_value	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_node_value( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
calc_non_rbf_base	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_non_rbf_base( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results, double alpha, double beta )
calc_output_scale	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_output_scale( const CvVectors* vecs, int flags );$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvVectors* vecs, int flags )
calc_poly	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_poly( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
calc_rbf	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_rbf( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
calc_rho	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_rho( double& rho, double& r );$/;"	p	class:CvSVMSolver	access:public	signature:( double& rho, double& r )
calc_rho_func	/usr/include/opencv2/ml/ml.hpp	/^    CalcRho calc_rho_func;$/;"	m	class:CvSVMSolver	access:public
calc_rho_nu_svm	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_rho_nu_svm( double& rho, double& r );$/;"	p	class:CvSVMSolver	access:public	signature:( double& rho, double& r )
calc_sigmoid	/usr/include/opencv2/ml/ml.hpp	/^    virtual void calc_sigmoid( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
calc_var_importance	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW bool calc_var_importance; \/\/ true <=> RF processes variable importance$/;"	m	struct:CvRTParams	access:public
calibrateCamera	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W double calibrateCamera( const vector<vector<Point3f> >& objectPoints,$/;"	p	namespace:cv	signature:( const vector<vector<Point3f> >& objectPoints, const vector<vector<Point2f> >& imagePoints, Size imageSize, CV_IN_OUT Mat& cameraMatrix, CV_IN_OUT Mat& distCoeffs, CV_OUT vector<Mat>& rvecs, CV_OUT vector<Mat>& tvecs, int flags=0 )
calibrationMatrixValues	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void calibrationMatrixValues( const Mat& cameraMatrix,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, CV_OUT double& fovx, CV_OUT double& fovy, CV_OUT double& focalLength, CV_OUT Point2d& principalPoint, CV_OUT double& aspectRatio )
callback	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCallback callback;$/;"	m	union:__anon170	access:public
camera	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCamera* camera[2]; \/* two individual camera parameters *\/$/;"	m	struct:CvStereoCamera	access:public
cameraCount	/usr/include/opencv2/legacy/legacy.hpp	/^    int     cameraCount;$/;"	m	class:CvCalibFilter	access:protected
cameraParams	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCamera cameraParams[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
canMapHostMemory	/usr/include/opencv2/gpu/gpu.hpp	/^            static bool canMapHostMemory();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
cand_weight	/usr/include/opencv2/legacy/legacy.hpp	/^    float* cand_weight;$/;"	m	struct:CvCliqueFinder	access:public
cap	/usr/include/opencv2/highgui/highgui.hpp	/^    Ptr<CvCapture> cap;$/;"	m	class:cv::VideoCapture	access:protected
capacity	/usr/include/opencv2/core/operations.hpp	/^        size_t capacity;$/;"	m	struct:cv::Vector::Hdr	access:public
capacity	/usr/include/opencv2/core/operations.hpp	/^    size_t capacity() const { return hdr.capacity; }$/;"	f	class:cv::Vector	access:public	signature:() const
capacity	/usr/include/opencv2/flann/result_set.h	/^    int capacity;$/;"	m	class:cvflann::KNNResultSet	access:private
capture	/usr/include/opencv2/highgui/highgui_c.h	/^CVAPI(IplImage*) cvQueryFrame( CvCapture* capture );$/;"	v
capture	/usr/include/opencv2/highgui/highgui_c.h	/^CVAPI(int)    cvGetCaptureDomain( CvCapture* capture);  $/;"	v
capture	/usr/include/opencv2/highgui/highgui_c.h	/^CVAPI(int) cvGrabFrame( CvCapture* capture );$/;"	v
capture	/usr/include/opencv2/highgui/highgui_c.h	/^CVAPI(void) cvReleaseCapture( CvCapture** capture );$/;"	v
cartToPolar	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void cartToPolar(const Mat& x, const Mat& y,$/;"	p	namespace:cv	signature:(const Mat& x, const Mat& y, CV_OUT Mat& magnitude, CV_OUT Mat& angle, bool angleInDegrees=false)
cartToPolar	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cartToPolar(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees = false)
cartToPolar	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cartToPolar(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees, const Stream& stream)
cascade	/usr/include/opencv2/objdetect/objdetect.hpp	/^CVAPI(void) cvReleaseHaarClassifierCascade( CvHaarClassifierCascade** cascade );$/;"	v
cat_count	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* cat_count;$/;"	m	struct:CvDTreeTrainData	access:public
cat_map	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* cat_map;$/;"	m	struct:CvDTreeTrainData	access:public
cat_ofs	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* cat_ofs;$/;"	m	struct:CvDTreeTrainData	access:public
cat_var_count	/usr/include/opencv2/ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
cbBounds	/usr/include/opencv2/video/background_segm.hpp	/^    uchar cbBounds[3];$/;"	m	struct:CvBGCodeBookModel	access:public
cb_index	/usr/include/opencv2/flann/composite_index.h	/^    float cb_index;            \/\/ cluster boundary index. Used when searching the kmeans tree$/;"	m	struct:cvflann::CompositeIndexParams	access:public
cb_index	/usr/include/opencv2/flann/kmeans_index.h	/^    float cb_index;            \/\/ cluster boundary index. Used when searching the kmeans tree$/;"	m	struct:cvflann::KMeansIndexParams	access:public
cb_index	/usr/include/opencv2/flann/kmeans_index.h	/^    float cb_index;$/;"	m	class:cvflann::KMeansIndex	access:private
cbmap	/usr/include/opencv2/video/background_segm.hpp	/^    CvBGCodeBookElem** cbmap;$/;"	m	struct:CvBGCodeBookModel	access:public
cctable	/usr/include/opencv2/video/background_segm.hpp	/^    CvBGPixelCCStatTable* cctable;$/;"	m	struct:CvBGPixelStat	access:public
ce	/usr/include/opencv2/legacy/legacy.hpp	/^    int* ce;$/;"	m	struct:CvCliqueFinder	access:public
cellSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP Size cellSize;$/;"	m	struct:cv::HOGDescriptor	access:public
cell_size	/usr/include/opencv2/gpu/gpu.hpp	/^            Size cell_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
center	/usr/include/opencv2/core/core.hpp	/^    Point2f center; \/\/< the rectangle mass center$/;"	m	class:cv::RotatedRect	access:public
center	/usr/include/opencv2/core/types_c.h	/^    CvPoint2D32f center;  \/* Center of the box.                          *\/$/;"	m	struct:CvBox2D	access:public
centersAlgFunction	/usr/include/opencv2/flann/kmeans_index.h	/^	typedef void (KMeansIndex::*centersAlgFunction)(int, int*, int, int*, int&);$/;"	t	class:cvflann::KMeansIndex	access:private
centers_init	/usr/include/opencv2/flann/composite_index.h	/^	flann_centers_init_t centers_init;          \/\/ algorithm used for picking the initial cluster centers for kmeans tree$/;"	m	struct:cvflann::CompositeIndexParams	access:public
centers_init	/usr/include/opencv2/flann/kmeans_index.h	/^	flann_centers_init_t centers_init;          \/\/ algorithm used for picking the initial cluster centers for kmeans tree$/;"	m	struct:cvflann::KMeansIndexParams	access:public
centre	/usr/include/opencv2/contrib/contrib.hpp	/^    double value, centre;$/;"	m	class:CvFuzzyCurve	access:private
chahge_var_idx	/usr/include/opencv2/ml/ml.hpp	/^    void chahge_var_idx( int vi, bool state ); \/\/ state == true to set vi-variable as predictor$/;"	p	class:CvMLData	access:public	signature:( int vi, bool state )
chain	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSeq* chain;$/;"	m	struct:CvLCMEdge	access:public
chamerMatching	/usr/include/opencv2/contrib/contrib.hpp	/^    CV_EXPORTS int chamerMatching( Mat& img, Mat& templ,$/;"	p	namespace:cv	signature:( Mat& img, Mat& templ, vector<vector<Point> >& results, vector<float>& cost, double templScale=1, int maxMatches = 20, double minMatchDistance = 1.0, int padX = 3, int padY = 3, int scales = 5, double minScale = 0.6, double maxScale = 1.6, double orientationWeight = 0.5, double truncate = 20)
change_values	/usr/include/opencv2/ml/ml.hpp	/^    virtual void change_values(CvDTree* tree, const int k = 0);$/;"	p	class:CvGBTrees	access:protected	signature:(CvDTree* tree, const int k = 0)
change_var_type	/usr/include/opencv2/ml/ml.hpp	/^    void change_var_type( int var_idx, int type); \/\/ type in { CV_VAR_ORDERED, CV_VAR_CATEGORICAL }    $/;"	p	class:CvMLData	access:public	signature:( int var_idx, int type)
channelSeq	/usr/include/opencv2/core/types_c.h	/^    char channelSeq[4];     \/* ditto *\/$/;"	m	struct:_IplImage	access:public
channel_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp channel_type;$/;"	t	class:cv::DataType	access:public
channel_type	/usr/include/opencv2/core/core.hpp	/^    typedef int channel_type;$/;"	t	class:cv::DataType	access:public
channel_type	/usr/include/opencv2/core/core.hpp	/^    typedef typename DataType<_Tp>::channel_type channel_type;$/;"	t	class:cv::Mat_	access:public
channel_type	/usr/include/opencv2/core/core.hpp	/^    typedef value_type channel_type;$/;"	t	class:cv::DataType	access:public
channels	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon121
channels	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon120
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon125
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon126
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon127
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon128
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon129
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon130
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon131
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon134
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon135
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon137
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon140
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon136
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon138
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon139
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon132
channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 1, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
channels	/usr/include/opencv2/core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Mat	access:public	signature:() const
channels	/usr/include/opencv2/core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
channels	/usr/include/opencv2/core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Seq	access:public	signature:() const
channels	/usr/include/opencv2/core/core.hpp	/^    int channels() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
channels	/usr/include/opencv2/core/core.hpp	/^    int channels() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
channels	/usr/include/opencv2/core/mat.hpp	/^inline int Mat::channels() const { return CV_MAT_CN(flags); }$/;"	f	class:cv::Mat	signature:() const
channels	/usr/include/opencv2/core/mat.hpp	/^inline int SparseMat::channels() const$/;"	f	class:cv::SparseMat	signature:() const
channels	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::channels() const$/;"	f	class:cv::Mat_	signature:() const
channels	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::channels() const$/;"	f	class:cv::SparseMat_	signature:() const
channels	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::channels() const$/;"	f	class:cv::Seq	signature:() const
channels	/usr/include/opencv2/gpu/gpu.hpp	/^            int channels() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
channels	/usr/include/opencv2/gpu/gpu.hpp	/^            int channels() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
channels	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int CudaMem::channels() const { return CV_MAT_CN(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
channels	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int GpuMat::channels() const { return CV_MAT_CN(flags); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
channels	/usr/include/opencv2/legacy/legacy.hpp	/^    int channels() const { return image ? image->nChannels : 0; }$/;"	f	class:CvImage	access:public	signature:() const
channels	/usr/include/opencv2/legacy/legacy.hpp	/^    int channels() const { return matrix ? CV_MAT_CN(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
check	/usr/include/opencv2/ml/ml.hpp	/^    bool check() const;$/;"	p	struct:CvParamGrid	access:public	signature:() const
check	/usr/include/opencv2/ml/ml.hpp	113;"	d
checkDetectorSize	/usr/include/opencv2/gpu/gpu.hpp	/^            bool checkDetectorSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
checkDetectorSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP bool checkDetectorSize() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
checkHardwareSupport	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W bool checkHardwareSupport(int feature);$/;"	p	namespace:cv	signature:(int feature)
checkIfGpuCallReasonable	/usr/include/opencv2/gpu/gpu.hpp	/^            static bool checkIfGpuCallReasonable();$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:()
checkMasks	/usr/include/opencv2/features2d/features2d.hpp	/^	void checkMasks( const vector<Mat>& masks, int queryDescriptorsCount ) const;$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const vector<Mat>& masks, int queryDescriptorsCount ) const
checkRange	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W bool checkRange(const Mat& a, bool quiet=true, CV_OUT Point* pt=0,$/;"	p	namespace:cv	signature:(const Mat& a, bool quiet=true, CV_OUT Point* pt=0, double minVal=-DBL_MAX, double maxVal=DBL_MAX)
checkVector	/usr/include/opencv2/core/core.hpp	/^    int checkVector(int elemChannels, int depth=-1, bool requireContinuous=true) const;$/;"	p	class:cv::Mat	access:public	signature:(int elemChannels, int depth=-1, bool requireContinuous=true) const
checks	/usr/include/opencv2/flann/general.h	/^	int checks;$/;"	m	struct:cvflann::SearchParams	access:public
chi_square_dist	/usr/include/opencv2/flann/dist.h	/^double chi_square_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
child	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int child;$/;"	m	struct:CvHaarStageClassifier	access:public
child1	/usr/include/opencv2/flann/kdtree_index.h	/^		TreeSt *child1, *child2;$/;"	m	struct:cvflann::KDTreeIndex::TreeSt	access:public
child2	/usr/include/opencv2/flann/kdtree_index.h	/^		TreeSt *child1, *child2;$/;"	m	struct:cvflann::KDTreeIndex::TreeSt	access:public
children	/usr/include/opencv2/contrib/contrib.hpp	/^            int children[8];$/;"	m	struct:cv::Octree::Node	access:public
childs	/usr/include/opencv2/flann/kmeans_index.h	/^		KMeansNodeSt** childs;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
chooseCenters	/usr/include/opencv2/flann/kmeans_index.h	/^    centersAlgFunction chooseCenters;$/;"	m	class:cvflann::KMeansIndex	access:private
chooseCentersGonzales	/usr/include/opencv2/flann/kmeans_index.h	/^    void chooseCentersGonzales(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
chooseCentersKMeanspp	/usr/include/opencv2/flann/kmeans_index.h	/^    void chooseCentersKMeanspp(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
chooseCentersRandom	/usr/include/opencv2/flann/kmeans_index.h	/^    void chooseCentersRandom(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
chooseDivision	/usr/include/opencv2/flann/kdtree_index.h	/^	void chooseDivision(Tree node, int first, int last)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(Tree node, int first, int last)
circle	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void circle(Mat& img, Point center, int radius,$/;"	p	namespace:cv	signature:(Mat& img, Point center, int radius, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
classCounters	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<int> classCounters;$/;"	m	class:cv::FernClassifier	access:protected
class_count	/usr/include/opencv2/ml/ml.hpp	/^    int class_count;$/;"	m	class:CvGBTrees	access:protected
class_id	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW int class_id; \/\/!< object class (if the keypoints need to be clustered by an object they belong to) $/;"	m	class:cv::KeyPoint	access:public
class_idx	/usr/include/opencv2/ml/ml.hpp	/^    int class_idx;$/;"	m	struct:CvDTreeNode	access:public
class_labels	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* class_labels;$/;"	m	class:CvGBTrees	access:protected
class_labels	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* class_labels;$/;"	m	class:CvSVM	access:protected
class_map	/usr/include/opencv2/ml/ml.hpp	/^    std::map<std::string, int> *class_map;$/;"	m	class:CvMLData	access:protected
class_part	/usr/include/opencv2/ml/ml.hpp	/^    } *class_part;$/;"	m	struct:CvTrainTestSplit	typeref:union:CvTrainTestSplit::__anon92	access:public
class_part_mode	/usr/include/opencv2/ml/ml.hpp	/^    int class_part_mode;$/;"	m	struct:CvTrainTestSplit	access:public
class_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat*      class_weights; \/\/ for CV_SVM_C_SVC$/;"	m	struct:CvSVMParams	access:public
class_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* class_weights;$/;"	m	class:CvSVM	access:protected
classes	/usr/include/opencv2/features2d/features2d.hpp	/^  inline int classes() const { return classes_; }$/;"	f	class:cv::RTreeClassifier	access:public	signature:() const
classes	/usr/include/opencv2/features2d/features2d.hpp	/^  int classes() { return classes_; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
classes_	/usr/include/opencv2/features2d/features2d.hpp	/^  int classes_;$/;"	m	class:cv::RTreeClassifier	access:private
classes_	/usr/include/opencv2/features2d/features2d.hpp	/^  int classes_;$/;"	m	class:cv::RandomizedTree	access:private
classifier	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<FernClassifier> classifier;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
classifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvHaarClassifier* classifier;$/;"	m	struct:CvHaarStageClassifier	access:public
classifier_	/usr/include/opencv2/features2d/features2d.hpp	/^    RTreeClassifier classifier_;$/;"	m	class:cv::CalonderDescriptorExtractor	access:protected
classifiers	/usr/include/opencv2/objdetect/objdetect.hpp	/^    vector<DTree> classifiers;$/;"	m	class:cv::CascadeClassifier	access:public
classify	/usr/include/opencv2/features2d/features2d.hpp	/^    void classify( const Mat& queryImage, vector<KeyPoint>& queryKeypoints );$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints )
classify	/usr/include/opencv2/features2d/features2d.hpp	/^    void classify( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints ) const
clear	/usr/include/opencv2/calib3d/calib3d.hpp	/^    void clear();$/;"	p	class:CvLevMarq	access:public	signature:()
clear	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void clear();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
clear	/usr/include/opencv2/contrib/contrib.hpp	/^    void clear();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
clear	/usr/include/opencv2/core/core.hpp	/^        void clear();$/;"	p	struct:cv::SparseMat::Hdr	access:public	signature:()
clear	/usr/include/opencv2/core/core.hpp	/^    void clear();$/;"	p	class:cv::Seq	access:public	signature:()
clear	/usr/include/opencv2/core/core.hpp	/^    void clear();$/;"	p	class:cv::SparseMat	access:public	signature:()
clear	/usr/include/opencv2/core/operations.hpp	/^    void clear() { resize(0); }$/;"	f	class:cv::Vector	access:public	signature:()
clear	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::clear()$/;"	f	class:cv::Seq	signature:()
clear	/usr/include/opencv2/features2d/features2d.hpp	/^        virtual void clear();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
clear	/usr/include/opencv2/features2d/features2d.hpp	/^        void clear();$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:()
clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FernClassifier	access:public	signature:()
clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:()
clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
clear	/usr/include/opencv2/features2d/features2d.hpp	/^    void clear ();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
clear	/usr/include/opencv2/flann/heap.h	/^	void clear()$/;"	f	class:cvflann::Heap	access:public	signature:()
clear	/usr/include/opencv2/legacy/legacy.hpp	/^    void clear() { detach(); }$/;"	f	class:CvImage	access:public	signature:()
clear	/usr/include/opencv2/legacy/legacy.hpp	/^    void clear()$/;"	f	class:CvMatrix	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvANN_MLP	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvBoost	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvDTree	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvEM	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvGBTrees	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvRTrees	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvSVM	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvBoostTree	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvKNearest	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvMLData	access:protected	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvSVMSolver	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvStatModel	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
clear	/usr/include/opencv2/ml/ml.hpp	/^    virtual void clear();$/;"	p	struct:CvSVMKernel	access:public	signature:()
clearOctree	/usr/include/opencv2/contrib/contrib.hpp	/^        void clearOctree();$/;"	p	class:cv::Mesh3D	access:public	signature:()
clearSeq	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  clearSeq( CvSeq* seq );$/;"	p	namespace:cv	signature:( CvSeq* seq )
clipLine	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS bool clipLine(Size imgSize, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2);$/;"	p	namespace:cv	signature:(Size imgSize, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2)
clipLine	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W bool clipLine(Rect imgRect, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2);$/;"	p	namespace:cv	signature:(Rect imgRect, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2)
clone	/usr/include/opencv2/core/core.hpp	/^    Mat clone() const;$/;"	p	class:cv::Mat	access:public	signature:() const
clone	/usr/include/opencv2/core/core.hpp	/^    Mat_ clone() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
clone	/usr/include/opencv2/core/core.hpp	/^    SparseMat clone() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
clone	/usr/include/opencv2/core/core.hpp	/^    SparseMat_ clone() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
clone	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::clone() const$/;"	f	class:cv::SparseMat_	signature:() const
clone	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::clone() const$/;"	f	class:cv::Mat	signature:() const
clone	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat SparseMat::clone() const$/;"	f	class:cv::SparseMat	signature:() const
clone	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::clone() const$/;"	f	class:cv::Mat_	signature:() const
clone	/usr/include/opencv2/core/operations.hpp	/^    Vector<_Tp> clone() const$/;"	f	class:cv::Vector	access:public	signature:() const
clone	/usr/include/opencv2/core/operations.hpp	/^    static void* clone(const void* ptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(const void* ptr)
clone	/usr/include/opencv2/core/types_c.h	/^    CvCloneFunc clone;$/;"	m	struct:CvTypeInfo	access:public
clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const = 0;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::BruteForceMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const = 0;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	/usr/include/opencv2/features2d/features2d.hpp	/^Ptr<DescriptorMatcher> BruteForceMatcher<Distance>::clone( bool emptyTrainData ) const$/;"	f	class:cv::BruteForceMatcher	signature:( bool emptyTrainData ) const
clone	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem clone() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
clone	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat clone() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
clone	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem CudaMem::clone() const$/;"	f	class:cv::gpu::CudaMem	signature:() const
clone	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::clone() const$/;"	f	class:cv::gpu::GpuMat	signature:() const
clone	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage clone() { return CvImage(image ? cvCloneImage(image) : 0); }$/;"	f	class:CvImage	access:public	signature:()
clone	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix clone() { return CvMatrix(matrix ? cvCloneMat(matrix) : 0); }$/;"	f	class:CvMatrix	access:public	signature:()
clone	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual Ptr<FeatureEvaluator> clone() const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:() const
clone_op	/usr/include/opencv2/features2d/features2d.hpp	/^        static Mat clone_op( Mat m ) { return m.clone(); }$/;"	f	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:private	signature:( Mat m )
clone_op	/usr/include/opencv2/features2d/features2d.hpp	/^    static Mat clone_op( Mat m ) { return m.clone(); }$/;"	f	class:cv::DescriptorMatcher	access:protected	signature:( Mat m )
cls_labels	/usr/include/opencv2/ml/ml.hpp	/^    CvMat*  cls_labels;$/;"	m	class:CvNormalBayesClassifier	access:protected
cluster	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Mat cluster( const Mat& descriptors ) const = 0;$/;"	p	class:cv::BOWTrainer	access:public	signature:( const Mat& descriptors ) const
cluster	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Mat cluster( const Mat& descriptors ) const;$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:( const Mat& descriptors ) const
cluster	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Mat cluster() const = 0;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
cluster	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Mat cluster() const;$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:() const
clusterCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int clusterCount;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
cluster_categories	/usr/include/opencv2/ml/ml.hpp	/^    virtual void cluster_categories( const int* vectors, int vector_count,$/;"	p	class:CvDTree	access:protected	signature:( const int* vectors, int vector_count, int var_count, int* sums, int k, int* cluster_labels )
clusteringDistance	/usr/include/opencv2/features2d/features2d.hpp	/^    double clusteringDistance;$/;"	m	class:cv::LDetector	access:public
code	/usr/include/opencv2/core/core.hpp	/^	int code; \/\/\/< error code @see CVStatus$/;"	m	class:cv::Exception	access:public
code	/usr/include/opencv2/imgproc/types_c.h	/^    char      code;$/;"	m	struct:CvChainPtReader	access:public
coef0	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      coef0;  \/\/ for poly\/sigmoid$/;"	m	struct:CvSVMParams	access:public
coeffs	/usr/include/opencv2/legacy/legacy.hpp	/^    double coeffs[2][3][3];\/* coefficients for transformation *\/$/;"	m	struct:CvStereoCamera	access:public
coi	/usr/include/opencv2/core/types_c.h	/^    int  coi; \/* 0 - no COI (all channels are selected), 1 - 0th channel is selected ...*\/$/;"	m	struct:_IplROI	access:public
coi	/usr/include/opencv2/legacy/legacy.hpp	/^    int coi() const { return !image || !image->roi ? 0 : image->roi->coi; }$/;"	f	class:CvImage	access:public	signature:() const
col	/usr/include/opencv2/core/core.hpp	/^    Mat col(int x) const;$/;"	p	class:cv::Mat	access:public	signature:(int x) const
col	/usr/include/opencv2/core/core.hpp	/^    Mat_ col(int x) const;$/;"	p	class:cv::Mat_	access:public	signature:(int x) const
col	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, m, 1> col(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
col	/usr/include/opencv2/core/mat.hpp	/^    MatExpr col(int x) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int x) const
col	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::col(int x) const { return Mat(*this, Range::all(), Range(x, x+1)); }$/;"	f	class:cv::Mat	signature:(int x) const
col	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::col(int x) const$/;"	f	class:cv::Mat_	signature:(int x) const
col	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, 1> Matx<_Tp, m, n>::col(int j) const$/;"	f	class:cv::Matx	signature:(int j) const
col	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat col(int x) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int x) const
col	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::col(int x) const { return GpuMat(*this, Range::all(), Range(x, x+1)); }$/;"	f	class:cv::gpu::GpuMat	signature:(int x) const
colRange	/usr/include/opencv2/core/core.hpp	/^    Mat colRange(const Range& r) const;$/;"	p	class:cv::Mat	access:public	signature:(const Range& r) const
colRange	/usr/include/opencv2/core/core.hpp	/^    Mat colRange(int startcol, int endcol) const;$/;"	p	class:cv::Mat	access:public	signature:(int startcol, int endcol) const
colRange	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::colRange(const Range& r) const$/;"	f	class:cv::Mat	signature:(const Range& r) const
colRange	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::colRange(int startcol, int endcol) const$/;"	f	class:cv::Mat	signature:(int startcol, int endcol) const
colRange	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat colRange(const Range& r) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Range& r) const
colRange	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat colRange(int startcol, int endcol) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int startcol, int endcol) const
colRange	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::colRange(const Range& r) const { return GpuMat(*this, Range::all(), r); }$/;"	f	class:cv::gpu::GpuMat	signature:(const Range& r) const
colRange	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::colRange(int startcol, int endcol) const { return GpuMat(*this, Range::all(), Range(startcol, endcol)); }$/;"	f	class:cv::gpu::GpuMat	signature:(int startcol, int endcol) const
color	/usr/include/opencv2/core/core_c.h	/^	CvScalar color;				\/\/Qt:ColorFont -> cvScalar(blue_component, green_component, red\\_component[, alpha_component])$/;"	m	struct:CvFont	access:public
color	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvScalar color;$/;"	m	struct:CvDrawShape	access:public
colorModel	/usr/include/opencv2/core/types_c.h	/^    char colorModel[4];     \/* Ignored by OpenCV *\/$/;"	m	struct:_IplImage	access:public
color_transform	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void color_transform( const IplImage* img );$/;"	p	class:CvCamShiftTracker	access:protected	signature:( const IplImage* img )
cols	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon120
cols	/usr/include/opencv2/core/core.hpp	/^    int rows, cols;$/;"	m	class:cv::Mat	access:public
cols	/usr/include/opencv2/core/types_c.h	/^        int cols;$/;"	m	union:CvMat::__anon96	access:public
cols	/usr/include/opencv2/core/types_c.h	/^    int cols;$/;"	m	struct:CvMat	access:public
cols	/usr/include/opencv2/flann/matrix.h	/^    size_t cols;$/;"	m	class:cvflann::Matrix	access:public
cols	/usr/include/opencv2/flann/matrix.h	/^    size_t cols;$/;"	m	class:cvflann::UntypedMatrix	access:public
cols	/usr/include/opencv2/flann/saving.h	/^	int cols;$/;"	m	struct:cvflann::IndexHeader	access:public
cols	/usr/include/opencv2/gpu/devmem2d.hpp	/^            int cols;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
cols	/usr/include/opencv2/gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::CudaMem	access:public
cols	/usr/include/opencv2/gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::GpuMat	access:public
cols	/usr/include/opencv2/legacy/legacy.hpp	/^    int cols() const { return matrix ? matrix->cols : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
columnBorderType	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int rowBorderType, columnBorderType;$/;"	m	class:cv::FilterEngine	access:public
columnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Ptr<BaseColumnFilter> columnFilter;$/;"	m	class:cv::FilterEngine	access:public
comLen	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int comLen; \/\/common length for two tracks$/;"	m	struct:CvTracksTimePos	access:public
commParams	/usr/include/opencv2/features2d/features2d.hpp	/^    CommonParams commParams;$/;"	m	class:cv::SIFT	access:protected
commonKnnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    static void commonKnnMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	p	class:cv::BruteForceMatcher	access:private	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
commonKnnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^inline void BruteForceMatcher<Distance>::commonKnnMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	f	class:cv::BruteForceMatcher	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int knn, const vector<Mat>& masks, bool compactResult )
commonRadiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    static void commonRadiusMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	p	class:cv::BruteForceMatcher	access:private	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
commonRadiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^inline void BruteForceMatcher<Distance>::commonRadiusMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	f	class:cv::BruteForceMatcher	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
compare	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void compare(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, int cmpop);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, int cmpop)
compare	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void compare(const Mat& src1, double s, CV_OUT Mat& dst, int cmpop);$/;"	p	namespace:cv	signature:(const Mat& src1, double s, CV_OUT Mat& dst, int cmpop)
compare	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void compare(const GpuMat& a, const GpuMat& b, GpuMat& c, int cmpop);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, int cmpop)
compareHist	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS double compareHist( const SparseMat& H1, const SparseMat& H2, int method );$/;"	p	namespace:cv	signature:( const SparseMat& H1, const SparseMat& H2, int method )
compareHist	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double compareHist( const Mat& H1, const Mat& H2, int method );$/;"	p	namespace:cv	signature:( const Mat& H1, const Mat& H2, int method )
completeSymm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void completeSymm(Mat& mtx, bool lowerToUpper=false);$/;"	p	namespace:cv	signature:(Mat& mtx, bool lowerToUpper=false)
completeSymmFlag	/usr/include/opencv2/calib3d/calib3d.hpp	/^    bool completeSymmFlag;$/;"	m	class:CvLevMarq	access:public
complete_node_dir	/usr/include/opencv2/ml/ml.hpp	/^    virtual void complete_node_dir( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
complexity	/usr/include/opencv2/ml/ml.hpp	/^    int complexity;$/;"	m	struct:CvDTreeNode	access:public
composeRT	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_AS(composeRT_J) void composeRT( const Mat& rvec1, const Mat& tvec1,$/;"	p	namespace:cv	signature:( const Mat& rvec1, const Mat& tvec1, const Mat& rvec2, const Mat& tvec2, CV_OUT Mat& rvec3, CV_OUT Mat& tvec3, CV_OUT Mat& dr3dr1, CV_OUT Mat& dr3dt1, CV_OUT Mat& dr3dr2, CV_OUT Mat& dr3dt2, CV_OUT Mat& dt3dr1, CV_OUT Mat& dt3dt1, CV_OUT Mat& dt3dr2, CV_OUT Mat& dt3dt2 )
composeRT	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void composeRT( const Mat& rvec1, const Mat& tvec1,$/;"	p	namespace:cv	signature:( const Mat& rvec1, const Mat& tvec1, const Mat& rvec2, const Mat& tvec2, CV_OUT Mat& rvec3, CV_OUT Mat& tvec3 )
compressLeaves	/usr/include/opencv2/features2d/features2d.hpp	/^  void compressLeaves(size_t reduced_num_dim);$/;"	p	class:cv::RandomizedTree	access:private	signature:(size_t reduced_num_dim)
compressionMethod	/usr/include/opencv2/features2d/features2d.hpp	/^        int compressionMethod;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
compressionMethod	/usr/include/opencv2/features2d/features2d.hpp	/^    int compressionMethod;$/;"	m	class:cv::FernClassifier	access:protected
compute	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void compute(const Mat& img, vector<float>& descriptors, Size winStride=Size(),$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const Mat& img, vector<float>& descriptors, Size winStride=Size(), const vector<Point>& locations=vector<Point>()) const
compute	/usr/include/opencv2/contrib/contrib.hpp	/^        void compute();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
compute	/usr/include/opencv2/core/core.hpp	/^    static void compute( const Mat& src, CV_OUT Mat& w, CV_OUT Mat& u, CV_OUT Mat& vt, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( const Mat& src, CV_OUT Mat& w, CV_OUT Mat& u, CV_OUT Mat& vt, int flags=0 )
compute	/usr/include/opencv2/core/core.hpp	/^    static void compute( const Mat& src, CV_OUT Mat& w, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( const Mat& src, CV_OUT Mat& w, int flags=0 )
compute	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int m, int n, int nm> static void compute( const Matx<_Tp, m, n>& a,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )
compute	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int m, int n, int nm> static void compute( const Matx<_Tp, m, n>& a,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )
compute	/usr/include/opencv2/core/mat.hpp	/^    SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )
compute	/usr/include/opencv2/core/mat.hpp	/^SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )
compute	/usr/include/opencv2/features2d/features2d.hpp	/^    void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
compute	/usr/include/opencv2/features2d/features2d.hpp	/^    void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& imgDescriptor,$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& imgDescriptor, vector<vector<int> >* pointIdxsOfClusters=0, Mat* descriptors=0 )
compute	/usr/include/opencv2/features2d/features2d.hpp	/^    void compute( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, vector<Mat>& descriptors ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, vector<Mat>& descriptors ) const
compute	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void compute(const Mat& img,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<float>& descriptors, Size winStride=Size(), Size padding=Size(), const vector<Point>& locations=vector<Point>()) const
computeBlockHistograms	/usr/include/opencv2/gpu/gpu.hpp	/^            void computeBlockHistograms(const GpuMat& img);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(const GpuMat& img)
computeClustering	/usr/include/opencv2/flann/kmeans_index.h	/^	void computeClustering(KMeansNode node, int* indices, int indices_length, int branching, int level)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, int* indices, int indices_length, int branching, int level)
computeCorrespondEpilines	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void computeCorrespondEpilines( const Mat& points1,$/;"	p	namespace:cv	signature:( const Mat& points1, int whichImage, const Mat& F, CV_OUT vector<Vec3f>& lines )
computeDistanceRaport	/usr/include/opencv2/flann/index_testing.h	/^float computeDistanceRaport(const Matrix<ELEM_TYPE>& inputData, ELEM_TYPE* target, int* neighbors, int* groundTruth, int veclen, int n)$/;"	f	namespace:cvflann	signature:(const Matrix<ELEM_TYPE>& inputData, ELEM_TYPE* target, int* neighbors, int* groundTruth, int veclen, int n)
computeGradient	/usr/include/opencv2/gpu/gpu.hpp	/^            void computeGradient(const GpuMat& img, GpuMat& grad, GpuMat& qangle);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(const GpuMat& img, GpuMat& grad, GpuMat& qangle)
computeGradient	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void computeGradient(const Mat& img, CV_OUT Mat& grad, CV_OUT Mat& angleOfs,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT Mat& grad, CV_OUT Mat& angleOfs, Size paddingTL=Size(), Size paddingBR=Size()) const
computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const = 0;$/;"	p	class:cv::DescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::CalonderDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::SiftDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::SurfDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl(const Mat& image, std::vector<KeyPoint>& keypoints, Mat& descriptors) const;$/;"	p	class:cv::BriefDescriptorExtractor	access:protected	signature:(const Mat& image, std::vector<KeyPoint>& keypoints, Mat& descriptors) const
computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::computeImpl( const cv::Mat& image,$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, cv::Mat& descriptors) const
computeLogPolarMapping	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void computeLogPolarMapping(Mat& mappingMask) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(Mat& mappingMask) const
computeNodeStatistics	/usr/include/opencv2/flann/kmeans_index.h	/^	void computeNodeStatistics(KMeansNode node, int* indices, int indices_length) {$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, int* indices, int indices_length)
computeNormals	/usr/include/opencv2/contrib/contrib.hpp	/^        void computeNormals(const vector<int>& subset, float normalRadius, int minNeighbors = 20);$/;"	p	class:cv::Mesh3D	access:public	signature:(const vector<int>& subset, float normalRadius, int minNeighbors = 20)
computeNormals	/usr/include/opencv2/contrib/contrib.hpp	/^        void computeNormals(float normalRadius, int minNeighbors = 20);$/;"	p	class:cv::Mesh3D	access:public	signature:(float normalRadius, int minNeighbors = 20)
computeRecallPrecisionCurve	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void computeRecallPrecisionCurve( const vector<vector<DMatch> >& matches1to2,$/;"	p	namespace:cv	signature:( const vector<vector<DMatch> >& matches1to2, const vector<vector<uchar> >& correctMatches1to2Mask, vector<Point2f>& recallPrecisionCurve )
compute_ground_truth	/usr/include/opencv2/flann/ground_truth.h	/^void compute_ground_truth(const Matrix<T>& dataset, const Matrix<T>& testset, Matrix<int>& matches, int skip=0)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& dataset, const Matrix<T>& testset, Matrix<int>& matches, int skip=0)
condens	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(void)  cvConDensUpdateByTime( CvConDensation* condens);$/;"	v
condens	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(void)  cvReleaseConDensation( CvConDensation** condens );$/;"	v
condensed_idx	/usr/include/opencv2/ml/ml.hpp	/^    int condensed_idx;$/;"	m	struct:CvDTreeSplit	access:public
conj	/usr/include/opencv2/core/core.hpp	/^    Complex conj() const;$/;"	p	class:cv::Complex	access:public	signature:() const
conj	/usr/include/opencv2/core/core.hpp	/^    Scalar_<_Tp> conj() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
conj	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp> Complex<_Tp>::conj() const$/;"	f	class:cv::Complex	signature:() const
conj	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::conj() const$/;"	f	class:cv::Scalar_	signature:() const
constBorderRow	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<uchar> constBorderRow;$/;"	m	class:cv::FilterEngine	access:public
constBorderValue	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<uchar> constBorderValue;$/;"	m	class:cv::FilterEngine	access:public
const_iterator	/usr/include/opencv2/core/core.hpp	/^    typedef MatConstIterator_<_Tp> const_iterator;$/;"	t	class:cv::Mat_	access:public
const_iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SeqIterator<_Tp> const_iterator;$/;"	t	class:cv::Seq	access:public
const_iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SparseMatConstIterator const_iterator;$/;"	t	class:cv::SparseMat	access:public
const_iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SparseMatConstIterator_<_Tp> const_iterator;$/;"	t	class:cv::SparseMat_	access:public
const_iterator	/usr/include/opencv2/core/operations.hpp	/^    typedef const _Tp* const_iterator;$/;"	t	class:cv::Vector	access:public
const_pointer	/usr/include/opencv2/core/core.hpp	/^    typedef const value_type* const_pointer;$/;"	t	class:cv::Allocator	access:public
const_reference	/usr/include/opencv2/core/core.hpp	/^    typedef const value_type& const_reference;$/;"	t	class:cv::Allocator	access:public
const_reference	/usr/include/opencv2/core/operations.hpp	/^    typedef const _Tp& const_reference;$/;"	t	class:cv::Vector	access:public
construct	/usr/include/opencv2/core/core.hpp	/^    void construct(pointer p, const _Tp& v) { new(static_cast<void*>(p)) _Tp(v); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p, const _Tp& v)
container	/usr/include/opencv2/core/core.hpp	/^    const CvFileNode* container;$/;"	m	class:cv::FileNodeIterator	access:public
contains	/usr/include/opencv2/core/core.hpp	/^    bool contains(const Point_<_Tp>& pt) const;$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& pt) const
contains	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool Rect_<_Tp>::contains(const Point_<_Tp>& pt) const$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& pt) const
contour	/usr/include/opencv2/imgproc/imgproc_c.h	/^CVAPI(int)  cvCheckContourConvexity( const CvArr* contour );$/;"	v
contour	/usr/include/opencv2/imgproc/types_c.h	/^    CvSeq* contour; \/* optional component boundary$/;"	m	struct:CvConnectedComp	access:public
contour	/usr/include/opencv2/legacy/legacy.hpp	/^    CvContour* contour; $/;"	m	struct:CvLCMNode	access:public
contourArea	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double contourArea( const Mat& contour, bool oriented=false );$/;"	p	namespace:cv	signature:( const Mat& contour, bool oriented=false )
controlMatrix	/usr/include/opencv2/video/tracking.hpp	/^    Mat controlMatrix;      \/\/!< control matrix (B) (not used if there is no control)$/;"	m	class:cv::KalmanFilter	access:public
control_matrix	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* control_matrix;      \/* control matrix (B)$/;"	m	struct:CvKalman	access:public
convert	/usr/include/opencv2/features2d/features2d.hpp	/^    static void convert(const std::vector<KeyPoint>& keypoints,$/;"	p	class:cv::KeyPoint	access:public	signature:(const std::vector<KeyPoint>& keypoints, CV_OUT std::vector<Point2f>& points2f, const std::vector<int>& keypointIndexes=std::vector<int>())
convert	/usr/include/opencv2/features2d/features2d.hpp	/^    static void convert(const std::vector<Point2f>& points2f,$/;"	p	class:cv::KeyPoint	access:public	signature:(const std::vector<Point2f>& points2f, CV_OUT std::vector<KeyPoint>& keypoints, float size=1, float response=1, int octave=0, int class_id=-1)
convertMaps	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void convertMaps( const Mat& map1, const Mat& map2,$/;"	p	namespace:cv	signature:( const Mat& map1, const Mat& map2, CV_OUT Mat& dstmap1, CV_OUT Mat& dstmap2, int dstmap1type, bool nninterpolation=false )
convertPointsHomogeneous	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void convertPointsHomogeneous( const Mat& src, CV_OUT vector<Point2f>& dst );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT vector<Point2f>& dst )
convertPointsHomogeneous	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void convertPointsHomogeneous( const Mat& src, CV_OUT vector<Point3f>& dst );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT vector<Point3f>& dst )
convertPosteriorsToChar	/usr/include/opencv2/features2d/features2d.hpp	/^  void convertPosteriorsToChar();$/;"	p	class:cv::RandomizedTree	access:private	signature:()
convertScaleAbs	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void convertScaleAbs(const Mat& src, CV_OUT Mat& dst, double alpha=1, double beta=0);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, double alpha=1, double beta=0)
convertTo	/usr/include/opencv2/core/core.hpp	/^    void convertTo( Mat& m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::Mat	access:public	signature:( Mat& m, int rtype, double alpha=1, double beta=0 ) const
convertTo	/usr/include/opencv2/core/core.hpp	/^    void convertTo( Mat& m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( Mat& m, int rtype, double alpha=1, double beta=0 ) const
convertTo	/usr/include/opencv2/core/core.hpp	/^    void convertTo( SparseMat& m, int rtype, double alpha=1 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m, int rtype, double alpha=1 ) const
convertTo	/usr/include/opencv2/gpu/gpu.hpp	/^            void convertTo( GpuMat& m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, int rtype, double alpha=1, double beta=0 ) const
convertToDMatches	/usr/include/opencv2/features2d/features2d.hpp	/^    static void convertToDMatches( const DescriptorCollection& descriptors,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const DescriptorCollection& descriptors, const Mat& indices, const Mat& distances, vector<vector<DMatch> >& matches )
convexHull	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void convexHull( const Mat& points, CV_OUT vector<Point2f>& hull, bool clockwise=false );$/;"	p	namespace:cv	signature:( const Mat& points, CV_OUT vector<Point2f>& hull, bool clockwise=false )
convexHull	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void convexHull( const Mat& points, CV_OUT vector<Point>& hull, bool clockwise=false );$/;"	p	namespace:cv	signature:( const Mat& points, CV_OUT vector<Point>& hull, bool clockwise=false )
convexHull	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void convexHull( const Mat& points, CV_OUT vector<int>& hull, bool clockwise=false );$/;"	p	namespace:cv	signature:( const Mat& points, CV_OUT vector<int>& hull, bool clockwise=false )
copyMakeBorder	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void copyMakeBorder(const GpuMat& src, GpuMat& dst, int top, int bottom, int left, int right, const Scalar& value = Scalar());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int top, int bottom, int left, int right, const Scalar& value = Scalar())
copyMakeBorder	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void copyMakeBorder( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int top, int bottom, int left, int right, int borderType, const Scalar& value=Scalar() )
copySize	/usr/include/opencv2/core/core.hpp	/^    void copySize(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
copyTo	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> void copyTo( vector<_Tp>& v ) const;$/;"	p	class:cv::Mat	access:public	signature:( vector<_Tp>& v ) const
copyTo	/usr/include/opencv2/core/core.hpp	/^    void copyTo( Mat& m ) const;$/;"	p	class:cv::Mat	access:public	signature:( Mat& m ) const
copyTo	/usr/include/opencv2/core/core.hpp	/^    void copyTo( Mat& m ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( Mat& m ) const
copyTo	/usr/include/opencv2/core/core.hpp	/^    void copyTo( Mat& m, const Mat& mask ) const;$/;"	p	class:cv::Mat	access:public	signature:( Mat& m, const Mat& mask ) const
copyTo	/usr/include/opencv2/core/core.hpp	/^    void copyTo( SparseMat& m ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m ) const
copyTo	/usr/include/opencv2/core/core.hpp	/^    void copyTo(vector<_Tp>& vec, const Range& range=Range::all()) const;$/;"	p	class:cv::Seq	access:public	signature:(vector<_Tp>& vec, const Range& range=Range::all()) const
copyTo	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat::copyTo(vector<_Tp>& v) const$/;"	f	class:cv::Mat	signature:(vector<_Tp>& v) const
copyTo	/usr/include/opencv2/core/operations.hpp	/^    void copyTo(Vector<_Tp>& vec) const$/;"	f	class:cv::Vector	access:public	signature:(Vector<_Tp>& vec) const
copyTo	/usr/include/opencv2/core/operations.hpp	/^    void copyTo(std::vector<_Tp>& vec) const$/;"	f	class:cv::Vector	access:public	signature:(std::vector<_Tp>& vec) const
copyTo	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::copyTo(vector<_Tp>& vec, const Range& range) const$/;"	f	class:cv::Seq	signature:(vector<_Tp>& vec, const Range& range) const
copyTo	/usr/include/opencv2/gpu/gpu.hpp	/^            void copyTo( GpuMat& m ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m ) const
copyTo	/usr/include/opencv2/gpu/gpu.hpp	/^            void copyTo( GpuMat& m, const GpuMat& mask ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, const GpuMat& mask ) const
copyTo	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual void copyTo(HOGDescriptor& c) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(HOGDescriptor& c) const
cornerEigenValsAndVecs	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerEigenValsAndVecs( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int blockSize, int ksize, int borderType=BORDER_DEFAULT )
cornerHarris	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cornerHarris(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101)
cornerHarris	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerHarris( const Mat& src, CV_OUT Mat& dst, int blockSize,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int blockSize, int ksize, double k, int borderType=BORDER_DEFAULT )
cornerMinEigenVal	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cornerMinEigenVal(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, int borderType=BORDER_REFLECT101)
cornerMinEigenVal	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerMinEigenVal( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int blockSize, int ksize=3, int borderType=BORDER_DEFAULT )
cornerSubPix	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void cornerSubPix( const Mat& image, vector<Point2f>& corners,$/;"	p	namespace:cv	signature:( const Mat& image, vector<Point2f>& corners, Size winSize, Size zeroZone, TermCriteria criteria )
correct	/usr/include/opencv2/video/tracking.hpp	/^    CV_WRAP const Mat& correct(const Mat& measurement);$/;"	p	class:cv::KalmanFilter	access:public	signature:(const Mat& measurement)
cost	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* cost;$/;"	m	struct:CvStereoBMState	access:public
count	/usr/include/opencv2/core/core.hpp	/^    int err, count;$/;"	m	class:cv::LineIterator	access:public
count	/usr/include/opencv2/core/core_c.h	/^    int count; \/* number of arrays *\/$/;"	m	struct:CvNArrayIterator	access:public
count	/usr/include/opencv2/core/types_c.h	/^    int    count;             \/* Number of elements in the block.           *\/$/;"	m	struct:CvSeqBlock	access:public
count	/usr/include/opencv2/flann/heap.h	/^	int count;$/;"	m	class:cvflann::Heap	access:private
count	/usr/include/opencv2/flann/result_set.h	/^	int count;$/;"	m	class:cvflann::KNNResultSet	access:private
count	/usr/include/opencv2/flann/result_set.h	/^	size_t count;$/;"	m	class:cvflann::RadiusResultSet	access:private
count	/usr/include/opencv2/ml/ml.hpp	/^        int *count;$/;"	m	union:CvTrainTestSplit::__anon92	access:public
count	/usr/include/opencv2/ml/ml.hpp	/^        int count;$/;"	m	union:CvTrainTestSplit::__anon91	access:public
count	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** count;$/;"	m	class:CvNormalBayesClassifier	access:protected
count	/usr/include/opencv2/ml/ml.hpp	/^    int dims, count;$/;"	m	struct:CvVectors	access:public
count	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int  count;$/;"	m	struct:CvHaarClassifierCascade	access:public
count	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int  count;$/;"	m	struct:CvHaarStageClassifier	access:public
count	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int count;$/;"	m	struct:CvHaarClassifier	access:public
countCorrectMatches	/usr/include/opencv2/flann/index_testing.h	/^CV_EXPORTS int countCorrectMatches(int* neighbors, int* groundTruth, int n);$/;"	p	namespace:cvflann	signature:(int* neighbors, int* groundTruth, int n)
countFrames	/usr/include/opencv2/video/background_segm.hpp	/^    int                        countFrames;$/;"	m	struct:CvGaussBGModel	access:public
countNonZero	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W int countNonZero( const Mat& src );$/;"	p	namespace:cv	signature:( const Mat& src )
countNonZero	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS int countNonZero(const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
countNonZero	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS int countNonZero(const GpuMat& src, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& buf)
countNonZeroElements	/usr/include/opencv2/features2d/features2d.hpp	/^  static int countNonZeroElements(float *vec, int n, double tol=1e-10);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(float *vec, int n, double tol=1e-10)
countZeroElements	/usr/include/opencv2/features2d/features2d.hpp	/^  float countZeroElements();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
counter	/usr/include/opencv2/contrib/contrib.hpp	/^        int64 counter;$/;"	m	class:cv::TickMeter	access:private
counter	/usr/include/opencv2/flann/random.h	/^	int counter;$/;"	m	class:cvflann::UniqueRandom	access:private
counts	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* counts;$/;"	m	struct:CvDTreeTrainData	access:public
cov_mat_type	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int cov_mat_type;$/;"	m	struct:CvEMParams	access:public
cov_rotate_mats	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** cov_rotate_mats;$/;"	m	class:CvEM	access:protected
cov_rotate_mats	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** cov_rotate_mats;$/;"	m	class:CvNormalBayesClassifier	access:protected
covs	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** covs;$/;"	m	class:CvEM	access:protected
covs	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat** covs;$/;"	m	struct:CvEMParams	access:public
create	/usr/include/opencv2/core/core.hpp	/^    void create(Size _size);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size)
create	/usr/include/opencv2/core/core.hpp	/^    void create(Size _size, int _type);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type)
create	/usr/include/opencv2/core/core.hpp	/^    void create(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
create	/usr/include/opencv2/core/core.hpp	/^    void create(int _ndims, const int* _sizes, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type)
create	/usr/include/opencv2/core/core.hpp	/^    void create(int _rows, int _cols);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols)
create	/usr/include/opencv2/core/core.hpp	/^    void create(int _rows, int _cols, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type)
create	/usr/include/opencv2/core/core.hpp	/^    void create(int dims, const int* _sizes);$/;"	p	class:cv::SparseMat_	access:public	signature:(int dims, const int* _sizes)
create	/usr/include/opencv2/core/core.hpp	/^    void create(int dims, const int* _sizes, int _type);$/;"	p	class:cv::SparseMat	access:public	signature:(int dims, const int* _sizes, int _type)
create	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::create(int _dims, const int* _sizes)$/;"	f	class:cv::SparseMat_	signature:(int _dims, const int* _sizes)
create	/usr/include/opencv2/core/mat.hpp	/^inline void Mat::create(Size _sz, int _type)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type)
create	/usr/include/opencv2/core/mat.hpp	/^inline void Mat::create(int _rows, int _cols, int _type)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type)
create	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(Size _sz)$/;"	f	class:cv::Mat_	signature:(Size _sz)
create	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(int _dims, const int* _sz)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz)
create	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(int _rows, int _cols)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols)
create	/usr/include/opencv2/features2d/features2d.hpp	/^    static Ptr<AdjusterAdapter> create( const string& detectorType );$/;"	p	class:cv::AdjusterAdapter	access:public	signature:( const string& detectorType )
create	/usr/include/opencv2/features2d/features2d.hpp	/^    static Ptr<DescriptorExtractor> create( const string& descriptorExtractorType );$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const string& descriptorExtractorType )
create	/usr/include/opencv2/features2d/features2d.hpp	/^    static Ptr<DescriptorMatcher> create( const string& descriptorMatcherType );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const string& descriptorMatcherType )
create	/usr/include/opencv2/features2d/features2d.hpp	/^    static Ptr<FeatureDetector> create( const string& detectorType );$/;"	p	class:cv::FeatureDetector	access:public	signature:( const string& detectorType )
create	/usr/include/opencv2/features2d/features2d.hpp	/^    static Ptr<GenericDescriptorMatcher> create( const string& genericDescritptorMatcherType,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const string& genericDescritptorMatcherType, const string &paramsFilename=string() )
create	/usr/include/opencv2/flann/object_factory.h	/^   BaseClass* create(UniqueIdType id)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id)
create	/usr/include/opencv2/gpu/gpu.hpp	/^            void create();$/;"	p	class:cv::gpu::Stream	access:private	signature:()
create	/usr/include/opencv2/gpu/gpu.hpp	/^            void create(Size size, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type)
create	/usr/include/opencv2/gpu/gpu.hpp	/^            void create(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED)
create	/usr/include/opencv2/gpu/gpu.hpp	/^            void create(int rows, int cols, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type)
create	/usr/include/opencv2/gpu/gpu.hpp	/^            void create(int rows, int cols, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(int rows, int cols, int type, int alloc_type = ALLOC_PAGE_LOCKED)
create	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline void CudaMem::create(Size _size, int _type, int _alloc_type) { create(_size.height, _size.width, _type, _alloc_type); }$/;"	f	class:cv::gpu::CudaMem	signature:(Size _size, int _type, int _alloc_type)
create	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline void GpuMat::create(Size _size, int _type) { create(_size.height, _size.width, _type); }$/;"	f	class:cv::gpu::GpuMat	signature:(Size _size, int _type)
create	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateBlobTrackAnalysisList(CvBlobTrackAnalysisOne* (*create)());$/;"	p	signature:()
create	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackPostProc* cvCreateBlobTrackPostProcList(CvBlobTrackPostProcOne* (*create)());$/;"	p	signature:()
create	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerList(CvBlobTrackerOne* (*create)());$/;"	p	signature:()
create	/usr/include/opencv2/legacy/legacy.hpp	/^    void create( CvSize size, int depth, int channels )$/;"	f	class:CvImage	access:public	signature:( CvSize size, int depth, int channels )
create	/usr/include/opencv2/legacy/legacy.hpp	/^    void create( int rows, int cols, int type )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type )
create	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void create( const cv::Mat& layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
create	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool create( const CvSVMParams* params, Calc _calc_func );$/;"	p	struct:CvSVMKernel	access:public	signature:( const CvSVMParams* params, Calc _calc_func )
create	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool create( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, int alpha_count, double* alpha, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row, SelectWorkingSet select_working_set, CalcRho calc_rho )
create	/usr/include/opencv2/ml/ml.hpp	/^    virtual void create( const CvMat* layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
create	/usr/include/opencv2/objdetect/objdetect.hpp	/^    static Ptr<FeatureEvaluator> create(int type);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int type)
createBoxFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createBoxFilter( int srcType, int dstType, Size ksize,$/;"	p	namespace:cv	signature:( int srcType, int dstType, Size ksize, Point anchor=Point(-1,-1), bool normalize=true, int borderType=BORDER_DEFAULT)
createBoxFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createBoxFilter_GPU(int srcType, int dstType, const Size& ksize, $/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, const Point& anchor = Point(-1,-1))
createButton	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS int createButton( const string& bar_name, ButtonCallback on_change , void* userdata CV_DEFAULT(NULL), int type CV_DEFAULT(CV_PUSH_BUTTON), bool initial_button_state CV_DEFAULT(0));$/;"	p	namespace:cv	signature:( const string& bar_name, ButtonCallback on_change , void* userdata CV_DEFAULT(NULL), int type CV_DEFAULT(CV_PUSH_BUTTON), bool initial_button_state CV_DEFAULT(0))
createDerivFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createDerivFilter( int srcType, int dstType,$/;"	p	namespace:cv	signature:( int srcType, int dstType, int dx, int dy, int ksize, int borderType=BORDER_DEFAULT )
createDerivFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createDerivFilter_GPU(int srcType, int dstType, int dx, int dy, int ksize);$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, int dx, int dy, int ksize)
createFilter2D_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createFilter2D_GPU(const Ptr<BaseFilter_GPU> filter2D);$/;"	p	namespace:cv::gpu	signature:(const Ptr<BaseFilter_GPU> filter2D)
createGaussianFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createGaussianFilter( int type, Size ksize,$/;"	p	namespace:cv	signature:( int type, Size ksize, double sigma1, double sigma2=0, int borderType=BORDER_DEFAULT)
createGaussianFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createGaussianFilter_GPU(int type, Size ksize, double sigma1, double sigma2 = 0);$/;"	p	namespace:cv::gpu	signature:(int type, Size ksize, double sigma1, double sigma2 = 0)
createGpuMatHeader	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat createGpuMatHeader() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
createLinearFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, const Mat& kernel, Point _anchor=Point(-1,-1), double delta=0, int _rowBorderType=BORDER_DEFAULT, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
createLinearFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createLinearFilter_GPU(int srcType, int dstType, const Mat& kernel, $/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& kernel, const Point& anchor = Point(-1,-1))
createMatHeader	/usr/include/opencv2/gpu/gpu.hpp	/^            Mat createMatHeader() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
createMatHeader	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline Mat CudaMem::createMatHeader() const { return Mat(size(), type(), data); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
createMorphologyFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createMorphologyFilter(int op, int type, const Mat& kernel,$/;"	p	namespace:cv	signature:(int op, int type, const Mat& kernel, Point anchor=Point(-1,-1), int _rowBorderType=BORDER_CONSTANT, int _columnBorderType=-1, const Scalar& _borderValue=morphologyDefaultBorderValue())
createMorphologyFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createMorphologyFilter_GPU(int op, int type, const Mat& kernel, $/;"	p	namespace:cv::gpu	signature:(int op, int type, const Mat& kernel, const Point& anchor = Point(-1,-1), int iterations = 1)
createNodes	/usr/include/opencv2/features2d/features2d.hpp	/^  void createNodes(int num_nodes, RNG &rng);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_nodes, RNG &rng)
createObject	/usr/include/opencv2/flann/object_factory.h	/^BaseClass* createObject()$/;"	f	namespace:cvflann	signature:()
createOpenGLCallback	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void createOpenGLCallback(const string& winname, CvOpenGLCallback callbackOpenGL, void* userdata CV_DEFAULT(0));$/;"	p	namespace:cv	signature:(const string& winname, CvOpenGLCallback callbackOpenGL, void* userdata CV_DEFAULT(0))
createSeparableFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createSeparableFilter_GPU(const Ptr<BaseRowFilter_GPU>& rowFilter, $/;"	p	namespace:cv::gpu	signature:(const Ptr<BaseRowFilter_GPU>& rowFilter, const Ptr<BaseColumnFilter_GPU>& columnFilter)
createSeparableLinearFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createSeparableLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, const Mat& rowKernel, const Mat& columnKernel, Point _anchor=Point(-1,-1), double delta=0, int _rowBorderType=BORDER_DEFAULT, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
createSeparableLinearFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createSeparableLinearFilter_GPU(int srcType, int dstType, const Mat& rowKernel, $/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& rowKernel, const Mat& columnKernel, const Point& anchor = Point(-1,-1))
createTrackbar	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS int createTrackbar( const string& trackbarname, const string& winname,$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname, int* value, int count, TrackbarCallback onChange CV_DEFAULT(0), void* userdata CV_DEFAULT(0))
create_index_by_type	/usr/include/opencv2/flann/all_indices.h	/^NNIndex<T>* create_index_by_type(const Matrix<T>& dataset, const IndexParams& params)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& dataset, const IndexParams& params)
create_kernel	/usr/include/opencv2/ml/ml.hpp	/^    virtual void create_kernel();$/;"	p	class:CvSVM	access:protected	signature:()
create_solver	/usr/include/opencv2/ml/ml.hpp	/^    virtual void create_solver();$/;"	p	class:CvSVM	access:protected	signature:()
criteria	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvTermCriteria criteria;$/;"	m	class:CvLevMarq	access:public
criteria	/usr/include/opencv2/contrib/contrib.hpp	/^        CvTermCriteria criteria;$/;"	m	class:cv::LevMarqSparse	access:protected
cross	/usr/include/opencv2/core/core.hpp	/^    Mat cross(const Mat& m) const;$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m) const
cross	/usr/include/opencv2/core/core.hpp	/^    Mat_ cross(const Mat_& m) const;$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m) const
cross	/usr/include/opencv2/core/core.hpp	/^    Point3_ cross(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
cross	/usr/include/opencv2/core/core.hpp	/^    Vec cross(const Vec& v) const;$/;"	p	class:cv::Vec	access:public	signature:(const Vec& v) const
cross	/usr/include/opencv2/core/mat.hpp	/^    Mat cross(const Mat& m) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m) const
cross	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::cross(const Mat_& m) const$/;"	f	class:cv::Mat_	signature:(const Mat_& m) const
cross	/usr/include/opencv2/core/operations.hpp	/^template<> inline Vec<double, 3> Vec<double, 3>::cross(const Vec<double, 3>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<double, 3>& v) const
cross	/usr/include/opencv2/core/operations.hpp	/^template<> inline Vec<float, 3> Vec<float, 3>::cross(const Vec<float, 3>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<float, 3>& v) const
cross	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::cross(const Vec<_Tp, cn>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& v) const
cross	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp> Point3_<_Tp>::cross(const Point3_<_Tp>& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_<_Tp>& pt) const
ctable	/usr/include/opencv2/video/background_segm.hpp	/^    CvBGPixelCStatTable*  ctable;$/;"	m	struct:CvBGPixelStat	access:public
cubeRoot	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W float cubeRoot(float val);$/;"	p	namespace:cv	signature:(float val)
cur_weight	/usr/include/opencv2/legacy/legacy.hpp	/^    float* cur_weight;$/;"	m	struct:CvCliqueFinder	access:public
curidx	/usr/include/opencv2/core/types_c.h	/^    int curidx;$/;"	m	struct:CvSparseMatIterator	access:public
current_comp	/usr/include/opencv2/legacy/legacy.hpp	/^    int* current_comp;$/;"	m	struct:CvCliqueFinder	access:public
currline	/usr/include/opencv2/legacy/compat.hpp	/^    float*  currline;$/;"	m	struct:_CvPixelPosition32f	access:public
currline	/usr/include/opencv2/legacy/compat.hpp	/^    schar*  currline;$/;"	m	struct:_CvPixelPosition8s	access:public
currline	/usr/include/opencv2/legacy/compat.hpp	/^    uchar*  currline;      \/* pointer to the start of the current pixel line   *\/$/;"	m	struct:_CvPixelPosition8u	access:public
curves	/usr/include/opencv2/contrib/contrib.hpp	/^    std::vector<CvFuzzyCurve> curves;$/;"	m	class:CvFuzzyFunction	access:public
custom_dist	/usr/include/opencv2/flann/dist.h	/^double custom_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
cut_tree	/usr/include/opencv2/ml/ml.hpp	/^    virtual int cut_tree( int T, int fold, double min_alpha );$/;"	p	class:CvDTree	access:protected	signature:( int T, int fold, double min_alpha )
cv	/usr/include/opencv2/calib3d/calib3d.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/contrib/contrib.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/core/core.hpp	/^namespace cv {$/;"	n
cv	/usr/include/opencv2/core/eigen.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/core/internal.hpp	/^    namespace cv$/;"	n
cv	/usr/include/opencv2/core/mat.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/core/operations.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/core/wimage.hpp	/^namespace cv {$/;"	n
cv	/usr/include/opencv2/features2d/features2d.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/flann/flann.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/gpu/devmem2d.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/gpu/gpu.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/gpu/matrix_operations.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/gpu/stream_accessor.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/highgui/highgui.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/imgproc/imgproc.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/ml/ml.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/objdetect/objdetect.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/video/background_segm.hpp	/^namespace cv$/;"	n
cv	/usr/include/opencv2/video/tracking.hpp	/^namespace cv$/;"	n
cv2eigen	/usr/include/opencv2/core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, 1, Eigen::Dynamic>& dst )
cv2eigen	/usr/include/opencv2/core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, Eigen::Dynamic, 1>& dst )
cv2eigen	/usr/include/opencv2/core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, Eigen::Dynamic, Eigen::Dynamic>& dst )
cv2eigen	/usr/include/opencv2/core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& dst )
cv3dTracker2dTrackedObject	/usr/include/opencv2/legacy/legacy.hpp	/^CV_INLINE Cv3dTracker2dTrackedObject cv3dTracker2dTrackedObject(int id, CvPoint2D32f p)$/;"	f	signature:(int id, CvPoint2D32f p)
cv3dTrackerTrackedObject	/usr/include/opencv2/legacy/legacy.hpp	/^CV_INLINE Cv3dTrackerTrackedObject cv3dTrackerTrackedObject(int id, CvPoint3D32f p)$/;"	f	signature:(int id, CvPoint3D32f p)
cv::ADAPTIVE_THRESH_GAUSSIAN_C	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { ADAPTIVE_THRESH_MEAN_C=0, ADAPTIVE_THRESH_GAUSSIAN_C=1 };$/;"	e	enum:cv::__anon43
cv::ADAPTIVE_THRESH_MEAN_C	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { ADAPTIVE_THRESH_MEAN_C=0, ADAPTIVE_THRESH_GAUSSIAN_C=1 };$/;"	e	enum:cv::__anon43
cv::ANN_MLP_TrainParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvANN_MLP_TrainParams ANN_MLP_TrainParams;$/;"	t	namespace:cv
cv::Accumulator	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS Accumulator$/;"	s	namespace:cv
cv::Accumulator	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<char>   { typedef float Type; };$/;"	s	namespace:cv
cv::Accumulator	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<short>  { typedef float Type; };$/;"	s	namespace:cv
cv::Accumulator	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<unsigned char>  { typedef float Type; };$/;"	s	namespace:cv
cv::Accumulator	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<unsigned short> { typedef float Type; };$/;"	s	namespace:cv
cv::Accumulator::Type	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef T Type;$/;"	t	struct:cv::Accumulator	access:public
cv::Accumulator::Type	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<char>   { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
cv::Accumulator::Type	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<short>  { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
cv::Accumulator::Type	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<unsigned char>  { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
cv::Accumulator::Type	/usr/include/opencv2/features2d/features2d.hpp	/^template<> struct Accumulator<unsigned short> { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
cv::AdjusterAdapter	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS AdjusterAdapter: public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::AdjusterAdapter::create	/usr/include/opencv2/features2d/features2d.hpp	/^    static Ptr<AdjusterAdapter> create( const string& detectorType );$/;"	p	class:cv::AdjusterAdapter	access:public	signature:( const string& detectorType )
cv::AdjusterAdapter::good	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual bool good() const = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:() const
cv::AdjusterAdapter::tooFew	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooFew(int min, int n_detected) = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:(int min, int n_detected)
cv::AdjusterAdapter::tooMany	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooMany(int max, int n_detected) = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:(int max, int n_detected)
cv::AdjusterAdapter::~AdjusterAdapter	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~AdjusterAdapter() {}$/;"	f	class:cv::AdjusterAdapter	access:public	signature:()
cv::Allocator	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Allocator$/;"	c	namespace:cv
cv::Allocator::Allocator	/usr/include/opencv2/core/core.hpp	/^    explicit Allocator() {}$/;"	f	class:cv::Allocator	access:public	signature:()
cv::Allocator::Allocator	/usr/include/opencv2/core/core.hpp	/^    explicit Allocator(Allocator const&) {}$/;"	f	class:cv::Allocator	access:public	signature:(Allocator const&)
cv::Allocator::Allocator	/usr/include/opencv2/core/core.hpp	/^    explicit Allocator(Allocator<U> const&) {}$/;"	f	class:cv::Allocator	access:public	signature:(Allocator<U> const&)
cv::Allocator::address	/usr/include/opencv2/core/core.hpp	/^    const_pointer address(const_reference r) { return &r; }$/;"	f	class:cv::Allocator	access:public	signature:(const_reference r)
cv::Allocator::address	/usr/include/opencv2/core/core.hpp	/^    pointer address(reference r) { return &r; }$/;"	f	class:cv::Allocator	access:public	signature:(reference r)
cv::Allocator::allocate	/usr/include/opencv2/core/core.hpp	/^    pointer allocate(size_type count, const void* =0)$/;"	f	class:cv::Allocator	access:public	signature:(size_type count, const void* =0)
cv::Allocator::const_pointer	/usr/include/opencv2/core/core.hpp	/^    typedef const value_type* const_pointer;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::const_reference	/usr/include/opencv2/core/core.hpp	/^    typedef const value_type& const_reference;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::construct	/usr/include/opencv2/core/core.hpp	/^    void construct(pointer p, const _Tp& v) { new(static_cast<void*>(p)) _Tp(v); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p, const _Tp& v)
cv::Allocator::deallocate	/usr/include/opencv2/core/core.hpp	/^    void deallocate(pointer p, size_type) {fastFree(p); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p, size_type)
cv::Allocator::destroy	/usr/include/opencv2/core/core.hpp	/^    void destroy(pointer p) { p->~_Tp(); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p)
cv::Allocator::difference_type	/usr/include/opencv2/core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::max_size	/usr/include/opencv2/core/core.hpp	/^    size_type max_size() const$/;"	f	class:cv::Allocator	access:public	signature:() const
cv::Allocator::pointer	/usr/include/opencv2/core/core.hpp	/^    typedef value_type* pointer;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::rebind	/usr/include/opencv2/core/core.hpp	/^    template<typename U> class rebind { typedef Allocator<U> other; };$/;"	c	class:cv::Allocator	access:public
cv::Allocator::rebind::other	/usr/include/opencv2/core/core.hpp	/^    template<typename U> class rebind { typedef Allocator<U> other; };$/;"	t	class:cv::Allocator::rebind	access:private
cv::Allocator::reference	/usr/include/opencv2/core/core.hpp	/^    typedef value_type& reference;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::size_type	/usr/include/opencv2/core/core.hpp	/^    typedef size_t size_type;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::~Allocator	/usr/include/opencv2/core/core.hpp	/^    ~Allocator() {}$/;"	f	class:cv::Allocator	access:public	signature:()
cv::AutoBuffer	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, size_t fixed_size=4096\/sizeof(_Tp)+8> class CV_EXPORTS AutoBuffer$/;"	c	namespace:cv
cv::AutoBuffer::AutoBuffer	/usr/include/opencv2/core/core.hpp	/^    AutoBuffer();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
cv::AutoBuffer::AutoBuffer	/usr/include/opencv2/core/core.hpp	/^    AutoBuffer(size_t _size);$/;"	p	class:cv::AutoBuffer	access:public	signature:(size_t _size)
cv::AutoBuffer::AutoBuffer	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer()$/;"	f	class:cv::AutoBuffer	signature:()
cv::AutoBuffer::AutoBuffer	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer(size_t _size)$/;"	f	class:cv::AutoBuffer	signature:(size_t _size)
cv::AutoBuffer::allocate	/usr/include/opencv2/core/core.hpp	/^    void allocate(size_t _size);$/;"	p	class:cv::AutoBuffer	access:public	signature:(size_t _size)
cv::AutoBuffer::allocate	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::allocate(size_t _size)$/;"	f	class:cv::AutoBuffer	signature:(size_t _size)
cv::AutoBuffer::buf	/usr/include/opencv2/core/core.hpp	/^    _Tp buf[fixed_size];$/;"	m	class:cv::AutoBuffer	access:protected
cv::AutoBuffer::deallocate	/usr/include/opencv2/core/core.hpp	/^    void deallocate();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
cv::AutoBuffer::deallocate	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::deallocate()$/;"	f	class:cv::AutoBuffer	signature:()
cv::AutoBuffer::operator _Tp*	/usr/include/opencv2/core/core.hpp	/^    operator _Tp* ();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
cv::AutoBuffer::operator _Tp*	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator _Tp* ()$/;"	f	class:cv::AutoBuffer	signature:()
cv::AutoBuffer::operator const _Tp*	/usr/include/opencv2/core/core.hpp	/^    operator const _Tp* () const;$/;"	p	class:cv::AutoBuffer	access:public	signature:() const
cv::AutoBuffer::operator const _Tp*	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator const _Tp* () const$/;"	f	class:cv::AutoBuffer	signature:() const
cv::AutoBuffer::ptr	/usr/include/opencv2/core/core.hpp	/^    _Tp* ptr;$/;"	m	class:cv::AutoBuffer	access:protected
cv::AutoBuffer::size	/usr/include/opencv2/core/core.hpp	/^    size_t size;$/;"	m	class:cv::AutoBuffer	access:protected
cv::AutoBuffer::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::AutoBuffer	access:public
cv::AutoBuffer::~AutoBuffer	/usr/include/opencv2/core/core.hpp	/^    ~AutoBuffer();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
cv::AutoBuffer::~AutoBuffer	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::~AutoBuffer()$/;"	f	class:cv::AutoBuffer	signature:()
cv::BORDER_CONSTANT	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { BORDER_REPLICATE=IPL_BORDER_REPLICATE, BORDER_CONSTANT=IPL_BORDER_CONSTANT,$/;"	e	enum:cv::__anon36
cv::BORDER_DEFAULT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       BORDER_DEFAULT=BORDER_REFLECT_101, BORDER_ISOLATED=16 };$/;"	e	enum:cv::__anon36
cv::BORDER_ISOLATED	/usr/include/opencv2/imgproc/imgproc.hpp	/^       BORDER_DEFAULT=BORDER_REFLECT_101, BORDER_ISOLATED=16 };$/;"	e	enum:cv::__anon36
cv::BORDER_REFLECT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       BORDER_REFLECT=IPL_BORDER_REFLECT, BORDER_WRAP=IPL_BORDER_WRAP, $/;"	e	enum:cv::__anon36
cv::BORDER_REFLECT101	/usr/include/opencv2/imgproc/imgproc.hpp	/^ 	   BORDER_REFLECT_101=IPL_BORDER_REFLECT_101, BORDER_REFLECT101=BORDER_REFLECT_101,$/;"	e	enum:cv::__anon36
cv::BORDER_REFLECT_101	/usr/include/opencv2/imgproc/imgproc.hpp	/^ 	   BORDER_REFLECT_101=IPL_BORDER_REFLECT_101, BORDER_REFLECT101=BORDER_REFLECT_101,$/;"	e	enum:cv::__anon36
cv::BORDER_REPLICATE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { BORDER_REPLICATE=IPL_BORDER_REPLICATE, BORDER_CONSTANT=IPL_BORDER_CONSTANT,$/;"	e	enum:cv::__anon36
cv::BORDER_TRANSPARENT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       BORDER_TRANSPARENT=IPL_BORDER_TRANSPARENT,$/;"	e	enum:cv::__anon36
cv::BORDER_WRAP	/usr/include/opencv2/imgproc/imgproc.hpp	/^       BORDER_REFLECT=IPL_BORDER_REFLECT, BORDER_WRAP=IPL_BORDER_WRAP, $/;"	e	enum:cv::__anon36
cv::BOWImgDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS BOWImgDescriptorExtractor$/;"	c	namespace:cv
cv::BOWImgDescriptorExtractor::BOWImgDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    BOWImgDescriptorExtractor( const Ptr<DescriptorExtractor>& dextractor,$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Ptr<DescriptorExtractor>& dextractor, const Ptr<DescriptorMatcher>& dmatcher )
cv::BOWImgDescriptorExtractor::compute	/usr/include/opencv2/features2d/features2d.hpp	/^    void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& imgDescriptor,$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& imgDescriptor, vector<vector<int> >* pointIdxsOfClusters=0, Mat* descriptors=0 )
cv::BOWImgDescriptorExtractor::descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int descriptorSize() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
cv::BOWImgDescriptorExtractor::descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    int descriptorType() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
cv::BOWImgDescriptorExtractor::dextractor	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> dextractor;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
cv::BOWImgDescriptorExtractor::dmatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<DescriptorMatcher> dmatcher;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
cv::BOWImgDescriptorExtractor::getVocabulary	/usr/include/opencv2/features2d/features2d.hpp	/^    const Mat& getVocabulary() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
cv::BOWImgDescriptorExtractor::setVocabulary	/usr/include/opencv2/features2d/features2d.hpp	/^    void setVocabulary( const Mat& vocabulary );$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Mat& vocabulary )
cv::BOWImgDescriptorExtractor::vocabulary	/usr/include/opencv2/features2d/features2d.hpp	/^    Mat vocabulary;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
cv::BOWImgDescriptorExtractor::~BOWImgDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~BOWImgDescriptorExtractor();$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:()
cv::BOWKMeansTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS BOWKMeansTrainer : public BOWTrainer$/;"	c	namespace:cv	inherits:BOWTrainer
cv::BOWKMeansTrainer::BOWKMeansTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^    BOWKMeansTrainer( int clusterCount, const TermCriteria& termcrit=TermCriteria(),$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:( int clusterCount, const TermCriteria& termcrit=TermCriteria(), int attempts=3, int flags=KMEANS_PP_CENTERS )
cv::BOWKMeansTrainer::attempts	/usr/include/opencv2/features2d/features2d.hpp	/^    int attempts;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
cv::BOWKMeansTrainer::cluster	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Mat cluster( const Mat& descriptors ) const;$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:( const Mat& descriptors ) const
cv::BOWKMeansTrainer::cluster	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Mat cluster() const;$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:() const
cv::BOWKMeansTrainer::clusterCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int clusterCount;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
cv::BOWKMeansTrainer::flags	/usr/include/opencv2/features2d/features2d.hpp	/^    int flags;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
cv::BOWKMeansTrainer::termcrit	/usr/include/opencv2/features2d/features2d.hpp	/^    TermCriteria termcrit;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
cv::BOWKMeansTrainer::~BOWKMeansTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~BOWKMeansTrainer();$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:()
cv::BOWTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS BOWTrainer$/;"	c	namespace:cv
cv::BOWTrainer::BOWTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^    BOWTrainer();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
cv::BOWTrainer::add	/usr/include/opencv2/features2d/features2d.hpp	/^    void add( const Mat& descriptors );$/;"	p	class:cv::BOWTrainer	access:public	signature:( const Mat& descriptors )
cv::BOWTrainer::clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
cv::BOWTrainer::cluster	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Mat cluster( const Mat& descriptors ) const = 0;$/;"	p	class:cv::BOWTrainer	access:public	signature:( const Mat& descriptors ) const
cv::BOWTrainer::cluster	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Mat cluster() const = 0;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
cv::BOWTrainer::descripotorsCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int descripotorsCount() const;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
cv::BOWTrainer::descriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<Mat> descriptors;$/;"	m	class:cv::BOWTrainer	access:protected
cv::BOWTrainer::getDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    const vector<Mat>& getDescriptors() const;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
cv::BOWTrainer::size	/usr/include/opencv2/features2d/features2d.hpp	/^    int size;$/;"	m	class:cv::BOWTrainer	access:protected
cv::BOWTrainer::~BOWTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~BOWTrainer();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
cv::BackgroundSubtractor	/usr/include/opencv2/video/background_segm.hpp	/^class CV_EXPORTS_W BackgroundSubtractor$/;"	c	namespace:cv
cv::BackgroundSubtractor::operator ()	/usr/include/opencv2/video/background_segm.hpp	/^    CV_WRAP_AS(apply) virtual void operator()(const Mat& image, CV_OUT Mat& fgmask,$/;"	p	class:cv::BackgroundSubtractor	access:public	signature:(const Mat& image, CV_OUT Mat& fgmask, double learningRate=0)
cv::BackgroundSubtractor::~BackgroundSubtractor	/usr/include/opencv2/video/background_segm.hpp	/^    virtual ~BackgroundSubtractor();$/;"	p	class:cv::BackgroundSubtractor	access:public	signature:()
cv::BackgroundSubtractorMOG	/usr/include/opencv2/video/background_segm.hpp	/^class CV_EXPORTS_W BackgroundSubtractorMOG : public BackgroundSubtractor$/;"	c	namespace:cv	inherits:BackgroundSubtractor
cv::BackgroundSubtractorMOG::BackgroundSubtractorMOG	/usr/include/opencv2/video/background_segm.hpp	/^    CV_WRAP BackgroundSubtractorMOG();$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:()
cv::BackgroundSubtractorMOG::BackgroundSubtractorMOG	/usr/include/opencv2/video/background_segm.hpp	/^    CV_WRAP BackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma=0);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(int history, int nmixtures, double backgroundRatio, double noiseSigma=0)
cv::BackgroundSubtractorMOG::backgroundRatio	/usr/include/opencv2/video/background_segm.hpp	/^    double backgroundRatio;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::bgmodel	/usr/include/opencv2/video/background_segm.hpp	/^    Mat bgmodel;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::frameSize	/usr/include/opencv2/video/background_segm.hpp	/^    Size frameSize;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::frameType	/usr/include/opencv2/video/background_segm.hpp	/^    int frameType;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::history	/usr/include/opencv2/video/background_segm.hpp	/^    int history;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::initialize	/usr/include/opencv2/video/background_segm.hpp	/^    virtual void initialize(Size frameSize, int frameType);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(Size frameSize, int frameType)
cv::BackgroundSubtractorMOG::nframes	/usr/include/opencv2/video/background_segm.hpp	/^    int nframes;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::nmixtures	/usr/include/opencv2/video/background_segm.hpp	/^    int nmixtures;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::noiseSigma	/usr/include/opencv2/video/background_segm.hpp	/^    double noiseSigma;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::operator ()	/usr/include/opencv2/video/background_segm.hpp	/^    virtual void operator()(const Mat& image, Mat& fgmask, double learningRate=0);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(const Mat& image, Mat& fgmask, double learningRate=0)
cv::BackgroundSubtractorMOG::varThreshold	/usr/include/opencv2/video/background_segm.hpp	/^    double varThreshold;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::~BackgroundSubtractorMOG	/usr/include/opencv2/video/background_segm.hpp	/^    virtual ~BackgroundSubtractorMOG();$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:()
cv::BaseColumnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^class CV_EXPORTS BaseColumnFilter$/;"	c	namespace:cv
cv::BaseColumnFilter::BaseColumnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    BaseColumnFilter();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
cv::BaseColumnFilter::anchor	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseColumnFilter	access:public
cv::BaseColumnFilter::ksize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseColumnFilter	access:public
cv::BaseColumnFilter::operator ()	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void operator()(const uchar** src, uchar* dst, int dststep,$/;"	p	class:cv::BaseColumnFilter	access:public	signature:(const uchar** src, uchar* dst, int dststep, int dstcount, int width)
cv::BaseColumnFilter::reset	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void reset();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
cv::BaseColumnFilter::~BaseColumnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual ~BaseColumnFilter();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
cv::BaseFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^class CV_EXPORTS BaseFilter$/;"	c	namespace:cv
cv::BaseFilter::BaseFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    BaseFilter();$/;"	p	class:cv::BaseFilter	access:public	signature:()
cv::BaseFilter::anchor	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Point anchor;$/;"	m	class:cv::BaseFilter	access:public
cv::BaseFilter::ksize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Size ksize;$/;"	m	class:cv::BaseFilter	access:public
cv::BaseFilter::operator ()	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void operator()(const uchar** src, uchar* dst, int dststep,$/;"	p	class:cv::BaseFilter	access:public	signature:(const uchar** src, uchar* dst, int dststep, int dstcount, int width, int cn)
cv::BaseFilter::reset	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void reset();$/;"	p	class:cv::BaseFilter	access:public	signature:()
cv::BaseFilter::~BaseFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual ~BaseFilter();$/;"	p	class:cv::BaseFilter	access:public	signature:()
cv::BaseKeypoint	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS BaseKeypoint$/;"	s	namespace:cv
cv::BaseKeypoint::BaseKeypoint	/usr/include/opencv2/features2d/features2d.hpp	/^  BaseKeypoint()$/;"	f	struct:cv::BaseKeypoint	access:public	signature:()
cv::BaseKeypoint::BaseKeypoint	/usr/include/opencv2/features2d/features2d.hpp	/^  BaseKeypoint(int x, int y, IplImage* image)$/;"	f	struct:cv::BaseKeypoint	access:public	signature:(int x, int y, IplImage* image)
cv::BaseKeypoint::image	/usr/include/opencv2/features2d/features2d.hpp	/^  IplImage* image;$/;"	m	struct:cv::BaseKeypoint	access:public
cv::BaseKeypoint::x	/usr/include/opencv2/features2d/features2d.hpp	/^  int x;$/;"	m	struct:cv::BaseKeypoint	access:public
cv::BaseKeypoint::y	/usr/include/opencv2/features2d/features2d.hpp	/^  int y;$/;"	m	struct:cv::BaseKeypoint	access:public
cv::BaseRowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^class CV_EXPORTS BaseRowFilter$/;"	c	namespace:cv
cv::BaseRowFilter::BaseRowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    BaseRowFilter();$/;"	p	class:cv::BaseRowFilter	access:public	signature:()
cv::BaseRowFilter::anchor	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseRowFilter	access:public
cv::BaseRowFilter::ksize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseRowFilter	access:public
cv::BaseRowFilter::operator ()	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void operator()(const uchar* src, uchar* dst,$/;"	p	class:cv::BaseRowFilter	access:public	signature:(const uchar* src, uchar* dst, int width, int cn)
cv::BaseRowFilter::~BaseRowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual ~BaseRowFilter();$/;"	p	class:cv::BaseRowFilter	access:public	signature:()
cv::BlockedRange	/usr/include/opencv2/core/internal.hpp	/^        typedef tbb::blocked_range<int> BlockedRange;$/;"	t	namespace:cv
cv::Boost	/usr/include/opencv2/ml/ml.hpp	/^typedef CvBoost Boost;$/;"	t	namespace:cv
cv::BoostParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvBoostParams BoostParams;$/;"	t	namespace:cv
cv::BoostTree	/usr/include/opencv2/ml/ml.hpp	/^typedef CvBoostTree BoostTree;$/;"	t	namespace:cv
cv::BriefDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS BriefDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
cv::BriefDescriptorExtractor::BriefDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    BriefDescriptorExtractor( int bytes = 32 );$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:( int bytes = 32 )
cv::BriefDescriptorExtractor::KERNEL_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^    static const int KERNEL_SIZE = 9;$/;"	m	class:cv::BriefDescriptorExtractor	access:public
cv::BriefDescriptorExtractor::PATCH_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^    static const int PATCH_SIZE = 48;$/;"	m	class:cv::BriefDescriptorExtractor	access:public
cv::BriefDescriptorExtractor::PixelTestFn	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef void(*PixelTestFn)(const Mat&, const std::vector<KeyPoint>&, Mat&);$/;"	t	class:cv::BriefDescriptorExtractor	access:protected
cv::BriefDescriptorExtractor::bytes_	/usr/include/opencv2/features2d/features2d.hpp	/^    int bytes_;$/;"	m	class:cv::BriefDescriptorExtractor	access:protected
cv::BriefDescriptorExtractor::computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl(const Mat& image, std::vector<KeyPoint>& keypoints, Mat& descriptors) const;$/;"	p	class:cv::BriefDescriptorExtractor	access:protected	signature:(const Mat& image, std::vector<KeyPoint>& keypoints, Mat& descriptors) const
cv::BriefDescriptorExtractor::descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:() const
cv::BriefDescriptorExtractor::descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:() const
cv::BriefDescriptorExtractor::test_fn_	/usr/include/opencv2/features2d/features2d.hpp	/^    PixelTestFn test_fn_;$/;"	m	class:cv::BriefDescriptorExtractor	access:protected
cv::BruteForceMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS BruteForceMatcher : public DescriptorMatcher$/;"	c	namespace:cv	inherits:DescriptorMatcher
cv::BruteForceMatcher::BruteForceMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    BruteForceMatcher( Distance d = Distance() ) : distance(d) {}$/;"	f	class:cv::BruteForceMatcher	access:public	signature:( Distance d = Distance() )
cv::BruteForceMatcher::clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::BruteForceMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::BruteForceMatcher::clone	/usr/include/opencv2/features2d/features2d.hpp	/^Ptr<DescriptorMatcher> BruteForceMatcher<Distance>::clone( bool emptyTrainData ) const$/;"	f	class:cv::BruteForceMatcher	signature:( bool emptyTrainData ) const
cv::BruteForceMatcher::commonKnnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    static void commonKnnMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	p	class:cv::BruteForceMatcher	access:private	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::commonKnnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^inline void BruteForceMatcher<Distance>::commonKnnMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	f	class:cv::BruteForceMatcher	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int knn, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::commonRadiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    static void commonRadiusMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	p	class:cv::BruteForceMatcher	access:private	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::commonRadiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^inline void BruteForceMatcher<Distance>::commonRadiusMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	f	class:cv::BruteForceMatcher	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::distance	/usr/include/opencv2/features2d/features2d.hpp	/^    Distance distance;$/;"	m	class:cv::BruteForceMatcher	access:protected
cv::BruteForceMatcher::isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported() const { return true; }$/;"	f	class:cv::BruteForceMatcher	access:public	signature:() const
cv::BruteForceMatcher::knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::BruteForceMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::BruteForceMatcher::knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^void BruteForceMatcher<Distance>::knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	f	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^void BruteForceMatcher<L2<float> >::knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::BruteForceMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::BruteForceMatcher::radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^void BruteForceMatcher<Distance>::radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches,$/;"	f	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^void BruteForceMatcher<L2<float> >::radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches,$/;"	p	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::~BruteForceMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~BruteForceMatcher() {}$/;"	f	class:cv::BruteForceMatcher	access:public	signature:()
cv::ButtonCallback	/usr/include/opencv2/highgui/highgui.hpp	/^typedef void (CV_CDECL *ButtonCallback)(int state, void* userdata);$/;"	t	namespace:cv
cv::CALIB_CB_ADAPTIVE_THRESH	/usr/include/opencv2/calib3d/calib3d.hpp	/^enum { CALIB_CB_ADAPTIVE_THRESH = 1, CALIB_CB_NORMALIZE_IMAGE = 2,$/;"	e	enum:cv::__anon68
cv::CALIB_CB_FAST_CHECK	/usr/include/opencv2/calib3d/calib3d.hpp	/^       CALIB_CB_FILTER_QUADS = 4, CALIB_CB_FAST_CHECK = 8 };$/;"	e	enum:cv::__anon68
cv::CALIB_CB_FILTER_QUADS	/usr/include/opencv2/calib3d/calib3d.hpp	/^       CALIB_CB_FILTER_QUADS = 4, CALIB_CB_FAST_CHECK = 8 };$/;"	e	enum:cv::__anon68
cv::CALIB_CB_NORMALIZE_IMAGE	/usr/include/opencv2/calib3d/calib3d.hpp	/^enum { CALIB_CB_ADAPTIVE_THRESH = 1, CALIB_CB_NORMALIZE_IMAGE = 2,$/;"	e	enum:cv::__anon68
cv::CALIB_FIX_ASPECT_RATIO	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_ASPECT_RATIO = CV_CALIB_FIX_ASPECT_RATIO,$/;"	e	enum:cv::__anon69
cv::CALIB_FIX_FOCAL_LENGTH	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_FOCAL_LENGTH = CV_CALIB_FIX_FOCAL_LENGTH,$/;"	e	enum:cv::__anon69
cv::CALIB_FIX_INTRINSIC	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_INTRINSIC = CV_CALIB_FIX_INTRINSIC,$/;"	e	enum:cv::__anon69
cv::CALIB_FIX_K1	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K1 = CV_CALIB_FIX_K1,$/;"	e	enum:cv::__anon69
cv::CALIB_FIX_K2	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K2 = CV_CALIB_FIX_K2,$/;"	e	enum:cv::__anon69
cv::CALIB_FIX_K3	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K3 = CV_CALIB_FIX_K3,$/;"	e	enum:cv::__anon69
cv::CALIB_FIX_K4	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K4 = CV_CALIB_FIX_K4,$/;"	e	enum:cv::__anon69
cv::CALIB_FIX_K5	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K5 = CV_CALIB_FIX_K5,$/;"	e	enum:cv::__anon69
cv::CALIB_FIX_K6	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_K6 = CV_CALIB_FIX_K6,$/;"	e	enum:cv::__anon69
cv::CALIB_FIX_PRINCIPAL_POINT	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_FIX_PRINCIPAL_POINT = CV_CALIB_FIX_PRINCIPAL_POINT,$/;"	e	enum:cv::__anon69
cv::CALIB_RATIONAL_MODEL	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_RATIONAL_MODEL = CV_CALIB_RATIONAL_MODEL,$/;"	e	enum:cv::__anon69
cv::CALIB_SAME_FOCAL_LENGTH	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_SAME_FOCAL_LENGTH = CV_CALIB_SAME_FOCAL_LENGTH,$/;"	e	enum:cv::__anon69
cv::CALIB_USE_INTRINSIC_GUESS	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_USE_INTRINSIC_GUESS = CV_CALIB_USE_INTRINSIC_GUESS,$/;"	e	enum:cv::__anon69
cv::CALIB_ZERO_DISPARITY	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_ZERO_DISPARITY = CV_CALIB_ZERO_DISPARITY$/;"	e	enum:cv::__anon69
cv::CALIB_ZERO_TANGENT_DIST	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CALIB_ZERO_TANGENT_DIST = CV_CALIB_ZERO_TANGENT_DIST,$/;"	e	enum:cv::__anon69
cv::CHAIN_APPROX_NONE	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CHAIN_APPROX_NONE=0,$/;"	e	enum:cv::__anon51
cv::CHAIN_APPROX_SIMPLE	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CHAIN_APPROX_SIMPLE=1,$/;"	e	enum:cv::__anon51
cv::CHAIN_APPROX_TC89_KCOS	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CHAIN_APPROX_TC89_KCOS=3$/;"	e	enum:cv::__anon51
cv::CHAIN_APPROX_TC89_L1	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CHAIN_APPROX_TC89_L1=2,$/;"	e	enum:cv::__anon51
cv::CMP_EQ	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
cv::CMP_GE	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
cv::CMP_GT	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
cv::CMP_LE	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
cv::CMP_LT	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
cv::CMP_NE	/usr/include/opencv2/core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon106
cv::CalonderDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS CalonderDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
cv::CalonderDescriptorExtractor::BORDER_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^    static const int BORDER_SIZE = 16;$/;"	m	class:cv::CalonderDescriptorExtractor	access:protected
cv::CalonderDescriptorExtractor::CalonderDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    CalonderDescriptorExtractor( const string& classifierFile );$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( const string& classifierFile )
cv::CalonderDescriptorExtractor::CalonderDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^CalonderDescriptorExtractor<T>::CalonderDescriptorExtractor(const std::string& classifier_file)$/;"	f	class:cv::CalonderDescriptorExtractor	signature:(const std::string& classifier_file)
cv::CalonderDescriptorExtractor::classifier_	/usr/include/opencv2/features2d/features2d.hpp	/^    RTreeClassifier classifier_;$/;"	m	class:cv::CalonderDescriptorExtractor	access:protected
cv::CalonderDescriptorExtractor::computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::CalonderDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::CalonderDescriptorExtractor::computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::computeImpl( const cv::Mat& image,$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, cv::Mat& descriptors) const
cv::CalonderDescriptorExtractor::descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const { return classifier_.classes(); }$/;"	f	class:cv::CalonderDescriptorExtractor	access:public	signature:() const
cv::CalonderDescriptorExtractor::descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const { return DataType<T>::type; }$/;"	f	class:cv::CalonderDescriptorExtractor	access:public	signature:() const
cv::CalonderDescriptorExtractor::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( const FileNode &fn )
cv::CalonderDescriptorExtractor::read	/usr/include/opencv2/features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::read( const FileNode& )$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( const FileNode& )
cv::CalonderDescriptorExtractor::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
cv::CalonderDescriptorExtractor::write	/usr/include/opencv2/features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::write( FileStorage& ) const$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( FileStorage& ) const
cv::CamShift	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W RotatedRect CamShift( const Mat& probImage, CV_IN_OUT Rect& window,$/;"	p	namespace:cv	signature:( const Mat& probImage, CV_IN_OUT Rect& window, TermCriteria criteria )
cv::Canny	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(canny) void Canny( const Mat& image, CV_OUT Mat& edges,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT Mat& edges, double threshold1, double threshold2, int apertureSize=3, bool L2gradient=false )
cv::CascadeClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^class CV_EXPORTS_W CascadeClassifier$/;"	c	namespace:cv
cv::CascadeClassifier::BOOST	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { BOOST = 0 };$/;"	e	enum:cv::CascadeClassifier::__anon62
cv::CascadeClassifier::CascadeClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP CascadeClassifier();$/;"	p	class:cv::CascadeClassifier	access:public	signature:()
cv::CascadeClassifier::CascadeClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP CascadeClassifier(const string& filename);$/;"	p	class:cv::CascadeClassifier	access:public	signature:(const string& filename)
cv::CascadeClassifier::DO_CANNY_PRUNING	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { DO_CANNY_PRUNING = 1, SCALE_IMAGE = 2,$/;"	e	enum:cv::CascadeClassifier::__anon63
cv::CascadeClassifier::DO_ROUGH_SEARCH	/usr/include/opencv2/objdetect/objdetect.hpp	/^           FIND_BIGGEST_OBJECT = 4, DO_ROUGH_SEARCH = 8 };$/;"	e	enum:cv::CascadeClassifier::__anon63
cv::CascadeClassifier::DTree	/usr/include/opencv2/objdetect/objdetect.hpp	/^    struct CV_EXPORTS DTree$/;"	s	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::DTree::nodeCount	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int nodeCount;$/;"	m	struct:cv::CascadeClassifier::DTree	access:public
cv::CascadeClassifier::DTreeNode	/usr/include/opencv2/objdetect/objdetect.hpp	/^    struct CV_EXPORTS DTreeNode$/;"	s	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::DTreeNode::featureIdx	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int featureIdx;$/;"	m	struct:cv::CascadeClassifier::DTreeNode	access:public
cv::CascadeClassifier::DTreeNode::left	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int left;$/;"	m	struct:cv::CascadeClassifier::DTreeNode	access:public
cv::CascadeClassifier::DTreeNode::right	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int right;$/;"	m	struct:cv::CascadeClassifier::DTreeNode	access:public
cv::CascadeClassifier::DTreeNode::threshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^        float threshold; \/\/ for ordered features only$/;"	m	struct:cv::CascadeClassifier::DTreeNode	access:public
cv::CascadeClassifier::FIND_BIGGEST_OBJECT	/usr/include/opencv2/objdetect/objdetect.hpp	/^           FIND_BIGGEST_OBJECT = 4, DO_ROUGH_SEARCH = 8 };$/;"	e	enum:cv::CascadeClassifier::__anon63
cv::CascadeClassifier::SCALE_IMAGE	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { DO_CANNY_PRUNING = 1, SCALE_IMAGE = 2,$/;"	e	enum:cv::CascadeClassifier::__anon63
cv::CascadeClassifier::Stage	/usr/include/opencv2/objdetect/objdetect.hpp	/^    struct CV_EXPORTS Stage$/;"	s	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::Stage::first	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int first;$/;"	m	struct:cv::CascadeClassifier::Stage	access:public
cv::CascadeClassifier::Stage::ntrees	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int ntrees;$/;"	m	struct:cv::CascadeClassifier::Stage	access:public
cv::CascadeClassifier::Stage::threshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^        float threshold;$/;"	m	struct:cv::CascadeClassifier::Stage	access:public
cv::CascadeClassifier::classifiers	/usr/include/opencv2/objdetect/objdetect.hpp	/^    vector<DTree> classifiers;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::detectMultiScale	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP void detectMultiScale( const Mat& image,$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const Mat& image, CV_OUT vector<Rect>& objects, double scaleFactor=1.1, int minNeighbors=3, int flags=0, Size minSize=Size(), Size maxSize=Size())
cv::CascadeClassifier::empty	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP bool empty() const;$/;"	p	class:cv::CascadeClassifier	access:public	signature:() const
cv::CascadeClassifier::featureType	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int featureType;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::feval	/usr/include/opencv2/objdetect/objdetect.hpp	/^    Ptr<FeatureEvaluator> feval;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::is_stump_based	/usr/include/opencv2/objdetect/objdetect.hpp	/^    bool is_stump_based;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::leaves	/usr/include/opencv2/objdetect/objdetect.hpp	/^    vector<float> leaves;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::load	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP bool load(const string& filename);$/;"	p	class:cv::CascadeClassifier	access:public	signature:(const string& filename)
cv::CascadeClassifier::ncategories	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int ncategories;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::nodes	/usr/include/opencv2/objdetect/objdetect.hpp	/^    vector<DTreeNode> nodes;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::oldCascade	/usr/include/opencv2/objdetect/objdetect.hpp	/^    Ptr<CvHaarClassifierCascade> oldCascade;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::origWinSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    Size origWinSize;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::read	/usr/include/opencv2/objdetect/objdetect.hpp	/^    bool read(const FileNode& node);$/;"	p	class:cv::CascadeClassifier	access:public	signature:(const FileNode& node)
cv::CascadeClassifier::runAt	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int runAt( Ptr<FeatureEvaluator>&, Point );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( Ptr<FeatureEvaluator>&, Point )
cv::CascadeClassifier::setImage	/usr/include/opencv2/objdetect/objdetect.hpp	/^    bool setImage( Ptr<FeatureEvaluator>&, const Mat& );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( Ptr<FeatureEvaluator>&, const Mat& )
cv::CascadeClassifier::stageType	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int stageType;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::stages	/usr/include/opencv2/objdetect/objdetect.hpp	/^    vector<Stage> stages;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::subsets	/usr/include/opencv2/objdetect/objdetect.hpp	/^    vector<int> subsets;$/;"	m	class:cv::CascadeClassifier	access:public
cv::CascadeClassifier::~CascadeClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^    ~CascadeClassifier();$/;"	p	class:cv::CascadeClassifier	access:public	signature:()
cv::Cholesky	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS bool Cholesky(double* A, int m, double* b, int n);    $/;"	p	namespace:cv	signature:(double* A, int m, double* b, int n)
cv::Cholesky	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS bool Cholesky(float* A, int m, float* b, int n);$/;"	p	namespace:cv	signature:(float* A, int m, float* b, int n)
cv::Complex	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Complex$/;"	c	namespace:cv
cv::Complex::Complex	/usr/include/opencv2/core/core.hpp	/^    Complex( _Tp _re, _Tp _im=0 );$/;"	p	class:cv::Complex	access:public	signature:( _Tp _re, _Tp _im=0 )
cv::Complex::Complex	/usr/include/opencv2/core/core.hpp	/^    Complex( const std::complex<_Tp>& c );$/;"	p	class:cv::Complex	access:public	signature:( const std::complex<_Tp>& c )
cv::Complex::Complex	/usr/include/opencv2/core/core.hpp	/^    Complex();$/;"	p	class:cv::Complex	access:public	signature:()
cv::Complex::Complex	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp>::Complex( _Tp _re, _Tp _im ) : re(_re), im(_im) {}$/;"	f	class:cv::Complex	signature:( _Tp _re, _Tp _im )
cv::Complex::Complex	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp>::Complex() : re(0), im(0) {}$/;"	f	class:cv::Complex	signature:()
cv::Complex::conj	/usr/include/opencv2/core/core.hpp	/^    Complex conj() const;$/;"	p	class:cv::Complex	access:public	signature:() const
cv::Complex::conj	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp> Complex<_Tp>::conj() const$/;"	f	class:cv::Complex	signature:() const
cv::Complex::im	/usr/include/opencv2/core/core.hpp	/^    _Tp re, im; \/\/< the real and the imaginary parts$/;"	m	class:cv::Complex	access:public
cv::Complex::operator Complex<T2>	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> operator Complex<T2>() const;$/;"	p	class:cv::Complex	access:public	signature:() const
cv::Complex::operator Complex<T2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename T2> inline Complex<_Tp>::operator Complex<T2>() const$/;"	f	class:cv::Complex	signature:() const
cv::Complex::operator std::complex<_Tp>	/usr/include/opencv2/core/core.hpp	/^    operator std::complex<_Tp>() const;$/;"	p	class:cv::Complex	access:public	signature:() const
cv::Complex::re	/usr/include/opencv2/core/core.hpp	/^    _Tp re, im; \/\/< the real and the imaginary parts$/;"	m	class:cv::Complex	access:public
cv::Complexd	/usr/include/opencv2/core/core.hpp	/^typedef Complex<double> Complexd;$/;"	t	namespace:cv
cv::Complexf	/usr/include/opencv2/core/core.hpp	/^typedef Complex<float> Complexf;$/;"	t	namespace:cv
cv::ConcurrentRectVector	/usr/include/opencv2/core/internal.hpp	/^        typedef tbb::concurrent_vector<Rect> ConcurrentRectVector;$/;"	t	namespace:cv
cv::ConvertData	/usr/include/opencv2/core/core.hpp	/^typedef void (*ConvertData)(const void* from, void* to, int cn);$/;"	t	namespace:cv
cv::ConvertScaleData	/usr/include/opencv2/core/core.hpp	/^typedef void (*ConvertScaleData)(const void* from, void* to, int cn, double alpha, double beta);$/;"	t	namespace:cv
cv::CvAffinePose	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS CvAffinePose$/;"	c	namespace:cv
cv::CvAffinePose::lambda1	/usr/include/opencv2/features2d/features2d.hpp	/^    float lambda1;$/;"	m	class:cv::CvAffinePose	access:public
cv::CvAffinePose::lambda2	/usr/include/opencv2/features2d/features2d.hpp	/^    float lambda2;$/;"	m	class:cv::CvAffinePose	access:public
cv::CvAffinePose::phi	/usr/include/opencv2/features2d/features2d.hpp	/^    float phi;$/;"	m	class:cv::CvAffinePose	access:public
cv::CvAffinePose::theta	/usr/include/opencv2/features2d/features2d.hpp	/^    float theta;$/;"	m	class:cv::CvAffinePose	access:public
cv::DCT_INVERSE	/usr/include/opencv2/core/core.hpp	/^    DCT_INVERSE = DFT_INVERSE, DCT_ROWS=DFT_ROWS };$/;"	e	enum:cv::__anon108
cv::DCT_ROWS	/usr/include/opencv2/core/core.hpp	/^    DCT_INVERSE = DFT_INVERSE, DCT_ROWS=DFT_ROWS };$/;"	e	enum:cv::__anon108
cv::DECOMP_CHOLESKY	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
cv::DECOMP_EIG	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
cv::DECOMP_LU	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
cv::DECOMP_NORMAL	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
cv::DECOMP_QR	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
cv::DECOMP_SVD	/usr/include/opencv2/core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon104
cv::DEPTH_MASK	/usr/include/opencv2/core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon141
cv::DFT_COMPLEX_OUTPUT	/usr/include/opencv2/core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon108
cv::DFT_INVERSE	/usr/include/opencv2/core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon108
cv::DFT_REAL_OUTPUT	/usr/include/opencv2/core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon108
cv::DFT_ROWS	/usr/include/opencv2/core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon108
cv::DFT_SCALE	/usr/include/opencv2/core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon108
cv::DMatch	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS DMatch$/;"	s	namespace:cv
cv::DMatch::DMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    DMatch( int _queryIdx, int _trainIdx, float _distance ) :$/;"	f	struct:cv::DMatch	access:public	signature:( int _queryIdx, int _trainIdx, float _distance )
cv::DMatch::DMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    DMatch( int _queryIdx, int _trainIdx, int _imgIdx, float _distance ) :$/;"	f	struct:cv::DMatch	access:public	signature:( int _queryIdx, int _trainIdx, int _imgIdx, float _distance )
cv::DMatch::DMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    DMatch() : queryIdx(-1), trainIdx(-1), imgIdx(-1), distance(std::numeric_limits<float>::max()) {}$/;"	f	struct:cv::DMatch	access:public	signature:()
cv::DMatch::distance	/usr/include/opencv2/features2d/features2d.hpp	/^    float distance;$/;"	m	struct:cv::DMatch	access:public
cv::DMatch::imgIdx	/usr/include/opencv2/features2d/features2d.hpp	/^    int imgIdx;   \/\/ train image index$/;"	m	struct:cv::DMatch	access:public
cv::DMatch::operator <	/usr/include/opencv2/features2d/features2d.hpp	/^    bool operator<( const DMatch &m ) const$/;"	f	struct:cv::DMatch	access:public	signature:( const DMatch &m ) const
cv::DMatch::queryIdx	/usr/include/opencv2/features2d/features2d.hpp	/^    int queryIdx; \/\/ query descriptor index$/;"	m	struct:cv::DMatch	access:public
cv::DMatch::trainIdx	/usr/include/opencv2/features2d/features2d.hpp	/^    int trainIdx; \/\/ train descriptor index$/;"	m	struct:cv::DMatch	access:public
cv::DTreeParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvDTreeParams DTreeParams;$/;"	t	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	c	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	c	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	c	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	c	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	c	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	c	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	c	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	c	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	c	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	c	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS DataDepth {};$/;"	c	namespace:cv
cv::DataDepth	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	c	namespace:cv
cv::DataDepth::fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon109
cv::DataDepth::fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon112
cv::DataDepth::fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	e	enum:cv::DataDepth::__anon118
cv::DataDepth::fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	e	enum:cv::DataDepth::__anon117
cv::DataDepth::fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon115
cv::DataDepth::fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon111
cv::DataDepth::fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	e	enum:cv::DataDepth::__anon114
cv::DataDepth::fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon110
cv::DataDepth::fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon116
cv::DataDepth::fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	e	enum:cv::DataDepth::__anon113
cv::DataDepth::fmt	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	e	enum:cv::DataDepth::__anon119
cv::DataDepth::value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon109
cv::DataDepth::value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon112
cv::DataDepth::value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	e	enum:cv::DataDepth::__anon118
cv::DataDepth::value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	e	enum:cv::DataDepth::__anon117
cv::DataDepth::value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon115
cv::DataDepth::value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon111
cv::DataDepth::value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	e	enum:cv::DataDepth::__anon114
cv::DataDepth::value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon110
cv::DataDepth::value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon116
cv::DataDepth::value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	e	enum:cv::DataDepth::__anon113
cv::DataDepth::value	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	e	enum:cv::DataDepth::__anon119
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<Range>$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<bool>$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<char>$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<double>$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<float>$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<int>$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<schar>$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<short>$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<uchar>$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<> class DataType<ushort>$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int cn> class DataType<Vec<_Tp, cn> >$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Complex<_Tp> >$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Point3_<_Tp> >$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Point_<_Tp> >$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Rect_<_Tp> >$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Scalar_<_Tp> >$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<Size_<_Tp> >$/;"	c	namespace:cv
cv::DataType	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataType<std::complex<_Tp> >$/;"	c	namespace:cv
cv::DataType::channel_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp channel_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::channel_type	/usr/include/opencv2/core/core.hpp	/^    typedef int channel_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::channel_type	/usr/include/opencv2/core/core.hpp	/^    typedef value_type channel_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon125
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon126
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon127
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon128
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon129
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon130
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon131
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon134
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon135
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon137
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon140
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon136
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon138
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon139
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon132
cv::DataType::channels	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 1, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon125
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon126
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon127
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon128
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon129
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon130
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon131
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon134
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon135
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon137
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon140
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon136
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon138
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon139
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon132
cv::DataType::depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 1, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon132
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon133
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon134
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon135
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon136
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon137
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon138
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon139
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon140
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon123
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon124
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon125
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon126
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon127
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon128
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon129
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon130
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon131
cv::DataType::fmt	/usr/include/opencv2/core/core.hpp	/^        fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon122
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon125
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon126
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon127
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon128
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon129
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon130
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon131
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon134
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon135
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon137
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon140
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon136
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon138
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon139
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon132
cv::DataType::generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 1, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon123
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon124
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon125
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon126
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon127
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon128
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon129
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon130
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon131
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon132
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon133
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon134
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon135
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon136
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon137
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon138
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon139
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon140
cv::DataType::type	/usr/include/opencv2/core/core.hpp	/^        type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon122
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Complex<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Point3_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Point_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Range value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Rect_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Scalar_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Size_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Vec<_Tp, cn> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef bool value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef double value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef float value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef int value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef schar value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef short value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef std::complex<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef uchar value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef ushort value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::vec_type	/usr/include/opencv2/core/core.hpp	/^    typedef Vec<channel_type, channels> vec_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::vec_type	/usr/include/opencv2/core/core.hpp	/^    typedef value_type vec_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Point3_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Point_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Rect_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Scalar_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Size_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Vec<typename DataType<_Tp>::work_type, cn> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	/usr/include/opencv2/core/core.hpp	/^    typedef int work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	/usr/include/opencv2/core/core.hpp	/^    typedef value_type work_type;$/;"	t	class:cv::DataType	access:public
cv::DecisionTree	/usr/include/opencv2/ml/ml.hpp	/^typedef CvDTree DecisionTree;$/;"	t	namespace:cv
cv::DefaultRngAuto	/usr/include/opencv2/features2d/features2d.hpp	/^    struct CV_EXPORTS DefaultRngAuto$/;"	s	namespace:cv
cv::DefaultRngAuto::DefaultRngAuto	/usr/include/opencv2/features2d/features2d.hpp	/^        DefaultRngAuto() : old_state(theRNG().state) { theRNG().state = (uint64)-1; }$/;"	f	struct:cv::DefaultRngAuto	access:public	signature:()
cv::DefaultRngAuto::old_state	/usr/include/opencv2/features2d/features2d.hpp	/^        const uint64 old_state;$/;"	m	struct:cv::DefaultRngAuto	access:public
cv::DefaultRngAuto::operator =	/usr/include/opencv2/features2d/features2d.hpp	/^        DefaultRngAuto& operator=(const DefaultRngAuto&);$/;"	p	struct:cv::DefaultRngAuto	access:public	signature:(const DefaultRngAuto&)
cv::DefaultRngAuto::~DefaultRngAuto	/usr/include/opencv2/features2d/features2d.hpp	/^        ~DefaultRngAuto() { theRNG().state = old_state; }$/;"	f	struct:cv::DefaultRngAuto	access:public	signature:()
cv::DenseFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS DenseFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::DenseFeatureDetector::DenseFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    DenseFeatureDetector( const DenseFeatureDetector::Params& params=DenseFeatureDetector::Params() );$/;"	p	class:cv::DenseFeatureDetector	access:public	signature:( const DenseFeatureDetector::Params& params=DenseFeatureDetector::Params() )
cv::DenseFeatureDetector::Params	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::DenseFeatureDetector	access:public
cv::DenseFeatureDetector::Params::Params	/usr/include/opencv2/features2d/features2d.hpp	/^        Params( float initFeatureScale=1.f, int featureScaleLevels=1, float featureScaleMul=0.1f,$/;"	p	class:cv::DenseFeatureDetector::Params	access:public	signature:( float initFeatureScale=1.f, int featureScaleLevels=1, float featureScaleMul=0.1f, int initXyStep=6, int initImgBound=0, bool varyXyStepWithScale=true, bool varyImgBoundWithScale=false )
cv::DenseFeatureDetector::Params::featureScaleLevels	/usr/include/opencv2/features2d/features2d.hpp	/^        int featureScaleLevels;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::featureScaleMul	/usr/include/opencv2/features2d/features2d.hpp	/^        float featureScaleMul;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::initFeatureScale	/usr/include/opencv2/features2d/features2d.hpp	/^        float initFeatureScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::initImgBound	/usr/include/opencv2/features2d/features2d.hpp	/^        int initImgBound;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::initXyStep	/usr/include/opencv2/features2d/features2d.hpp	/^        int initXyStep;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::varyImgBoundWithScale	/usr/include/opencv2/features2d/features2d.hpp	/^        bool varyImgBoundWithScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::varyXyStepWithScale	/usr/include/opencv2/features2d/features2d.hpp	/^        bool varyXyStepWithScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::DenseFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::DenseFeatureDetector::params	/usr/include/opencv2/features2d/features2d.hpp	/^	Params params;$/;"	m	class:cv::DenseFeatureDetector	access:protected
cv::DescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS DescriptorExtractor$/;"	c	namespace:cv
cv::DescriptorExtractor::compute	/usr/include/opencv2/features2d/features2d.hpp	/^    void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::DescriptorExtractor::compute	/usr/include/opencv2/features2d/features2d.hpp	/^    void compute( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, vector<Mat>& descriptors ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, vector<Mat>& descriptors ) const
cv::DescriptorExtractor::computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const = 0;$/;"	p	class:cv::DescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::DescriptorExtractor::create	/usr/include/opencv2/features2d/features2d.hpp	/^    static Ptr<DescriptorExtractor> create( const string& descriptorExtractorType );$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const string& descriptorExtractorType )
cv::DescriptorExtractor::descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const = 0;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:() const
cv::DescriptorExtractor::descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const = 0;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:() const
cv::DescriptorExtractor::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const FileNode& )
cv::DescriptorExtractor::removeBorderKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^    static void removeBorderKeypoints( vector<KeyPoint>& keypoints,$/;"	p	class:cv::DescriptorExtractor	access:protected	signature:( vector<KeyPoint>& keypoints, Size imageSize, int borderSize )
cv::DescriptorExtractor::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( FileStorage& ) const
cv::DescriptorExtractor::~DescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~DescriptorExtractor();$/;"	p	class:cv::DescriptorExtractor	access:public	signature:()
cv::DescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS DescriptorMatcher$/;"	c	namespace:cv
cv::DescriptorMatcher::DescriptorCollection	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS DescriptorCollection$/;"	c	class:cv::DescriptorMatcher	access:protected
cv::DescriptorMatcher::DescriptorCollection::DescriptorCollection	/usr/include/opencv2/features2d/features2d.hpp	/^        DescriptorCollection( const DescriptorCollection& collection );$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( const DescriptorCollection& collection )
cv::DescriptorMatcher::DescriptorCollection::DescriptorCollection	/usr/include/opencv2/features2d/features2d.hpp	/^        DescriptorCollection();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
cv::DescriptorMatcher::DescriptorCollection::clear	/usr/include/opencv2/features2d/features2d.hpp	/^        virtual void clear();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
cv::DescriptorMatcher::DescriptorCollection::getDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^        const Mat getDescriptor( int globalDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int globalDescIdx ) const
cv::DescriptorMatcher::DescriptorCollection::getDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^        const Mat getDescriptor( int imgIdx, int localDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int imgIdx, int localDescIdx ) const
cv::DescriptorMatcher::DescriptorCollection::getDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^        const Mat& getDescriptors() const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:() const
cv::DescriptorMatcher::DescriptorCollection::getLocalIdx	/usr/include/opencv2/features2d/features2d.hpp	/^        void getLocalIdx( int globalDescIdx, int& imgIdx, int& localDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int globalDescIdx, int& imgIdx, int& localDescIdx ) const
cv::DescriptorMatcher::DescriptorCollection::mergedDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^        Mat mergedDescriptors;$/;"	m	class:cv::DescriptorMatcher::DescriptorCollection	access:protected
cv::DescriptorMatcher::DescriptorCollection::set	/usr/include/opencv2/features2d/features2d.hpp	/^        void set( const vector<Mat>& descriptors );$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( const vector<Mat>& descriptors )
cv::DescriptorMatcher::DescriptorCollection::size	/usr/include/opencv2/features2d/features2d.hpp	/^        int size() const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:() const
cv::DescriptorMatcher::DescriptorCollection::startIdxs	/usr/include/opencv2/features2d/features2d.hpp	/^        vector<int> startIdxs;$/;"	m	class:cv::DescriptorMatcher::DescriptorCollection	access:protected
cv::DescriptorMatcher::DescriptorCollection::~DescriptorCollection	/usr/include/opencv2/features2d/features2d.hpp	/^        virtual ~DescriptorCollection();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
cv::DescriptorMatcher::add	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& descriptors );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const vector<Mat>& descriptors )
cv::DescriptorMatcher::checkMasks	/usr/include/opencv2/features2d/features2d.hpp	/^	void checkMasks( const vector<Mat>& masks, int queryDescriptorsCount ) const;$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const vector<Mat>& masks, int queryDescriptorsCount ) const
cv::DescriptorMatcher::clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
cv::DescriptorMatcher::clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const = 0;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::DescriptorMatcher::clone_op	/usr/include/opencv2/features2d/features2d.hpp	/^    static Mat clone_op( Mat m ) { return m.clone(); }$/;"	f	class:cv::DescriptorMatcher	access:protected	signature:( Mat m )
cv::DescriptorMatcher::create	/usr/include/opencv2/features2d/features2d.hpp	/^    static Ptr<DescriptorMatcher> create( const string& descriptorMatcherType );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const string& descriptorMatcherType )
cv::DescriptorMatcher::empty	/usr/include/opencv2/features2d/features2d.hpp	/^	bool empty() const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
cv::DescriptorMatcher::getTrainDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    const vector<Mat>& getTrainDescriptors() const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
cv::DescriptorMatcher::isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported() const = 0;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
cv::DescriptorMatcher::isMaskedOut	/usr/include/opencv2/features2d/features2d.hpp	/^    static bool isMaskedOut( const vector<Mat>& masks, int queryIdx );$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const vector<Mat>& masks, int queryIdx )
cv::DescriptorMatcher::isPossibleMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    static bool isPossibleMatch( const Mat& mask, int queryIdx, int trainIdx );$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& mask, int queryIdx, int trainIdx )
cv::DescriptorMatcher::knnMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void knnMatch( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<vector<DMatch> >& matches, int k, const Mat& mask=Mat(), bool compactResult=false ) const
cv::DescriptorMatcher::knnMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void knnMatch( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::DescriptorMatcher::knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::DescriptorMatcher::match	/usr/include/opencv2/features2d/features2d.hpp	/^    void match( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<DMatch>& matches, const Mat& mask=Mat() ) const
cv::DescriptorMatcher::match	/usr/include/opencv2/features2d/features2d.hpp	/^    void match( const Mat& queryDescriptors, vector<DMatch>& matches,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<DMatch>& matches, const vector<Mat>& masks=vector<Mat>() )
cv::DescriptorMatcher::radiusMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const Mat& mask=Mat(), bool compactResult=false ) const
cv::DescriptorMatcher::radiusMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::DescriptorMatcher::radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::DescriptorMatcher::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const FileNode& )
cv::DescriptorMatcher::train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
cv::DescriptorMatcher::trainDescCollection	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<Mat> trainDescCollection;$/;"	m	class:cv::DescriptorMatcher	access:protected
cv::DescriptorMatcher::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( FileStorage& ) const
cv::DescriptorMatcher::~DescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~DescriptorMatcher();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
cv::DrawMatchesFlags	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS DrawMatchesFlags$/;"	s	namespace:cv
cv::DrawMatchesFlags::DEFAULT	/usr/include/opencv2/features2d/features2d.hpp	/^    enum{ DEFAULT = 0, \/\/ Output image matrix will be created (Mat::create),$/;"	e	enum:cv::DrawMatchesFlags::__anon75
cv::DrawMatchesFlags::DRAW_OVER_OUTIMG	/usr/include/opencv2/features2d/features2d.hpp	/^          DRAW_OVER_OUTIMG = 1, \/\/ Output image matrix will not be created (Mat::create).$/;"	e	enum:cv::DrawMatchesFlags::__anon75
cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS	/usr/include/opencv2/features2d/features2d.hpp	/^          DRAW_RICH_KEYPOINTS = 4 \/\/ For each keypoint the circle around keypoint with keypoint size and$/;"	e	enum:cv::DrawMatchesFlags::__anon75
cv::DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS	/usr/include/opencv2/features2d/features2d.hpp	/^          NOT_DRAW_SINGLE_POINTS = 2, \/\/ Single keypoints will not be drawn.$/;"	e	enum:cv::DrawMatchesFlags::__anon75
cv::DynamicAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS DynamicAdaptedFeatureDetector: public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::DynamicAdaptedFeatureDetector::DynamicAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    DynamicAdaptedFeatureDetector( const Ptr<AdjusterAdapter>& adjaster, int min_features=400, int max_features=500, int max_iters=5 );$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:public	signature:( const Ptr<AdjusterAdapter>& adjaster, int min_features=400, int max_features=500, int max_iters=5 )
cv::DynamicAdaptedFeatureDetector::adjuster_	/usr/include/opencv2/features2d/features2d.hpp	/^	Ptr<AdjusterAdapter> adjuster_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
cv::DynamicAdaptedFeatureDetector::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::DynamicAdaptedFeatureDetector::escape_iters_	/usr/include/opencv2/features2d/features2d.hpp	/^	int escape_iters_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
cv::DynamicAdaptedFeatureDetector::max_features_	/usr/include/opencv2/features2d/features2d.hpp	/^	int min_features_, max_features_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
cv::DynamicAdaptedFeatureDetector::min_features_	/usr/include/opencv2/features2d/features2d.hpp	/^	int min_features_, max_features_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
cv::EMParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvEMParams EMParams;$/;"	t	namespace:cv
cv::ERTree	/usr/include/opencv2/ml/ml.hpp	/^typedef CvForestERTree ERTree;$/;"	t	namespace:cv
cv::ERTreeTRainData	/usr/include/opencv2/ml/ml.hpp	/^typedef CvERTreeTrainData ERTreeTRainData;$/;"	t	namespace:cv
cv::ERTrees	/usr/include/opencv2/ml/ml.hpp	/^typedef CvERTrees ERTrees;$/;"	t	namespace:cv
cv::ErrorCallback	/usr/include/opencv2/core/core.hpp	/^typedef int (CV_CDECL *ErrorCallback)( int status, const char* func_name,$/;"	t	namespace:cv
cv::Exception	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS Exception : public std::exception$/;"	c	namespace:cv	inherits:std::exception
cv::Exception::Exception	/usr/include/opencv2/core/core.hpp	/^	Exception(int _code, const string& _err, const string& _func, const string& _file, int _line)$/;"	f	class:cv::Exception	access:public	signature:(int _code, const string& _err, const string& _func, const string& _file, int _line)
cv::Exception::Exception	/usr/include/opencv2/core/core.hpp	/^    Exception() { code = 0; line = 0; }$/;"	f	class:cv::Exception	access:public	signature:()
cv::Exception::code	/usr/include/opencv2/core/core.hpp	/^	int code; \/\/\/< error code @see CVStatus$/;"	m	class:cv::Exception	access:public
cv::Exception::err	/usr/include/opencv2/core/core.hpp	/^	string err; \/\/\/< error description$/;"	m	class:cv::Exception	access:public
cv::Exception::file	/usr/include/opencv2/core/core.hpp	/^	string file; \/\/\/< source file name where the error has occured$/;"	m	class:cv::Exception	access:public
cv::Exception::formatMessage	/usr/include/opencv2/core/core.hpp	/^    void formatMessage()$/;"	f	class:cv::Exception	access:public	signature:()
cv::Exception::func	/usr/include/opencv2/core/core.hpp	/^	string func; \/\/\/< function name. Available only when the compiler supports __func__ macro$/;"	m	class:cv::Exception	access:public
cv::Exception::line	/usr/include/opencv2/core/core.hpp	/^	int line; \/\/\/< line number in the source file where the error has occured $/;"	m	class:cv::Exception	access:public
cv::Exception::msg	/usr/include/opencv2/core/core.hpp	/^	string msg; \/\/\/< the formatted error message$/;"	m	class:cv::Exception	access:public
cv::Exception::what	/usr/include/opencv2/core/core.hpp	/^	virtual const char *what() const throw() { return msg.c_str(); }$/;"	f	class:cv::Exception	access:public	signature:() const
cv::Exception::~Exception	/usr/include/opencv2/core/core.hpp	/^	virtual ~Exception() throw() {}$/;"	f	class:cv::Exception	access:public	signature:()
cv::ExpectationMaximization	/usr/include/opencv2/ml/ml.hpp	/^typedef CvEM ExpectationMaximization;$/;"	t	namespace:cv
cv::FAST	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void FAST( const Mat& image, CV_OUT vector<KeyPoint>& keypoints,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int threshold, bool nonmaxSupression=true )
cv::FLOODFILL_FIXED_RANGE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { FLOODFILL_FIXED_RANGE = 1 << 16,$/;"	e	enum:cv::__anon48
cv::FLOODFILL_MASK_ONLY	/usr/include/opencv2/imgproc/imgproc.hpp	/^       FLOODFILL_MASK_ONLY = 1 << 17 };$/;"	e	enum:cv::__anon48
cv::FM_7POINT	/usr/include/opencv2/calib3d/calib3d.hpp	/^    FM_7POINT = CV_FM_7POINT, \/\/!< 7-point algorithm$/;"	e	enum:cv::__anon70
cv::FM_8POINT	/usr/include/opencv2/calib3d/calib3d.hpp	/^    FM_8POINT = CV_FM_8POINT, \/\/!< 8-point algorithm$/;"	e	enum:cv::__anon70
cv::FM_LMEDS	/usr/include/opencv2/calib3d/calib3d.hpp	/^    FM_LMEDS = CV_FM_LMEDS,  \/\/!< least-median algorithm$/;"	e	enum:cv::__anon70
cv::FM_RANSAC	/usr/include/opencv2/calib3d/calib3d.hpp	/^    FM_RANSAC = CV_FM_RANSAC  \/\/!< RANSAC algorithm$/;"	e	enum:cv::__anon70
cv::FONT_HERSHEY_COMPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_COMPLEX = 3,$/;"	e	enum:cv::__anon147
cv::FONT_HERSHEY_COMPLEX_SMALL	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_COMPLEX_SMALL = 5,$/;"	e	enum:cv::__anon147
cv::FONT_HERSHEY_DUPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_DUPLEX = 2,$/;"	e	enum:cv::__anon147
cv::FONT_HERSHEY_PLAIN	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_PLAIN = 1,$/;"	e	enum:cv::__anon147
cv::FONT_HERSHEY_SCRIPT_COMPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_SCRIPT_COMPLEX = 7,$/;"	e	enum:cv::__anon147
cv::FONT_HERSHEY_SCRIPT_SIMPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_SCRIPT_SIMPLEX = 6,$/;"	e	enum:cv::__anon147
cv::FONT_HERSHEY_SIMPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_SIMPLEX = 0,$/;"	e	enum:cv::__anon147
cv::FONT_HERSHEY_TRIPLEX	/usr/include/opencv2/core/core.hpp	/^    FONT_HERSHEY_TRIPLEX = 4,$/;"	e	enum:cv::__anon147
cv::FONT_ITALIC	/usr/include/opencv2/core/core.hpp	/^    FONT_ITALIC = 16$/;"	e	enum:cv::__anon147
cv::FastAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FastAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
cv::FastAdjuster::FastAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^	FastAdjuster(int init_thresh = 20, bool nonmax = true);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int init_thresh = 20, bool nonmax = true)
cv::FastAdjuster::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FastAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::FastAdjuster::good	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual bool good() const;$/;"	p	class:cv::FastAdjuster	access:public	signature:() const
cv::FastAdjuster::nonmax_	/usr/include/opencv2/features2d/features2d.hpp	/^	bool nonmax_;$/;"	m	class:cv::FastAdjuster	access:protected
cv::FastAdjuster::thresh_	/usr/include/opencv2/features2d/features2d.hpp	/^	int thresh_;$/;"	m	class:cv::FastAdjuster	access:protected
cv::FastAdjuster::tooFew	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int min, int n_detected)
cv::FastAdjuster::tooMany	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int max, int n_detected)
cv::FastFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FastFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::FastFeatureDetector::FastFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    FastFeatureDetector( int threshold=10, bool nonmaxSuppression=true );$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( int threshold=10, bool nonmaxSuppression=true )
cv::FastFeatureDetector::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FastFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::FastFeatureDetector::nonmaxSuppression	/usr/include/opencv2/features2d/features2d.hpp	/^    bool nonmaxSuppression;$/;"	m	class:cv::FastFeatureDetector	access:protected
cv::FastFeatureDetector::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( const FileNode& fn )
cv::FastFeatureDetector::threshold	/usr/include/opencv2/features2d/features2d.hpp	/^    int threshold;$/;"	m	class:cv::FastFeatureDetector	access:protected
cv::FastFeatureDetector::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( FileStorage& fs ) const
cv::FeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FeatureDetector$/;"	c	namespace:cv
cv::FeatureDetector::create	/usr/include/opencv2/features2d/features2d.hpp	/^    static Ptr<FeatureDetector> create( const string& detectorType );$/;"	p	class:cv::FeatureDetector	access:public	signature:( const string& detectorType )
cv::FeatureDetector::detect	/usr/include/opencv2/features2d/features2d.hpp	/^    void detect( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::FeatureDetector::detect	/usr/include/opencv2/features2d/features2d.hpp	/^    void detect( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const vector<Mat>& masks=vector<Mat>() ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const vector<Mat>& masks=vector<Mat>() ) const
cv::FeatureDetector::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const = 0;$/;"	p	class:cv::FeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::FeatureDetector::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::FeatureDetector	access:public	signature:( const FileNode& )
cv::FeatureDetector::removeInvalidPoints	/usr/include/opencv2/features2d/features2d.hpp	/^    static void removeInvalidPoints( const Mat& mask, vector<KeyPoint>& keypoints );$/;"	p	class:cv::FeatureDetector	access:protected	signature:( const Mat& mask, vector<KeyPoint>& keypoints )
cv::FeatureDetector::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( FileStorage& ) const
cv::FeatureDetector::~FeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~FeatureDetector();$/;"	p	class:cv::FeatureDetector	access:public	signature:()
cv::FeatureEvaluator	/usr/include/opencv2/objdetect/objdetect.hpp	/^class CV_EXPORTS FeatureEvaluator$/;"	c	namespace:cv
cv::FeatureEvaluator::HAAR	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { HAAR = 0, LBP = 1 };$/;"	e	enum:cv::FeatureEvaluator::__anon61
cv::FeatureEvaluator::LBP	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { HAAR = 0, LBP = 1 };$/;"	e	enum:cv::FeatureEvaluator::__anon61
cv::FeatureEvaluator::calcCat	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual int calcCat(int featureIdx) const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int featureIdx) const
cv::FeatureEvaluator::calcOrd	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual double calcOrd(int featureIdx) const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int featureIdx) const
cv::FeatureEvaluator::clone	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual Ptr<FeatureEvaluator> clone() const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:() const
cv::FeatureEvaluator::create	/usr/include/opencv2/objdetect/objdetect.hpp	/^    static Ptr<FeatureEvaluator> create(int type);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int type)
cv::FeatureEvaluator::getFeatureType	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual int getFeatureType() const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:() const
cv::FeatureEvaluator::read	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual bool read(const FileNode& node);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(const FileNode& node)
cv::FeatureEvaluator::setImage	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual bool setImage(const Mat&, Size origWinSize);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(const Mat&, Size origWinSize)
cv::FeatureEvaluator::setWindow	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual bool setWindow(Point p);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(Point p)
cv::FeatureEvaluator::~FeatureEvaluator	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual ~FeatureEvaluator();$/;"	p	class:cv::FeatureEvaluator	access:public	signature:()
cv::FernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FernClassifier$/;"	c	namespace:cv
cv::FernClassifier::COMPRESSION_NONE	/usr/include/opencv2/features2d/features2d.hpp	/^        COMPRESSION_NONE = 0,$/;"	e	enum:cv::FernClassifier::__anon74
cv::FernClassifier::COMPRESSION_PCA	/usr/include/opencv2/features2d/features2d.hpp	/^        COMPRESSION_PCA = 2,$/;"	e	enum:cv::FernClassifier::__anon74
cv::FernClassifier::COMPRESSION_RANDOM_PROJ	/usr/include/opencv2/features2d/features2d.hpp	/^        COMPRESSION_RANDOM_PROJ = 1,$/;"	e	enum:cv::FernClassifier::__anon74
cv::FernClassifier::DEFAULT_COMPRESSION_METHOD	/usr/include/opencv2/features2d/features2d.hpp	/^        DEFAULT_COMPRESSION_METHOD = COMPRESSION_NONE$/;"	e	enum:cv::FernClassifier::__anon74
cv::FernClassifier::DEFAULT_SIGNATURE_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^        DEFAULT_SIGNATURE_SIZE = 176,$/;"	e	enum:cv::FernClassifier::__anon74
cv::FernClassifier::DEFAULT_STRUCTS	/usr/include/opencv2/features2d/features2d.hpp	/^        DEFAULT_STRUCTS = 50,$/;"	e	enum:cv::FernClassifier::__anon74
cv::FernClassifier::DEFAULT_STRUCT_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^        DEFAULT_STRUCT_SIZE = 9,$/;"	e	enum:cv::FernClassifier::__anon74
cv::FernClassifier::DEFAULT_VIEWS	/usr/include/opencv2/features2d/features2d.hpp	/^        DEFAULT_VIEWS = 5000,$/;"	e	enum:cv::FernClassifier::__anon74
cv::FernClassifier::Feature	/usr/include/opencv2/features2d/features2d.hpp	/^    struct Feature$/;"	s	class:cv::FernClassifier	access:public
cv::FernClassifier::Feature::Feature	/usr/include/opencv2/features2d/features2d.hpp	/^        Feature() : x1(0), y1(0), x2(0), y2(0) {}$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:()
cv::FernClassifier::Feature::Feature	/usr/include/opencv2/features2d/features2d.hpp	/^        Feature(int _x1, int _y1, int _x2, int _y2)$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:(int _x1, int _y1, int _x2, int _y2)
cv::FernClassifier::Feature::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^        template<typename _Tp> bool operator ()(const Mat_<_Tp>& patch) const$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:(const Mat_<_Tp>& patch) const
cv::FernClassifier::Feature::x1	/usr/include/opencv2/features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
cv::FernClassifier::Feature::x2	/usr/include/opencv2/features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
cv::FernClassifier::Feature::y1	/usr/include/opencv2/features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
cv::FernClassifier::Feature::y2	/usr/include/opencv2/features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
cv::FernClassifier::FernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    FernClassifier();$/;"	p	class:cv::FernClassifier	access:public	signature:()
cv::FernClassifier::FernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    FernClassifier(const FileNode& node);$/;"	p	class:cv::FernClassifier	access:public	signature:(const FileNode& node)
cv::FernClassifier::FernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    FernClassifier(const vector<vector<Point2f> >& points,$/;"	p	class:cv::FernClassifier	access:public	signature:(const vector<vector<Point2f> >& points, const vector<Mat>& refimgs, const vector<vector<int> >& labels=vector<vector<int> >(), int _nclasses=0, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
cv::FernClassifier::PATCH_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^        PATCH_SIZE = 31,$/;"	e	enum:cv::FernClassifier::__anon74
cv::FernClassifier::classCounters	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<int> classCounters;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FernClassifier	access:public	signature:()
cv::FernClassifier::compressionMethod	/usr/include/opencv2/features2d/features2d.hpp	/^    int compressionMethod;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::features	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<Feature> features;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::finalize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void finalize(RNG& rng);$/;"	p	class:cv::FernClassifier	access:protected	signature:(RNG& rng)
cv::FernClassifier::getClassCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int getClassCount() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::getCompressionMethod	/usr/include/opencv2/features2d/features2d.hpp	/^    int getCompressionMethod() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::getLeaf	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int getLeaf(int fidx, const Mat& patch) const;$/;"	p	class:cv::FernClassifier	access:protected	signature:(int fidx, const Mat& patch) const
cv::FernClassifier::getPatchSize	/usr/include/opencv2/features2d/features2d.hpp	/^    Size getPatchSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::getSignatureSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int getSignatureSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::getStructCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int getStructCount() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::getStructSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int getStructSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::leavesPerStruct	/usr/include/opencv2/features2d/features2d.hpp	/^    int leavesPerStruct;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::nclasses	/usr/include/opencv2/features2d/features2d.hpp	/^    int nclasses;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::nstructs	/usr/include/opencv2/features2d/features2d.hpp	/^    int nstructs;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int operator()(const Mat& img, Point2f kpt, vector<float>& signature) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& img, Point2f kpt, vector<float>& signature) const
cv::FernClassifier::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int operator()(const Mat& patch, vector<float>& signature) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& patch, vector<float>& signature) const
cv::FernClassifier::patchSize	/usr/include/opencv2/features2d/features2d.hpp	/^    Size patchSize;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::posteriors	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<float> posteriors;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::prepare	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void prepare(int _nclasses, int _patchSize, int _signatureSize,$/;"	p	class:cv::FernClassifier	access:protected	signature:(int _nclasses, int _patchSize, int _signatureSize, int _nstructs, int _structSize, int _nviews, int _compressionMethod)
cv::FernClassifier::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read(const FileNode& n);$/;"	p	class:cv::FernClassifier	access:public	signature:(const FileNode& n)
cv::FernClassifier::setVerbose	/usr/include/opencv2/features2d/features2d.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::FernClassifier	access:public	signature:(bool verbose)
cv::FernClassifier::signatureSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int signatureSize;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::structSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int structSize;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train(const vector<vector<Point2f> >& points,$/;"	p	class:cv::FernClassifier	access:public	signature:(const vector<vector<Point2f> >& points, const vector<Mat>& refimgs, const vector<vector<int> >& labels=vector<vector<int> >(), int _nclasses=0, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
cv::FernClassifier::trainFromSingleView	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void trainFromSingleView(const Mat& image,$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& image, const vector<KeyPoint>& keypoints, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
cv::FernClassifier::verbose	/usr/include/opencv2/features2d/features2d.hpp	/^    bool verbose;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(FileStorage& fs, const String& name=String()) const
cv::FernClassifier::~FernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~FernClassifier();$/;"	p	class:cv::FernClassifier	access:public	signature:()
cv::FernDescriptorMatch	/usr/include/opencv2/features2d/features2d.hpp	/^typedef FernDescriptorMatcher FernDescriptorMatch;$/;"	t	namespace:cv
cv::FernDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FernDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
cv::FernDescriptorMatcher::FernDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    FernDescriptorMatcher( const Params& params=Params() );$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( const Params& params=Params() )
cv::FernDescriptorMatcher::Params	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::FernDescriptorMatcher	access:public
cv::FernDescriptorMatcher::Params::Params	/usr/include/opencv2/features2d/features2d.hpp	/^        Params( const string& filename );$/;"	p	class:cv::FernDescriptorMatcher::Params	access:public	signature:( const string& filename )
cv::FernDescriptorMatcher::Params::Params	/usr/include/opencv2/features2d/features2d.hpp	/^        Params( int nclasses=0,$/;"	p	class:cv::FernDescriptorMatcher::Params	access:public	signature:( int nclasses=0, int patchSize=FernClassifier::PATCH_SIZE, int signatureSize=FernClassifier::DEFAULT_SIGNATURE_SIZE, int nstructs=FernClassifier::DEFAULT_STRUCTS, int structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int nviews=FernClassifier::DEFAULT_VIEWS, int compressionMethod=FernClassifier::COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator() )
cv::FernDescriptorMatcher::Params::compressionMethod	/usr/include/opencv2/features2d/features2d.hpp	/^        int compressionMethod;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::filename	/usr/include/opencv2/features2d/features2d.hpp	/^        string filename;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::nclasses	/usr/include/opencv2/features2d/features2d.hpp	/^        int nclasses;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::nstructs	/usr/include/opencv2/features2d/features2d.hpp	/^        int nstructs;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::nviews	/usr/include/opencv2/features2d/features2d.hpp	/^        int nviews;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::patchGenerator	/usr/include/opencv2/features2d/features2d.hpp	/^        PatchGenerator patchGenerator;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::patchSize	/usr/include/opencv2/features2d/features2d.hpp	/^        int patchSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::signatureSize	/usr/include/opencv2/features2d/features2d.hpp	/^        int signatureSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::structSize	/usr/include/opencv2/features2d/features2d.hpp	/^        int structSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::calcBestProbAndMatchIdx	/usr/include/opencv2/features2d/features2d.hpp	/^    void calcBestProbAndMatchIdx( const Mat& image, const Point2f& pt,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& image, const Point2f& pt, float& bestProb, int& bestMatchIdx, vector<float>& signature )
cv::FernDescriptorMatcher::classifier	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<FernClassifier> classifier;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
cv::FernDescriptorMatcher::clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
cv::FernDescriptorMatcher::clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::FernDescriptorMatcher::isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
cv::FernDescriptorMatcher::knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::FernDescriptorMatcher::params	/usr/include/opencv2/features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
cv::FernDescriptorMatcher::prevTrainCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int prevTrainCount;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
cv::FernDescriptorMatcher::radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::FernDescriptorMatcher::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( const FileNode &fn )
cv::FernDescriptorMatcher::train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
cv::FernDescriptorMatcher::trainFernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    void trainFernClassifier();$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:()
cv::FernDescriptorMatcher::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
cv::FernDescriptorMatcher::~FernDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~FernDescriptorMatcher();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
cv::FileNode	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS FileNode;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::FileNode	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS_W_SIMPLE FileNode$/;"	c	namespace:cv
cv::FileNode::EMPTY	/usr/include/opencv2/core/core.hpp	/^        EMPTY=32, \/\/!< empty structure (sequence or mapping)$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::FLOAT	/usr/include/opencv2/core/core.hpp	/^        FLOAT=REAL, \/\/!< synonym or REAL$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::FLOW	/usr/include/opencv2/core/core.hpp	/^        FLOW=8, \/\/!< compact representation of a sequence or mapping. Used only by YAML writer$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::FileNode	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode();$/;"	p	class:cv::FileNode	access:public	signature:()
cv::FileNode::FileNode	/usr/include/opencv2/core/core.hpp	/^    FileNode(const CvFileStorage* fs, const CvFileNode* node);$/;"	p	class:cv::FileNode	access:public	signature:(const CvFileStorage* fs, const CvFileNode* node)
cv::FileNode::FileNode	/usr/include/opencv2/core/core.hpp	/^    FileNode(const FileNode& node);$/;"	p	class:cv::FileNode	access:public	signature:(const FileNode& node)
cv::FileNode::FileNode	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::FileNode() : fs(0), node(0) {}$/;"	f	class:cv::FileNode	signature:()
cv::FileNode::FileNode	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::FileNode(const CvFileStorage* _fs, const CvFileNode* _node)$/;"	f	class:cv::FileNode	signature:(const CvFileStorage* _fs, const CvFileNode* _node)
cv::FileNode::FileNode	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::FileNode(const FileNode& _node) : fs(_node.fs), node(_node.node) {}$/;"	f	class:cv::FileNode	signature:(const FileNode& _node)
cv::FileNode::INT	/usr/include/opencv2/core/core.hpp	/^        INT=1, \/\/!< an integer$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::MAP	/usr/include/opencv2/core/core.hpp	/^        MAP=6, \/\/!< mapping$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::NAMED	/usr/include/opencv2/core/core.hpp	/^        NAMED=64 \/\/!< the node has a name (i.e. it is element of a mapping)$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::NONE	/usr/include/opencv2/core/core.hpp	/^        NONE=0, \/\/!< empty node$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::REAL	/usr/include/opencv2/core/core.hpp	/^        REAL=2, \/\/!< floating-point number$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::REF	/usr/include/opencv2/core/core.hpp	/^        REF=4, \/\/!< integer of size size_t. Typically used for storing complex dynamic structures where some elements reference the others $/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::SEQ	/usr/include/opencv2/core/core.hpp	/^        SEQ=5, \/\/!< sequence$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::STR	/usr/include/opencv2/core/core.hpp	/^        STR=3, \/\/!< text string in UTF-8 encoding$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::STRING	/usr/include/opencv2/core/core.hpp	/^        STRING=STR, \/\/!< synonym for STR$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::TYPE_MASK	/usr/include/opencv2/core/core.hpp	/^        TYPE_MASK=7,$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::USER	/usr/include/opencv2/core/core.hpp	/^        USER=16, \/\/!< a registered object (e.g. a matrix)$/;"	e	enum:cv::FileNode::__anon151
cv::FileNode::begin	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator begin() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::begin	/usr/include/opencv2/core/operations.hpp	/^inline FileNodeIterator FileNode::begin() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::empty	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool empty() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::empty	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::empty() const { return node == 0; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::end	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator end() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::end	/usr/include/opencv2/core/operations.hpp	/^inline FileNodeIterator FileNode::end() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::fs	/usr/include/opencv2/core/core.hpp	/^    const CvFileStorage* fs;$/;"	m	class:cv::FileNode	access:public
cv::FileNode::isInt	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isInt() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isInt	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isInt() const { return type() == INT; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isMap	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isMap() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isMap	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isMap() const { return type() == MAP; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isNamed	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isNamed() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isNamed	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isNamed() const { return !node ? false : (node->tag & NAMED) != 0; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isNone	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isNone() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isNone	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isNone() const { return type() == NONE; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isReal	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isReal() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isReal	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isReal() const { return type() == REAL; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isSeq	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isSeq() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isSeq	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isSeq() const { return type() == SEQ; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isString	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isString() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isString	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isString() const { return type() == STR; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::name	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP string name() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::node	/usr/include/opencv2/core/core.hpp	/^    const CvFileNode* node;$/;"	m	class:cv::FileNode	access:public
cv::FileNode::operator *	/usr/include/opencv2/core/core.hpp	/^    CvFileNode* operator *();$/;"	p	class:cv::FileNode	access:public	signature:()
cv::FileNode::operator *	/usr/include/opencv2/core/core.hpp	/^    const CvFileNode* operator* () const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::operator *	/usr/include/opencv2/core/operations.hpp	/^inline CvFileNode* FileNode::operator *() { return (CvFileNode*)node; }$/;"	f	class:cv::FileNode	signature:()
cv::FileNode::operator *	/usr/include/opencv2/core/operations.hpp	/^inline const CvFileNode* FileNode::operator* () const { return node; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::operator []	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode operator[](const char* nodename) const;$/;"	p	class:cv::FileNode	access:public	signature:(const char* nodename) const
cv::FileNode::operator []	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode operator[](int i) const;$/;"	p	class:cv::FileNode	access:public	signature:(int i) const
cv::FileNode::operator []	/usr/include/opencv2/core/core.hpp	/^    FileNode operator[](const string& nodename) const;$/;"	p	class:cv::FileNode	access:public	signature:(const string& nodename) const
cv::FileNode::operator double	/usr/include/opencv2/core/core.hpp	/^    operator double() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::operator double	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::operator double() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::operator float	/usr/include/opencv2/core/core.hpp	/^    operator float() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::operator float	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::operator float() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::operator int	/usr/include/opencv2/core/core.hpp	/^    operator int() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::operator int	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::operator int() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::operator string	/usr/include/opencv2/core/core.hpp	/^    operator string() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::operator string	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::operator string() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::readObj	/usr/include/opencv2/core/core.hpp	/^    void* readObj() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::readRaw	/usr/include/opencv2/core/core.hpp	/^    void readRaw( const string& fmt, uchar* vec, size_t len ) const;$/;"	p	class:cv::FileNode	access:public	signature:( const string& fmt, uchar* vec, size_t len ) const
cv::FileNode::readRaw	/usr/include/opencv2/core/operations.hpp	/^inline void FileNode::readRaw( const string& fmt, uchar* vec, size_t len ) const$/;"	f	class:cv::FileNode	signature:( const string& fmt, uchar* vec, size_t len ) const
cv::FileNode::size	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP size_t size() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::size	/usr/include/opencv2/core/operations.hpp	/^inline size_t FileNode::size() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::type	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP int type() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::type	/usr/include/opencv2/core/operations.hpp	/^inline int FileNode::type() const { return !node ? NONE : (node->tag & TYPE_MASK); }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNodeIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS FileNodeIterator$/;"	c	namespace:cv
cv::FileNodeIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS FileNodeIterator;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::FileNodeIterator::FileNodeIterator	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
cv::FileNodeIterator::FileNodeIterator	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator(const CvFileStorage* fs, const CvFileNode* node, size_t ofs=0);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(const CvFileStorage* fs, const CvFileNode* node, size_t ofs=0)
cv::FileNodeIterator::FileNodeIterator	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator(const FileNodeIterator& it);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(const FileNodeIterator& it)
cv::FileNodeIterator::container	/usr/include/opencv2/core/core.hpp	/^    const CvFileNode* container;$/;"	m	class:cv::FileNodeIterator	access:public
cv::FileNodeIterator::fs	/usr/include/opencv2/core/core.hpp	/^    const CvFileStorage* fs;$/;"	m	class:cv::FileNodeIterator	access:public
cv::FileNodeIterator::operator *	/usr/include/opencv2/core/core.hpp	/^    FileNode operator *() const;$/;"	p	class:cv::FileNodeIterator	access:public	signature:() const
cv::FileNodeIterator::operator *	/usr/include/opencv2/core/operations.hpp	/^inline FileNode FileNodeIterator::operator *() const$/;"	f	class:cv::FileNodeIterator	signature:() const
cv::FileNodeIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator operator ++ (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
cv::FileNodeIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator& operator ++ ();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
cv::FileNodeIterator::operator +=	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator& operator += (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
cv::FileNodeIterator::operator --	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator operator -- (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
cv::FileNodeIterator::operator --	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator& operator -- ();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
cv::FileNodeIterator::operator -=	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator& operator -= (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
cv::FileNodeIterator::operator ->	/usr/include/opencv2/core/core.hpp	/^    FileNode operator ->() const;$/;"	p	class:cv::FileNodeIterator	access:public	signature:() const
cv::FileNodeIterator::operator ->	/usr/include/opencv2/core/operations.hpp	/^inline FileNode FileNodeIterator::operator ->() const$/;"	f	class:cv::FileNodeIterator	signature:() const
cv::FileNodeIterator::readRaw	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator& readRaw( const string& fmt, uchar* vec,$/;"	p	class:cv::FileNodeIterator	access:public	signature:( const string& fmt, uchar* vec, size_t maxCount=(size_t)INT_MAX )
cv::FileNodeIterator::reader	/usr/include/opencv2/core/core.hpp	/^    CvSeqReader reader;$/;"	m	class:cv::FileNodeIterator	access:public
cv::FileNodeIterator::remaining	/usr/include/opencv2/core/core.hpp	/^    size_t remaining;$/;"	m	class:cv::FileNodeIterator	access:public
cv::FileStorage	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS_W FileStorage$/;"	c	namespace:cv
cv::FileStorage::APPEND	/usr/include/opencv2/core/core.hpp	/^        APPEND=2 \/\/! append mode$/;"	e	enum:cv::FileStorage::__anon149
cv::FileStorage::FileStorage	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileStorage();$/;"	p	class:cv::FileStorage	access:public	signature:()
cv::FileStorage::FileStorage	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileStorage(const string& filename, int flags);$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename, int flags)
cv::FileStorage::FileStorage	/usr/include/opencv2/core/core.hpp	/^    FileStorage(CvFileStorage* fs);$/;"	p	class:cv::FileStorage	access:public	signature:(CvFileStorage* fs)
cv::FileStorage::INSIDE_MAP	/usr/include/opencv2/core/core.hpp	/^        INSIDE_MAP=4$/;"	e	enum:cv::FileStorage::__anon150
cv::FileStorage::NAME_EXPECTED	/usr/include/opencv2/core/core.hpp	/^        NAME_EXPECTED=2,$/;"	e	enum:cv::FileStorage::__anon150
cv::FileStorage::READ	/usr/include/opencv2/core/core.hpp	/^        READ=0, \/\/! read mode$/;"	e	enum:cv::FileStorage::__anon149
cv::FileStorage::UNDEFINED	/usr/include/opencv2/core/core.hpp	/^        UNDEFINED=0, $/;"	e	enum:cv::FileStorage::__anon150
cv::FileStorage::VALUE_EXPECTED	/usr/include/opencv2/core/core.hpp	/^        VALUE_EXPECTED=1,$/;"	e	enum:cv::FileStorage::__anon150
cv::FileStorage::WRITE	/usr/include/opencv2/core/core.hpp	/^        WRITE=1, \/\/! write mode$/;"	e	enum:cv::FileStorage::__anon149
cv::FileStorage::elname	/usr/include/opencv2/core/core.hpp	/^    string elname; \/\/!< the currently written element$/;"	m	class:cv::FileStorage	access:public
cv::FileStorage::fs	/usr/include/opencv2/core/core.hpp	/^    Ptr<CvFileStorage> fs; \/\/!< the underlying C FileStorage structure$/;"	m	class:cv::FileStorage	access:public
cv::FileStorage::getDefaultObjectName	/usr/include/opencv2/core/core.hpp	/^    static string getDefaultObjectName(const string& filename);$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename)
cv::FileStorage::getFirstTopLevelNode	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode getFirstTopLevelNode() const;$/;"	p	class:cv::FileStorage	access:public	signature:() const
cv::FileStorage::getFirstTopLevelNode	/usr/include/opencv2/core/operations.hpp	/^inline FileNode FileStorage::getFirstTopLevelNode() const$/;"	f	class:cv::FileStorage	signature:() const
cv::FileStorage::isOpened	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::FileStorage	access:public	signature:() const
cv::FileStorage::open	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP virtual bool open(const string& filename, int flags);$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename, int flags)
cv::FileStorage::operator *	/usr/include/opencv2/core/core.hpp	/^    CvFileStorage* operator *() { return fs; }$/;"	f	class:cv::FileStorage	access:public	signature:()
cv::FileStorage::operator *	/usr/include/opencv2/core/core.hpp	/^    const CvFileStorage* operator *() const { return fs; }$/;"	f	class:cv::FileStorage	access:public	signature:() const
cv::FileStorage::operator []	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode operator[](const char* nodename) const;$/;"	p	class:cv::FileStorage	access:public	signature:(const char* nodename) const
cv::FileStorage::operator []	/usr/include/opencv2/core/core.hpp	/^    FileNode operator[](const string& nodename) const;$/;"	p	class:cv::FileStorage	access:public	signature:(const string& nodename) const
cv::FileStorage::release	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP virtual void release();$/;"	p	class:cv::FileStorage	access:public	signature:()
cv::FileStorage::root	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode root(int streamidx=0) const;$/;"	p	class:cv::FileStorage	access:public	signature:(int streamidx=0) const
cv::FileStorage::state	/usr/include/opencv2/core/core.hpp	/^    int state; \/\/!< the writer state$/;"	m	class:cv::FileStorage	access:public
cv::FileStorage::structs	/usr/include/opencv2/core/core.hpp	/^    vector<char> structs; \/\/!< the stack of written structures$/;"	m	class:cv::FileStorage	access:public
cv::FileStorage::writeObj	/usr/include/opencv2/core/core.hpp	/^    void writeObj( const string& name, const void* obj );$/;"	p	class:cv::FileStorage	access:public	signature:( const string& name, const void* obj )
cv::FileStorage::writeRaw	/usr/include/opencv2/core/core.hpp	/^    void writeRaw( const string& fmt, const uchar* vec, size_t len );$/;"	p	class:cv::FileStorage	access:public	signature:( const string& fmt, const uchar* vec, size_t len )
cv::FileStorage::~FileStorage	/usr/include/opencv2/core/core.hpp	/^    virtual ~FileStorage();$/;"	p	class:cv::FileStorage	access:public	signature:()
cv::FilterEngine	/usr/include/opencv2/imgproc/imgproc.hpp	/^class CV_EXPORTS FilterEngine$/;"	c	namespace:cv
cv::FilterEngine::FilterEngine	/usr/include/opencv2/imgproc/imgproc.hpp	/^    FilterEngine();$/;"	p	class:cv::FilterEngine	access:public	signature:()
cv::FilterEngine::FilterEngine	/usr/include/opencv2/imgproc/imgproc.hpp	/^    FilterEngine(const Ptr<BaseFilter>& _filter2D,$/;"	p	class:cv::FilterEngine	access:public	signature:(const Ptr<BaseFilter>& _filter2D, const Ptr<BaseRowFilter>& _rowFilter, const Ptr<BaseColumnFilter>& _columnFilter, int srcType, int dstType, int bufType, int _rowBorderType=BORDER_REPLICATE, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
cv::FilterEngine::anchor	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Point anchor;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::apply	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void apply( const Mat& src, Mat& dst,$/;"	p	class:cv::FilterEngine	access:public	signature:( const Mat& src, Mat& dst, const Rect& srcRoi=Rect(0,0,-1,-1), Point dstOfs=Point(0,0), bool isolated=false)
cv::FilterEngine::borderElemSize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int borderElemSize;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::borderTab	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<int> borderTab;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::bufStep	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::bufType	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::columnBorderType	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int rowBorderType, columnBorderType;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::columnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Ptr<BaseColumnFilter> columnFilter;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::constBorderRow	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<uchar> constBorderRow;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::constBorderValue	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<uchar> constBorderValue;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::dstType	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::dstY	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::dx1	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int dx1, dx2;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::dx2	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int dx1, dx2;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::endY	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::filter2D	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Ptr<BaseFilter> filter2D;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::init	/usr/include/opencv2/imgproc/imgproc.hpp	/^    void init(const Ptr<BaseFilter>& _filter2D,$/;"	p	class:cv::FilterEngine	access:public	signature:(const Ptr<BaseFilter>& _filter2D, const Ptr<BaseRowFilter>& _rowFilter, const Ptr<BaseColumnFilter>& _columnFilter, int srcType, int dstType, int bufType, int _rowBorderType=BORDER_REPLICATE, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
cv::FilterEngine::isSeparable	/usr/include/opencv2/imgproc/imgproc.hpp	/^    bool isSeparable() const { return (const BaseFilter*)filter2D == 0; }$/;"	f	class:cv::FilterEngine	access:public	signature:() const
cv::FilterEngine::ksize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Size ksize;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::maxWidth	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int maxWidth;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::proceed	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual int proceed(const uchar* src, int srcStep, int srcCount,$/;"	p	class:cv::FilterEngine	access:public	signature:(const uchar* src, int srcStep, int srcCount, uchar* dst, int dstStep)
cv::FilterEngine::remainingInputRows	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int remainingInputRows() const;$/;"	p	class:cv::FilterEngine	access:public	signature:() const
cv::FilterEngine::remainingOutputRows	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int remainingOutputRows() const;$/;"	p	class:cv::FilterEngine	access:public	signature:() const
cv::FilterEngine::ringBuf	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<uchar> ringBuf;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::roi	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Rect roi;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::rowBorderType	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int rowBorderType, columnBorderType;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::rowCount	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::rowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Ptr<BaseRowFilter> rowFilter;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::rows	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<uchar*> rows;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::srcRow	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<uchar> srcRow;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::srcType	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::start	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual int start(Size wholeSize, Rect roi, int maxBufRows=-1);$/;"	p	class:cv::FilterEngine	access:public	signature:(Size wholeSize, Rect roi, int maxBufRows=-1)
cv::FilterEngine::start	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual int start(const Mat& src, const Rect& srcRoi=Rect(0,0,-1,-1),$/;"	p	class:cv::FilterEngine	access:public	signature:(const Mat& src, const Rect& srcRoi=Rect(0,0,-1,-1), bool isolated=false, int maxBufRows=-1)
cv::FilterEngine::startY	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::startY0	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::wholeSize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Size wholeSize;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::~FilterEngine	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual ~FilterEngine();$/;"	p	class:cv::FilterEngine	access:public	signature:()
cv::FlannBasedMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS FlannBasedMatcher : public DescriptorMatcher$/;"	c	namespace:cv	inherits:DescriptorMatcher
cv::FlannBasedMatcher::FlannBasedMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    FlannBasedMatcher( const Ptr<flann::IndexParams>& indexParams=new flann::KDTreeIndexParams(),$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( const Ptr<flann::IndexParams>& indexParams=new flann::KDTreeIndexParams(), const Ptr<flann::SearchParams>& searchParams=new flann::SearchParams() )
cv::FlannBasedMatcher::add	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& descriptors );$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( const vector<Mat>& descriptors )
cv::FlannBasedMatcher::addedDescCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int addedDescCount;$/;"	m	class:cv::FlannBasedMatcher	access:protected
cv::FlannBasedMatcher::clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:()
cv::FlannBasedMatcher::clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::FlannBasedMatcher::convertToDMatches	/usr/include/opencv2/features2d/features2d.hpp	/^    static void convertToDMatches( const DescriptorCollection& descriptors,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const DescriptorCollection& descriptors, const Mat& indices, const Mat& distances, vector<vector<DMatch> >& matches )
cv::FlannBasedMatcher::flannIndex	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<flann::Index> flannIndex;$/;"	m	class:cv::FlannBasedMatcher	access:protected
cv::FlannBasedMatcher::indexParams	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<flann::IndexParams> indexParams;$/;"	m	class:cv::FlannBasedMatcher	access:protected
cv::FlannBasedMatcher::isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported() const;$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:() const
cv::FlannBasedMatcher::knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::FlannBasedMatcher::mergedDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    DescriptorCollection mergedDescriptors;$/;"	m	class:cv::FlannBasedMatcher	access:protected
cv::FlannBasedMatcher::radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::FlannBasedMatcher::searchParams	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<flann::SearchParams> searchParams;$/;"	m	class:cv::FlannBasedMatcher	access:protected
cv::FlannBasedMatcher::train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:()
cv::ForestTree	/usr/include/opencv2/ml/ml.hpp	/^typedef CvForestTree ForestTree;$/;"	t	namespace:cv
cv::Formatted	/usr/include/opencv2/core/operations.hpp	/^struct CV_EXPORTS Formatted$/;"	s	namespace:cv
cv::Formatted::Formatted	/usr/include/opencv2/core/operations.hpp	/^    Formatted(const Mat& m, const Formatter* fmt,$/;"	p	struct:cv::Formatted	access:public	signature:(const Mat& m, const Formatter* fmt, const int* params=0)
cv::Formatted::Formatted	/usr/include/opencv2/core/operations.hpp	/^    Formatted(const Mat& m, const Formatter* fmt,$/;"	p	struct:cv::Formatted	access:public	signature:(const Mat& m, const Formatter* fmt, const vector<int>& params)
cv::Formatted::fmt	/usr/include/opencv2/core/operations.hpp	/^    const Formatter* fmt;$/;"	m	struct:cv::Formatted	access:public
cv::Formatted::mtx	/usr/include/opencv2/core/operations.hpp	/^    Mat mtx;$/;"	m	struct:cv::Formatted	access:public
cv::Formatted::params	/usr/include/opencv2/core/operations.hpp	/^    vector<int> params;$/;"	m	struct:cv::Formatted	access:public
cv::Formatter	/usr/include/opencv2/core/operations.hpp	/^class CV_EXPORTS Formatter$/;"	c	namespace:cv
cv::Formatter::get	/usr/include/opencv2/core/operations.hpp	/^    static const Formatter* get(const char* fmt="");$/;"	p	class:cv::Formatter	access:public	signature:(const char* fmt=)
cv::Formatter::setDefault	/usr/include/opencv2/core/operations.hpp	/^    static const Formatter* setDefault(const Formatter* fmt);$/;"	p	class:cv::Formatter	access:public	signature:(const Formatter* fmt)
cv::Formatter::write	/usr/include/opencv2/core/operations.hpp	/^    virtual void write(std::ostream& out, const Mat& m, const int* params=0, int nparams=0) const = 0;$/;"	p	class:cv::Formatter	access:public	signature:(std::ostream& out, const Mat& m, const int* params=0, int nparams=0) const
cv::Formatter::write	/usr/include/opencv2/core/operations.hpp	/^    virtual void write(std::ostream& out, const void* data, int nelems, int type,$/;"	p	class:cv::Formatter	access:public	signature:(std::ostream& out, const void* data, int nelems, int type, const int* params=0, int nparams=0) const
cv::Formatter::~Formatter	/usr/include/opencv2/core/operations.hpp	/^    virtual ~Formatter() {}$/;"	f	class:cv::Formatter	access:public	signature:()
cv::GC_BGD	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { GC_BGD    = 0,  \/\/!< background$/;"	e	enum:cv::__anon45
cv::GC_EVAL	/usr/include/opencv2/imgproc/imgproc.hpp	/^       GC_EVAL            = 2$/;"	e	enum:cv::__anon46
cv::GC_FGD	/usr/include/opencv2/imgproc/imgproc.hpp	/^       GC_FGD    = 1,  \/\/!< foreground$/;"	e	enum:cv::__anon45
cv::GC_INIT_WITH_MASK	/usr/include/opencv2/imgproc/imgproc.hpp	/^       GC_INIT_WITH_MASK  = 1,$/;"	e	enum:cv::__anon46
cv::GC_INIT_WITH_RECT	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { GC_INIT_WITH_RECT  = 0,$/;"	e	enum:cv::__anon46
cv::GC_PR_BGD	/usr/include/opencv2/imgproc/imgproc.hpp	/^       GC_PR_BGD = 2,  \/\/!< most probably background$/;"	e	enum:cv::__anon45
cv::GC_PR_FGD	/usr/include/opencv2/imgproc/imgproc.hpp	/^       GC_PR_FGD = 3   \/\/!< most probably foreground $/;"	e	enum:cv::__anon45
cv::GEMM_1_T	/usr/include/opencv2/core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon107
cv::GEMM_2_T	/usr/include/opencv2/core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon107
cv::GEMM_3_T	/usr/include/opencv2/core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon107
cv::GaussianBlur	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(gaussianBlur) void GaussianBlur( const Mat& src, CV_OUT Mat& dst, Size ksize,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, Size ksize, double sigma1, double sigma2=0, int borderType=BORDER_DEFAULT )
cv::GenericDescriptorMatch	/usr/include/opencv2/features2d/features2d.hpp	/^typedef GenericDescriptorMatcher GenericDescriptorMatch;$/;"	t	namespace:cv
cv::GenericDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS GenericDescriptorMatcher$/;"	c	namespace:cv
cv::GenericDescriptorMatcher::GenericDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    GenericDescriptorMatcher();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
cv::GenericDescriptorMatcher::KeyPointCollection	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS KeyPointCollection$/;"	c	class:cv::GenericDescriptorMatcher	access:protected
cv::GenericDescriptorMatcher::KeyPointCollection::KeyPointCollection	/usr/include/opencv2/features2d/features2d.hpp	/^        KeyPointCollection( const KeyPointCollection& collection );$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( const KeyPointCollection& collection )
cv::GenericDescriptorMatcher::KeyPointCollection::KeyPointCollection	/usr/include/opencv2/features2d/features2d.hpp	/^        KeyPointCollection();$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:()
cv::GenericDescriptorMatcher::KeyPointCollection::add	/usr/include/opencv2/features2d/features2d.hpp	/^        void add( const vector<Mat>& images, const vector<vector<KeyPoint> >& keypoints );$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( const vector<Mat>& images, const vector<vector<KeyPoint> >& keypoints )
cv::GenericDescriptorMatcher::KeyPointCollection::clear	/usr/include/opencv2/features2d/features2d.hpp	/^        void clear();$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:()
cv::GenericDescriptorMatcher::KeyPointCollection::clone_op	/usr/include/opencv2/features2d/features2d.hpp	/^        static Mat clone_op( Mat m ) { return m.clone(); }$/;"	f	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:private	signature:( Mat m )
cv::GenericDescriptorMatcher::KeyPointCollection::getImage	/usr/include/opencv2/features2d/features2d.hpp	/^        const Mat& getImage( int imgIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx ) const
cv::GenericDescriptorMatcher::KeyPointCollection::getImages	/usr/include/opencv2/features2d/features2d.hpp	/^        const vector<Mat>& getImages() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
cv::GenericDescriptorMatcher::KeyPointCollection::getKeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^        const KeyPoint& getKeyPoint( int globalPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int globalPointIdx ) const
cv::GenericDescriptorMatcher::KeyPointCollection::getKeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^        const KeyPoint& getKeyPoint( int imgIdx, int localPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx, int localPointIdx ) const
cv::GenericDescriptorMatcher::KeyPointCollection::getKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^        const vector<KeyPoint>& getKeypoints( int imgIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx ) const
cv::GenericDescriptorMatcher::KeyPointCollection::getKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^        const vector<vector<KeyPoint> >& getKeypoints() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
cv::GenericDescriptorMatcher::KeyPointCollection::getLocalIdx	/usr/include/opencv2/features2d/features2d.hpp	/^        void getLocalIdx( int globalPointIdx, int& imgIdx, int& localPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int globalPointIdx, int& imgIdx, int& localPointIdx ) const
cv::GenericDescriptorMatcher::KeyPointCollection::imageCount	/usr/include/opencv2/features2d/features2d.hpp	/^        size_t imageCount() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
cv::GenericDescriptorMatcher::KeyPointCollection::images	/usr/include/opencv2/features2d/features2d.hpp	/^        vector<Mat> images;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
cv::GenericDescriptorMatcher::KeyPointCollection::keypointCount	/usr/include/opencv2/features2d/features2d.hpp	/^        size_t keypointCount() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
cv::GenericDescriptorMatcher::KeyPointCollection::keypoints	/usr/include/opencv2/features2d/features2d.hpp	/^        vector<vector<KeyPoint> > keypoints;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
cv::GenericDescriptorMatcher::KeyPointCollection::pointCount	/usr/include/opencv2/features2d/features2d.hpp	/^        int pointCount;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
cv::GenericDescriptorMatcher::KeyPointCollection::startIndices	/usr/include/opencv2/features2d/features2d.hpp	/^        vector<int> startIndices;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
cv::GenericDescriptorMatcher::add	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& images,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints )
cv::GenericDescriptorMatcher::classify	/usr/include/opencv2/features2d/features2d.hpp	/^    void classify( const Mat& queryImage, vector<KeyPoint>& queryKeypoints );$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints )
cv::GenericDescriptorMatcher::classify	/usr/include/opencv2/features2d/features2d.hpp	/^    void classify( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints ) const
cv::GenericDescriptorMatcher::clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
cv::GenericDescriptorMatcher::clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const = 0;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::GenericDescriptorMatcher::create	/usr/include/opencv2/features2d/features2d.hpp	/^    static Ptr<GenericDescriptorMatcher> create( const string& genericDescritptorMatcherType,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const string& genericDescritptorMatcherType, const string &paramsFilename=string() )
cv::GenericDescriptorMatcher::getTrainImages	/usr/include/opencv2/features2d/features2d.hpp	/^    const vector<Mat>& getTrainImages() const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:() const
cv::GenericDescriptorMatcher::getTrainKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^    const vector<vector<KeyPoint> >& getTrainKeypoints() const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:() const
cv::GenericDescriptorMatcher::isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported() = 0;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
cv::GenericDescriptorMatcher::knnMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void knnMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<vector<DMatch> >& matches, int k, const Mat& mask=Mat(), bool compactResult=false ) const
cv::GenericDescriptorMatcher::knnMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void knnMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::GenericDescriptorMatcher::knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::GenericDescriptorMatcher::match	/usr/include/opencv2/features2d/features2d.hpp	/^    void match( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<DMatch>& matches, const Mat& mask=Mat() ) const
cv::GenericDescriptorMatcher::match	/usr/include/opencv2/features2d/features2d.hpp	/^    void match( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<DMatch>& matches, const vector<Mat>& masks=vector<Mat>() )
cv::GenericDescriptorMatcher::radiusMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const Mat& mask=Mat(), bool compactResult=false ) const
cv::GenericDescriptorMatcher::radiusMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::GenericDescriptorMatcher::radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::GenericDescriptorMatcher::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const FileNode& )
cv::GenericDescriptorMatcher::train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
cv::GenericDescriptorMatcher::trainPointCollection	/usr/include/opencv2/features2d/features2d.hpp	/^    KeyPointCollection trainPointCollection;$/;"	m	class:cv::GenericDescriptorMatcher	access:protected
cv::GenericDescriptorMatcher::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( FileStorage& ) const
cv::GenericDescriptorMatcher::~GenericDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~GenericDescriptorMatcher();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
cv::GoodFeaturesToTrackDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS GoodFeaturesToTrackDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::GoodFeaturesToTrackDetector::GoodFeaturesToTrackDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    GoodFeaturesToTrackDetector( const GoodFeaturesToTrackDetector::Params& params=GoodFeaturesToTrackDetector::Params() );$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( const GoodFeaturesToTrackDetector::Params& params=GoodFeaturesToTrackDetector::Params() )
cv::GoodFeaturesToTrackDetector::GoodFeaturesToTrackDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    GoodFeaturesToTrackDetector( int maxCorners, double qualityLevel, double minDistance,$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( int maxCorners, double qualityLevel, double minDistance, int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
cv::GoodFeaturesToTrackDetector::Params	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::GoodFeaturesToTrackDetector	access:public
cv::GoodFeaturesToTrackDetector::Params::Params	/usr/include/opencv2/features2d/features2d.hpp	/^        Params( int maxCorners=1000, double qualityLevel=0.01, double minDistance=1.,$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( int maxCorners=1000, double qualityLevel=0.01, double minDistance=1., int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
cv::GoodFeaturesToTrackDetector::Params::blockSize	/usr/include/opencv2/features2d/features2d.hpp	/^        int blockSize;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::k	/usr/include/opencv2/features2d/features2d.hpp	/^        double k;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::maxCorners	/usr/include/opencv2/features2d/features2d.hpp	/^        int maxCorners;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::minDistance	/usr/include/opencv2/features2d/features2d.hpp	/^        double minDistance;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::qualityLevel	/usr/include/opencv2/features2d/features2d.hpp	/^        double qualityLevel;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::read	/usr/include/opencv2/features2d/features2d.hpp	/^        void read( const FileNode& fn );$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( const FileNode& fn )
cv::GoodFeaturesToTrackDetector::Params::useHarrisDetector	/usr/include/opencv2/features2d/features2d.hpp	/^        bool useHarrisDetector;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::write	/usr/include/opencv2/features2d/features2d.hpp	/^        void write( FileStorage& fs ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( FileStorage& fs ) const
cv::GoodFeaturesToTrackDetector::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::GoodFeaturesToTrackDetector::params	/usr/include/opencv2/features2d/features2d.hpp	/^	Params params;$/;"	m	class:cv::GoodFeaturesToTrackDetector	access:protected
cv::GoodFeaturesToTrackDetector::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( const FileNode& fn )
cv::GoodFeaturesToTrackDetector::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( FileStorage& fs ) const
cv::GradientBoostingTreeParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvGBTreesParams GradientBoostingTreeParams;$/;"	t	namespace:cv
cv::GradientBoostingTrees	/usr/include/opencv2/ml/ml.hpp	/^typedef CvGBTrees GradientBoostingTrees;$/;"	t	namespace:cv
cv::GreaterEq	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS GreaterEq$/;"	c	namespace:cv
cv::GreaterEq::operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const _Tp& a, const _Tp& b) const { return a >= b; }$/;"	f	class:cv::GreaterEq	access:public	signature:(const _Tp& a, const _Tp& b) const
cv::GreaterEqIdx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS GreaterEqIdx$/;"	c	namespace:cv
cv::GreaterEqIdx::GreaterEqIdx	/usr/include/opencv2/core/operations.hpp	/^    GreaterEqIdx( const _Tp* _arr ) : arr(_arr) {}$/;"	f	class:cv::GreaterEqIdx	access:public	signature:( const _Tp* _arr )
cv::GreaterEqIdx::arr	/usr/include/opencv2/core/operations.hpp	/^    const _Tp* arr;$/;"	m	class:cv::GreaterEqIdx	access:public
cv::GreaterEqIdx::operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(int a, int b) const { return arr[a] >= arr[b]; }$/;"	f	class:cv::GreaterEqIdx	access:public	signature:(int a, int b) const
cv::GridAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS GridAdaptedFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::GridAdaptedFeatureDetector::GridAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    GridAdaptedFeatureDetector( const Ptr<FeatureDetector>& detector, int maxTotalKeypoints=1000,$/;"	p	class:cv::GridAdaptedFeatureDetector	access:public	signature:( const Ptr<FeatureDetector>& detector, int maxTotalKeypoints=1000, int gridRows=4, int gridCols=4 )
cv::GridAdaptedFeatureDetector::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::GridAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::GridAdaptedFeatureDetector::detector	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<FeatureDetector> detector;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
cv::GridAdaptedFeatureDetector::gridCols	/usr/include/opencv2/features2d/features2d.hpp	/^    int gridCols;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
cv::GridAdaptedFeatureDetector::gridRows	/usr/include/opencv2/features2d/features2d.hpp	/^    int gridRows;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
cv::GridAdaptedFeatureDetector::maxTotalKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^    int maxTotalKeypoints;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
cv::HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^struct CV_EXPORTS_W HOGDescriptor$/;"	s	namespace:cv
cv::HOGDescriptor::DEFAULT_NLEVELS	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { DEFAULT_NLEVELS=64 };$/;"	e	enum:cv::HOGDescriptor::__anon65
cv::HOGDescriptor::HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor() : winSize(64,128), blockSize(16,16), blockStride(8,8),$/;"	f	struct:cv::HOGDescriptor	access:public	signature:()
cv::HOGDescriptor::HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride,$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture=1, double _winSigma=-1, int _histogramNormType=HOGDescriptor::L2Hys, double _L2HysThreshold=0.2, bool _gammaCorrection=false, int _nlevels=HOGDescriptor::DEFAULT_NLEVELS)
cv::HOGDescriptor::HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor(const String& filename)$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(const String& filename)
cv::HOGDescriptor::HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^    HOGDescriptor(const HOGDescriptor& d)$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(const HOGDescriptor& d)
cv::HOGDescriptor::L2Hys	/usr/include/opencv2/objdetect/objdetect.hpp	/^    enum { L2Hys=0 };$/;"	e	enum:cv::HOGDescriptor::__anon64
cv::HOGDescriptor::L2HysThreshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP double L2HysThreshold;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::blockSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP Size blockSize;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::blockStride	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP Size blockStride;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::cellSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP Size cellSize;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::checkDetectorSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP bool checkDetectorSize() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
cv::HOGDescriptor::compute	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void compute(const Mat& img,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<float>& descriptors, Size winStride=Size(), Size padding=Size(), const vector<Point>& locations=vector<Point>()) const
cv::HOGDescriptor::computeGradient	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void computeGradient(const Mat& img, CV_OUT Mat& grad, CV_OUT Mat& angleOfs,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT Mat& grad, CV_OUT Mat& angleOfs, Size paddingTL=Size(), Size paddingBR=Size()) const
cv::HOGDescriptor::copyTo	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual void copyTo(HOGDescriptor& c) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(HOGDescriptor& c) const
cv::HOGDescriptor::derivAperture	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP int derivAperture;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::detect	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void detect(const Mat& img, CV_OUT vector<Point>& foundLocations,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Point>& foundLocations, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), const vector<Point>& searchLocations=vector<Point>()) const
cv::HOGDescriptor::detectMultiScale	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void detectMultiScale(const Mat& img, CV_OUT vector<Rect>& foundLocations,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Rect>& foundLocations, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), double scale=1.05, int groupThreshold=2) const
cv::HOGDescriptor::gammaCorrection	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP bool gammaCorrection;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::getDefaultPeopleDetector	/usr/include/opencv2/objdetect/objdetect.hpp	/^    static vector<float> getDefaultPeopleDetector();$/;"	p	struct:cv::HOGDescriptor	access:public	signature:()
cv::HOGDescriptor::getDescriptorSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP size_t getDescriptorSize() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
cv::HOGDescriptor::getWinSigma	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP double getWinSigma() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
cv::HOGDescriptor::histogramNormType	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP int histogramNormType;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::load	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual bool load(const String& filename, const String& objname=String());$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const String& filename, const String& objname=String())
cv::HOGDescriptor::nbins	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP int nbins;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::nlevels	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP int nlevels;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::read	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual bool read(FileNode& fn);$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(FileNode& fn)
cv::HOGDescriptor::save	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void save(const String& filename, const String& objname=String()) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const String& filename, const String& objname=String()) const
cv::HOGDescriptor::setSVMDetector	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void setSVMDetector(const vector<float>& _svmdetector);$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const vector<float>& _svmdetector)
cv::HOGDescriptor::svmDetector	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP vector<float> svmDetector;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::winSigma	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP double winSigma;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::winSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP Size winSize;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::write	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual void write(FileStorage& fs, const String& objname) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(FileStorage& fs, const String& objname) const
cv::HOGDescriptor::~HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual ~HOGDescriptor() {}$/;"	f	struct:cv::HOGDescriptor	access:public	signature:()
cv::Hamming	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS Hamming$/;"	s	namespace:cv
cv::Hamming::ResultType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef int ResultType;$/;"	t	struct:cv::Hamming	access:public
cv::Hamming::ValueType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef unsigned char ValueType;$/;"	t	struct:cv::Hamming	access:public
cv::Hamming::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    ResultType operator()(const unsigned char* a, const unsigned char* b, int size) const;$/;"	p	struct:cv::Hamming	access:public	signature:(const unsigned char* a, const unsigned char* b, int size) const
cv::HammingLUT	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS HammingLUT$/;"	s	namespace:cv
cv::HammingLUT::ResultType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef int ResultType;$/;"	t	struct:cv::HammingLUT	access:public
cv::HammingLUT::ValueType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef unsigned char ValueType;$/;"	t	struct:cv::HammingLUT	access:public
cv::HammingLUT::byteBitsLookUp	/usr/include/opencv2/features2d/features2d.hpp	/^    static unsigned char byteBitsLookUp(unsigned char b);$/;"	p	struct:cv::HammingLUT	access:public	signature:(unsigned char b)
cv::HammingLUT::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    ResultType operator()( const unsigned char* a, const unsigned char* b, int size ) const;$/;"	p	struct:cv::HammingLUT	access:public	signature:( const unsigned char* a, const unsigned char* b, int size ) const
cv::HoughCircles	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(houghCircles) void HoughCircles( const Mat& image, CV_OUT vector<Vec3f>& circles,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT vector<Vec3f>& circles, int method, double dp, double minDist, double param1=100, double param2=100, int minRadius=0, int maxRadius=0 )
cv::HoughLines	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(houghLines) void HoughLines( const Mat& image, CV_OUT vector<Vec2f>& lines,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT vector<Vec2f>& lines, double rho, double theta, int threshold, double srn=0, double stn=0 )
cv::HoughLinesP	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(houghLinesP) void HoughLinesP( Mat& image, CV_OUT vector<Vec4i>& lines,$/;"	p	namespace:cv	signature:( Mat& image, CV_OUT vector<Vec4i>& lines, double rho, double theta, int threshold, double minLineLength=0, double maxLineGap=0 )
cv::HuMoments	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void HuMoments( const Moments& moments, double hu[7] );$/;"	p	namespace:cv	signature:( const Moments& moments, double hu[7] )
cv::INPAINT_NS	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INPAINT_NS=0, \/\/ Navier-Stokes algorithm$/;"	e	enum:cv::__anon47
cv::INPAINT_TELEA	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INPAINT_TELEA=1 \/\/ A. Telea algorithm$/;"	e	enum:cv::__anon47
cv::INTER_AREA	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_AREA=3, \/\/!< area-based (or super) interpolation$/;"	e	enum:cv::__anon40
cv::INTER_BITS	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { INTER_BITS=5, INTER_BITS2=INTER_BITS*2,$/;"	e	enum:cv::__anon41
cv::INTER_BITS2	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { INTER_BITS=5, INTER_BITS2=INTER_BITS*2,$/;"	e	enum:cv::__anon41
cv::INTER_CUBIC	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_CUBIC=2, \/\/!< bicubic interpolation$/;"	e	enum:cv::__anon40
cv::INTER_LANCZOS4	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_LANCZOS4=4, \/\/!< Lanczos interpolation over 8x8 neighborhood$/;"	e	enum:cv::__anon40
cv::INTER_LINEAR	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_LINEAR=1, \/\/!< bilinear interpolation$/;"	e	enum:cv::__anon40
cv::INTER_MAX	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_MAX=7,$/;"	e	enum:cv::__anon40
cv::INTER_NEAREST	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_NEAREST=0, \/\/!< nearest neighbor interpolation$/;"	e	enum:cv::__anon40
cv::INTER_TAB_SIZE	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_TAB_SIZE=(1<<INTER_BITS),$/;"	e	enum:cv::__anon41
cv::INTER_TAB_SIZE2	/usr/include/opencv2/imgproc/imgproc.hpp	/^    INTER_TAB_SIZE2=INTER_TAB_SIZE*INTER_TAB_SIZE };    $/;"	e	enum:cv::__anon41
cv::KDTree	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS_W KDTree$/;"	c	namespace:cv
cv::KDTree::KDTree	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP KDTree();$/;"	p	class:cv::KDTree	access:public	signature:()
cv::KDTree::KDTree	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP KDTree(const Mat& _points, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(const Mat& _points, bool copyAndReorderPoints=false)
cv::KDTree::KDTree	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP KDTree(const Mat& _points, const Mat& _labels, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(const Mat& _points, const Mat& _labels, bool copyAndReorderPoints=false)
cv::KDTree::Node	/usr/include/opencv2/core/core.hpp	/^    struct Node$/;"	s	class:cv::KDTree	access:public
cv::KDTree::Node::Node	/usr/include/opencv2/core/core.hpp	/^        Node() : idx(-1), left(-1), right(-1), boundary(0.f) {}$/;"	f	struct:cv::KDTree::Node	access:public	signature:()
cv::KDTree::Node::Node	/usr/include/opencv2/core/core.hpp	/^        Node(int _idx, int _left, int _right, float _boundary)$/;"	f	struct:cv::KDTree::Node	access:public	signature:(int _idx, int _left, int _right, float _boundary)
cv::KDTree::Node::boundary	/usr/include/opencv2/core/core.hpp	/^        float boundary;$/;"	m	struct:cv::KDTree::Node	access:public
cv::KDTree::Node::idx	/usr/include/opencv2/core/core.hpp	/^        int idx;$/;"	m	struct:cv::KDTree::Node	access:public
cv::KDTree::Node::left	/usr/include/opencv2/core/core.hpp	/^        int left, right;$/;"	m	struct:cv::KDTree::Node	access:public
cv::KDTree::Node::right	/usr/include/opencv2/core/core.hpp	/^        int left, right;$/;"	m	struct:cv::KDTree::Node	access:public
cv::KDTree::build	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP void build(const Mat& _points, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(const Mat& _points, bool copyAndReorderPoints=false)
cv::KDTree::build	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP void build(const Mat& _points, const Mat& _labels, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(const Mat& _points, const Mat& _labels, bool copyAndReorderPoints=false)
cv::KDTree::dims	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP int dims() const;$/;"	p	class:cv::KDTree	access:public	signature:() const
cv::KDTree::findNearest	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP int findNearest(const vector<float>& vec, int K, int Emax,$/;"	p	class:cv::KDTree	access:public	signature:(const vector<float>& vec, int K, int Emax, CV_OUT vector<int>* neighborsIdx, CV_OUT Mat* neighbors=0, CV_OUT vector<float>* dist=0, CV_OUT vector<int>* labels=0) const
cv::KDTree::findNearest	/usr/include/opencv2/core/core.hpp	/^    int findNearest(const float* vec, int K, int Emax,$/;"	p	class:cv::KDTree	access:public	signature:(const float* vec, int K, int Emax, vector<int>* neighborsIdx, Mat* neighbors=0, vector<float>* dist=0, vector<int>* labels=0) const
cv::KDTree::findNearest	/usr/include/opencv2/core/core.hpp	/^    int findNearest(const float* vec,$/;"	p	class:cv::KDTree	access:public	signature:(const float* vec, int K, int Emax, int* neighborsIdx, Mat* neighbors=0, float* dist=0, int* labels=0) const
cv::KDTree::findOrthoRange	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP void findOrthoRange(const vector<float>& minBounds, const vector<float>& maxBounds,$/;"	p	class:cv::KDTree	access:public	signature:(const vector<float>& minBounds, const vector<float>& maxBounds, CV_OUT vector<int>* neighborsIdx, CV_OUT Mat* neighbors=0, CV_OUT vector<int>* labels=0) const
cv::KDTree::findOrthoRange	/usr/include/opencv2/core/core.hpp	/^    void findOrthoRange(const float* minBounds, const float* maxBounds,$/;"	p	class:cv::KDTree	access:public	signature:(const float* minBounds, const float* maxBounds, vector<int>* neighborsIdx, Mat* neighbors=0, vector<int>* labels=0) const
cv::KDTree::getPoint	/usr/include/opencv2/core/core.hpp	/^    const float* getPoint(int ptidx, int* label=0) const;$/;"	p	class:cv::KDTree	access:public	signature:(int ptidx, int* label=0) const
cv::KDTree::getPoints	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP void getPoints(const vector<int>& idxs, Mat& pts, CV_OUT vector<int>* labels=0) const;$/;"	p	class:cv::KDTree	access:public	signature:(const vector<int>& idxs, Mat& pts, CV_OUT vector<int>* labels=0) const
cv::KDTree::getPoints	/usr/include/opencv2/core/core.hpp	/^    void getPoints(const int* idx, size_t nidx, Mat& pts, vector<int>* labels=0) const;$/;"	p	class:cv::KDTree	access:public	signature:(const int* idx, size_t nidx, Mat& pts, vector<int>* labels=0) const
cv::KDTree::labels	/usr/include/opencv2/core/core.hpp	/^    CV_PROP vector<int> labels; \/\/!< the parallel array of labels.$/;"	m	class:cv::KDTree	access:public
cv::KDTree::maxDepth	/usr/include/opencv2/core/core.hpp	/^    CV_PROP int maxDepth; \/\/!< maximum depth of the search tree. Do not modify it$/;"	m	class:cv::KDTree	access:public
cv::KDTree::nodes	/usr/include/opencv2/core/core.hpp	/^    vector<Node> nodes; \/\/!< all the tree nodes$/;"	m	class:cv::KDTree	access:public
cv::KDTree::normType	/usr/include/opencv2/core/core.hpp	/^    CV_PROP_RW int normType; \/\/!< type of the distance (cv::NORM_L1 or cv::NORM_L2) used for search. Initially set to cv::NORM_L2, but you can modify it$/;"	m	class:cv::KDTree	access:public
cv::KDTree::points	/usr/include/opencv2/core/core.hpp	/^    CV_PROP Mat points; \/\/!< all the points. It can be a reordered copy of the input vector set or the original vector set.$/;"	m	class:cv::KDTree	access:public
cv::KERNEL_ASYMMETRICAL	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon37
cv::KERNEL_GENERAL	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon37
cv::KERNEL_INTEGER	/usr/include/opencv2/imgproc/imgproc.hpp	/^       KERNEL_SMOOTH=4, KERNEL_INTEGER=8 };$/;"	e	enum:cv::__anon37
cv::KERNEL_SMOOTH	/usr/include/opencv2/imgproc/imgproc.hpp	/^       KERNEL_SMOOTH=4, KERNEL_INTEGER=8 };$/;"	e	enum:cv::__anon37
cv::KERNEL_SYMMETRICAL	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon37
cv::KMEANS_PP_CENTERS	/usr/include/opencv2/core/core.hpp	/^    KMEANS_PP_CENTERS=2,     \/\/ Uses k-Means++ algorithm for initialization$/;"	e	enum:cv::__anon146
cv::KMEANS_RANDOM_CENTERS	/usr/include/opencv2/core/core.hpp	/^    KMEANS_RANDOM_CENTERS=0, \/\/ Chooses random centers for k-Means initialization$/;"	e	enum:cv::__anon146
cv::KMEANS_USE_INITIAL_LABELS	/usr/include/opencv2/core/core.hpp	/^    KMEANS_USE_INITIAL_LABELS=1 \/\/ Uses the user-provided labels for K-Means initialization$/;"	e	enum:cv::__anon146
cv::KNearest	/usr/include/opencv2/ml/ml.hpp	/^typedef CvKNearest KNearest;$/;"	t	namespace:cv
cv::KalmanFilter	/usr/include/opencv2/video/tracking.hpp	/^class CV_EXPORTS_W KalmanFilter$/;"	c	namespace:cv
cv::KalmanFilter::KalmanFilter	/usr/include/opencv2/video/tracking.hpp	/^    CV_WRAP KalmanFilter();$/;"	p	class:cv::KalmanFilter	access:public	signature:()
cv::KalmanFilter::KalmanFilter	/usr/include/opencv2/video/tracking.hpp	/^    CV_WRAP KalmanFilter(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F);$/;"	p	class:cv::KalmanFilter	access:public	signature:(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F)
cv::KalmanFilter::controlMatrix	/usr/include/opencv2/video/tracking.hpp	/^    Mat controlMatrix;      \/\/!< control matrix (B) (not used if there is no control)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::correct	/usr/include/opencv2/video/tracking.hpp	/^    CV_WRAP const Mat& correct(const Mat& measurement);$/;"	p	class:cv::KalmanFilter	access:public	signature:(const Mat& measurement)
cv::KalmanFilter::errorCovPost	/usr/include/opencv2/video/tracking.hpp	/^    Mat errorCovPost;       \/\/!< posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::errorCovPre	/usr/include/opencv2/video/tracking.hpp	/^    Mat errorCovPre;        \/\/!< priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)*\/$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::gain	/usr/include/opencv2/video/tracking.hpp	/^    Mat gain;               \/\/!< Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::init	/usr/include/opencv2/video/tracking.hpp	/^    void init(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F);$/;"	p	class:cv::KalmanFilter	access:public	signature:(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F)
cv::KalmanFilter::measurementMatrix	/usr/include/opencv2/video/tracking.hpp	/^    Mat measurementMatrix;  \/\/!< measurement matrix (H)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::measurementNoiseCov	/usr/include/opencv2/video/tracking.hpp	/^    Mat measurementNoiseCov;\/\/!< measurement noise covariance matrix (R)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::predict	/usr/include/opencv2/video/tracking.hpp	/^    CV_WRAP const Mat& predict(const Mat& control=Mat());$/;"	p	class:cv::KalmanFilter	access:public	signature:(const Mat& control=Mat())
cv::KalmanFilter::processNoiseCov	/usr/include/opencv2/video/tracking.hpp	/^    Mat processNoiseCov;    \/\/!< process noise covariance matrix (Q)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::statePost	/usr/include/opencv2/video/tracking.hpp	/^    Mat statePost;          \/\/!< corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::statePre	/usr/include/opencv2/video/tracking.hpp	/^    Mat statePre;           \/\/!< predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::temp1	/usr/include/opencv2/video/tracking.hpp	/^    Mat temp1;$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::temp2	/usr/include/opencv2/video/tracking.hpp	/^    Mat temp2;$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::temp3	/usr/include/opencv2/video/tracking.hpp	/^    Mat temp3;$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::temp4	/usr/include/opencv2/video/tracking.hpp	/^    Mat temp4;$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::temp5	/usr/include/opencv2/video/tracking.hpp	/^    Mat temp5;$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::transitionMatrix	/usr/include/opencv2/video/tracking.hpp	/^    Mat transitionMatrix;   \/\/!< state transition matrix (A)$/;"	m	class:cv::KalmanFilter	access:public
cv::KeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS_W_SIMPLE KeyPoint$/;"	c	namespace:cv
cv::KeyPoint::KeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP KeyPoint() : pt(0,0), size(0), angle(-1), response(0), octave(0), class_id(-1) {}$/;"	f	class:cv::KeyPoint	access:public	signature:()
cv::KeyPoint::KeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP KeyPoint(float x, float y, float _size, float _angle=-1,$/;"	f	class:cv::KeyPoint	access:public	signature:(float x, float y, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1)
cv::KeyPoint::KeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^    KeyPoint(Point2f _pt, float _size, float _angle=-1,$/;"	f	class:cv::KeyPoint	access:public	signature:(Point2f _pt, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1)
cv::KeyPoint::angle	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW float angle; \/\/!< computed orientation of the keypoint (-1 if not applicable)$/;"	m	class:cv::KeyPoint	access:public
cv::KeyPoint::class_id	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW int class_id; \/\/!< object class (if the keypoints need to be clustered by an object they belong to) $/;"	m	class:cv::KeyPoint	access:public
cv::KeyPoint::convert	/usr/include/opencv2/features2d/features2d.hpp	/^    static void convert(const std::vector<KeyPoint>& keypoints,$/;"	p	class:cv::KeyPoint	access:public	signature:(const std::vector<KeyPoint>& keypoints, CV_OUT std::vector<Point2f>& points2f, const std::vector<int>& keypointIndexes=std::vector<int>())
cv::KeyPoint::convert	/usr/include/opencv2/features2d/features2d.hpp	/^    static void convert(const std::vector<Point2f>& points2f,$/;"	p	class:cv::KeyPoint	access:public	signature:(const std::vector<Point2f>& points2f, CV_OUT std::vector<KeyPoint>& keypoints, float size=1, float response=1, int octave=0, int class_id=-1)
cv::KeyPoint::octave	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW int octave; \/\/!< octave (pyramid layer) from which the keypoint has been extracted$/;"	m	class:cv::KeyPoint	access:public
cv::KeyPoint::overlap	/usr/include/opencv2/features2d/features2d.hpp	/^    static float overlap(const KeyPoint& kp1, const KeyPoint& kp2);$/;"	p	class:cv::KeyPoint	access:public	signature:(const KeyPoint& kp1, const KeyPoint& kp2)
cv::KeyPoint::pt	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW Point2f pt; \/\/!< coordinates of the keypoints$/;"	m	class:cv::KeyPoint	access:public
cv::KeyPoint::response	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW float response; \/\/!< the response by which the most strong keypoints have been selected. Can be used for the further sorting or subsampling$/;"	m	class:cv::KeyPoint	access:public
cv::KeyPoint::size	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW float size; \/\/!< diameter of the meaningfull keypoint neighborhood$/;"	m	class:cv::KeyPoint	access:public
cv::L1	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS L1$/;"	s	namespace:cv
cv::L1::ResultType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cv::L1	access:public
cv::L1::ValueType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef T ValueType;$/;"	t	struct:cv::L1	access:public
cv::L1::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    ResultType operator()( const T* a, const T* b, int size ) const$/;"	f	struct:cv::L1	access:public	signature:( const T* a, const T* b, int size ) const
cv::L2	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS L2$/;"	s	namespace:cv
cv::L2::ResultType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cv::L2	access:public
cv::L2::ValueType	/usr/include/opencv2/features2d/features2d.hpp	/^    typedef T ValueType;$/;"	t	struct:cv::L2	access:public
cv::L2::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    ResultType operator()( const T* a, const T* b, int size ) const$/;"	f	struct:cv::L2	access:public	signature:( const T* a, const T* b, int size ) const
cv::LDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS LDetector$/;"	c	namespace:cv
cv::LDetector::LDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    LDetector();$/;"	p	class:cv::LDetector	access:public	signature:()
cv::LDetector::LDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    LDetector(int _radius, int _threshold, int _nOctaves,$/;"	p	class:cv::LDetector	access:public	signature:(int _radius, int _threshold, int _nOctaves, int _nViews, double _baseFeatureSize, double _clusteringDistance)
cv::LDetector::baseFeatureSize	/usr/include/opencv2/features2d/features2d.hpp	/^    double baseFeatureSize;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::clusteringDistance	/usr/include/opencv2/features2d/features2d.hpp	/^    double clusteringDistance;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::getMostStable2D	/usr/include/opencv2/features2d/features2d.hpp	/^    void getMostStable2D(const Mat& image, CV_OUT vector<KeyPoint>& keypoints,$/;"	p	class:cv::LDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int maxCount, const PatchGenerator& patchGenerator) const
cv::LDetector::nOctaves	/usr/include/opencv2/features2d/features2d.hpp	/^    int nOctaves;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::nViews	/usr/include/opencv2/features2d/features2d.hpp	/^    int nViews;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const Mat& image,$/;"	p	class:cv::LDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int maxCount=0, bool scaleCoords=true) const
cv::LDetector::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const vector<Mat>& pyr,$/;"	p	class:cv::LDetector	access:public	signature:(const vector<Mat>& pyr, CV_OUT vector<KeyPoint>& keypoints, int maxCount=0, bool scaleCoords=true) const
cv::LDetector::radius	/usr/include/opencv2/features2d/features2d.hpp	/^    int radius;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::read	/usr/include/opencv2/features2d/features2d.hpp	/^    void read(const FileNode& node);$/;"	p	class:cv::LDetector	access:public	signature:(const FileNode& node)
cv::LDetector::setVerbose	/usr/include/opencv2/features2d/features2d.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::LDetector	access:public	signature:(bool verbose)
cv::LDetector::threshold	/usr/include/opencv2/features2d/features2d.hpp	/^    int threshold;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::verbose	/usr/include/opencv2/features2d/features2d.hpp	/^    bool verbose;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::write	/usr/include/opencv2/features2d/features2d.hpp	/^    void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::LDetector	access:public	signature:(FileStorage& fs, const String& name=String()) const
cv::LMEDS	/usr/include/opencv2/calib3d/calib3d.hpp	/^    LMEDS=CV_LMEDS, \/\/!< least-median algorithm$/;"	e	enum:cv::__anon67
cv::LU	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS int LU(double* A, int m, double* b, int n);$/;"	p	namespace:cv	signature:(double* A, int m, double* b, int n)
cv::LU	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS int LU(float* A, int m, float* b, int n);$/;"	p	namespace:cv	signature:(float* A, int m, float* b, int n)
cv::LUT	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void LUT(const Mat& src, const Mat& lut, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, const Mat& lut, CV_OUT Mat& dst)
cv::Laplacian	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(laplacian) void Laplacian( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, int ksize=1, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
cv::LessThan	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS LessThan$/;"	c	namespace:cv
cv::LessThan::operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const _Tp& a, const _Tp& b) const { return a < b; }$/;"	f	class:cv::LessThan	access:public	signature:(const _Tp& a, const _Tp& b) const
cv::LessThanIdx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS LessThanIdx$/;"	c	namespace:cv
cv::LessThanIdx::LessThanIdx	/usr/include/opencv2/core/operations.hpp	/^    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}$/;"	f	class:cv::LessThanIdx	access:public	signature:( const _Tp* _arr )
cv::LessThanIdx::arr	/usr/include/opencv2/core/operations.hpp	/^    const _Tp* arr;$/;"	m	class:cv::LessThanIdx	access:public
cv::LessThanIdx::operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(int a, int b) const { return arr[a] < arr[b]; }$/;"	f	class:cv::LessThanIdx	access:public	signature:(int a, int b) const
cv::LevMarqSparse	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS LevMarqSparse$/;"	c	namespace:cv
cv::LevMarqSparse::A	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* A;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::B	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* B;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::JtJ_diag	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* JtJ_diag; \/\/diagonal of JtJ,  used to backup diagonal elements before augmentation$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::LevMarqSparse	/usr/include/opencv2/contrib/contrib.hpp	/^        LevMarqSparse();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
cv::LevMarqSparse::LevMarqSparse	/usr/include/opencv2/contrib/contrib.hpp	/^        LevMarqSparse(int npoints, \/\/ number of points$/;"	p	class:cv::LevMarqSparse	access:public	signature:(int npoints, int ncameras, int nPointParams, int nCameraParams, int nErrParams, Mat& visibility, Mat& P0, Mat& X, TermCriteria criteria, void (CV_CDECL * fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data), void (CV_CDECL * func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data), void* data )
cv::LevMarqSparse::P	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* P; \/\/ parameters used to evaluate function with new params$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::S	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* S; \/\/big matrix of block Sjk  , each block has size num_cam_params x num_cam_params$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::U	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** U; \/\/size of array is equal to number of cameras$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::V	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** V; \/\/size of array is equal to number of points$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::Vis_index	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* Vis_index; \/\/ matrix which element is index of measurement for point i and camera j$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::W	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* W;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::X	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* X; \/\/measurement$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::Yj	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** Yj; \/\/length of array is i = num_points$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::ask_for_proj	/usr/include/opencv2/contrib/contrib.hpp	/^        void ask_for_proj();$/;"	p	class:cv::LevMarqSparse	access:protected	signature:()
cv::LevMarqSparse::ask_for_projac	/usr/include/opencv2/contrib/contrib.hpp	/^        void ask_for_projac();$/;"	p	class:cv::LevMarqSparse	access:protected	signature:()
cv::LevMarqSparse::bundleAdjust	/usr/include/opencv2/contrib/contrib.hpp	/^        static void bundleAdjust(vector<Point3d>& points, \/\/positions of points in global coordinate system (input and output)$/;"	p	class:cv::LevMarqSparse	access:public	signature:(vector<Point3d>& points, const vector<vector<Point2d> >& imagePoints, const vector<vector<int> >& visibility, vector<Mat>& cameraMatrix, vector<Mat>& R, vector<Mat>& T, vector<Mat>& distCoeffs, const TermCriteria& criteria= TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, DBL_EPSILON))
cv::LevMarqSparse::clear	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void clear();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
cv::LevMarqSparse::criteria	/usr/include/opencv2/contrib/contrib.hpp	/^        CvTermCriteria criteria;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::data	/usr/include/opencv2/contrib/contrib.hpp	/^        void* data;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::deltaP	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* deltaP; \/\/computed increase of parameters (result of normal system solution )$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::ea	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** ea; \/\/ sum_i  AijT * e_ij , used as right part of normal equation$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::eb	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** eb; \/\/ sum_j  BijT * e_ij , used as right part of normal equation$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::err	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* err; \/\/error X-hX$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::errNorm	/usr/include/opencv2/contrib/contrib.hpp	/^        double prevErrNorm, errNorm;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::fjac	/usr/include/opencv2/contrib/contrib.hpp	/^        void (*fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data);$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::func	/usr/include/opencv2/contrib/contrib.hpp	/^        void (*func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data );$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::hX	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* hX; \/\/current measurement extimation given new parameter vector$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::inv_V_star	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** inv_V_star; \/\/inverse of V*$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::iters	/usr/include/opencv2/contrib/contrib.hpp	/^        int iters;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::lambda	/usr/include/opencv2/contrib/contrib.hpp	/^        double lambda;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::num_cam_param	/usr/include/opencv2/contrib/contrib.hpp	/^        int num_cam_param;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::num_cams	/usr/include/opencv2/contrib/contrib.hpp	/^        int num_cams;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::num_err_param	/usr/include/opencv2/contrib/contrib.hpp	/^        int num_err_param;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::num_point_param	/usr/include/opencv2/contrib/contrib.hpp	/^        int num_point_param;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::num_points	/usr/include/opencv2/contrib/contrib.hpp	/^        int num_points;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::optimize	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void optimize(); \/\/main function that runs minimization$/;"	p	class:cv::LevMarqSparse	access:protected	signature:()
cv::LevMarqSparse::prevErrNorm	/usr/include/opencv2/contrib/contrib.hpp	/^        double prevErrNorm, errNorm;$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::prevP	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* prevP; \/\/current already accepted parameter.$/;"	m	class:cv::LevMarqSparse	access:protected
cv::LevMarqSparse::run	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void run( int npoints, \/\/ number of points$/;"	p	class:cv::LevMarqSparse	access:public	signature:( int npoints, int ncameras, int nPointParams, int nCameraParams, int nErrParams, Mat& visibility, Mat& P0, Mat& X, TermCriteria criteria, void (CV_CDECL * fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data), void (CV_CDECL * func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data), void* data )
cv::LevMarqSparse::~LevMarqSparse	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual ~LevMarqSparse();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
cv::LineIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS LineIterator$/;"	c	namespace:cv
cv::LineIterator::LineIterator	/usr/include/opencv2/core/core.hpp	/^    LineIterator( const Mat& img, Point pt1, Point pt2,$/;"	p	class:cv::LineIterator	access:public	signature:( const Mat& img, Point pt1, Point pt2, int connectivity=8, bool leftToRight=false )
cv::LineIterator::count	/usr/include/opencv2/core/core.hpp	/^    int err, count;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::elemSize	/usr/include/opencv2/core/core.hpp	/^    int step, elemSize;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::err	/usr/include/opencv2/core/core.hpp	/^    int err, count;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::minusDelta	/usr/include/opencv2/core/core.hpp	/^    int minusDelta, plusDelta;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::minusStep	/usr/include/opencv2/core/core.hpp	/^    int minusStep, plusStep;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::operator *	/usr/include/opencv2/core/core.hpp	/^    uchar* operator *();$/;"	p	class:cv::LineIterator	access:public	signature:()
cv::LineIterator::operator *	/usr/include/opencv2/core/operations.hpp	/^inline uchar* LineIterator::operator *() { return ptr; }$/;"	f	class:cv::LineIterator	signature:()
cv::LineIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    LineIterator operator ++(int);$/;"	p	class:cv::LineIterator	access:public	signature:(int)
cv::LineIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    LineIterator& operator ++();$/;"	p	class:cv::LineIterator	access:public	signature:()
cv::LineIterator::operator ++	/usr/include/opencv2/core/operations.hpp	/^inline LineIterator LineIterator::operator ++(int)$/;"	f	class:cv::LineIterator	signature:(int)
cv::LineIterator::operator ++	/usr/include/opencv2/core/operations.hpp	/^inline LineIterator& LineIterator::operator ++()$/;"	f	class:cv::LineIterator	signature:()
cv::LineIterator::plusDelta	/usr/include/opencv2/core/core.hpp	/^    int minusDelta, plusDelta;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::plusStep	/usr/include/opencv2/core/core.hpp	/^    int minusStep, plusStep;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::pos	/usr/include/opencv2/core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::LineIterator	access:public	signature:() const
cv::LineIterator::pos	/usr/include/opencv2/core/operations.hpp	/^inline Point LineIterator::pos() const$/;"	f	class:cv::LineIterator	signature:() const
cv::LineIterator::ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::ptr0	/usr/include/opencv2/core/core.hpp	/^    const uchar* ptr0;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::step	/usr/include/opencv2/core/core.hpp	/^    int step, elemSize;$/;"	m	class:cv::LineIterator	access:public
cv::MAGIC_MASK	/usr/include/opencv2/core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon141
cv::MORPH_BLACKHAT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       MORPH_GRADIENT=4, MORPH_TOPHAT=5, MORPH_BLACKHAT=6 };$/;"	e	enum:cv::__anon38
cv::MORPH_CLOSE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_ERODE=0, MORPH_DILATE=1, MORPH_OPEN=2, MORPH_CLOSE=3,$/;"	e	enum:cv::__anon38
cv::MORPH_CROSS	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon39
cv::MORPH_DILATE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_ERODE=0, MORPH_DILATE=1, MORPH_OPEN=2, MORPH_CLOSE=3,$/;"	e	enum:cv::__anon38
cv::MORPH_ELLIPSE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon39
cv::MORPH_ERODE	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_ERODE=0, MORPH_DILATE=1, MORPH_OPEN=2, MORPH_CLOSE=3,$/;"	e	enum:cv::__anon38
cv::MORPH_GRADIENT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       MORPH_GRADIENT=4, MORPH_TOPHAT=5, MORPH_BLACKHAT=6 };$/;"	e	enum:cv::__anon38
cv::MORPH_OPEN	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_ERODE=0, MORPH_DILATE=1, MORPH_OPEN=2, MORPH_CLOSE=3,$/;"	e	enum:cv::__anon38
cv::MORPH_RECT	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon39
cv::MORPH_TOPHAT	/usr/include/opencv2/imgproc/imgproc.hpp	/^       MORPH_GRADIENT=4, MORPH_TOPHAT=5, MORPH_BLACKHAT=6 };$/;"	e	enum:cv::__anon38
cv::MSER	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS_W MSER : public CvMSERParams$/;"	c	namespace:cv	inherits:CvMSERParams
cv::MSER::MSER	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP MSER( int _delta, int _min_area, int _max_area,$/;"	p	class:cv::MSER	access:public	signature:( int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold, double _min_margin, int _edge_blur_size )
cv::MSER::MSER	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP MSER();$/;"	p	class:cv::MSER	access:public	signature:()
cv::MSER::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()( const Mat& image,$/;"	p	class:cv::MSER	access:public	signature:( const Mat& image, CV_OUT vector<vector<Point> >& msers, const Mat& mask ) const
cv::Mahalanobis	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double Mahalanobis(const Mat& v1, const Mat& v2, const Mat& icovar);$/;"	p	namespace:cv	signature:(const Mat& v1, const Mat& v2, const Mat& icovar)
cv::Mahalonobis	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS double Mahalonobis(const Mat& v1, const Mat& v2, const Mat& icovar);$/;"	p	namespace:cv	signature:(const Mat& v1, const Mat& v2, const Mat& icovar)
cv::Mat	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS Mat$/;"	c	namespace:cv
cv::Mat1b	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<uchar> Mat1b;$/;"	t	namespace:cv
cv::Mat1d	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<double> Mat1d;$/;"	t	namespace:cv
cv::Mat1f	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<float> Mat1f;$/;"	t	namespace:cv
cv::Mat1i	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<int>   Mat1i;$/;"	t	namespace:cv
cv::Mat1s	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<short> Mat1s;$/;"	t	namespace:cv
cv::Mat1w	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<ushort> Mat1w;$/;"	t	namespace:cv
cv::Mat2b	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2b> Mat2b;$/;"	t	namespace:cv
cv::Mat2d	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2d> Mat2d;$/;"	t	namespace:cv
cv::Mat2f	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2f> Mat2f;$/;"	t	namespace:cv
cv::Mat2i	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2i> Mat2i;$/;"	t	namespace:cv
cv::Mat2s	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2s> Mat2s;$/;"	t	namespace:cv
cv::Mat2w	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec2w> Mat2w;$/;"	t	namespace:cv
cv::Mat3b	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3b> Mat3b;$/;"	t	namespace:cv
cv::Mat3d	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3d> Mat3d;$/;"	t	namespace:cv
cv::Mat3f	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3f> Mat3f;$/;"	t	namespace:cv
cv::Mat3i	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3i> Mat3i;$/;"	t	namespace:cv
cv::Mat3s	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3s> Mat3s;$/;"	t	namespace:cv
cv::Mat3w	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec3w> Mat3w;$/;"	t	namespace:cv
cv::Mat4b	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4b> Mat4b;$/;"	t	namespace:cv
cv::Mat4d	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4d> Mat4d;$/;"	t	namespace:cv
cv::Mat4f	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4f> Mat4f;$/;"	t	namespace:cv
cv::Mat4i	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4i> Mat4i;$/;"	t	namespace:cv
cv::Mat4s	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4s> Mat4s;$/;"	t	namespace:cv
cv::Mat4w	/usr/include/opencv2/core/core.hpp	/^typedef Mat_<Vec4w> Mat4w;$/;"	t	namespace:cv
cv::Mat::AUTO_STEP	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon142
cv::Mat::CONTINUOUS_FLAG	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon142
cv::Mat::MAGIC_VAL	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon142
cv::Mat::MSize	/usr/include/opencv2/core/core.hpp	/^    struct CV_EXPORTS MSize$/;"	s	class:cv::Mat	access:public
cv::Mat::MSize::MSize	/usr/include/opencv2/core/core.hpp	/^        MSize(int* _p);$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int* _p)
cv::Mat::MSize::MSize	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MSize::MSize(int* _p) : p(_p) {}$/;"	f	class:cv::Mat::MSize	signature:(int* _p)
cv::Mat::MSize::operator !=	/usr/include/opencv2/core/core.hpp	/^        bool operator != (const MSize& sz) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(const MSize& sz) const
cv::Mat::MSize::operator !=	/usr/include/opencv2/core/mat.hpp	/^inline bool Mat::MSize::operator != (const MSize& sz) const$/;"	f	class:cv::Mat::MSize	signature:(const MSize& sz) const
cv::Mat::MSize::operator ()	/usr/include/opencv2/core/core.hpp	/^        Size operator()() const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:() const
cv::Mat::MSize::operator ()	/usr/include/opencv2/core/mat.hpp	/^inline Size Mat::MSize::operator()() const$/;"	f	class:cv::Mat::MSize	signature:() const
cv::Mat::MSize::operator ==	/usr/include/opencv2/core/core.hpp	/^        bool operator == (const MSize& sz) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(const MSize& sz) const
cv::Mat::MSize::operator ==	/usr/include/opencv2/core/mat.hpp	/^inline bool Mat::MSize::operator == (const MSize& sz) const$/;"	f	class:cv::Mat::MSize	signature:(const MSize& sz) const
cv::Mat::MSize::operator []	/usr/include/opencv2/core/core.hpp	/^        int operator[](int i) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int i) const
cv::Mat::MSize::operator []	/usr/include/opencv2/core/core.hpp	/^        int& operator[](int i);$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int i)
cv::Mat::MSize::operator []	/usr/include/opencv2/core/mat.hpp	/^inline int Mat::MSize::operator[](int i) const { return p[i]; }$/;"	f	class:cv::Mat::MSize	signature:(int i) const
cv::Mat::MSize::operator []	/usr/include/opencv2/core/mat.hpp	/^inline int& Mat::MSize::operator[](int i) { return p[i]; }$/;"	f	class:cv::Mat::MSize	signature:(int i)
cv::Mat::MSize::operator const int*	/usr/include/opencv2/core/core.hpp	/^        operator const int*() const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:() const
cv::Mat::MSize::operator const int*	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MSize::operator const int*() const { return p; }$/;"	f	class:cv::Mat::MSize	signature:() const
cv::Mat::MSize::p	/usr/include/opencv2/core/core.hpp	/^        int* p;$/;"	m	struct:cv::Mat::MSize	access:public
cv::Mat::MStep	/usr/include/opencv2/core/core.hpp	/^    struct CV_EXPORTS MStep$/;"	s	class:cv::Mat	access:public
cv::Mat::MStep::MStep	/usr/include/opencv2/core/core.hpp	/^        MStep();$/;"	p	struct:cv::Mat::MStep	access:public	signature:()
cv::Mat::MStep::MStep	/usr/include/opencv2/core/core.hpp	/^        MStep(size_t s);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(size_t s)
cv::Mat::MStep::MStep	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MStep::MStep() { p = buf; p[0] = p[1] = 0; }$/;"	f	class:cv::Mat::MStep	signature:()
cv::Mat::MStep::MStep	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MStep::MStep(size_t s) { p = buf; p[0] = s; p[1] = 0; }$/;"	f	class:cv::Mat::MStep	signature:(size_t s)
cv::Mat::MStep::buf	/usr/include/opencv2/core/core.hpp	/^        size_t buf[2];$/;"	m	struct:cv::Mat::MStep	access:public
cv::Mat::MStep::operator =	/usr/include/opencv2/core/core.hpp	/^        MStep& operator = (const MStep&);$/;"	p	struct:cv::Mat::MStep	access:protected	signature:(const MStep&)
cv::Mat::MStep::operator =	/usr/include/opencv2/core/core.hpp	/^        MStep& operator = (size_t s);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(size_t s)
cv::Mat::MStep::operator =	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MStep& Mat::MStep::operator = (size_t s)$/;"	f	class:cv::Mat::MStep	signature:(size_t s)
cv::Mat::MStep::operator []	/usr/include/opencv2/core/core.hpp	/^        size_t operator[](int i) const;$/;"	p	struct:cv::Mat::MStep	access:public	signature:(int i) const
cv::Mat::MStep::operator []	/usr/include/opencv2/core/core.hpp	/^        size_t& operator[](int i);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(int i)
cv::Mat::MStep::operator []	/usr/include/opencv2/core/mat.hpp	/^inline size_t Mat::MStep::operator[](int i) const { return p[i]; }$/;"	f	class:cv::Mat::MStep	signature:(int i) const
cv::Mat::MStep::operator []	/usr/include/opencv2/core/mat.hpp	/^inline size_t& Mat::MStep::operator[](int i) { return p[i]; }$/;"	f	class:cv::Mat::MStep	signature:(int i)
cv::Mat::MStep::operator size_t	/usr/include/opencv2/core/core.hpp	/^        operator size_t() const;$/;"	p	struct:cv::Mat::MStep	access:public	signature:() const
cv::Mat::MStep::operator size_t	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MStep::operator size_t() const$/;"	f	class:cv::Mat::MStep	signature:() const
cv::Mat::MStep::p	/usr/include/opencv2/core/core.hpp	/^        size_t* p;$/;"	m	struct:cv::Mat::MStep	access:public
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(Size _size, int _type);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(Size _size, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type, const Scalar& _s)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(Size _size, int _type, void* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type, void* _data, size_t _step=AUTO_STEP)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const CvMat* m, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const CvMat* m, bool copyData=false)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const CvMatND* m, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const CvMatND* m, bool copyData=false)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const IplImage* img, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const IplImage* img, bool copyData=false)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const Mat& m, const Range& rowRange, const Range& colRange=Range::all());$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Range& rowRange, const Range& colRange=Range::all())
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const Mat& m, const Range* ranges);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Range* ranges)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(const Mat& m, const Rect& roi);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Rect& roi)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type, const Scalar& _s)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type, void* _data, const size_t* _steps=0);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type, void* _data, const size_t* _steps=0)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _rows, int _cols, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _rows, int _cols, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type, const Scalar& _s)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    Mat(int _rows, int _cols, int _type, void* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type, void* _data, size_t _step=AUTO_STEP)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int m, int n> explicit Mat(const Matx<_Tp, m, n>& mtx,$/;"	p	class:cv::Mat	access:public	signature:(const Matx<_Tp, m, n>& mtx, bool copyData=true)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> explicit Mat(const Vec<_Tp, n>& vec,$/;"	p	class:cv::Mat	access:public	signature:(const Vec<_Tp, n>& vec, bool copyData=true)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> explicit Mat(const MatCommaInitializer_<_Tp>& commaInitializer);$/;"	p	class:cv::Mat	access:public	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> explicit Mat(const Point3_<_Tp>& pt, bool copyData=true);$/;"	p	class:cv::Mat	access:public	signature:(const Point3_<_Tp>& pt, bool copyData=true)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> explicit Mat(const Point_<_Tp>& pt, bool copyData=true);$/;"	p	class:cv::Mat	access:public	signature:(const Point_<_Tp>& pt, bool copyData=true)
cv::Mat::Mat	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> explicit Mat(const vector<_Tp>& vec, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const vector<_Tp>& vec, bool copyData=false)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat()$/;"	f	class:cv::Mat	signature:()
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type, const Scalar& _s)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type, void* _data, size_t _step)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type, void* _data, size_t _step)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(const CvMat* m, bool copyData)$/;"	f	class:cv::Mat	signature:(const CvMat* m, bool copyData)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(const Mat& m)$/;"	f	class:cv::Mat	signature:(const Mat& m)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(int _dims, const int* _sz, int _type)$/;"	f	class:cv::Mat	signature:(int _dims, const int* _sz, int _type)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(int _dims, const int* _sz, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(int _dims, const int* _sz, int _type, const Scalar& _s)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type, const Scalar& _s)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type, void* _data, size_t _step)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type, void* _data, size_t _step)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp, int m, int n> inline Mat::Mat(const Matx<_Tp,m,n>& M, bool copyData)$/;"	f	class:cv::Mat	signature:(const Matx<_Tp,m,n>& M, bool copyData)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp, int n> inline Mat::Mat(const Vec<_Tp, n>& vec, bool copyData)$/;"	f	class:cv::Mat	signature:(const Vec<_Tp, n>& vec, bool copyData)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const MatCommaInitializer_<_Tp>& commaInitializer)$/;"	f	class:cv::Mat	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const Point3_<_Tp>& pt, bool copyData)$/;"	f	class:cv::Mat	signature:(const Point3_<_Tp>& pt, bool copyData)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const Point_<_Tp>& pt, bool copyData)$/;"	f	class:cv::Mat	signature:(const Point_<_Tp>& pt, bool copyData)
cv::Mat::Mat	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const vector<_Tp>& vec, bool copyData)$/;"	f	class:cv::Mat	signature:(const vector<_Tp>& vec, bool copyData)
cv::Mat::SUBMATRIX_FLAG	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon142
cv::Mat::addref	/usr/include/opencv2/core/core.hpp	/^    void addref();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::addref	/usr/include/opencv2/core/mat.hpp	/^inline void Mat::addref()$/;"	f	class:cv::Mat	signature:()
cv::Mat::adjustROI	/usr/include/opencv2/core/core.hpp	/^    Mat& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::Mat	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
cv::Mat::allocator	/usr/include/opencv2/core/core.hpp	/^    MatAllocator* allocator;$/;"	m	class:cv::Mat	access:public
cv::Mat::assignTo	/usr/include/opencv2/core/core.hpp	/^    void assignTo( Mat& m, int type=-1 ) const;$/;"	p	class:cv::Mat	access:public	signature:( Mat& m, int type=-1 ) const
cv::Mat::assignTo	/usr/include/opencv2/core/mat.hpp	/^inline void Mat::assignTo( Mat& m, int type ) const$/;"	f	class:cv::Mat	signature:( Mat& m, int type ) const
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> _Tp& at(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> const _Tp& at(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& at(Point pt);$/;"	p	class:cv::Mat	access:public	signature:(Point pt)
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& at(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& at(Point pt) const;$/;"	p	class:cv::Mat	access:public	signature:(Point pt) const
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& at(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
cv::Mat::at	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
cv::Mat::at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(Point pt)$/;"	f	class:cv::Mat	signature:(Point pt)
cv::Mat::at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(const int* idx)$/;"	f	class:cv::Mat	signature:(const int* idx)
cv::Mat::at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0)$/;"	f	class:cv::Mat	signature:(int i0)
cv::Mat::at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0, int i1)$/;"	f	class:cv::Mat	signature:(int i0, int i1)
cv::Mat::at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0, int i1, int i2)$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2)
cv::Mat::at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(Point pt) const$/;"	f	class:cv::Mat	signature:(Point pt) const
cv::Mat::at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(const int* idx) const$/;"	f	class:cv::Mat	signature:(const int* idx) const
cv::Mat::at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0) const$/;"	f	class:cv::Mat	signature:(int i0) const
cv::Mat::at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1) const$/;"	f	class:cv::Mat	signature:(int i0, int i1) const
cv::Mat::at	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1, int i2) const$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2) const
cv::Mat::begin	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> MatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::begin	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> MatIterator_<_Tp> begin();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat::begin() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat::begin()$/;"	f	class:cv::Mat	signature:()
cv::Mat::channels	/usr/include/opencv2/core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::channels	/usr/include/opencv2/core/mat.hpp	/^inline int Mat::channels() const { return CV_MAT_CN(flags); }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::checkVector	/usr/include/opencv2/core/core.hpp	/^    int checkVector(int elemChannels, int depth=-1, bool requireContinuous=true) const;$/;"	p	class:cv::Mat	access:public	signature:(int elemChannels, int depth=-1, bool requireContinuous=true) const
cv::Mat::clone	/usr/include/opencv2/core/core.hpp	/^    Mat clone() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::clone	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::clone() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::col	/usr/include/opencv2/core/core.hpp	/^    Mat col(int x) const;$/;"	p	class:cv::Mat	access:public	signature:(int x) const
cv::Mat::col	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::col(int x) const { return Mat(*this, Range::all(), Range(x, x+1)); }$/;"	f	class:cv::Mat	signature:(int x) const
cv::Mat::colRange	/usr/include/opencv2/core/core.hpp	/^    Mat colRange(const Range& r) const;$/;"	p	class:cv::Mat	access:public	signature:(const Range& r) const
cv::Mat::colRange	/usr/include/opencv2/core/core.hpp	/^    Mat colRange(int startcol, int endcol) const;$/;"	p	class:cv::Mat	access:public	signature:(int startcol, int endcol) const
cv::Mat::colRange	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::colRange(const Range& r) const$/;"	f	class:cv::Mat	signature:(const Range& r) const
cv::Mat::colRange	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::colRange(int startcol, int endcol) const$/;"	f	class:cv::Mat	signature:(int startcol, int endcol) const
cv::Mat::cols	/usr/include/opencv2/core/core.hpp	/^    int rows, cols;$/;"	m	class:cv::Mat	access:public
cv::Mat::convertTo	/usr/include/opencv2/core/core.hpp	/^    void convertTo( Mat& m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::Mat	access:public	signature:( Mat& m, int rtype, double alpha=1, double beta=0 ) const
cv::Mat::copySize	/usr/include/opencv2/core/core.hpp	/^    void copySize(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
cv::Mat::copyTo	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> void copyTo( vector<_Tp>& v ) const;$/;"	p	class:cv::Mat	access:public	signature:( vector<_Tp>& v ) const
cv::Mat::copyTo	/usr/include/opencv2/core/core.hpp	/^    void copyTo( Mat& m ) const;$/;"	p	class:cv::Mat	access:public	signature:( Mat& m ) const
cv::Mat::copyTo	/usr/include/opencv2/core/core.hpp	/^    void copyTo( Mat& m, const Mat& mask ) const;$/;"	p	class:cv::Mat	access:public	signature:( Mat& m, const Mat& mask ) const
cv::Mat::copyTo	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat::copyTo(vector<_Tp>& v) const$/;"	f	class:cv::Mat	signature:(vector<_Tp>& v) const
cv::Mat::create	/usr/include/opencv2/core/core.hpp	/^    void create(Size _size, int _type);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type)
cv::Mat::create	/usr/include/opencv2/core/core.hpp	/^    void create(int _ndims, const int* _sizes, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type)
cv::Mat::create	/usr/include/opencv2/core/core.hpp	/^    void create(int _rows, int _cols, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type)
cv::Mat::create	/usr/include/opencv2/core/mat.hpp	/^inline void Mat::create(Size _sz, int _type)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type)
cv::Mat::create	/usr/include/opencv2/core/mat.hpp	/^inline void Mat::create(int _rows, int _cols, int _type)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type)
cv::Mat::cross	/usr/include/opencv2/core/core.hpp	/^    Mat cross(const Mat& m) const;$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m) const
cv::Mat::data	/usr/include/opencv2/core/core.hpp	/^    uchar* data;$/;"	m	class:cv::Mat	access:public
cv::Mat::dataend	/usr/include/opencv2/core/core.hpp	/^    uchar* dataend;$/;"	m	class:cv::Mat	access:public
cv::Mat::datalimit	/usr/include/opencv2/core/core.hpp	/^    uchar* datalimit;$/;"	m	class:cv::Mat	access:public
cv::Mat::datastart	/usr/include/opencv2/core/core.hpp	/^    uchar* datastart;$/;"	m	class:cv::Mat	access:public
cv::Mat::deallocate	/usr/include/opencv2/core/core.hpp	/^    void deallocate();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::depth	/usr/include/opencv2/core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::depth	/usr/include/opencv2/core/mat.hpp	/^inline int Mat::depth() const { return CV_MAT_DEPTH(flags); }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::diag	/usr/include/opencv2/core/core.hpp	/^    Mat diag(int d=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int d=0) const
cv::Mat::diag	/usr/include/opencv2/core/core.hpp	/^    static Mat diag(const Mat& d);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& d)
cv::Mat::diag	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::diag(const Mat& d)$/;"	f	class:cv::Mat	signature:(const Mat& d)
cv::Mat::dims	/usr/include/opencv2/core/core.hpp	/^    int dims;$/;"	m	class:cv::Mat	access:public
cv::Mat::dot	/usr/include/opencv2/core/core.hpp	/^    double dot(const Mat& m) const;$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m) const
cv::Mat::elemSize	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::elemSize	/usr/include/opencv2/core/mat.hpp	/^inline size_t Mat::elemSize() const { return dims > 0 ? step.p[dims-1] : 0; }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::elemSize1	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::elemSize1	/usr/include/opencv2/core/mat.hpp	/^inline size_t Mat::elemSize1() const { return CV_ELEM_SIZE1(flags); }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::empty	/usr/include/opencv2/core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::empty	/usr/include/opencv2/core/mat.hpp	/^inline bool Mat::empty() const { return data == 0 || total() == 0; }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::end	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> MatConstIterator_<_Tp> end() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::end	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> MatIterator_<_Tp> end();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat::end() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat::end()$/;"	f	class:cv::Mat	signature:()
cv::Mat::eye	/usr/include/opencv2/core/core.hpp	/^    static MatExpr eye(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
cv::Mat::eye	/usr/include/opencv2/core/core.hpp	/^    static MatExpr eye(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
cv::Mat::flags	/usr/include/opencv2/core/core.hpp	/^    int flags;$/;"	m	class:cv::Mat	access:public
cv::Mat::inv	/usr/include/opencv2/core/core.hpp	/^    MatExpr inv(int method=DECOMP_LU) const;$/;"	p	class:cv::Mat	access:public	signature:(int method=DECOMP_LU) const
cv::Mat::isContinuous	/usr/include/opencv2/core/core.hpp	/^    bool isContinuous() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::isContinuous	/usr/include/opencv2/core/mat.hpp	/^inline bool Mat::isContinuous() const { return (flags & CONTINUOUS_FLAG) != 0; }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::isSubmatrix	/usr/include/opencv2/core/core.hpp	/^    bool isSubmatrix() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::isSubmatrix	/usr/include/opencv2/core/mat.hpp	/^inline bool Mat::isSubmatrix() const { return (flags & SUBMATRIX_FLAG) != 0; }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::locateROI	/usr/include/opencv2/core/core.hpp	/^    void locateROI( Size& wholeSize, Point& ofs ) const;$/;"	p	class:cv::Mat	access:public	signature:( Size& wholeSize, Point& ofs ) const
cv::Mat::mul	/usr/include/opencv2/core/core.hpp	/^    MatExpr mul(const Mat& m, double scale=1) const;$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, double scale=1) const
cv::Mat::mul	/usr/include/opencv2/core/core.hpp	/^    MatExpr mul(const MatExpr& m, double scale=1) const;$/;"	p	class:cv::Mat	access:public	signature:(const MatExpr& m, double scale=1) const
cv::Mat::ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
cv::Mat::ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(int ndims, const int* sz, int type);$/;"	p	class:cv::Mat	access:public	signature:(int ndims, const int* sz, int type)
cv::Mat::ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
cv::Mat::operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat operator()( Range rowRange, Range colRange ) const;$/;"	p	class:cv::Mat	access:public	signature:( Range rowRange, Range colRange ) const
cv::Mat::operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat operator()( const Range* ranges ) const;$/;"	p	class:cv::Mat	access:public	signature:( const Range* ranges ) const
cv::Mat::operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat operator()( const Rect& roi ) const;$/;"	p	class:cv::Mat	access:public	signature:( const Rect& roi ) const
cv::Mat::operator ()	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::operator()( Range rowRange, Range colRange ) const$/;"	f	class:cv::Mat	signature:( Range rowRange, Range colRange ) const
cv::Mat::operator ()	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::operator()( const Rect& roi ) const$/;"	f	class:cv::Mat	signature:( const Rect& roi ) const
cv::Mat::operator ()	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::operator()(const Range* ranges) const$/;"	f	class:cv::Mat	signature:(const Range* ranges) const
cv::Mat::operator =	/usr/include/opencv2/core/core.hpp	/^    Mat& operator = (const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
cv::Mat::operator =	/usr/include/opencv2/core/core.hpp	/^    Mat& operator = (const MatExpr& expr);$/;"	p	class:cv::Mat	access:public	signature:(const MatExpr& expr)
cv::Mat::operator =	/usr/include/opencv2/core/core.hpp	/^    Mat& operator = (const Scalar& s);$/;"	p	class:cv::Mat	access:public	signature:(const Scalar& s)
cv::Mat::operator =	/usr/include/opencv2/core/mat.hpp	/^inline Mat& Mat::operator = (const Mat& m)$/;"	f	class:cv::Mat	signature:(const Mat& m)
cv::Mat::operator =	/usr/include/opencv2/core/mat.hpp	/^inline Mat& Mat::operator = (const MatExpr& e)$/;"	f	class:cv::Mat	signature:(const MatExpr& e)
cv::Mat::operator CvMat	/usr/include/opencv2/core/core.hpp	/^    operator CvMat() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator CvMat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::operator CvMat() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::operator CvMatND	/usr/include/opencv2/core/core.hpp	/^    operator CvMatND() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator IplImage	/usr/include/opencv2/core/core.hpp	/^    operator IplImage() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator Matx<_Tp, m, n>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int m, int n> operator Matx<_Tp, m, n>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator Matx<_Tp, m, n>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp, int m, int n> inline Mat::operator Matx<_Tp, m, n>() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::operator Vec<_Tp, n>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> operator Vec<_Tp, n>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator Vec<_Tp, n>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp, int n> inline Mat::operator Vec<_Tp, n>() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::operator vector<_Tp>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> operator vector<_Tp>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator vector<_Tp>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat::operator vector<_Tp>() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::pop_back	/usr/include/opencv2/core/core.hpp	/^    void pop_back(size_t nelems=1);$/;"	p	class:cv::Mat	access:public	signature:(size_t nelems=1)
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    const uchar* ptr(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    const uchar* ptr(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    const uchar* ptr(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    const uchar* ptr(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<int n> const uchar* ptr(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<int n> uchar* ptr(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> _Tp* ptr(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> const _Tp* ptr(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp* ptr(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
cv::Mat::ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
cv::Mat::ptr	/usr/include/opencv2/core/mat.hpp	/^inline const uchar* Mat::ptr(const int* idx) const$/;"	f	class:cv::Mat	signature:(const int* idx) const
cv::Mat::ptr	/usr/include/opencv2/core/mat.hpp	/^inline const uchar* Mat::ptr(int i0, int i1) const$/;"	f	class:cv::Mat	signature:(int i0, int i1) const
cv::Mat::ptr	/usr/include/opencv2/core/mat.hpp	/^inline const uchar* Mat::ptr(int i0, int i1, int i2) const$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2) const
cv::Mat::ptr	/usr/include/opencv2/core/mat.hpp	/^inline const uchar* Mat::ptr(int y) const$/;"	f	class:cv::Mat	signature:(int y) const
cv::Mat::ptr	/usr/include/opencv2/core/mat.hpp	/^inline uchar* Mat::ptr(const int* idx)$/;"	f	class:cv::Mat	signature:(const int* idx)
cv::Mat::ptr	/usr/include/opencv2/core/mat.hpp	/^inline uchar* Mat::ptr(int i0, int i1)$/;"	f	class:cv::Mat	signature:(int i0, int i1)
cv::Mat::ptr	/usr/include/opencv2/core/mat.hpp	/^inline uchar* Mat::ptr(int i0, int i1, int i2)$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2)
cv::Mat::ptr	/usr/include/opencv2/core/mat.hpp	/^inline uchar* Mat::ptr(int y)$/;"	f	class:cv::Mat	signature:(int y)
cv::Mat::ptr	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat::ptr(int y)$/;"	f	class:cv::Mat	signature:(int y)
cv::Mat::ptr	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat::ptr(int y) const$/;"	f	class:cv::Mat	signature:(int y) const
cv::Mat::push_back	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> void push_back(const Mat_<_Tp>& elem);$/;"	p	class:cv::Mat	access:public	signature:(const Mat_<_Tp>& elem)
cv::Mat::push_back	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> void push_back(const _Tp& elem);$/;"	p	class:cv::Mat	access:public	signature:(const _Tp& elem)
cv::Mat::push_back	/usr/include/opencv2/core/core.hpp	/^    void push_back(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
cv::Mat::push_back	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat::push_back(const Mat_<_Tp>& m)$/;"	f	class:cv::Mat	signature:(const Mat_<_Tp>& m)
cv::Mat::push_back	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat::push_back(const _Tp& elem)$/;"	f	class:cv::Mat	signature:(const _Tp& elem)
cv::Mat::push_back_	/usr/include/opencv2/core/core.hpp	/^    void push_back_(const void* elem);$/;"	p	class:cv::Mat	access:public	signature:(const void* elem)
cv::Mat::refcount	/usr/include/opencv2/core/core.hpp	/^    int* refcount;$/;"	m	class:cv::Mat	access:public
cv::Mat::release	/usr/include/opencv2/core/core.hpp	/^    void release();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::release	/usr/include/opencv2/core/mat.hpp	/^inline void Mat::release()$/;"	f	class:cv::Mat	signature:()
cv::Mat::reserve	/usr/include/opencv2/core/core.hpp	/^    void reserve(size_t sz);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz)
cv::Mat::reshape	/usr/include/opencv2/core/core.hpp	/^    Mat reshape(int _cn, int _newndims, const int* _newsz) const;$/;"	p	class:cv::Mat	access:public	signature:(int _cn, int _newndims, const int* _newsz) const
cv::Mat::reshape	/usr/include/opencv2/core/core.hpp	/^    Mat reshape(int _cn, int _rows=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int _cn, int _rows=0) const
cv::Mat::resize	/usr/include/opencv2/core/core.hpp	/^    void resize(size_t sz);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz)
cv::Mat::resize	/usr/include/opencv2/core/core.hpp	/^    void resize(size_t sz, const Scalar& s);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz, const Scalar& s)
cv::Mat::row	/usr/include/opencv2/core/core.hpp	/^    Mat row(int y) const;$/;"	p	class:cv::Mat	access:public	signature:(int y) const
cv::Mat::row	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::row(int y) const { return Mat(*this, Range(y, y+1), Range::all()); }$/;"	f	class:cv::Mat	signature:(int y) const
cv::Mat::rowRange	/usr/include/opencv2/core/core.hpp	/^    Mat rowRange(const Range& r) const;$/;"	p	class:cv::Mat	access:public	signature:(const Range& r) const
cv::Mat::rowRange	/usr/include/opencv2/core/core.hpp	/^    Mat rowRange(int startrow, int endrow) const;$/;"	p	class:cv::Mat	access:public	signature:(int startrow, int endrow) const
cv::Mat::rowRange	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::rowRange(const Range& r) const$/;"	f	class:cv::Mat	signature:(const Range& r) const
cv::Mat::rowRange	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::rowRange(int startrow, int endrow) const$/;"	f	class:cv::Mat	signature:(int startrow, int endrow) const
cv::Mat::rows	/usr/include/opencv2/core/core.hpp	/^    int rows, cols;$/;"	m	class:cv::Mat	access:public
cv::Mat::setTo	/usr/include/opencv2/core/core.hpp	/^    Mat& setTo(const Scalar& s, const Mat& mask=Mat());$/;"	p	class:cv::Mat	access:public	signature:(const Scalar& s, const Mat& mask=Mat())
cv::Mat::size	/usr/include/opencv2/core/core.hpp	/^    MSize size;$/;"	m	class:cv::Mat	access:public
cv::Mat::step	/usr/include/opencv2/core/core.hpp	/^    MStep step;$/;"	m	class:cv::Mat	access:public
cv::Mat::step1	/usr/include/opencv2/core/core.hpp	/^    size_t step1(int i=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i=0) const
cv::Mat::step1	/usr/include/opencv2/core/mat.hpp	/^inline size_t Mat::step1(int i) const { return step.p[i]\/elemSize1(); }$/;"	f	class:cv::Mat	signature:(int i) const
cv::Mat::t	/usr/include/opencv2/core/core.hpp	/^    MatExpr t() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::total	/usr/include/opencv2/core/core.hpp	/^    size_t total() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::total	/usr/include/opencv2/core/mat.hpp	/^inline size_t Mat::total() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::type	/usr/include/opencv2/core/core.hpp	/^    int type() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::type	/usr/include/opencv2/core/mat.hpp	/^inline int Mat::type() const { return CV_MAT_TYPE(flags); }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
cv::Mat::zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(int ndims, const int* sz, int type);$/;"	p	class:cv::Mat	access:public	signature:(int ndims, const int* sz, int type)
cv::Mat::zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
cv::Mat::~Mat	/usr/include/opencv2/core/core.hpp	/^    ~Mat();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::~Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::~Mat()$/;"	f	class:cv::Mat	signature:()
cv::MatAllocator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatAllocator$/;"	c	namespace:cv
cv::MatAllocator::MatAllocator	/usr/include/opencv2/core/core.hpp	/^    MatAllocator() {}$/;"	f	class:cv::MatAllocator	access:public	signature:()
cv::MatAllocator::allocate	/usr/include/opencv2/core/core.hpp	/^    virtual void allocate(int dims, const int* sizes, int type, int*& refcount,$/;"	p	class:cv::MatAllocator	access:public	signature:(int dims, const int* sizes, int type, int*& refcount, uchar*& datastart, uchar*& data, size_t* step)
cv::MatAllocator::deallocate	/usr/include/opencv2/core/core.hpp	/^    virtual void deallocate(int* refcount, uchar* datastart, uchar* data) = 0;$/;"	p	class:cv::MatAllocator	access:public	signature:(int* refcount, uchar* datastart, uchar* data)
cv::MatAllocator::~MatAllocator	/usr/include/opencv2/core/core.hpp	/^    virtual ~MatAllocator() {}$/;"	f	class:cv::MatAllocator	access:public	signature:()
cv::MatArg	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatArg;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatCommaInitializer_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatCommaInitializer_$/;"	c	namespace:cv
cv::MatCommaInitializer_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatCommaInitializer_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatCommaInitializer_::MatCommaInitializer_	/usr/include/opencv2/core/core.hpp	/^    MatCommaInitializer_(Mat_<_Tp>* _m);$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:(Mat_<_Tp>* _m)
cv::MatCommaInitializer_::MatCommaInitializer_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatCommaInitializer_<_Tp>::MatCommaInitializer_(Mat_<_Tp>* _m) : it(_m) {}$/;"	f	class:cv::MatCommaInitializer_	signature:(Mat_<_Tp>* _m)
cv::MatCommaInitializer_::it	/usr/include/opencv2/core/core.hpp	/^    MatIterator_<_Tp> it;$/;"	m	class:cv::MatCommaInitializer_	access:protected
cv::MatCommaInitializer_::operator *	/usr/include/opencv2/core/core.hpp	/^    Mat_<_Tp> operator *() const;$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:() const
cv::MatCommaInitializer_::operator *	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> MatCommaInitializer_<_Tp>::operator *() const$/;"	f	class:cv::MatCommaInitializer_	signature:() const
cv::MatCommaInitializer_::operator ,	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> MatCommaInitializer_<_Tp>& operator , (T2 v);$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:(T2 v)
cv::MatCommaInitializer_::operator ,	/usr/include/opencv2/core/mat.hpp	/^MatCommaInitializer_<_Tp>::operator , (T2 v)$/;"	f	class:cv::MatCommaInitializer_	signature:(T2 v)
cv::MatCommaInitializer_::operator Mat_<_Tp>	/usr/include/opencv2/core/core.hpp	/^    operator Mat_<_Tp>() const;$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:() const
cv::MatCommaInitializer_::operator Mat_<_Tp>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatCommaInitializer_<_Tp>::operator Mat_<_Tp>() const$/;"	f	class:cv::MatCommaInitializer_	signature:() const
cv::MatConstIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatConstIterator$/;"	c	namespace:cv
cv::MatConstIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatConstIterator;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatConstIterator::MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
cv::MatConstIterator::MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator(const Mat* _m);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m)
cv::MatConstIterator::MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator(const Mat* _m, Point _pt);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, Point _pt)
cv::MatConstIterator::MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator(const Mat* _m, const int* _idx);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, const int* _idx)
cv::MatConstIterator::MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator(const Mat* _m, int _row, int _col=0);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, int _row, int _col=0)
cv::MatConstIterator::MatConstIterator	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator(const MatConstIterator& it);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const MatConstIterator& it)
cv::MatConstIterator::MatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator::MatConstIterator()$/;"	f	class:cv::MatConstIterator	signature:()
cv::MatConstIterator::MatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m)
cv::MatConstIterator::MatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m, Point _pt)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m, Point _pt)
cv::MatConstIterator::MatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m, int _row, int _col)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m, int _row, int _col)
cv::MatConstIterator::MatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const MatConstIterator& it)$/;"	f	class:cv::MatConstIterator	signature:(const MatConstIterator& it)
cv::MatConstIterator::difference_type	/usr/include/opencv2/core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::MatConstIterator	access:public
cv::MatConstIterator::elemSize	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize;$/;"	m	class:cv::MatConstIterator	access:public
cv::MatConstIterator::iterator_category	/usr/include/opencv2/core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatConstIterator	access:public
cv::MatConstIterator::lpos	/usr/include/opencv2/core/core.hpp	/^    ptrdiff_t lpos() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
cv::MatConstIterator::m	/usr/include/opencv2/core/core.hpp	/^    const Mat* m;$/;"	m	class:cv::MatConstIterator	access:public
cv::MatConstIterator::operator *	/usr/include/opencv2/core/core.hpp	/^    uchar* operator *() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
cv::MatConstIterator::operator *	/usr/include/opencv2/core/mat.hpp	/^inline uchar* MatConstIterator::operator *() const { return ptr; }$/;"	f	class:cv::MatConstIterator	signature:() const
cv::MatConstIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator operator ++(int);$/;"	p	class:cv::MatConstIterator	access:public	signature:(int)
cv::MatConstIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator& operator ++();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
cv::MatConstIterator::operator ++	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator MatConstIterator::operator ++(int)$/;"	f	class:cv::MatConstIterator	signature:(int)
cv::MatConstIterator::operator ++	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator ++()$/;"	f	class:cv::MatConstIterator	signature:()
cv::MatConstIterator::operator +=	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs)
cv::MatConstIterator::operator +=	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t ofs)
cv::MatConstIterator::operator --	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator operator --(int);$/;"	p	class:cv::MatConstIterator	access:public	signature:(int)
cv::MatConstIterator::operator --	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator& operator --();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
cv::MatConstIterator::operator --	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator MatConstIterator::operator --(int)$/;"	f	class:cv::MatConstIterator	signature:(int)
cv::MatConstIterator::operator --	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator --()$/;"	f	class:cv::MatConstIterator	signature:()
cv::MatConstIterator::operator -=	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs)
cv::MatConstIterator::operator -=	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t ofs)
cv::MatConstIterator::operator =	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator& operator = (const MatConstIterator& it);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const MatConstIterator& it)
cv::MatConstIterator::operator =	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator = (const MatConstIterator& it )$/;"	f	class:cv::MatConstIterator	signature:(const MatConstIterator& it )
cv::MatConstIterator::operator []	/usr/include/opencv2/core/core.hpp	/^    uchar* operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t i) const
cv::MatConstIterator::operator []	/usr/include/opencv2/core/mat.hpp	/^inline uchar* MatConstIterator::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t i) const
cv::MatConstIterator::pointer	/usr/include/opencv2/core/core.hpp	/^    typedef const uchar** pointer;$/;"	t	class:cv::MatConstIterator	access:public
cv::MatConstIterator::pos	/usr/include/opencv2/core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
cv::MatConstIterator::pos	/usr/include/opencv2/core/core.hpp	/^    void pos(int* _idx) const;$/;"	p	class:cv::MatConstIterator	access:public	signature:(int* _idx) const
cv::MatConstIterator::ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::MatConstIterator	access:public
cv::MatConstIterator::reference	/usr/include/opencv2/core/core.hpp	/^    typedef uchar* reference;$/;"	t	class:cv::MatConstIterator	access:public
cv::MatConstIterator::seek	/usr/include/opencv2/core/core.hpp	/^    void seek(const int* _idx, bool relative=false);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const int* _idx, bool relative=false)
cv::MatConstIterator::seek	/usr/include/opencv2/core/core.hpp	/^    void seek(ptrdiff_t ofs, bool relative=false);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs, bool relative=false)
cv::MatConstIterator::sliceEnd	/usr/include/opencv2/core/core.hpp	/^    uchar* sliceEnd;$/;"	m	class:cv::MatConstIterator	access:public
cv::MatConstIterator::sliceStart	/usr/include/opencv2/core/core.hpp	/^    uchar* sliceStart;$/;"	m	class:cv::MatConstIterator	access:public
cv::MatConstIterator::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef uchar* value_type;$/;"	t	class:cv::MatConstIterator	access:public
cv::MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatConstIterator_ : public MatConstIterator$/;"	c	namespace:cv	inherits:MatConstIterator
cv::MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatConstIterator_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatConstIterator_::MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
cv::MatConstIterator_::MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_(const MatConstIterator_& it);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const MatConstIterator_& it)
cv::MatConstIterator_::MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m)
cv::MatConstIterator_::MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, Point _pt)
cv::MatConstIterator_::MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, const int* _idx);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, const int* _idx)
cv::MatConstIterator_::MatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col=0);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, int _row, int _col=0)
cv::MatConstIterator_::MatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^    MatConstIterator_(const MatConstIterator_& it)$/;"	f	class:cv::MatConstIterator_	signature:(const MatConstIterator_& it)
cv::MatConstIterator_::MatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m, Point _pt)
cv::MatConstIterator_::MatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m, int _row, int _col)
cv::MatConstIterator_::MatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_() {}$/;"	f	class:cv::MatConstIterator_	signature:()
cv::MatConstIterator_::MatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m)
cv::MatConstIterator_::difference_type	/usr/include/opencv2/core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::MatConstIterator_	access:public
cv::MatConstIterator_::iterator_category	/usr/include/opencv2/core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatConstIterator_	access:public
cv::MatConstIterator_::operator *	/usr/include/opencv2/core/core.hpp	/^    _Tp operator *() const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:() const
cv::MatConstIterator_::operator *	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }$/;"	f	class:cv::MatConstIterator_	signature:() const
cv::MatConstIterator_::operator ++	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_ operator ++(int);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(int)
cv::MatConstIterator_::operator ++	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_& operator ++();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
cv::MatConstIterator_::operator ++	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::MatConstIterator_	signature:(int)
cv::MatConstIterator_::operator ++	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator ++()$/;"	f	class:cv::MatConstIterator_	signature:()
cv::MatConstIterator_::operator +=	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t ofs)
cv::MatConstIterator_::operator +=	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t ofs)
cv::MatConstIterator_::operator --	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_ operator --(int);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(int)
cv::MatConstIterator_::operator --	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_& operator --();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
cv::MatConstIterator_::operator --	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator --(int)$/;"	f	class:cv::MatConstIterator_	signature:(int)
cv::MatConstIterator_::operator --	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator --()$/;"	f	class:cv::MatConstIterator_	signature:()
cv::MatConstIterator_::operator -=	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t ofs)
cv::MatConstIterator_::operator -=	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t ofs)
cv::MatConstIterator_::operator =	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_& operator = (const MatConstIterator_& it);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const MatConstIterator_& it)
cv::MatConstIterator_::operator =	/usr/include/opencv2/core/mat.hpp	/^    MatConstIterator_<_Tp>::operator = (const MatConstIterator_& it )$/;"	f	class:cv::MatConstIterator_	signature:(const MatConstIterator_& it )
cv::MatConstIterator_::operator []	/usr/include/opencv2/core/core.hpp	/^    _Tp operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t i) const
cv::MatConstIterator_::operator []	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t i) const
cv::MatConstIterator_::pointer	/usr/include/opencv2/core/core.hpp	/^    typedef const _Tp* pointer;$/;"	t	class:cv::MatConstIterator_	access:public
cv::MatConstIterator_::pos	/usr/include/opencv2/core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:() const
cv::MatConstIterator_::pos	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Point MatConstIterator_<_Tp>::pos() const$/;"	f	class:cv::MatConstIterator_	signature:() const
cv::MatConstIterator_::reference	/usr/include/opencv2/core/core.hpp	/^    typedef const _Tp& reference;$/;"	t	class:cv::MatConstIterator_	access:public
cv::MatConstIterator_::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::MatConstIterator_	access:public
cv::MatExpr	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatExpr;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatExpr	/usr/include/opencv2/core/mat.hpp	/^class CV_EXPORTS MatExpr$/;"	c	namespace:cv
cv::MatExpr::MatExpr	/usr/include/opencv2/core/mat.hpp	/^    MatExpr() : op(0), flags(0), a(Mat()), b(Mat()), c(Mat()), alpha(0), beta(0), s(Scalar()) {}$/;"	f	class:cv::MatExpr	access:public	signature:()
cv::MatExpr::MatExpr	/usr/include/opencv2/core/mat.hpp	/^    MatExpr(const MatOp* _op, int _flags, const Mat& _a=Mat(), const Mat& _b=Mat(),$/;"	f	class:cv::MatExpr	access:public	signature:(const MatOp* _op, int _flags, const Mat& _a=Mat(), const Mat& _b=Mat(), const Mat& _c=Mat(), double _alpha=1, double _beta=1, const Scalar& _s=Scalar())
cv::MatExpr::MatExpr	/usr/include/opencv2/core/mat.hpp	/^    explicit MatExpr(const Mat& m);$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m)
cv::MatExpr::a	/usr/include/opencv2/core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::alpha	/usr/include/opencv2/core/mat.hpp	/^    double alpha, beta;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::b	/usr/include/opencv2/core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::beta	/usr/include/opencv2/core/mat.hpp	/^    double alpha, beta;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::c	/usr/include/opencv2/core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::col	/usr/include/opencv2/core/mat.hpp	/^    MatExpr col(int x) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int x) const
cv::MatExpr::cross	/usr/include/opencv2/core/mat.hpp	/^    Mat cross(const Mat& m) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m) const
cv::MatExpr::diag	/usr/include/opencv2/core/mat.hpp	/^    MatExpr diag(int d=0) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int d=0) const
cv::MatExpr::dot	/usr/include/opencv2/core/mat.hpp	/^    double dot(const Mat& m) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m) const
cv::MatExpr::flags	/usr/include/opencv2/core/mat.hpp	/^    int flags;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::inv	/usr/include/opencv2/core/mat.hpp	/^    MatExpr inv(int method = DECOMP_LU) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int method = DECOMP_LU) const
cv::MatExpr::mul	/usr/include/opencv2/core/mat.hpp	/^    MatExpr mul(const Mat& m, double scale=1) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m, double scale=1) const
cv::MatExpr::mul	/usr/include/opencv2/core/mat.hpp	/^    MatExpr mul(const MatExpr& e, double scale=1) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const MatExpr& e, double scale=1) const
cv::MatExpr::op	/usr/include/opencv2/core/mat.hpp	/^    const MatOp* op;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::operator ()	/usr/include/opencv2/core/mat.hpp	/^    MatExpr operator()( const Range& rowRange, const Range& colRange ) const;$/;"	p	class:cv::MatExpr	access:public	signature:( const Range& rowRange, const Range& colRange ) const
cv::MatExpr::operator ()	/usr/include/opencv2/core/mat.hpp	/^    MatExpr operator()( const Rect& roi ) const;$/;"	p	class:cv::MatExpr	access:public	signature:( const Rect& roi ) const
cv::MatExpr::operator Mat	/usr/include/opencv2/core/mat.hpp	/^    operator Mat() const$/;"	f	class:cv::MatExpr	access:public	signature:() const
cv::MatExpr::operator Mat_<_Tp>	/usr/include/opencv2/core/mat.hpp	/^    template<typename _Tp> operator Mat_<_Tp>() const$/;"	f	class:cv::MatExpr	access:public	signature:() const
cv::MatExpr::row	/usr/include/opencv2/core/mat.hpp	/^    MatExpr row(int y) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int y) const
cv::MatExpr::s	/usr/include/opencv2/core/mat.hpp	/^    Scalar s;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::t	/usr/include/opencv2/core/mat.hpp	/^    MatExpr t() const;$/;"	p	class:cv::MatExpr	access:public	signature:() const
cv::MatIterator_	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatIterator_ : public MatConstIterator_<_Tp>$/;"	c	namespace:cv	inherits:MatConstIterator_
cv::MatIterator_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatIterator_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_();$/;"	p	class:cv::MatIterator_	access:public	signature:()
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_(Mat_<_Tp>* _m);$/;"	p	class:cv::MatIterator_	access:public	signature:(Mat_<_Tp>* _m)
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_(Mat_<_Tp>* _m, int _row, int _col=0);$/;"	p	class:cv::MatIterator_	access:public	signature:(Mat_<_Tp>* _m, int _row, int _col=0)
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_(const MatIterator_& it);$/;"	p	class:cv::MatIterator_	access:public	signature:(const MatIterator_& it)
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_(const Mat_<_Tp>* _m, Point _pt);$/;"	p	class:cv::MatIterator_	access:public	signature:(const Mat_<_Tp>* _m, Point _pt)
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/core.hpp	/^    MatIterator_(const Mat_<_Tp>* _m, const int* _idx);$/;"	p	class:cv::MatIterator_	access:public	signature:(const Mat_<_Tp>* _m, const int* _idx)
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_() : MatConstIterator_<_Tp>() {}$/;"	f	class:cv::MatIterator_	signature:()
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m)$/;"	f	class:cv::MatIterator_	signature:(Mat_<_Tp>* _m)
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, int _row, int _col)$/;"	f	class:cv::MatIterator_	signature:(Mat_<_Tp>* _m, int _row, int _col)
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const MatIterator_& it)$/;"	f	class:cv::MatIterator_	signature:(const MatIterator_& it)
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, Point _pt)$/;"	f	class:cv::MatIterator_	signature:(const Mat_<_Tp>* _m, Point _pt)
cv::MatIterator_::MatIterator_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, const int* _idx)$/;"	f	class:cv::MatIterator_	signature:(const Mat_<_Tp>* _m, const int* _idx)
cv::MatIterator_::iterator_category	/usr/include/opencv2/core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatIterator_	access:public
cv::MatIterator_::operator *	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator *() const;$/;"	p	class:cv::MatIterator_	access:public	signature:() const
cv::MatIterator_::operator *	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }$/;"	f	class:cv::MatIterator_	signature:() const
cv::MatIterator_::operator ++	/usr/include/opencv2/core/core.hpp	/^    MatIterator_ operator ++(int);$/;"	p	class:cv::MatIterator_	access:public	signature:(int)
cv::MatIterator_::operator ++	/usr/include/opencv2/core/core.hpp	/^    MatIterator_& operator ++();$/;"	p	class:cv::MatIterator_	access:public	signature:()
cv::MatIterator_::operator ++	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::MatIterator_	signature:(int)
cv::MatIterator_::operator ++	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator ++()$/;"	f	class:cv::MatIterator_	signature:()
cv::MatIterator_::operator +=	/usr/include/opencv2/core/core.hpp	/^    MatIterator_& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t ofs)
cv::MatIterator_::operator +=	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t ofs)
cv::MatIterator_::operator --	/usr/include/opencv2/core/core.hpp	/^    MatIterator_ operator --(int);$/;"	p	class:cv::MatIterator_	access:public	signature:(int)
cv::MatIterator_::operator --	/usr/include/opencv2/core/core.hpp	/^    MatIterator_& operator --();$/;"	p	class:cv::MatIterator_	access:public	signature:()
cv::MatIterator_::operator --	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator --(int)$/;"	f	class:cv::MatIterator_	signature:(int)
cv::MatIterator_::operator --	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator --()$/;"	f	class:cv::MatIterator_	signature:()
cv::MatIterator_::operator -=	/usr/include/opencv2/core/core.hpp	/^    MatIterator_& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t ofs)
cv::MatIterator_::operator -=	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t ofs)
cv::MatIterator_::operator =	/usr/include/opencv2/core/core.hpp	/^    MatIterator_& operator = (const MatIterator_<_Tp>& it );$/;"	p	class:cv::MatIterator_	access:public	signature:(const MatIterator_<_Tp>& it )
cv::MatIterator_::operator =	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator = (const MatIterator_<_Tp>& it )$/;"	f	class:cv::MatIterator_	signature:(const MatIterator_<_Tp>& it )
cv::MatIterator_::operator []	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t i) const
cv::MatIterator_::operator []	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t i) const
cv::MatIterator_::pointer	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp* pointer;$/;"	t	class:cv::MatIterator_	access:public
cv::MatIterator_::reference	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp& reference;$/;"	t	class:cv::MatIterator_	access:public
cv::MatND	/usr/include/opencv2/core/core.hpp	/^typedef Mat MatND;$/;"	t	namespace:cv
cv::MatOp	/usr/include/opencv2/core/mat.hpp	/^class CV_EXPORTS MatOp$/;"	c	namespace:cv
cv::MatOp::MatOp	/usr/include/opencv2/core/mat.hpp	/^    MatOp() {};$/;"	f	class:cv::MatOp	access:public	signature:()
cv::MatOp::abs	/usr/include/opencv2/core/mat.hpp	/^    virtual void abs(const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, MatExpr& res) const
cv::MatOp::add	/usr/include/opencv2/core/mat.hpp	/^    virtual void add(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
cv::MatOp::add	/usr/include/opencv2/core/mat.hpp	/^    virtual void add(const MatExpr& expr1, const Scalar& s, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const Scalar& s, MatExpr& res) const
cv::MatOp::assign	/usr/include/opencv2/core/mat.hpp	/^    virtual void assign(const MatExpr& expr, Mat& m, int type=-1) const = 0;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m, int type=-1) const
cv::MatOp::augAssignAdd	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignAdd(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignAnd	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignAnd(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignDivide	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignDivide(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignMultiply	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignMultiply(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignOr	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignOr(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignSubtract	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignSubtract(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignXor	/usr/include/opencv2/core/mat.hpp	/^    virtual void augAssignXor(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::diag	/usr/include/opencv2/core/mat.hpp	/^    virtual void diag(const MatExpr& expr, int d, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, int d, MatExpr& res) const
cv::MatOp::divide	/usr/include/opencv2/core/mat.hpp	/^    virtual void divide(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const
cv::MatOp::divide	/usr/include/opencv2/core/mat.hpp	/^    virtual void divide(double s, const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(double s, const MatExpr& expr, MatExpr& res) const
cv::MatOp::elementWise	/usr/include/opencv2/core/mat.hpp	/^    virtual bool elementWise(const MatExpr& expr) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr) const
cv::MatOp::invert	/usr/include/opencv2/core/mat.hpp	/^    virtual void invert(const MatExpr& expr, int method, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, int method, MatExpr& res) const
cv::MatOp::matmul	/usr/include/opencv2/core/mat.hpp	/^    virtual void matmul(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
cv::MatOp::multiply	/usr/include/opencv2/core/mat.hpp	/^    virtual void multiply(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const
cv::MatOp::multiply	/usr/include/opencv2/core/mat.hpp	/^    virtual void multiply(const MatExpr& expr1, double s, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, double s, MatExpr& res) const
cv::MatOp::roi	/usr/include/opencv2/core/mat.hpp	/^    virtual void roi(const MatExpr& expr, const Range& rowRange,$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, const Range& rowRange, const Range& colRange, MatExpr& res) const
cv::MatOp::subtract	/usr/include/opencv2/core/mat.hpp	/^    virtual void subtract(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
cv::MatOp::subtract	/usr/include/opencv2/core/mat.hpp	/^    virtual void subtract(const Scalar& s, const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const Scalar& s, const MatExpr& expr, MatExpr& res) const
cv::MatOp::transpose	/usr/include/opencv2/core/mat.hpp	/^    virtual void transpose(const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, MatExpr& res) const
cv::MatOp::~MatOp	/usr/include/opencv2/core/mat.hpp	/^    virtual ~MatOp() {};$/;"	f	class:cv::MatOp	access:public	signature:()
cv::MatOp_Base	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS MatOp_Base;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatOp_Iter_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatOp_Iter_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Mat_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Mat_ : public Mat$/;"	c	namespace:cv	inherits:Mat
cv::Mat_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Mat_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_();$/;"	p	class:cv::Mat_	access:public	signature:()
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(Size _size, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size, const _Tp& value)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(const Mat& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat& m)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(const Mat_& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(const Mat_& m, const Range& rowRange, const Range& colRange=Range::all());$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Range& rowRange, const Range& colRange=Range::all())
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(const Mat_& m, const Range* ranges);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Range* ranges)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(const Mat_& m, const Rect& roi);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Rect& roi)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _ndims, const int* _sizes, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes, const _Tp& value)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _rows, int _cols);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    Mat_(int _rows, int _cols, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols, const _Tp& value)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    explicit Mat_(Size _size);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    explicit Mat_(const MatCommaInitializer_<_Tp>& commaInitializer);$/;"	p	class:cv::Mat_	access:public	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    explicit Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    explicit Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    explicit Mat_(const vector<_Tp>& vec, bool copyData=false);$/;"	p	class:cv::Mat_	access:public	signature:(const vector<_Tp>& vec, bool copyData=false)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    template<int m, int n> explicit Mat_(const Matx<typename DataType<_Tp>::channel_type, m, n>& mtx, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Matx<typename DataType<_Tp>::channel_type, m, n>& mtx, bool copyData=true)
cv::Mat_::Mat_	/usr/include/opencv2/core/core.hpp	/^    template<int n> explicit Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData=true)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^    Mat_<_Tp>::Mat_(const Matx<typename DataType<_Tp>::channel_type,m,n>& M, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Matx<typename DataType<_Tp>::channel_type,m,n>& M, bool copyData)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^    Mat_<_Tp>::Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_()$/;"	f	class:cv::Mat_	signature:()
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz)$/;"	f	class:cv::Mat_	signature:(Size _sz)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz, const _Tp& value)$/;"	f	class:cv::Mat_	signature:(Size _sz, const _Tp& value)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat& m)$/;"	f	class:cv::Mat_	signature:(const Mat& m)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const MatCommaInitializer_<_Tp>& commaInitializer)$/;"	f	class:cv::Mat_	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m)$/;"	f	class:cv::Mat_	signature:(const Mat_& m)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Range& rowRange, const Range& colRange)$/;"	f	class:cv::Mat_	signature:(const Mat_& m, const Range& rowRange, const Range& colRange)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Rect& roi)$/;"	f	class:cv::Mat_	signature:(const Mat_& m, const Rect& roi)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const Range* ranges)$/;"	f	class:cv::Mat_	signature:(const Mat_<_Tp>& m, const Range* ranges)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const vector<_Tp>& vec, bool copyData)$/;"	f	class:cv::Mat_	signature:(const vector<_Tp>& vec, bool copyData)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz, const _Tp& _s)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz, const _Tp& _s)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, _Tp* _data, size_t steps)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols, _Tp* _data, size_t steps)
cv::Mat_::Mat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, const _Tp& value)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols, const _Tp& value)
cv::Mat_::adjustROI	/usr/include/opencv2/core/core.hpp	/^    Mat_& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::Mat_	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
cv::Mat_::adjustROI	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::adjustROI( int dtop, int dbottom, int dleft, int dright )$/;"	f	class:cv::Mat_	signature:( int dtop, int dbottom, int dleft, int dright )
cv::Mat_::begin	/usr/include/opencv2/core/core.hpp	/^    const_iterator begin() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::begin	/usr/include/opencv2/core/core.hpp	/^    iterator begin();$/;"	p	class:cv::Mat_	access:public	signature:()
cv::Mat_::begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::begin() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::begin()$/;"	f	class:cv::Mat_	signature:()
cv::Mat_::channel_type	/usr/include/opencv2/core/core.hpp	/^    typedef typename DataType<_Tp>::channel_type channel_type;$/;"	t	class:cv::Mat_	access:public
cv::Mat_::channels	/usr/include/opencv2/core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::channels	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::channels() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::clone	/usr/include/opencv2/core/core.hpp	/^    Mat_ clone() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::clone	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::clone() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::col	/usr/include/opencv2/core/core.hpp	/^    Mat_ col(int x) const;$/;"	p	class:cv::Mat_	access:public	signature:(int x) const
cv::Mat_::col	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::col(int x) const$/;"	f	class:cv::Mat_	signature:(int x) const
cv::Mat_::const_iterator	/usr/include/opencv2/core/core.hpp	/^    typedef MatConstIterator_<_Tp> const_iterator;$/;"	t	class:cv::Mat_	access:public
cv::Mat_::create	/usr/include/opencv2/core/core.hpp	/^    void create(Size _size);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size)
cv::Mat_::create	/usr/include/opencv2/core/core.hpp	/^    void create(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
cv::Mat_::create	/usr/include/opencv2/core/core.hpp	/^    void create(int _rows, int _cols);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols)
cv::Mat_::create	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(Size _sz)$/;"	f	class:cv::Mat_	signature:(Size _sz)
cv::Mat_::create	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(int _dims, const int* _sz)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz)
cv::Mat_::create	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(int _rows, int _cols)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols)
cv::Mat_::cross	/usr/include/opencv2/core/core.hpp	/^    Mat_ cross(const Mat_& m) const;$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m) const
cv::Mat_::cross	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::cross(const Mat_& m) const$/;"	f	class:cv::Mat_	signature:(const Mat_& m) const
cv::Mat_::depth	/usr/include/opencv2/core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::depth	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::depth() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::diag	/usr/include/opencv2/core/core.hpp	/^    Mat_ diag(int d=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int d=0) const
cv::Mat_::diag	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::diag(int d) const$/;"	f	class:cv::Mat_	signature:(int d) const
cv::Mat_::elemSize	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::elemSize	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::elemSize() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::elemSize1	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::elemSize1	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::elemSize1() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::end	/usr/include/opencv2/core/core.hpp	/^    const_iterator end() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::end	/usr/include/opencv2/core/core.hpp	/^    iterator end();$/;"	p	class:cv::Mat_	access:public	signature:()
cv::Mat_::end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::end() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::end()$/;"	f	class:cv::Mat_	signature:()
cv::Mat_::eye	/usr/include/opencv2/core/core.hpp	/^    static MatExpr eye(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
cv::Mat_::eye	/usr/include/opencv2/core/core.hpp	/^    static MatExpr eye(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
cv::Mat_::eye	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
cv::Mat_::eye	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
cv::Mat_::iterator	/usr/include/opencv2/core/core.hpp	/^    typedef MatIterator_<_Tp> iterator;$/;"	t	class:cv::Mat_	access:public
cv::Mat_::ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
cv::Mat_::ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
cv::Mat_::ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
cv::Mat_::ones	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
cv::Mat_::ones	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat_ operator()( const Range& rowRange, const Range& colRange ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Range& rowRange, const Range& colRange ) const
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat_ operator()( const Range* ranges ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Range* ranges ) const
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat_ operator()( const Rect& roi ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Rect& roi ) const
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(Point pt);$/;"	p	class:cv::Mat_	access:public	signature:(Point pt)
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(const int* idx);$/;"	p	class:cv::Mat_	access:public	signature:(const int* idx)
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int idx0);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0)
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int idx0, int idx1);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1)
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int idx0, int idx1, int idx2);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1, int idx2)
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(Point pt) const;$/;"	p	class:cv::Mat_	access:public	signature:(Point pt) const
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(const int* idx) const;$/;"	p	class:cv::Mat_	access:public	signature:(const int* idx) const
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int idx0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0) const
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int idx0, int idx1) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1) const
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int idx0, int idx1, int idx2) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1, int idx2) const
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    template<int n> _Tp& operator ()(const Vec<int, n>& idx);$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<int, n>& idx)
cv::Mat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    template<int n> const _Tp& operator ()(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<int, n>& idx) const
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range& rowRange, const Range& colRange ) const$/;"	f	class:cv::Mat_	signature:( const Range& rowRange, const Range& colRange ) const
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range* ranges ) const$/;"	f	class:cv::Mat_	signature:( const Range* ranges ) const
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Rect& roi ) const$/;"	f	class:cv::Mat_	signature:( const Rect& roi ) const
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(Point pt)$/;"	f	class:cv::Mat_	signature:(Point pt)
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(const int* idx)$/;"	f	class:cv::Mat_	signature:(const int* idx)
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0)$/;"	f	class:cv::Mat_	signature:(int i0)
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1)$/;"	f	class:cv::Mat_	signature:(int i0, int i1)
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2)$/;"	f	class:cv::Mat_	signature:(int i0, int i1, int i2)
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(Point pt) const$/;"	f	class:cv::Mat_	signature:(Point pt) const
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(const int* idx) const$/;"	f	class:cv::Mat_	signature:(const int* idx) const
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0) const$/;"	f	class:cv::Mat_	signature:(int i0) const
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1) const$/;"	f	class:cv::Mat_	signature:(int i0, int i1) const
cv::Mat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2) const$/;"	f	class:cv::Mat_	signature:(int i0, int i1, int i2) const
cv::Mat_::operator =	/usr/include/opencv2/core/core.hpp	/^    Mat_& operator = (const Mat& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat& m)
cv::Mat_::operator =	/usr/include/opencv2/core/core.hpp	/^    Mat_& operator = (const MatExpr& expr);$/;"	p	class:cv::Mat_	access:public	signature:(const MatExpr& expr)
cv::Mat_::operator =	/usr/include/opencv2/core/core.hpp	/^    Mat_& operator = (const Mat_& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m)
cv::Mat_::operator =	/usr/include/opencv2/core/core.hpp	/^    Mat_& operator = (const _Tp& s);$/;"	p	class:cv::Mat_	access:public	signature:(const _Tp& s)
cv::Mat_::operator =	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> Mat_<_Tp>& Mat_<_Tp>::operator = (const MatExpr& e)$/;"	f	class:cv::Mat_	signature:(const MatExpr& e)
cv::Mat_::operator =	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat& m)$/;"	f	class:cv::Mat_	signature:(const Mat& m)
cv::Mat_::operator =	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat_& m)$/;"	f	class:cv::Mat_	signature:(const Mat_& m)
cv::Mat_::operator =	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const _Tp& s)$/;"	f	class:cv::Mat_	signature:(const _Tp& s)
cv::Mat_::operator Mat_<T2>	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> operator Mat_<T2>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::operator Mat_<T2>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> template<typename T2> inline Mat_<_Tp>::operator Mat_<T2>() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::operator Matx<typename DataType<_Tp>::channel_type, m, n>	/usr/include/opencv2/core/core.hpp	/^    template<int m, int n> operator Matx<typename DataType<_Tp>::channel_type, m, n>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::operator Matx<typename DataType<_Tp>::channel_type, m, n>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> template<int m, int n> inline Mat_<_Tp>::operator Matx<typename DataType<_Tp>::channel_type, m, n>() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::operator Vec<typename DataType<_Tp>::channel_type, n>	/usr/include/opencv2/core/core.hpp	/^    template<int n> operator Vec<typename DataType<_Tp>::channel_type, n>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::operator Vec<typename DataType<_Tp>::channel_type, n>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> template<int n> inline Mat_<_Tp>::operator Vec<typename DataType<_Tp>::channel_type, n>() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::operator []	/usr/include/opencv2/core/core.hpp	/^    _Tp* operator [](int y);$/;"	p	class:cv::Mat_	access:public	signature:(int y)
cv::Mat_::operator []	/usr/include/opencv2/core/core.hpp	/^    const _Tp* operator [](int y) const;$/;"	p	class:cv::Mat_	access:public	signature:(int y) const
cv::Mat_::operator []	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat_<_Tp>::operator [](int y)$/;"	f	class:cv::Mat_	signature:(int y)
cv::Mat_::operator []	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat_<_Tp>::operator [](int y) const$/;"	f	class:cv::Mat_	signature:(int y) const
cv::Mat_::operator vector<_Tp>	/usr/include/opencv2/core/core.hpp	/^    operator vector<_Tp>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::operator vector<_Tp>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::operator vector<_Tp>() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::reshape	/usr/include/opencv2/core/core.hpp	/^    Mat_ reshape(int _rows) const;$/;"	p	class:cv::Mat_	access:public	signature:(int _rows) const
cv::Mat_::reshape	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::reshape(int _rows) const$/;"	f	class:cv::Mat_	signature:(int _rows) const
cv::Mat_::row	/usr/include/opencv2/core/core.hpp	/^    Mat_ row(int y) const;$/;"	p	class:cv::Mat_	access:public	signature:(int y) const
cv::Mat_::row	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::row(int y) const$/;"	f	class:cv::Mat_	signature:(int y) const
cv::Mat_::step1	/usr/include/opencv2/core/core.hpp	/^    size_t step1(int i=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int i=0) const
cv::Mat_::step1	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::step1(int i) const { return step.p[i]\/elemSize1(); }$/;"	f	class:cv::Mat_	signature:(int i) const
cv::Mat_::stepT	/usr/include/opencv2/core/core.hpp	/^    size_t stepT(int i=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int i=0) const
cv::Mat_::stepT	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::stepT(int i) const { return step.p[i]\/elemSize(); }$/;"	f	class:cv::Mat_	signature:(int i) const
cv::Mat_::type	/usr/include/opencv2/core/core.hpp	/^    int type() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::type	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::type() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Mat_	access:public
cv::Mat_::zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
cv::Mat_::zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
cv::Mat_::zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
cv::Mat_::zeros	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
cv::Mat_::zeros	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
cv::Matx	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS Matx$/;"	c	namespace:cv
cv::Matx	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS Matx;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Matx12d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 1, 2> Matx12d;$/;"	t	namespace:cv
cv::Matx12f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 1, 2> Matx12f;$/;"	t	namespace:cv
cv::Matx13d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 1, 3> Matx13d;$/;"	t	namespace:cv
cv::Matx13f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 1, 3> Matx13f;$/;"	t	namespace:cv
cv::Matx14d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 1, 4> Matx14d;$/;"	t	namespace:cv
cv::Matx14f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 1, 4> Matx14f;$/;"	t	namespace:cv
cv::Matx16d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 1, 6> Matx16d;$/;"	t	namespace:cv
cv::Matx16f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 1, 6> Matx16f;$/;"	t	namespace:cv
cv::Matx21d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 2, 1> Matx21d;$/;"	t	namespace:cv
cv::Matx21f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 2, 1> Matx21f;$/;"	t	namespace:cv
cv::Matx22d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 2, 2> Matx22d;$/;"	t	namespace:cv
cv::Matx22f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 2, 2> Matx22f;$/;"	t	namespace:cv
cv::Matx23d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 2, 3> Matx23d;$/;"	t	namespace:cv
cv::Matx23f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 2, 3> Matx23f;$/;"	t	namespace:cv
cv::Matx31d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 3, 1> Matx31d;$/;"	t	namespace:cv
cv::Matx31f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 3, 1> Matx31f;$/;"	t	namespace:cv
cv::Matx32d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 3, 2> Matx32d;$/;"	t	namespace:cv
cv::Matx32f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 3, 2> Matx32f;$/;"	t	namespace:cv
cv::Matx33d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 3, 3> Matx33d;$/;"	t	namespace:cv
cv::Matx33f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 3, 3> Matx33f;$/;"	t	namespace:cv
cv::Matx34d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 3, 4> Matx34d;$/;"	t	namespace:cv
cv::Matx34f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 3, 4> Matx34f;$/;"	t	namespace:cv
cv::Matx41d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 4, 1> Matx41d;$/;"	t	namespace:cv
cv::Matx41f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 4, 1> Matx41f;$/;"	t	namespace:cv
cv::Matx43d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 4, 3> Matx43d;$/;"	t	namespace:cv
cv::Matx43f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 4, 3> Matx43f;$/;"	t	namespace:cv
cv::Matx44d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 4, 4> Matx44d;$/;"	t	namespace:cv
cv::Matx44f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 4, 4> Matx44f;$/;"	t	namespace:cv
cv::Matx61d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 6, 1> Matx61d;$/;"	t	namespace:cv
cv::Matx61f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 6, 1> Matx61f;$/;"	t	namespace:cv
cv::Matx66d	/usr/include/opencv2/core/core.hpp	/^typedef Matx<double, 6, 6> Matx66d;    $/;"	t	namespace:cv
cv::Matx66f	/usr/include/opencv2/core/core.hpp	/^typedef Matx<float, 6, 6> Matx66f;$/;"	t	namespace:cv
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx();$/;"	p	class:cv::Matx	access:public	signature:()
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0); \/\/!< 1x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1); \/\/!< 1x2 or 2x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2); \/\/!< 1x3 or 3x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3); \/\/!< 1x4, 2x2 or 4x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); \/\/!< 1x5 or 5x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); \/\/!< 1x6, 2x3, 3x2 or 6x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); \/\/!< 1x7 or 7x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); \/\/!< 1x8, 2x4, 4x2 or 8x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); \/\/!< 1x9, 3x3 or 9x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); \/\/!< 1x10, 2x5 or 5x2 or 10x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    Matx(const Matx<_Tp, n, m>& a, Matx_TOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, n, m>& a, Matx_TOp)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    explicit Matx(const _Tp* vals); \/\/!< initialize from a plain array$/;"	p	class:cv::Matx	access:public	signature:(const _Tp* vals)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    template<int l> Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)
cv::Matx::Matx	/usr/include/opencv2/core/core.hpp	/^    template<typename _T2> Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, n, m>& a, Matx_TOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, n, m>& a, Matx_TOp)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx()$/;"	f	class:cv::Matx	signature:()
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0)$/;"	f	class:cv::Matx	signature:(_Tp v0)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
cv::Matx::Matx	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(const _Tp* values)$/;"	f	class:cv::Matx	signature:(const _Tp* values)
cv::Matx::all	/usr/include/opencv2/core/core.hpp	/^    static Matx all(_Tp alpha);$/;"	p	class:cv::Matx	access:public	signature:(_Tp alpha)
cv::Matx::all	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n> Matx<_Tp, m, n>::all(_Tp alpha)$/;"	f	class:cv::Matx	signature:(_Tp alpha)
cv::Matx::channels	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon120
cv::Matx::col	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, m, 1> col(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
cv::Matx::col	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, 1> Matx<_Tp, m, n>::col(int j) const$/;"	f	class:cv::Matx	signature:(int j) const
cv::Matx::cols	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon120
cv::Matx::ddot	/usr/include/opencv2/core/core.hpp	/^    double ddot(const Matx<_Tp, m, n>& v) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& v) const
cv::Matx::ddot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline double Matx<_Tp, m, n>::ddot(const Matx<_Tp, m, n>& M) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& M) const
cv::Matx::depth	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon120
cv::Matx::diag	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, MIN(m,n), 1> diag() const;$/;"	p	class:cv::Matx	access:public	signature:() const
cv::Matx::diag	/usr/include/opencv2/core/core.hpp	/^    static Matx diag(const diag_type& d);$/;"	p	class:cv::Matx	access:public	signature:(const diag_type& d)
cv::Matx::diag	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, MIN(m,n), 1> Matx<_Tp, m, n>::diag() const$/;"	f	class:cv::Matx	signature:() const
cv::Matx::diag	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::diag(const Matx<_Tp,MIN(m,n),1>& d)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp,MIN(m,n),1>& d)
cv::Matx::diag_type	/usr/include/opencv2/core/core.hpp	/^    typedef Matx<_Tp, MIN(m, n), 1> diag_type;$/;"	t	class:cv::Matx	access:public
cv::Matx::dot	/usr/include/opencv2/core/core.hpp	/^    _Tp dot(const Matx<_Tp, m, n>& v) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& v) const
cv::Matx::dot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline _Tp Matx<_Tp, m, n>::dot(const Matx<_Tp, m, n>& M) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& M) const
cv::Matx::eye	/usr/include/opencv2/core/core.hpp	/^    static Matx eye();$/;"	p	class:cv::Matx	access:public	signature:()
cv::Matx::eye	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::eye()$/;"	f	class:cv::Matx	signature:()
cv::Matx::get_minor	/usr/include/opencv2/core/core.hpp	/^    template<int m1, int n1> Matx<_Tp, m1, n1> get_minor(int i, int j) const;$/;"	p	class:cv::Matx	access:public	signature:(int i, int j) const
cv::Matx::get_minor	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m1, n1> Matx<_Tp, m, n>::get_minor(int i, int j) const$/;"	f	class:cv::Matx	signature:(int i, int j) const
cv::Matx::inv	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, n, m> inv(int method=DECOMP_LU) const;$/;"	p	class:cv::Matx	access:public	signature:(int method=DECOMP_LU) const
cv::Matx::inv	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, n, m> Matx<_Tp, m, n>::inv(int method) const$/;"	f	class:cv::Matx	signature:(int method) const
cv::Matx::mat_type	/usr/include/opencv2/core/core.hpp	/^    typedef Matx<_Tp, m, n> mat_type;$/;"	t	class:cv::Matx	access:public
cv::Matx::mul	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, m, n> mul(const Matx<_Tp, m, n>& a) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a) const
cv::Matx::mul	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> Matx<_Tp, m, n>::mul(const Matx<_Tp, m, n>& a) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a) const
cv::Matx::ones	/usr/include/opencv2/core/core.hpp	/^    static Matx ones();$/;"	p	class:cv::Matx	access:public	signature:()
cv::Matx::ones	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::ones()$/;"	f	class:cv::Matx	signature:()
cv::Matx::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int i);$/;"	p	class:cv::Matx	access:public	signature:(int i)
cv::Matx::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int i, int j);$/;"	p	class:cv::Matx	access:public	signature:(int i, int j)
cv::Matx::operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
cv::Matx::operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int i, int j) const;$/;"	p	class:cv::Matx	access:public	signature:(int i, int j) const
cv::Matx::operator ()	/usr/include/opencv2/core/operations.hpp	/^_Tp& Matx<_Tp, m, n>::operator ()(int i)$/;"	f	class:cv::Matx	signature:(int i)
cv::Matx::operator ()	/usr/include/opencv2/core/operations.hpp	/^_Tp& Matx<_Tp, m, n>::operator ()(int i, int j)$/;"	f	class:cv::Matx	signature:(int i, int j)
cv::Matx::operator ()	/usr/include/opencv2/core/operations.hpp	/^const _Tp& Matx<_Tp, m, n>::operator ()(int i) const$/;"	f	class:cv::Matx	signature:(int i) const
cv::Matx::operator ()	/usr/include/opencv2/core/operations.hpp	/^const _Tp& Matx<_Tp, m, n>::operator ()(int i, int j) const$/;"	f	class:cv::Matx	signature:(int i, int j) const
cv::Matx::operator Matx<T2, m, n>	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> operator Matx<T2, m, n>() const;$/;"	p	class:cv::Matx	access:public	signature:() const
cv::Matx::operator Matx<T2, m, n>	/usr/include/opencv2/core/operations.hpp	/^inline Matx<_Tp, m, n>::operator Matx<T2, m, n>() const$/;"	f	class:cv::Matx	signature:() const
cv::Matx::randn	/usr/include/opencv2/core/core.hpp	/^    static Matx randn(_Tp a, _Tp b);$/;"	p	class:cv::Matx	access:public	signature:(_Tp a, _Tp b)
cv::Matx::randn	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::randn(_Tp a, _Tp b)$/;"	f	class:cv::Matx	signature:(_Tp a, _Tp b)
cv::Matx::randu	/usr/include/opencv2/core/core.hpp	/^    static Matx randu(_Tp a, _Tp b);$/;"	p	class:cv::Matx	access:public	signature:(_Tp a, _Tp b)
cv::Matx::randu	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::randu(_Tp a, _Tp b)$/;"	f	class:cv::Matx	signature:(_Tp a, _Tp b)
cv::Matx::reshape	/usr/include/opencv2/core/core.hpp	/^    template<int m1, int n1> Matx<_Tp, m1, n1> reshape() const;$/;"	p	class:cv::Matx	access:public	signature:() const
cv::Matx::reshape	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m1, n1> Matx<_Tp, m, n>::reshape() const$/;"	f	class:cv::Matx	signature:() const
cv::Matx::row	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, 1, n> row(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
cv::Matx::row	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, 1, n> Matx<_Tp, m, n>::row(int i) const$/;"	f	class:cv::Matx	signature:(int i) const
cv::Matx::rows	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon120
cv::Matx::solve	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, n, 1> solve(const Matx<_Tp, m, 1>& rhs, int method) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, 1>& rhs, int method) const
cv::Matx::solve	/usr/include/opencv2/core/core.hpp	/^    template<int l> Matx<_Tp, n, l> solve(const Matx<_Tp, m, l>& rhs, int flags=DECOMP_LU) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, l>& rhs, int flags=DECOMP_LU) const
cv::Matx::solve	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, n, l> Matx<_Tp, m, n>::solve(const Matx<_Tp, m, l>& rhs, int method) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, l>& rhs, int method) const
cv::Matx::t	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, n, m> t() const;$/;"	p	class:cv::Matx	access:public	signature:() const
cv::Matx::t	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, n, m> Matx<_Tp, m, n>::t() const$/;"	f	class:cv::Matx	signature:() const
cv::Matx::type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Matx::__anon120
cv::Matx::val	/usr/include/opencv2/core/core.hpp	/^    _Tp val[m*n]; \/\/< matrix elements$/;"	m	class:cv::Matx	access:public
cv::Matx::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Matx	access:public
cv::Matx::zeros	/usr/include/opencv2/core/core.hpp	/^    static Matx zeros();$/;"	p	class:cv::Matx	access:public	signature:()
cv::Matx::zeros	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::zeros()$/;"	f	class:cv::Matx	signature:()
cv::MatxCommaInitializer	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS MatxCommaInitializer$/;"	c	namespace:cv
cv::MatxCommaInitializer::MatxCommaInitializer	/usr/include/opencv2/core/core.hpp	/^    MatxCommaInitializer(Matx<_Tp, m, n>* _mtx);$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:(Matx<_Tp, m, n>* _mtx)
cv::MatxCommaInitializer::MatxCommaInitializer	/usr/include/opencv2/core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n>::MatxCommaInitializer(Matx<_Tp, m, n>* _mtx)$/;"	f	class:cv::MatxCommaInitializer	signature:(Matx<_Tp, m, n>* _mtx)
cv::MatxCommaInitializer::dst	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, m, n>* dst;$/;"	m	class:cv::MatxCommaInitializer	access:public
cv::MatxCommaInitializer::idx	/usr/include/opencv2/core/core.hpp	/^    int idx;$/;"	m	class:cv::MatxCommaInitializer	access:public
cv::MatxCommaInitializer::operator *	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, m, n> operator *() const;$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:() const
cv::MatxCommaInitializer::operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> MatxCommaInitializer<_Tp, m, n>::operator *() const$/;"	f	class:cv::MatxCommaInitializer	signature:() const
cv::MatxCommaInitializer::operator ,	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> MatxCommaInitializer<_Tp, m, n>& operator , (T2 val);$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:(T2 val)
cv::MatxCommaInitializer::operator ,	/usr/include/opencv2/core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n>& MatxCommaInitializer<_Tp, m, n>::operator , (_T2 value)$/;"	f	class:cv::MatxCommaInitializer	signature:(_T2 value)
cv::Matx_AddOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_AddOp {};$/;"	s	namespace:cv
cv::Matx_DetOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m> struct CV_EXPORTS Matx_DetOp$/;"	s	namespace:cv
cv::Matx_DetOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 1>$/;"	s	namespace:cv
cv::Matx_DetOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 2>$/;"	s	namespace:cv
cv::Matx_DetOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 3>$/;"	s	namespace:cv
cv::Matx_DetOp::operator ()	/usr/include/opencv2/core/operations.hpp	/^    double operator ()(const Matx<_Tp, 1, 1>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 1, 1>& a) const
cv::Matx_DetOp::operator ()	/usr/include/opencv2/core/operations.hpp	/^    double operator ()(const Matx<_Tp, 2, 2>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 2, 2>& a) const
cv::Matx_DetOp::operator ()	/usr/include/opencv2/core/operations.hpp	/^    double operator ()(const Matx<_Tp, 3, 3>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 3, 3>& a) const
cv::Matx_DetOp::operator ()	/usr/include/opencv2/core/operations.hpp	/^    double operator ()(const Matx<_Tp, m, m>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, m, m>& a) const
cv::Matx_FastInvOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m> struct CV_EXPORTS Matx_FastInvOp$/;"	s	namespace:cv
cv::Matx_FastInvOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastInvOp<_Tp, 2>$/;"	s	namespace:cv
cv::Matx_FastInvOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastInvOp<_Tp, 3>$/;"	s	namespace:cv
cv::Matx_FastInvOp::operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, 2, 2>& a, Matx<_Tp, 2, 2>& b, int) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, 2, 2>& a, Matx<_Tp, 2, 2>& b, int) const
cv::Matx_FastInvOp::operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, 3, 3>& a, Matx<_Tp, 3, 3>& b, int) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, 3, 3>& a, Matx<_Tp, 3, 3>& b, int) const
cv::Matx_FastInvOp::operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, m, m>& a, Matx<_Tp, m, m>& b, int method) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, m, m>& a, Matx<_Tp, m, m>& b, int method) const
cv::Matx_FastSolveOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> struct CV_EXPORTS Matx_FastSolveOp$/;"	s	namespace:cv
cv::Matx_FastSolveOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastSolveOp<_Tp, 2, 1>$/;"	s	namespace:cv
cv::Matx_FastSolveOp	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastSolveOp<_Tp, 3, 1>$/;"	s	namespace:cv
cv::Matx_FastSolveOp::operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, 2, 2>& a, const Matx<_Tp, 2, 1>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, 2, 2>& a, const Matx<_Tp, 2, 1>& b, Matx<_Tp, 2, 1>& x, int method) const
cv::Matx_FastSolveOp::operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, 3, 3>& a, const Matx<_Tp, 3, 1>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, 3, 3>& a, const Matx<_Tp, 3, 1>& b, Matx<_Tp, 3, 1>& x, int method) const
cv::Matx_FastSolveOp::operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, m, m>& a, const Matx<_Tp, m, n>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, m, m>& a, const Matx<_Tp, m, n>& b, Matx<_Tp, m, n>& x, int method) const
cv::Matx_MatMulOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_MatMulOp {};$/;"	s	namespace:cv
cv::Matx_MulOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_MulOp {};$/;"	s	namespace:cv
cv::Matx_ScaleOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_ScaleOp {};$/;"	s	namespace:cv
cv::Matx_SubOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_SubOp {};$/;"	s	namespace:cv
cv::Matx_TOp	/usr/include/opencv2/core/core.hpp	/^struct CV_EXPORTS Matx_TOp {};$/;"	s	namespace:cv
cv::MemStorage	/usr/include/opencv2/core/core.hpp	/^typedef Ptr<CvMemStorage> MemStorage;$/;"	t	namespace:cv
cv::Mesh3D	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS Mesh3D$/;"	c	namespace:cv
cv::Mesh3D::EmptyMeshException	/usr/include/opencv2/contrib/contrib.hpp	/^        struct EmptyMeshException {};$/;"	s	class:cv::Mesh3D	access:public
cv::Mesh3D::Mesh3D	/usr/include/opencv2/contrib/contrib.hpp	/^        Mesh3D();$/;"	p	class:cv::Mesh3D	access:public	signature:()
cv::Mesh3D::Mesh3D	/usr/include/opencv2/contrib/contrib.hpp	/^        Mesh3D(const vector<Point3f>& vtx);$/;"	p	class:cv::Mesh3D	access:public	signature:(const vector<Point3f>& vtx)
cv::Mesh3D::allzero	/usr/include/opencv2/contrib/contrib.hpp	/^        const static Point3f allzero;$/;"	m	class:cv::Mesh3D	access:public
cv::Mesh3D::buildOctree	/usr/include/opencv2/contrib/contrib.hpp	/^        void buildOctree();$/;"	p	class:cv::Mesh3D	access:public	signature:()
cv::Mesh3D::clearOctree	/usr/include/opencv2/contrib/contrib.hpp	/^        void clearOctree();$/;"	p	class:cv::Mesh3D	access:public	signature:()
cv::Mesh3D::computeNormals	/usr/include/opencv2/contrib/contrib.hpp	/^        void computeNormals(const vector<int>& subset, float normalRadius, int minNeighbors = 20);$/;"	p	class:cv::Mesh3D	access:public	signature:(const vector<int>& subset, float normalRadius, int minNeighbors = 20)
cv::Mesh3D::computeNormals	/usr/include/opencv2/contrib/contrib.hpp	/^        void computeNormals(float normalRadius, int minNeighbors = 20);$/;"	p	class:cv::Mesh3D	access:public	signature:(float normalRadius, int minNeighbors = 20)
cv::Mesh3D::estimateResolution	/usr/include/opencv2/contrib/contrib.hpp	/^        float estimateResolution(float tryRatio = 0.1f);$/;"	p	class:cv::Mesh3D	access:public	signature:(float tryRatio = 0.1f)
cv::Mesh3D::normals	/usr/include/opencv2/contrib/contrib.hpp	/^        vector<Point3f> normals;$/;"	m	class:cv::Mesh3D	access:public
cv::Mesh3D::octree	/usr/include/opencv2/contrib/contrib.hpp	/^        Octree octree;$/;"	m	class:cv::Mesh3D	access:public
cv::Mesh3D::resolution	/usr/include/opencv2/contrib/contrib.hpp	/^        float resolution;$/;"	m	class:cv::Mesh3D	access:public
cv::Mesh3D::vtx	/usr/include/opencv2/contrib/contrib.hpp	/^        vector<Point3f> vtx;$/;"	m	class:cv::Mesh3D	access:public
cv::Mesh3D::writeAsVrml	/usr/include/opencv2/contrib/contrib.hpp	/^        void writeAsVrml(const String& file, const vector<Scalar>& colors = vector<Scalar>()) const;$/;"	p	class:cv::Mesh3D	access:public	signature:(const String& file, const vector<Scalar>& colors = vector<Scalar>()) const
cv::Mesh3D::~Mesh3D	/usr/include/opencv2/contrib/contrib.hpp	/^        ~Mesh3D();$/;"	p	class:cv::Mesh3D	access:public	signature:()
cv::Moments	/usr/include/opencv2/imgproc/imgproc.hpp	/^class CV_EXPORTS_W_MAP Moments$/;"	c	namespace:cv
cv::Moments::Moments	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Moments( const CvMoments& moments );$/;"	p	class:cv::Moments	access:public	signature:( const CvMoments& moments )
cv::Moments::Moments	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Moments();$/;"	p	class:cv::Moments	access:public	signature:()
cv::Moments::Moments	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Moments(double m00, double m10, double m01, double m20, double m11,$/;"	p	class:cv::Moments	access:public	signature:(double m00, double m10, double m01, double m20, double m11, double m02, double m30, double m21, double m12, double m03 )
cv::Moments::m00	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m01	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m02	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m03	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m10	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m11	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m12	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m20	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m21	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m30	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu02	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu03	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu11	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu12	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu20	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu21	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu30	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu02	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu03	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu11	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu12	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu20	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu21	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu30	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::operator CvMoments	/usr/include/opencv2/imgproc/imgproc.hpp	/^    operator CvMoments() const;$/;"	p	class:cv::Moments	access:public	signature:() const
cv::MouseCallback	/usr/include/opencv2/highgui/highgui.hpp	/^typedef void (*MouseCallback )(int event, int x, int y, int flags, void* param);$/;"	t	namespace:cv
cv::MserFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS MserFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::MserFeatureDetector::MserFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    MserFeatureDetector( CvMSERParams params=cvMSERParams() );$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( CvMSERParams params=cvMSERParams() )
cv::MserFeatureDetector::MserFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    MserFeatureDetector( int delta, int minArea, int maxArea, double maxVariation, double minDiversity,$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( int delta, int minArea, int maxArea, double maxVariation, double minDiversity, int maxEvolution, double areaThreshold, double minMargin, int edgeBlurSize )
cv::MserFeatureDetector::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::MserFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::MserFeatureDetector::mser	/usr/include/opencv2/features2d/features2d.hpp	/^    MSER mser;$/;"	m	class:cv::MserFeatureDetector	access:protected
cv::MserFeatureDetector::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( const FileNode& fn )
cv::MserFeatureDetector::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( FileStorage& fs ) const
cv::NAryMatIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS NAryMatIterator$/;"	c	namespace:cv
cv::NAryMatIterator::NAryMatIterator	/usr/include/opencv2/core/core.hpp	/^    NAryMatIterator();$/;"	p	class:cv::NAryMatIterator	access:public	signature:()
cv::NAryMatIterator::NAryMatIterator	/usr/include/opencv2/core/core.hpp	/^    NAryMatIterator(const Mat** arrays, Mat* planes, int narrays=-1);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(const Mat** arrays, Mat* planes, int narrays=-1)
cv::NAryMatIterator::arrays	/usr/include/opencv2/core/core.hpp	/^    const Mat** arrays;$/;"	m	class:cv::NAryMatIterator	access:public
cv::NAryMatIterator::idx	/usr/include/opencv2/core/core.hpp	/^    int iterdepth, idx;$/;"	m	class:cv::NAryMatIterator	access:protected
cv::NAryMatIterator::init	/usr/include/opencv2/core/core.hpp	/^    void init(const Mat** arrays, Mat* planes, int narrays=-1);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(const Mat** arrays, Mat* planes, int narrays=-1)
cv::NAryMatIterator::iterdepth	/usr/include/opencv2/core/core.hpp	/^    int iterdepth, idx;$/;"	m	class:cv::NAryMatIterator	access:protected
cv::NAryMatIterator::narrays	/usr/include/opencv2/core/core.hpp	/^    int narrays;$/;"	m	class:cv::NAryMatIterator	access:public
cv::NAryMatIterator::nplanes	/usr/include/opencv2/core/core.hpp	/^    int nplanes;$/;"	m	class:cv::NAryMatIterator	access:public
cv::NAryMatIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    NAryMatIterator operator ++(int);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(int)
cv::NAryMatIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    NAryMatIterator& operator ++();$/;"	p	class:cv::NAryMatIterator	access:public	signature:()
cv::NAryMatIterator::planes	/usr/include/opencv2/core/core.hpp	/^    Mat* planes;$/;"	m	class:cv::NAryMatIterator	access:public
cv::NORM_INF	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
cv::NORM_L1	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
cv::NORM_L2	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
cv::NORM_MINMAX	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
cv::NORM_RELATIVE	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
cv::NORM_TYPE_MASK	/usr/include/opencv2/core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon105
cv::NeuralNet_MLP	/usr/include/opencv2/ml/ml.hpp	/^typedef CvANN_MLP NeuralNet_MLP;$/;"	t	namespace:cv
cv::NormalBayesClassifier	/usr/include/opencv2/ml/ml.hpp	/^typedef CvNormalBayesClassifier NormalBayesClassifier;$/;"	t	namespace:cv
cv::OPTFLOW_FARNEBACK_GAUSSIAN	/usr/include/opencv2/video/tracking.hpp	/^enum { OPTFLOW_USE_INITIAL_FLOW=4, OPTFLOW_FARNEBACK_GAUSSIAN=256 };$/;"	e	enum:cv::__anon183
cv::OPTFLOW_USE_INITIAL_FLOW	/usr/include/opencv2/video/tracking.hpp	/^enum { OPTFLOW_USE_INITIAL_FLOW=4, OPTFLOW_FARNEBACK_GAUSSIAN=256 };$/;"	e	enum:cv::__anon183
cv::Octree	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS Octree$/;"	c	namespace:cv
cv::Octree::Node	/usr/include/opencv2/contrib/contrib.hpp	/^        struct Node$/;"	s	class:cv::Octree	access:public
cv::Octree::Node::Node	/usr/include/opencv2/contrib/contrib.hpp	/^            Node() {}$/;"	f	struct:cv::Octree::Node	access:public	signature:()
cv::Octree::Node::begin	/usr/include/opencv2/contrib/contrib.hpp	/^            int begin, end;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::children	/usr/include/opencv2/contrib/contrib.hpp	/^            int children[8];$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::end	/usr/include/opencv2/contrib/contrib.hpp	/^            int begin, end;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::isLeaf	/usr/include/opencv2/contrib/contrib.hpp	/^            bool isLeaf;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::maxLevels	/usr/include/opencv2/contrib/contrib.hpp	/^            int maxLevels;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::x_max	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::x_min	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::y_max	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::y_min	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::z_max	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::z_min	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Octree	/usr/include/opencv2/contrib/contrib.hpp	/^        Octree( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 );$/;"	p	class:cv::Octree	access:public	signature:( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 )
cv::Octree::Octree	/usr/include/opencv2/contrib/contrib.hpp	/^        Octree();$/;"	p	class:cv::Octree	access:public	signature:()
cv::Octree::buildNext	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void buildNext(size_t node_ind);$/;"	p	class:cv::Octree	access:private	signature:(size_t node_ind)
cv::Octree::buildTree	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void buildTree( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 );$/;"	p	class:cv::Octree	access:public	signature:( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 )
cv::Octree::getNodes	/usr/include/opencv2/contrib/contrib.hpp	/^        const vector<Node>& getNodes() const { return nodes; }$/;"	f	class:cv::Octree	access:public	signature:() const
cv::Octree::getPointsWithinSphere	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void getPointsWithinSphere( const Point3f& center, float radius,$/;"	p	class:cv::Octree	access:public	signature:( const Point3f& center, float radius, vector<Point3f>& points ) const
cv::Octree::minPoints	/usr/include/opencv2/contrib/contrib.hpp	/^        int minPoints;$/;"	m	class:cv::Octree	access:private
cv::Octree::nodes	/usr/include/opencv2/contrib/contrib.hpp	/^        vector<Node> nodes;$/;"	m	class:cv::Octree	access:private
cv::Octree::points	/usr/include/opencv2/contrib/contrib.hpp	/^        vector<Point3f> points;$/;"	m	class:cv::Octree	access:private
cv::Octree::~Octree	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual ~Octree();$/;"	p	class:cv::Octree	access:public	signature:()
cv::OneWayDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptor$/;"	c	namespace:cv
cv::OneWayDescriptor::Allocate	/usr/include/opencv2/features2d/features2d.hpp	/^    void Allocate(int pose_count, CvSize size, int nChannels);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, CvSize size, int nChannels)
cv::OneWayDescriptor::EstimatePose	/usr/include/opencv2/features2d/features2d.hpp	/^    void EstimatePose(IplImage* patch, int& pose_idx, float& distance) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* patch, int& pose_idx, float& distance) const
cv::OneWayDescriptor::EstimatePosePCA	/usr/include/opencv2/features2d/features2d.hpp	/^    void EstimatePosePCA(CvArr* patch, int& pose_idx, float& distance, CvMat* avg, CvMat* eigenvalues) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvArr* patch, int& pose_idx, float& distance, CvMat* avg, CvMat* eigenvalues) const
cv::OneWayDescriptor::GenerateSamples	/usr/include/opencv2/features2d/features2d.hpp	/^    void GenerateSamples(int pose_count, IplImage* frontal, int norm = 0);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, int norm = 0)
cv::OneWayDescriptor::GenerateSamplesFast	/usr/include/opencv2/features2d/features2d.hpp	/^    void GenerateSamplesFast(IplImage* frontal, CvMat* pca_hr_avg,$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* frontal, CvMat* pca_hr_avg, CvMat* pca_hr_eigenvectors, OneWayDescriptor* pca_descriptors)
cv::OneWayDescriptor::GetCenter	/usr/include/opencv2/features2d/features2d.hpp	/^    CvPoint GetCenter() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetFeatureName	/usr/include/opencv2/features2d/features2d.hpp	/^    const char* GetFeatureName() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetInputPatchSize	/usr/include/opencv2/features2d/features2d.hpp	/^    CvSize GetInputPatchSize() const$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetPCACoeffs	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat** GetPCACoeffs() const {return m_pca_coeffs;}$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetPCADimHigh	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPCADimHigh() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetPCADimLow	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPCADimLow() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetPatch	/usr/include/opencv2/features2d/features2d.hpp	/^    IplImage* GetPatch(int index);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int index)
cv::OneWayDescriptor::GetPatchSize	/usr/include/opencv2/features2d/features2d.hpp	/^    CvSize GetPatchSize() const$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetPose	/usr/include/opencv2/features2d/features2d.hpp	/^    CvAffinePose GetPose(int index) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int index) const
cv::OneWayDescriptor::Initialize	/usr/include/opencv2/features2d/features2d.hpp	/^    void Initialize(int pose_count, IplImage* frontal, const char* feature_name = 0, int norm = 0);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, const char* feature_name = 0, int norm = 0)
cv::OneWayDescriptor::InitializeFast	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeFast(int pose_count, IplImage* frontal, const char* feature_name,$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, const char* feature_name, CvMat* pca_hr_avg, CvMat* pca_hr_eigenvectors, OneWayDescriptor* pca_descriptors)
cv::OneWayDescriptor::InitializePCACoeffs	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializePCACoeffs(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
cv::OneWayDescriptor::OneWayDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptor();$/;"	p	class:cv::OneWayDescriptor	access:public	signature:()
cv::OneWayDescriptor::ProjectPCASample	/usr/include/opencv2/features2d/features2d.hpp	/^    void ProjectPCASample(IplImage* patch, CvMat* avg, CvMat* eigenvectors, CvMat* pca_coeffs) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* patch, CvMat* avg, CvMat* eigenvectors, CvMat* pca_coeffs) const
cv::OneWayDescriptor::ReadByName	/usr/include/opencv2/features2d/features2d.hpp	/^    int ReadByName(CvFileStorage* fs, CvFileNode* parent, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvFileStorage* fs, CvFileNode* parent, const char* name)
cv::OneWayDescriptor::ReadByName	/usr/include/opencv2/features2d/features2d.hpp	/^    int ReadByName(const FileNode &parent, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(const FileNode &parent, const char* name)
cv::OneWayDescriptor::Save	/usr/include/opencv2/features2d/features2d.hpp	/^    void Save(const char* path);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(const char* path)
cv::OneWayDescriptor::SetPCADimHigh	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetPCADimHigh(int pca_dim_high) {m_pca_dim_high = pca_dim_high;};$/;"	f	class:cv::OneWayDescriptor	access:public	signature:(int pca_dim_high)
cv::OneWayDescriptor::SetPCADimLow	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetPCADimLow(int pca_dim_low) {m_pca_dim_low = pca_dim_low;};$/;"	f	class:cv::OneWayDescriptor	access:public	signature:(int pca_dim_low)
cv::OneWayDescriptor::SetTransforms	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetTransforms(CvAffinePose* poses, CvMat** transforms);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvAffinePose* poses, CvMat** transforms)
cv::OneWayDescriptor::Write	/usr/include/opencv2/features2d/features2d.hpp	/^    void Write(CvFileStorage* fs, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvFileStorage* fs, const char* name)
cv::OneWayDescriptor::m_affine_poses	/usr/include/opencv2/features2d/features2d.hpp	/^    CvAffinePose* m_affine_poses; \/\/ an array of poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_center	/usr/include/opencv2/features2d/features2d.hpp	/^    CvPoint m_center; \/\/ the coordinates of the feature (the center of the input image ROI)$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_feature_name	/usr/include/opencv2/features2d/features2d.hpp	/^    string m_feature_name; \/\/ the name of the feature associated with the descriptor$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_input_patch	/usr/include/opencv2/features2d/features2d.hpp	/^    IplImage* m_input_patch;$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_patch_size	/usr/include/opencv2/features2d/features2d.hpp	/^    CvSize m_patch_size; \/\/ size of each image$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_pca_coeffs	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat** m_pca_coeffs; \/\/ an array of length m_pose_count containing pca decomposition of the patch in different poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_pca_dim_high	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pca_dim_high; \/\/ the number of descriptor pca components to use for generating affine poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_pca_dim_low	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pca_dim_low; \/\/ the number of pca components to use for comparison$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_pose_count	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pose_count; \/\/ the number of poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_samples	/usr/include/opencv2/features2d/features2d.hpp	/^    IplImage** m_samples; \/\/ an array of length m_pose_count containing the patch in different poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_train_patch	/usr/include/opencv2/features2d/features2d.hpp	/^    IplImage* m_train_patch;$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_transforms	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat** m_transforms; \/\/ an array of affine transforms corresponding to poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::~OneWayDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    ~OneWayDescriptor();$/;"	p	class:cv::OneWayDescriptor	access:public	signature:()
cv::OneWayDescriptorBase	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorBase$/;"	c	namespace:cv
cv::OneWayDescriptorBase::Allocate	/usr/include/opencv2/features2d/features2d.hpp	/^    void Allocate(int train_feature_count);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int train_feature_count)
cv::OneWayDescriptorBase::AllocatePCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void AllocatePCADescriptors();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::ConvertDescriptorsArrayToTree	/usr/include/opencv2/features2d/features2d.hpp	/^    void ConvertDescriptorsArrayToTree(); \/\/ Converting pca_descriptors array to KD tree$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::CreateDescriptorsFromImage	/usr/include/opencv2/features2d/features2d.hpp	/^    void CreateDescriptorsFromImage(IplImage* src, const std::vector<cv::KeyPoint>& features);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* src, const std::vector<cv::KeyPoint>& features)
cv::OneWayDescriptorBase::CreatePCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void CreatePCADescriptors();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::FindDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    void FindDescriptor(IplImage* patch, int n, std::vector<int>& desc_idxs, std::vector<int>& pose_idxs,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* patch, int n, std::vector<int>& desc_idxs, std::vector<int>& pose_idxs, std::vector<float>& distances, std::vector<float>& _scales, float* scale_ranges = 0) const
cv::OneWayDescriptorBase::FindDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    void FindDescriptor(IplImage* patch, int& desc_idx, int& pose_idx, float& distance, float* _scale = 0, float* scale_ranges = 0) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* patch, int& desc_idx, int& pose_idx, float& distance, float* _scale = 0, float* scale_ranges = 0) const
cv::OneWayDescriptorBase::FindDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    void FindDescriptor(IplImage* src, cv::Point2f pt, int& desc_idx, int& pose_idx, float& distance) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* src, cv::Point2f pt, int& desc_idx, int& pose_idx, float& distance) const
cv::OneWayDescriptorBase::GeneratePCA	/usr/include/opencv2/features2d/features2d.hpp	/^    void GeneratePCA(const char* img_path, const char* images_list, int pose_count=500);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* img_path, const char* images_list, int pose_count=500)
cv::OneWayDescriptorBase::GetDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    const OneWayDescriptor* GetDescriptor(int desc_idx) const {return &m_descriptors[desc_idx];};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx) const
cv::OneWayDescriptorBase::GetDescriptorCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetDescriptorCount() const {return m_train_feature_count;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::GetLowPCA	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetLowPCA(CvMat** avg, CvMat** eigenvectors)$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat** avg, CvMat** eigenvectors)
cv::OneWayDescriptorBase::GetPCADimHigh	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPCADimHigh() const {return m_pca_dim_high;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::GetPCADimLow	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPCADimLow() const {return m_pca_dim_low;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::GetPCAFilename	/usr/include/opencv2/features2d/features2d.hpp	/^    static string GetPCAFilename () { return "pca.yml"; }$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::GetPatchSize	/usr/include/opencv2/features2d/features2d.hpp	/^    CvSize GetPatchSize() const {return m_patch_size;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::GetPoseCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPoseCount() const {return m_pose_count;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::GetPyrLevels	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetPyrLevels() const {return m_pyr_levels;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::InitializeDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeDescriptor(int desc_idx, IplImage* train_image, const char* feature_label);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx, IplImage* train_image, const char* feature_label)
cv::OneWayDescriptorBase::InitializeDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeDescriptor(int desc_idx, IplImage* train_image, const cv::KeyPoint& keypoint, const char* feature_label);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx, IplImage* train_image, const cv::KeyPoint& keypoint, const char* feature_label)
cv::OneWayDescriptorBase::InitializeDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeDescriptors(IplImage* train_image, const vector<cv::KeyPoint>& features,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* train_image, const vector<cv::KeyPoint>& features, const char* feature_label = , int desc_start_idx = 0)
cv::OneWayDescriptorBase::InitializePoseTransforms	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializePoseTransforms();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::InitializePoses	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializePoses();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::InitializeTransformsFromPoses	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeTransformsFromPoses();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::LoadPCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    int LoadPCADescriptors(const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const FileNode &fn)
cv::OneWayDescriptorBase::LoadPCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    int LoadPCADescriptors(const char* filename);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* filename)
cv::OneWayDescriptorBase::LoadPCAall	/usr/include/opencv2/features2d/features2d.hpp	/^    void LoadPCAall (const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:protected	signature:(const FileNode &fn)
cv::OneWayDescriptorBase::OneWayDescriptorBase	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptorBase(CvSize patch_size, int pose_count, const char* train_path = 0, const char* pca_config = 0,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvSize patch_size, int pose_count, const char* train_path = 0, const char* pca_config = 0, const char* pca_hr_config = 0, const char* pca_desc_config = 0, int pyr_levels = 1, int pca_dim_high = 100, int pca_dim_low = 100)
cv::OneWayDescriptorBase::OneWayDescriptorBase	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptorBase(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string(), const string &images_list = string(),$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string(), const string &images_list = string(), float _scale_min = 0.7f, float _scale_max=1.5f, float _scale_step=1.2f, int pyr_levels = 1, int pca_dim_high = 100, int pca_dim_low = 100)
cv::OneWayDescriptorBase::Read	/usr/include/opencv2/features2d/features2d.hpp	/^    void Read (const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const FileNode &fn)
cv::OneWayDescriptorBase::SavePCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void SavePCADescriptors(CvFileStorage* fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvFileStorage* fs) const
cv::OneWayDescriptorBase::SavePCADescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void SavePCADescriptors(const char* filename);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* filename)
cv::OneWayDescriptorBase::SavePCAall	/usr/include/opencv2/features2d/features2d.hpp	/^    void SavePCAall (FileStorage &fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:protected	signature:(FileStorage &fs) const
cv::OneWayDescriptorBase::SetPCAHigh	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetPCAHigh(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
cv::OneWayDescriptorBase::SetPCALow	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetPCALow(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
cv::OneWayDescriptorBase::Write	/usr/include/opencv2/features2d/features2d.hpp	/^    void Write (FileStorage &fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(FileStorage &fs) const
cv::OneWayDescriptorBase::clear	/usr/include/opencv2/features2d/features2d.hpp	/^    void clear ();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::m_descriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptor* m_descriptors; \/\/ array of train feature descriptors$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_patch_size	/usr/include/opencv2/features2d/features2d.hpp	/^    CvSize m_patch_size; \/\/ patch size$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_avg	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat* m_pca_avg; \/\/ PCA average Vector for small patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_descriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptor* m_pca_descriptors; \/\/ an array of PCA descriptors$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_descriptors_matrix	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat* m_pca_descriptors_matrix;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_descriptors_tree	/usr/include/opencv2/features2d/features2d.hpp	/^    cv::flann::Index* m_pca_descriptors_tree;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_dim_high	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pca_dim_high;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_dim_low	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pca_dim_low;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_eigenvectors	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat* m_pca_eigenvectors; \/\/ PCA eigenvectors for small patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_hr_avg	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat* m_pca_hr_avg; \/\/ PCA average Vector for large patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_hr_eigenvectors	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat* m_pca_hr_eigenvectors; \/\/ PCA eigenvectors for large patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pose_count	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pose_count; \/\/ the number of poses for each descriptor$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_poses	/usr/include/opencv2/features2d/features2d.hpp	/^    CvAffinePose* m_poses; \/\/ array of poses$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pyr_levels	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pyr_levels;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_train_feature_count	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_train_feature_count; \/\/ the number of the training features$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_transforms	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat** m_transforms; \/\/ array of affine transformations corresponding to poses$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::scale_max	/usr/include/opencv2/features2d/features2d.hpp	/^    float scale_max;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::scale_min	/usr/include/opencv2/features2d/features2d.hpp	/^    float scale_min;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::scale_step	/usr/include/opencv2/features2d/features2d.hpp	/^    float scale_step;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::~OneWayDescriptorBase	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~OneWayDescriptorBase();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorMatch	/usr/include/opencv2/features2d/features2d.hpp	/^typedef OneWayDescriptorMatcher OneWayDescriptorMatch;$/;"	t	namespace:cv
cv::OneWayDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
cv::OneWayDescriptorMatcher::OneWayDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptorMatcher( const Params& params=Params() );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const Params& params=Params() )
cv::OneWayDescriptorMatcher::Params	/usr/include/opencv2/features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::OneWayDescriptorMatcher	access:public
cv::OneWayDescriptorMatcher::Params::GET_MAX_SCALE	/usr/include/opencv2/features2d/features2d.hpp	/^        static float GET_MAX_SCALE() { return 1.5f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
cv::OneWayDescriptorMatcher::Params::GET_MIN_SCALE	/usr/include/opencv2/features2d/features2d.hpp	/^        static float GET_MIN_SCALE() { return 0.7f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
cv::OneWayDescriptorMatcher::Params::GET_STEP_SCALE	/usr/include/opencv2/features2d/features2d.hpp	/^        static float GET_STEP_SCALE() { return 1.2f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
cv::OneWayDescriptorMatcher::Params::PATCH_HEIGHT	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int PATCH_HEIGHT = 24;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::PATCH_WIDTH	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int PATCH_WIDTH = 24;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::POSE_COUNT	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int POSE_COUNT = 500;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::Params	/usr/include/opencv2/features2d/features2d.hpp	/^        Params( int poseCount = POSE_COUNT,$/;"	p	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:( int poseCount = POSE_COUNT, Size patchSize = Size(PATCH_WIDTH, PATCH_HEIGHT), string pcaFilename = string(), string trainPath = string(), string trainImagesList = string(), float minScale = GET_MIN_SCALE(), float maxScale = GET_MAX_SCALE(), float stepScale = GET_STEP_SCALE() )
cv::OneWayDescriptorMatcher::Params::maxScale	/usr/include/opencv2/features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::minScale	/usr/include/opencv2/features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::patchSize	/usr/include/opencv2/features2d/features2d.hpp	/^        Size patchSize;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::pcaFilename	/usr/include/opencv2/features2d/features2d.hpp	/^        string pcaFilename;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::poseCount	/usr/include/opencv2/features2d/features2d.hpp	/^        int poseCount;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::stepScale	/usr/include/opencv2/features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::trainImagesList	/usr/include/opencv2/features2d/features2d.hpp	/^        string trainImagesList;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::trainPath	/usr/include/opencv2/features2d/features2d.hpp	/^        string trainPath;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::base	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<OneWayDescriptorBase> base;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
cv::OneWayDescriptorMatcher::clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
cv::OneWayDescriptorMatcher::clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::OneWayDescriptorMatcher::initialize	/usr/include/opencv2/features2d/features2d.hpp	/^    void initialize( const Params& params, const Ptr<OneWayDescriptorBase>& base=Ptr<OneWayDescriptorBase>() );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const Params& params, const Ptr<OneWayDescriptorBase>& base=Ptr<OneWayDescriptorBase>() )
cv::OneWayDescriptorMatcher::isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
cv::OneWayDescriptorMatcher::knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::OneWayDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::OneWayDescriptorMatcher::params	/usr/include/opencv2/features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
cv::OneWayDescriptorMatcher::prevTrainCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int prevTrainCount;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
cv::OneWayDescriptorMatcher::radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::OneWayDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::OneWayDescriptorMatcher::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const FileNode &fn )
cv::OneWayDescriptorMatcher::train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
cv::OneWayDescriptorMatcher::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
cv::OneWayDescriptorMatcher::~OneWayDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~OneWayDescriptorMatcher();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
cv::OneWayDescriptorObject	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorObject : public OneWayDescriptorBase$/;"	c	namespace:cv	inherits:OneWayDescriptorBase
cv::OneWayDescriptorObject::Allocate	/usr/include/opencv2/features2d/features2d.hpp	/^    void Allocate(int train_feature_count, int object_feature_count);$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int train_feature_count, int object_feature_count)
cv::OneWayDescriptorObject::GetDescriptorPart	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetDescriptorPart(int desc_idx) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int desc_idx) const
cv::OneWayDescriptorObject::GetLabeledFeatures	/usr/include/opencv2/features2d/features2d.hpp	/^    const vector<cv::KeyPoint>& GetLabeledFeatures() const {return m_train_features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:() const
cv::OneWayDescriptorObject::GetLabeledFeatures	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<cv::KeyPoint>& GetLabeledFeatures() {return m_train_features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:()
cv::OneWayDescriptorObject::GetObjectFeatureCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int GetObjectFeatureCount() const {return m_object_feature_count;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:() const
cv::OneWayDescriptorObject::InitializeObjectDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    void InitializeObjectDescriptors(IplImage* train_image, const vector<cv::KeyPoint>& features,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(IplImage* train_image, const vector<cv::KeyPoint>& features, const char* feature_label, int desc_start_idx = 0, float scale = 1.0f, int is_background = 0)
cv::OneWayDescriptorObject::IsDescriptorObject	/usr/include/opencv2/features2d/features2d.hpp	/^    int IsDescriptorObject(int desc_idx) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int desc_idx) const
cv::OneWayDescriptorObject::MatchPointToPart	/usr/include/opencv2/features2d/features2d.hpp	/^    int MatchPointToPart(CvPoint pt) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvPoint pt) const
cv::OneWayDescriptorObject::OneWayDescriptorObject	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptorObject(CvSize patch_size, int pose_count, const char* train_path, const char* pca_config,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvSize patch_size, int pose_count, const char* train_path, const char* pca_config, const char* pca_hr_config = 0, const char* pca_desc_config = 0, int pyr_levels = 1)
cv::OneWayDescriptorObject::OneWayDescriptorObject	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptorObject(CvSize patch_size, int pose_count, const string &pca_filename,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string (), const string &images_list = string (), float _scale_min = 0.7f, float _scale_max=1.5f, float _scale_step=1.2f, int pyr_levels = 1)
cv::OneWayDescriptorObject::SetLabeledFeatures	/usr/include/opencv2/features2d/features2d.hpp	/^    void SetLabeledFeatures(const vector<cv::KeyPoint>& features) {m_train_features = features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:(const vector<cv::KeyPoint>& features)
cv::OneWayDescriptorObject::_GetLabeledFeatures	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<cv::KeyPoint> _GetLabeledFeatures() const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:() const
cv::OneWayDescriptorObject::m_object_feature_count	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_object_feature_count; \/\/ the number of the positive features$/;"	m	class:cv::OneWayDescriptorObject	access:protected
cv::OneWayDescriptorObject::m_part_id	/usr/include/opencv2/features2d/features2d.hpp	/^    int* m_part_id; \/\/ contains part id for each of object descriptors$/;"	m	class:cv::OneWayDescriptorObject	access:protected
cv::OneWayDescriptorObject::m_train_features	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<cv::KeyPoint> m_train_features; \/\/ train features$/;"	m	class:cv::OneWayDescriptorObject	access:protected
cv::OneWayDescriptorObject::~OneWayDescriptorObject	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~OneWayDescriptorObject();$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:()
cv::OpenGLCallback	/usr/include/opencv2/highgui/highgui.hpp	/^typedef void (CV_CDECL *OpenGLCallback)(void* userdata);$/;"	t	namespace:cv
cv::OpponentColorDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS OpponentColorDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
cv::OpponentColorDescriptorExtractor::OpponentColorDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    OpponentColorDescriptorExtractor( const Ptr<DescriptorExtractor>& descriptorExtractor );$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( const Ptr<DescriptorExtractor>& descriptorExtractor )
cv::OpponentColorDescriptorExtractor::computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::OpponentColorDescriptorExtractor::descriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> descriptorExtractor;$/;"	m	class:cv::OpponentColorDescriptorExtractor	access:protected
cv::OpponentColorDescriptorExtractor::descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:() const
cv::OpponentColorDescriptorExtractor::descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:() const
cv::OpponentColorDescriptorExtractor::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( const FileNode& )
cv::OpponentColorDescriptorExtractor::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( FileStorage& ) const
cv::PCA	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS PCA$/;"	c	namespace:cv
cv::PCA::PCA	/usr/include/opencv2/core/core.hpp	/^    PCA();$/;"	p	class:cv::PCA	access:public	signature:()
cv::PCA::PCA	/usr/include/opencv2/core/core.hpp	/^    PCA(const Mat& data, const Mat& mean, int flags, int maxComponents=0);$/;"	p	class:cv::PCA	access:public	signature:(const Mat& data, const Mat& mean, int flags, int maxComponents=0)
cv::PCA::backProject	/usr/include/opencv2/core/core.hpp	/^    Mat backProject(const Mat& vec) const;$/;"	p	class:cv::PCA	access:public	signature:(const Mat& vec) const
cv::PCA::backProject	/usr/include/opencv2/core/core.hpp	/^    void backProject(const Mat& vec, CV_OUT Mat& result) const;$/;"	p	class:cv::PCA	access:public	signature:(const Mat& vec, CV_OUT Mat& result) const
cv::PCA::eigenvalues	/usr/include/opencv2/core/core.hpp	/^    Mat eigenvalues; \/\/!< eigenvalues of the covariation matrix$/;"	m	class:cv::PCA	access:public
cv::PCA::eigenvectors	/usr/include/opencv2/core/core.hpp	/^    Mat eigenvectors; \/\/!< eigenvectors of the covariation matrix$/;"	m	class:cv::PCA	access:public
cv::PCA::mean	/usr/include/opencv2/core/core.hpp	/^    Mat mean; \/\/!< mean value subtracted before the projection and added after the back projection$/;"	m	class:cv::PCA	access:public
cv::PCA::operator ()	/usr/include/opencv2/core/core.hpp	/^    PCA& operator()(const Mat& data, const Mat& mean, int flags, int maxComponents=0);$/;"	p	class:cv::PCA	access:public	signature:(const Mat& data, const Mat& mean, int flags, int maxComponents=0)
cv::PCA::project	/usr/include/opencv2/core/core.hpp	/^    Mat project(const Mat& vec) const;$/;"	p	class:cv::PCA	access:public	signature:(const Mat& vec) const
cv::PCA::project	/usr/include/opencv2/core/core.hpp	/^    void project(const Mat& vec, CV_OUT Mat& result) const;$/;"	p	class:cv::PCA	access:public	signature:(const Mat& vec, CV_OUT Mat& result) const
cv::PROJ_SPHERICAL_EQRECT	/usr/include/opencv2/imgproc/imgproc.hpp	/^    PROJ_SPHERICAL_EQRECT = 1$/;"	e	enum:cv::__anon44
cv::PROJ_SPHERICAL_ORTHO	/usr/include/opencv2/imgproc/imgproc.hpp	/^    PROJ_SPHERICAL_ORTHO = 0,$/;"	e	enum:cv::__anon44
cv::ParamGrid	/usr/include/opencv2/ml/ml.hpp	/^typedef CvParamGrid ParamGrid;$/;"	t	namespace:cv
cv::PatchGenerator	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS PatchGenerator$/;"	c	namespace:cv
cv::PatchGenerator::PatchGenerator	/usr/include/opencv2/features2d/features2d.hpp	/^    PatchGenerator();$/;"	p	class:cv::PatchGenerator	access:public	signature:()
cv::PatchGenerator::PatchGenerator	/usr/include/opencv2/features2d/features2d.hpp	/^    PatchGenerator(double _backgroundMin, double _backgroundMax,$/;"	p	class:cv::PatchGenerator	access:public	signature:(double _backgroundMin, double _backgroundMax, double _noiseRange, bool _randomBlur=true, double _lambdaMin=0.6, double _lambdaMax=1.5, double _thetaMin=-CV_PI, double _thetaMax=CV_PI, double _phiMin=-CV_PI, double _phiMax=CV_PI )
cv::PatchGenerator::backgroundMax	/usr/include/opencv2/features2d/features2d.hpp	/^    double backgroundMin, backgroundMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::backgroundMin	/usr/include/opencv2/features2d/features2d.hpp	/^    double backgroundMin, backgroundMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::generateRandomTransform	/usr/include/opencv2/features2d/features2d.hpp	/^    void generateRandomTransform(Point2f srcCenter, Point2f dstCenter,$/;"	p	class:cv::PatchGenerator	access:public	signature:(Point2f srcCenter, Point2f dstCenter, CV_OUT Mat& transform, RNG& rng, bool inverse=false) const
cv::PatchGenerator::lambdaMax	/usr/include/opencv2/features2d/features2d.hpp	/^    double lambdaMin, lambdaMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::lambdaMin	/usr/include/opencv2/features2d/features2d.hpp	/^    double lambdaMin, lambdaMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::noiseRange	/usr/include/opencv2/features2d/features2d.hpp	/^    double noiseRange;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const Mat& image, Point2f pt, Mat& patch, Size patchSize, RNG& rng) const;$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, Point2f pt, Mat& patch, Size patchSize, RNG& rng) const
cv::PatchGenerator::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const Mat& image, const Mat& transform, Mat& patch,$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, const Mat& transform, Mat& patch, Size patchSize, RNG& rng) const
cv::PatchGenerator::phiMax	/usr/include/opencv2/features2d/features2d.hpp	/^    double phiMin, phiMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::phiMin	/usr/include/opencv2/features2d/features2d.hpp	/^    double phiMin, phiMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::randomBlur	/usr/include/opencv2/features2d/features2d.hpp	/^    bool randomBlur;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::setAffineParam	/usr/include/opencv2/features2d/features2d.hpp	/^    void setAffineParam(double lambda, double theta, double phi);$/;"	p	class:cv::PatchGenerator	access:public	signature:(double lambda, double theta, double phi)
cv::PatchGenerator::thetaMax	/usr/include/opencv2/features2d/features2d.hpp	/^    double thetaMin, thetaMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::thetaMin	/usr/include/opencv2/features2d/features2d.hpp	/^    double thetaMin, thetaMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::warpWholeImage	/usr/include/opencv2/features2d/features2d.hpp	/^    void warpWholeImage(const Mat& image, Mat& matT, Mat& buf,$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, Mat& matT, Mat& buf, CV_OUT Mat& warped, int border, RNG& rng) const
cv::PlanarObjectDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS PlanarObjectDetector$/;"	c	namespace:cv
cv::PlanarObjectDetector::PlanarObjectDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    PlanarObjectDetector();$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:()
cv::PlanarObjectDetector::PlanarObjectDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    PlanarObjectDetector(const FileNode& node);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const FileNode& node)
cv::PlanarObjectDetector::PlanarObjectDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    PlanarObjectDetector(const vector<Mat>& pyr, int _npoints=300,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, int _npoints=300, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
cv::PlanarObjectDetector::fernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    FernClassifier fernClassifier;$/;"	m	class:cv::PlanarObjectDetector	access:protected
cv::PlanarObjectDetector::getClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    const FernClassifier& getClassifier() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
cv::PlanarObjectDetector::getDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    const LDetector& getDetector() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
cv::PlanarObjectDetector::getModelPoints	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<KeyPoint> getModelPoints() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
cv::PlanarObjectDetector::getModelROI	/usr/include/opencv2/features2d/features2d.hpp	/^    Rect getModelROI() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
cv::PlanarObjectDetector::ldetector	/usr/include/opencv2/features2d/features2d.hpp	/^    LDetector ldetector;$/;"	m	class:cv::PlanarObjectDetector	access:protected
cv::PlanarObjectDetector::modelPoints	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<KeyPoint> modelPoints;$/;"	m	class:cv::PlanarObjectDetector	access:protected
cv::PlanarObjectDetector::modelROI	/usr/include/opencv2/features2d/features2d.hpp	/^    Rect modelROI;$/;"	m	class:cv::PlanarObjectDetector	access:protected
cv::PlanarObjectDetector::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    bool operator()(const Mat& image, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners) const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const Mat& image, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners) const
cv::PlanarObjectDetector::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    bool operator()(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners, CV_OUT vector<int>* pairs=0) const
cv::PlanarObjectDetector::read	/usr/include/opencv2/features2d/features2d.hpp	/^    void read(const FileNode& node);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const FileNode& node)
cv::PlanarObjectDetector::setVerbose	/usr/include/opencv2/features2d/features2d.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(bool verbose)
cv::PlanarObjectDetector::train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
cv::PlanarObjectDetector::train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train(const vector<Mat>& pyr, int _npoints=300,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, int _npoints=300, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
cv::PlanarObjectDetector::verbose	/usr/include/opencv2/features2d/features2d.hpp	/^    bool verbose;$/;"	m	class:cv::PlanarObjectDetector	access:protected
cv::PlanarObjectDetector::write	/usr/include/opencv2/features2d/features2d.hpp	/^    void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(FileStorage& fs, const String& name=String()) const
cv::PlanarObjectDetector::~PlanarObjectDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~PlanarObjectDetector();$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:()
cv::Point	/usr/include/opencv2/core/core.hpp	/^typedef Point2i Point;$/;"	t	namespace:cv
cv::Point2d	/usr/include/opencv2/core/core.hpp	/^typedef Point_<double> Point2d;$/;"	t	namespace:cv
cv::Point2f	/usr/include/opencv2/core/core.hpp	/^typedef Point_<float> Point2f;$/;"	t	namespace:cv
cv::Point2i	/usr/include/opencv2/core/core.hpp	/^typedef Point_<int> Point2i;$/;"	t	namespace:cv
cv::Point3_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point3_$/;"	c	namespace:cv
cv::Point3_::Point3_	/usr/include/opencv2/core/core.hpp	/^	explicit Point3_(const Point_<_Tp>& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point_<_Tp>& pt)
cv::Point3_::Point3_	/usr/include/opencv2/core/core.hpp	/^    Point3_();$/;"	p	class:cv::Point3_	access:public	signature:()
cv::Point3_::Point3_	/usr/include/opencv2/core/core.hpp	/^    Point3_(_Tp _x, _Tp _y, _Tp _z);$/;"	p	class:cv::Point3_	access:public	signature:(_Tp _x, _Tp _y, _Tp _z)
cv::Point3_::Point3_	/usr/include/opencv2/core/core.hpp	/^    Point3_(const CvPoint3D32f& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const CvPoint3D32f& pt)
cv::Point3_::Point3_	/usr/include/opencv2/core/core.hpp	/^    Point3_(const Point3_& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt)
cv::Point3_::Point3_	/usr/include/opencv2/core/core.hpp	/^    Point3_(const Vec<_Tp, 3>& v);$/;"	p	class:cv::Point3_	access:public	signature:(const Vec<_Tp, 3>& v)
cv::Point3_::Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_() : x(0), y(0), z(0) {}$/;"	f	class:cv::Point3_	signature:()
cv::Point3_::Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(_Tp _x, _Tp _y, _Tp _z) : x(_x), y(_y), z(_z) {}$/;"	f	class:cv::Point3_	signature:(_Tp _x, _Tp _y, _Tp _z)
cv::Point3_::Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const CvPoint3D32f& pt) :$/;"	f	class:cv::Point3_	signature:(const CvPoint3D32f& pt)
cv::Point3_::Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point3_& pt) : x(pt.x), y(pt.y), z(pt.z) {}$/;"	f	class:cv::Point3_	signature:(const Point3_& pt)
cv::Point3_::Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point_<_Tp>& pt) : x(pt.x), y(pt.y), z(_Tp()) {}$/;"	f	class:cv::Point3_	signature:(const Point_<_Tp>& pt)
cv::Point3_::Point3_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Vec<_Tp, 3>& v) : x(v[0]), y(v[1]), z(v[2]) {}$/;"	f	class:cv::Point3_	signature:(const Vec<_Tp, 3>& v)
cv::Point3_::cross	/usr/include/opencv2/core/core.hpp	/^    Point3_ cross(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
cv::Point3_::cross	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp> Point3_<_Tp>::cross(const Point3_<_Tp>& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_<_Tp>& pt) const
cv::Point3_::ddot	/usr/include/opencv2/core/core.hpp	/^    double ddot(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
cv::Point3_::ddot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline double Point3_<_Tp>::ddot(const Point3_& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_& pt) const
cv::Point3_::dot	/usr/include/opencv2/core/core.hpp	/^    _Tp dot(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
cv::Point3_::dot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp Point3_<_Tp>::dot(const Point3_& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_& pt) const
cv::Point3_::operator =	/usr/include/opencv2/core/core.hpp	/^    Point3_& operator = (const Point3_& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt)
cv::Point3_::operator =	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>& Point3_<_Tp>::operator = (const Point3_& pt)$/;"	f	class:cv::Point3_	signature:(const Point3_& pt)
cv::Point3_::operator CvPoint3D32f	/usr/include/opencv2/core/core.hpp	/^    operator CvPoint3D32f() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
cv::Point3_::operator CvPoint3D32f	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::operator CvPoint3D32f() const$/;"	f	class:cv::Point3_	signature:() const
cv::Point3_::operator Point3_<_Tp2>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp2> operator Point3_<_Tp2>() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
cv::Point3_::operator Point3_<_Tp2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Point3_<_Tp>::operator Point3_<_Tp2>() const$/;"	f	class:cv::Point3_	signature:() const
cv::Point3_::operator Vec<_Tp, 3>	/usr/include/opencv2/core/core.hpp	/^    operator Vec<_Tp, 3>() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
cv::Point3_::operator Vec<_Tp, 3>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::operator Vec<_Tp, 3>() const$/;"	f	class:cv::Point3_	signature:() const
cv::Point3_::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Point3_	access:public
cv::Point3_::x	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
cv::Point3_::y	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
cv::Point3_::z	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
cv::Point3d	/usr/include/opencv2/core/core.hpp	/^typedef Point3_<double> Point3d;$/;"	t	namespace:cv
cv::Point3f	/usr/include/opencv2/core/core.hpp	/^typedef Point3_<float> Point3f;$/;"	t	namespace:cv
cv::Point3i	/usr/include/opencv2/core/core.hpp	/^typedef Point3_<int> Point3i;$/;"	t	namespace:cv
cv::Point_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point_$/;"	c	namespace:cv
cv::Point_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Point_::Point_	/usr/include/opencv2/core/core.hpp	/^    Point_();$/;"	p	class:cv::Point_	access:public	signature:()
cv::Point_::Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(_Tp _x, _Tp _y);$/;"	p	class:cv::Point_	access:public	signature:(_Tp _x, _Tp _y)
cv::Point_::Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(const CvPoint& pt);$/;"	p	class:cv::Point_	access:public	signature:(const CvPoint& pt)
cv::Point_::Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(const CvPoint2D32f& pt);$/;"	p	class:cv::Point_	access:public	signature:(const CvPoint2D32f& pt)
cv::Point_::Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(const Point_& pt);$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt)
cv::Point_::Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(const Size_<_Tp>& sz);$/;"	p	class:cv::Point_	access:public	signature:(const Size_<_Tp>& sz)
cv::Point_::Point_	/usr/include/opencv2/core/core.hpp	/^    Point_(const Vec<_Tp, 2>& v);$/;"	p	class:cv::Point_	access:public	signature:(const Vec<_Tp, 2>& v)
cv::Point_::Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_() : x(0), y(0) {}$/;"	f	class:cv::Point_	signature:()
cv::Point_::Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(_Tp _x, _Tp _y) : x(_x), y(_y) {}$/;"	f	class:cv::Point_	signature:(_Tp _x, _Tp _y)
cv::Point_::Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint& pt) : x((_Tp)pt.x), y((_Tp)pt.y) {}$/;"	f	class:cv::Point_	signature:(const CvPoint& pt)
cv::Point_::Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint2D32f& pt)$/;"	f	class:cv::Point_	signature:(const CvPoint2D32f& pt)
cv::Point_::Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Point_& pt) : x(pt.x), y(pt.y) {}$/;"	f	class:cv::Point_	signature:(const Point_& pt)
cv::Point_::Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Size_<_Tp>& sz) : x(sz.width), y(sz.height) {}$/;"	f	class:cv::Point_	signature:(const Size_<_Tp>& sz)
cv::Point_::Point_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Vec<_Tp,2>& v) : x(v[0]), y(v[1]) {}$/;"	f	class:cv::Point_	signature:(const Vec<_Tp,2>& v)
cv::Point_::ddot	/usr/include/opencv2/core/core.hpp	/^    double ddot(const Point_& pt) const;$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt) const
cv::Point_::ddot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline double Point_<_Tp>::ddot(const Point_& pt) const$/;"	f	class:cv::Point_	signature:(const Point_& pt) const
cv::Point_::dot	/usr/include/opencv2/core/core.hpp	/^    _Tp dot(const Point_& pt) const;$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt) const
cv::Point_::dot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp Point_<_Tp>::dot(const Point_& pt) const$/;"	f	class:cv::Point_	signature:(const Point_& pt) const
cv::Point_::inside	/usr/include/opencv2/core/core.hpp	/^    bool inside(const Rect_<_Tp>& r) const;$/;"	p	class:cv::Point_	access:public	signature:(const Rect_<_Tp>& r) const
cv::Point_::inside	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool Point_<_Tp>::inside( const Rect_<_Tp>& r ) const$/;"	f	class:cv::Point_	signature:( const Rect_<_Tp>& r ) const
cv::Point_::operator =	/usr/include/opencv2/core/core.hpp	/^    Point_& operator = (const Point_& pt);$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt)
cv::Point_::operator =	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>& Point_<_Tp>::operator = (const Point_& pt)$/;"	f	class:cv::Point_	signature:(const Point_& pt)
cv::Point_::operator CvPoint	/usr/include/opencv2/core/core.hpp	/^    operator CvPoint() const;$/;"	p	class:cv::Point_	access:public	signature:() const
cv::Point_::operator CvPoint	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator CvPoint() const$/;"	f	class:cv::Point_	signature:() const
cv::Point_::operator CvPoint2D32f	/usr/include/opencv2/core/core.hpp	/^    operator CvPoint2D32f() const;$/;"	p	class:cv::Point_	access:public	signature:() const
cv::Point_::operator CvPoint2D32f	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator CvPoint2D32f() const$/;"	f	class:cv::Point_	signature:() const
cv::Point_::operator Point_<_Tp2>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp2> operator Point_<_Tp2>() const;$/;"	p	class:cv::Point_	access:public	signature:() const
cv::Point_::operator Point_<_Tp2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Point_<_Tp>::operator Point_<_Tp2>() const$/;"	f	class:cv::Point_	signature:() const
cv::Point_::operator Vec<_Tp, 2>	/usr/include/opencv2/core/core.hpp	/^    operator Vec<_Tp, 2>() const;$/;"	p	class:cv::Point_	access:public	signature:() const
cv::Point_::operator Vec<_Tp, 2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator Vec<_Tp, 2>() const$/;"	f	class:cv::Point_	signature:() const
cv::Point_::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Point_	access:public
cv::Point_::x	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y; \/\/< the point coordinates$/;"	m	class:cv::Point_	access:public
cv::Point_::y	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y; \/\/< the point coordinates$/;"	m	class:cv::Point_	access:public
cv::Ptr	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Ptr$/;"	c	namespace:cv
cv::Ptr::Ptr	/usr/include/opencv2/core/core.hpp	/^    Ptr();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::Ptr	/usr/include/opencv2/core/core.hpp	/^    Ptr(_Tp* _obj);$/;"	p	class:cv::Ptr	access:public	signature:(_Tp* _obj)
cv::Ptr::Ptr	/usr/include/opencv2/core/core.hpp	/^    Ptr(const Ptr& ptr);$/;"	p	class:cv::Ptr	access:public	signature:(const Ptr& ptr)
cv::Ptr::Ptr	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr() : obj(0), refcount(0) {}$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::Ptr	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr(_Tp* _obj) : obj(_obj)$/;"	f	class:cv::Ptr	signature:(_Tp* _obj)
cv::Ptr::Ptr	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr(const Ptr<_Tp>& ptr)$/;"	f	class:cv::Ptr	signature:(const Ptr<_Tp>& ptr)
cv::Ptr::addref	/usr/include/opencv2/core/core.hpp	/^    void addref();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::addref	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::addref()$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/calib3d/calib3d.hpp	/^template<> CV_EXPORTS void Ptr<CvStereoBMState>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/core/core.hpp	/^    void delete_obj();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvFileStorage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMat>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMatND>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMemStorage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvSparseMat>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<IplImage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::delete_obj()$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/highgui/highgui.hpp	/^template<> void CV_EXPORTS Ptr<CvCapture>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/highgui/highgui.hpp	/^template<> void CV_EXPORTS Ptr<CvVideoWriter>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/imgproc/imgproc.hpp	/^template<> CV_EXPORTS void Ptr<CvHistogram>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/imgproc/imgproc.hpp	/^template<> CV_EXPORTS void Ptr<IplConvKernel>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/ml/ml.hpp	/^template<> CV_EXPORTS void Ptr<CvDTreeSplit>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	/usr/include/opencv2/objdetect/objdetect.hpp	/^template<> CV_EXPORTS void Ptr<CvHaarClassifierCascade>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::empty	/usr/include/opencv2/core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Ptr	access:public	signature:() const
cv::Ptr::empty	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool Ptr<_Tp>::empty() const { return obj == 0; }$/;"	f	class:cv::Ptr	signature:() const
cv::Ptr::obj	/usr/include/opencv2/core/core.hpp	/^    _Tp* obj; \/\/< the object pointer.$/;"	m	class:cv::Ptr	access:protected
cv::Ptr::operator ->	/usr/include/opencv2/core/core.hpp	/^    _Tp* operator -> ();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::operator ->	/usr/include/opencv2/core/core.hpp	/^    const _Tp* operator -> () const;$/;"	p	class:cv::Ptr	access:public	signature:() const
cv::Ptr::operator ->	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp* Ptr<_Tp>::operator -> () { return obj; }$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::operator ->	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline const _Tp* Ptr<_Tp>::operator -> () const { return obj; }$/;"	f	class:cv::Ptr	signature:() const
cv::Ptr::operator =	/usr/include/opencv2/core/core.hpp	/^    Ptr& operator = (const Ptr& ptr);$/;"	p	class:cv::Ptr	access:public	signature:(const Ptr& ptr)
cv::Ptr::operator =	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>& Ptr<_Tp>::operator = (const Ptr<_Tp>& ptr)$/;"	f	class:cv::Ptr	signature:(const Ptr<_Tp>& ptr)
cv::Ptr::operator _Tp*	/usr/include/opencv2/core/core.hpp	/^    operator _Tp* ();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::operator _Tp*	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::operator _Tp* () { return obj; }$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::operator const _Tp*	/usr/include/opencv2/core/core.hpp	/^    operator const _Tp*() const;$/;"	p	class:cv::Ptr	access:public	signature:() const
cv::Ptr::operator const _Tp*	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::operator const _Tp*() const { return obj; }$/;"	f	class:cv::Ptr	signature:() const
cv::Ptr::refcount	/usr/include/opencv2/core/core.hpp	/^    int* refcount; \/\/< the associated                         bbbbbbbbbbbbbbbbbb reference counter$/;"	m	class:cv::Ptr	access:protected
cv::Ptr::release	/usr/include/opencv2/core/core.hpp	/^    void release();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::release	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::release()$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::~Ptr	/usr/include/opencv2/core/core.hpp	/^    ~Ptr();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::~Ptr	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }$/;"	f	class:cv::Ptr	signature:()
cv::PyramidAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS PyramidAdaptedFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::PyramidAdaptedFeatureDetector::PyramidAdaptedFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    PyramidAdaptedFeatureDetector( const Ptr<FeatureDetector>& detector, int levels=2 );$/;"	p	class:cv::PyramidAdaptedFeatureDetector	access:public	signature:( const Ptr<FeatureDetector>& detector, int levels=2 )
cv::PyramidAdaptedFeatureDetector::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::PyramidAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::PyramidAdaptedFeatureDetector::detector	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<FeatureDetector> detector;$/;"	m	class:cv::PyramidAdaptedFeatureDetector	access:protected
cv::PyramidAdaptedFeatureDetector::levels	/usr/include/opencv2/features2d/features2d.hpp	/^    int levels;$/;"	m	class:cv::PyramidAdaptedFeatureDetector	access:protected
cv::RANSAC	/usr/include/opencv2/calib3d/calib3d.hpp	/^    RANSAC=CV_RANSAC \/\/!< RANSAC algorithm$/;"	e	enum:cv::__anon67
cv::RETR_CCOMP	/usr/include/opencv2/imgproc/imgproc.hpp	/^    RETR_CCOMP=2, \/\/!< retrieve the connected components (that can possibly be nested)$/;"	e	enum:cv::__anon50
cv::RETR_EXTERNAL	/usr/include/opencv2/imgproc/imgproc.hpp	/^    RETR_EXTERNAL=0, \/\/!< retrieve only the most external (top-level) contours$/;"	e	enum:cv::__anon50
cv::RETR_LIST	/usr/include/opencv2/imgproc/imgproc.hpp	/^    RETR_LIST=1, \/\/!< retrieve all the contours without any hierarchical information$/;"	e	enum:cv::__anon50
cv::RETR_TREE	/usr/include/opencv2/imgproc/imgproc.hpp	/^    RETR_TREE=3 \/\/!< retrieve all the contours and the whole hierarchy$/;"	e	enum:cv::__anon50
cv::RNG	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS RNG$/;"	c	namespace:cv
cv::RNG::A	/usr/include/opencv2/core/core.hpp	/^    enum { A=4164903690U, UNIFORM=0, NORMAL=1 };$/;"	e	enum:cv::RNG::__anon143
cv::RNG::NORMAL	/usr/include/opencv2/core/core.hpp	/^    enum { A=4164903690U, UNIFORM=0, NORMAL=1 };$/;"	e	enum:cv::RNG::__anon143
cv::RNG::RNG	/usr/include/opencv2/core/core.hpp	/^    RNG();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::RNG	/usr/include/opencv2/core/core.hpp	/^    RNG(uint64 _state);$/;"	p	class:cv::RNG	access:public	signature:(uint64 _state)
cv::RNG::RNG	/usr/include/opencv2/core/operations.hpp	/^inline RNG::RNG() { state = 0xffffffff; }$/;"	f	class:cv::RNG	signature:()
cv::RNG::RNG	/usr/include/opencv2/core/operations.hpp	/^inline RNG::RNG(uint64 _state) { state = _state ? _state : 0xffffffff; }$/;"	f	class:cv::RNG	signature:(uint64 _state)
cv::RNG::UNIFORM	/usr/include/opencv2/core/core.hpp	/^    enum { A=4164903690U, UNIFORM=0, NORMAL=1 };$/;"	e	enum:cv::RNG::__anon143
cv::RNG::fill	/usr/include/opencv2/core/core.hpp	/^    void fill( Mat& mat, int distType, const Scalar& a, const Scalar& b );$/;"	p	class:cv::RNG	access:public	signature:( Mat& mat, int distType, const Scalar& a, const Scalar& b )
cv::RNG::gaussian	/usr/include/opencv2/core/core.hpp	/^	double gaussian(double sigma);$/;"	p	class:cv::RNG	access:public	signature:(double sigma)
cv::RNG::next	/usr/include/opencv2/core/core.hpp	/^    unsigned next();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::next	/usr/include/opencv2/core/operations.hpp	/^inline unsigned RNG::next()$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator ()	/usr/include/opencv2/core/core.hpp	/^	unsigned operator ()();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator ()	/usr/include/opencv2/core/core.hpp	/^	unsigned operator()(unsigned N);$/;"	p	class:cv::RNG	access:public	signature:(unsigned N)
cv::RNG::operator ()	/usr/include/opencv2/core/operations.hpp	/^inline unsigned RNG::operator ()() {return next();}$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator ()	/usr/include/opencv2/core/operations.hpp	/^inline unsigned RNG::operator ()(unsigned N) {return (unsigned)uniform(0,N);}$/;"	f	class:cv::RNG	signature:(unsigned N)
cv::RNG::operator double	/usr/include/opencv2/core/core.hpp	/^    operator double();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator double	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator double()$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator float	/usr/include/opencv2/core/core.hpp	/^    operator float();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator float	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator float() { return next()*2.3283064365386962890625e-10f; }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator int	/usr/include/opencv2/core/core.hpp	/^    operator int();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator int	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator int() { return (int)next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator schar	/usr/include/opencv2/core/core.hpp	/^    operator schar();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator schar	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator schar() { return (schar)next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator short	/usr/include/opencv2/core/core.hpp	/^    operator short();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator short	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator short() { return (short)next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator uchar	/usr/include/opencv2/core/core.hpp	/^    operator uchar();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator uchar	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator uchar() { return (uchar)next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator unsigned	/usr/include/opencv2/core/core.hpp	/^    operator unsigned();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator unsigned	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator unsigned() { return next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator ushort	/usr/include/opencv2/core/core.hpp	/^    operator ushort();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator ushort	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator ushort() { return (ushort)next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::state	/usr/include/opencv2/core/core.hpp	/^    uint64 state;$/;"	m	class:cv::RNG	access:public
cv::RNG::uniform	/usr/include/opencv2/core/core.hpp	/^    double uniform(double a, double b);$/;"	p	class:cv::RNG	access:public	signature:(double a, double b)
cv::RNG::uniform	/usr/include/opencv2/core/core.hpp	/^    float uniform(float a, float b);$/;"	p	class:cv::RNG	access:public	signature:(float a, float b)
cv::RNG::uniform	/usr/include/opencv2/core/core.hpp	/^    int uniform(int a, int b);$/;"	p	class:cv::RNG	access:public	signature:(int a, int b)
cv::RNG::uniform	/usr/include/opencv2/core/operations.hpp	/^inline double RNG::uniform(double a, double b) { return ((float)*this)*(b - a) + a; }$/;"	f	class:cv::RNG	signature:(double a, double b)
cv::RNG::uniform	/usr/include/opencv2/core/operations.hpp	/^inline float RNG::uniform(float a, float b) { return ((float)*this)*(b - a) + a; }$/;"	f	class:cv::RNG	signature:(float a, float b)
cv::RNG::uniform	/usr/include/opencv2/core/operations.hpp	/^inline int RNG::uniform(int a, int b) { return a == b ? a : next()%(b - a) + a; }$/;"	f	class:cv::RNG	signature:(int a, int b)
cv::RQDecomp3x3	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void RQDecomp3x3( const Mat& M, Mat& R, Mat& Q );$/;"	p	namespace:cv	signature:( const Mat& M, Mat& R, Mat& Q )
cv::RQDecomp3x3	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Vec3d RQDecomp3x3( const Mat& M, Mat& R, Mat& Q,$/;"	p	namespace:cv	signature:( const Mat& M, Mat& R, Mat& Q, CV_OUT Mat& Qx, CV_OUT Mat& Qy, CV_OUT Mat& Qz )
cv::RTTIImpl	/usr/include/opencv2/core/operations.hpp	/^template<typename _ClsName> struct CV_EXPORTS RTTIImpl$/;"	s	namespace:cv
cv::RTTIImpl::clone	/usr/include/opencv2/core/operations.hpp	/^    static void* clone(const void* ptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(const void* ptr)
cv::RTTIImpl::isInstance	/usr/include/opencv2/core/operations.hpp	/^    static int isInstance(const void* ptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(const void* ptr)
cv::RTTIImpl::read	/usr/include/opencv2/core/operations.hpp	/^    static void* read(CvFileStorage* fs, CvFileNode* n)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(CvFileStorage* fs, CvFileNode* n)
cv::RTTIImpl::release	/usr/include/opencv2/core/operations.hpp	/^    static void release(void** dbptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(void** dbptr)
cv::RTTIImpl::write	/usr/include/opencv2/core/operations.hpp	/^    static void write(CvFileStorage* _fs, const char* name, const void* ptr, CvAttrList)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(CvFileStorage* _fs, const char* name, const void* ptr, CvAttrList)
cv::RTreeClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS RTreeClassifier$/;"	c	namespace:cv
cv::RTreeClassifier::DEFAULT_NUM_QUANT_BITS	/usr/include/opencv2/features2d/features2d.hpp	/^  static const size_t DEFAULT_NUM_QUANT_BITS = 4;$/;"	m	class:cv::RTreeClassifier	access:public
cv::RTreeClassifier::DEFAULT_TREES	/usr/include/opencv2/features2d/features2d.hpp	/^  static const int DEFAULT_TREES = 48;$/;"	m	class:cv::RTreeClassifier	access:public
cv::RTreeClassifier::RTreeClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^  RTreeClassifier();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
cv::RTreeClassifier::classes	/usr/include/opencv2/features2d/features2d.hpp	/^  inline int classes() const { return classes_; }$/;"	f	class:cv::RTreeClassifier	access:public	signature:() const
cv::RTreeClassifier::classes_	/usr/include/opencv2/features2d/features2d.hpp	/^  int classes_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::countNonZeroElements	/usr/include/opencv2/features2d/features2d.hpp	/^  static int countNonZeroElements(float *vec, int n, double tol=1e-10);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(float *vec, int n, double tol=1e-10)
cv::RTreeClassifier::countZeroElements	/usr/include/opencv2/features2d/features2d.hpp	/^  float countZeroElements();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
cv::RTreeClassifier::discardFloatPosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void discardFloatPosteriors();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
cv::RTreeClassifier::getFloatSignature	/usr/include/opencv2/features2d/features2d.hpp	/^  void getFloatSignature(IplImage *patch, float *sig) const { getSignature(patch, sig); }$/;"	f	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig) const
cv::RTreeClassifier::getSignature	/usr/include/opencv2/features2d/features2d.hpp	/^  void getSignature(IplImage *patch, float *sig) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig) const
cv::RTreeClassifier::getSignature	/usr/include/opencv2/features2d/features2d.hpp	/^  void getSignature(IplImage *patch, uchar *sig) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, uchar *sig) const
cv::RTreeClassifier::getSparseSignature	/usr/include/opencv2/features2d/features2d.hpp	/^  void getSparseSignature(IplImage *patch, float *sig, float thresh) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig, float thresh) const
cv::RTreeClassifier::keep_floats_	/usr/include/opencv2/features2d/features2d.hpp	/^  bool keep_floats_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::num_quant_bits_	/usr/include/opencv2/features2d/features2d.hpp	/^  int num_quant_bits_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::original_num_classes	/usr/include/opencv2/features2d/features2d.hpp	/^  inline int original_num_classes() const { return original_num_classes_; }$/;"	f	class:cv::RTreeClassifier	access:public	signature:() const
cv::RTreeClassifier::original_num_classes_	/usr/include/opencv2/features2d/features2d.hpp	/^  int original_num_classes_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::posteriors_	/usr/include/opencv2/features2d/features2d.hpp	/^  mutable uchar **posteriors_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::ptemp_	/usr/include/opencv2/features2d/features2d.hpp	/^  mutable unsigned short *ptemp_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::read	/usr/include/opencv2/features2d/features2d.hpp	/^  void read(const char* file_name);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(const char* file_name)
cv::RTreeClassifier::read	/usr/include/opencv2/features2d/features2d.hpp	/^  void read(std::istream &is);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::istream &is)
cv::RTreeClassifier::safeSignatureAlloc	/usr/include/opencv2/features2d/features2d.hpp	/^  static inline uchar* safeSignatureAlloc(int num_sig=1, int sig_len=176);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(int num_sig=1, int sig_len=176)
cv::RTreeClassifier::safeSignatureAlloc	/usr/include/opencv2/features2d/features2d.hpp	/^  static inline void safeSignatureAlloc(uchar **sig, int num_sig=1, int sig_len=176);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(uchar **sig, int num_sig=1, int sig_len=176)
cv::RTreeClassifier::saveAllBytePosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void saveAllBytePosteriors(std::string file_url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string file_url)
cv::RTreeClassifier::saveAllFloatPosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void saveAllFloatPosteriors(std::string file_url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string file_url)
cv::RTreeClassifier::setFloatPosteriorsFromTextfile_176	/usr/include/opencv2/features2d/features2d.hpp	/^  void setFloatPosteriorsFromTextfile_176(std::string url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string url)
cv::RTreeClassifier::setQuantization	/usr/include/opencv2/features2d/features2d.hpp	/^  void setQuantization(int num_quant_bits);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(int num_quant_bits)
cv::RTreeClassifier::train	/usr/include/opencv2/features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set,$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, PatchGenerator &make_patch, int num_trees = RTreeClassifier::DEFAULT_TREES, int depth = RandomizedTree::DEFAULT_DEPTH, int views = RandomizedTree::DEFAULT_VIEWS, size_t reduced_num_dim = RandomizedTree::DEFAULT_REDUCED_NUM_DIM, int num_quant_bits = DEFAULT_NUM_QUANT_BITS)
cv::RTreeClassifier::train	/usr/include/opencv2/features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set,$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, int num_trees = RTreeClassifier::DEFAULT_TREES, int depth = RandomizedTree::DEFAULT_DEPTH, int views = RandomizedTree::DEFAULT_VIEWS, size_t reduced_num_dim = RandomizedTree::DEFAULT_REDUCED_NUM_DIM, int num_quant_bits = DEFAULT_NUM_QUANT_BITS)
cv::RTreeClassifier::trees_	/usr/include/opencv2/features2d/features2d.hpp	/^  std::vector<RandomizedTree> trees_;$/;"	m	class:cv::RTreeClassifier	access:public
cv::RTreeClassifier::write	/usr/include/opencv2/features2d/features2d.hpp	/^  void write(const char* file_name) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(const char* file_name) const
cv::RTreeClassifier::write	/usr/include/opencv2/features2d/features2d.hpp	/^  void write(std::ostream &os) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::ostream &os) const
cv::RTreeNode	/usr/include/opencv2/features2d/features2d.hpp	/^struct CV_EXPORTS RTreeNode$/;"	s	namespace:cv
cv::RTreeNode::RTreeNode	/usr/include/opencv2/features2d/features2d.hpp	/^  RTreeNode() {}$/;"	f	struct:cv::RTreeNode	access:public	signature:()
cv::RTreeNode::RTreeNode	/usr/include/opencv2/features2d/features2d.hpp	/^  RTreeNode(uchar x1, uchar y1, uchar x2, uchar y2)$/;"	f	struct:cv::RTreeNode	access:public	signature:(uchar x1, uchar y1, uchar x2, uchar y2)
cv::RTreeNode::offset1	/usr/include/opencv2/features2d/features2d.hpp	/^  short offset1, offset2;$/;"	m	struct:cv::RTreeNode	access:public
cv::RTreeNode::offset2	/usr/include/opencv2/features2d/features2d.hpp	/^  short offset1, offset2;$/;"	m	struct:cv::RTreeNode	access:public
cv::RTreeNode::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^  inline bool operator() (uchar* patch_data) const$/;"	f	struct:cv::RTreeNode	access:public	signature:(uchar* patch_data) const
cv::RandomTreeParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvRTParams RandomTreeParams;$/;"	t	namespace:cv
cv::RandomTrees	/usr/include/opencv2/ml/ml.hpp	/^typedef CvRTrees RandomTrees;$/;"	t	namespace:cv
cv::RandomizedTree	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS RandomizedTree$/;"	c	namespace:cv
cv::RandomizedTree::DEFAULT_DEPTH	/usr/include/opencv2/features2d/features2d.hpp	/^  static const int DEFAULT_DEPTH = 9;$/;"	m	class:cv::RandomizedTree	access:public
cv::RandomizedTree::DEFAULT_REDUCED_NUM_DIM	/usr/include/opencv2/features2d/features2d.hpp	/^  static const size_t DEFAULT_REDUCED_NUM_DIM = 176;$/;"	m	class:cv::RandomizedTree	access:public
cv::RandomizedTree::DEFAULT_VIEWS	/usr/include/opencv2/features2d/features2d.hpp	/^  static const int DEFAULT_VIEWS = 5000;$/;"	m	class:cv::RandomizedTree	access:public
cv::RandomizedTree::GET_LOWER_QUANT_PERC	/usr/include/opencv2/features2d/features2d.hpp	/^  static float GET_LOWER_QUANT_PERC() { return .03f; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::GET_UPPER_QUANT_PERC	/usr/include/opencv2/features2d/features2d.hpp	/^  static float GET_UPPER_QUANT_PERC() { return .92f; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::PATCH_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^  static const uchar PATCH_SIZE = 32;$/;"	m	class:cv::RandomizedTree	access:public
cv::RandomizedTree::RandomizedTree	/usr/include/opencv2/features2d/features2d.hpp	/^  RandomizedTree();$/;"	p	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::addExample	/usr/include/opencv2/features2d/features2d.hpp	/^  void addExample(int class_id, uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int class_id, uchar* patch_data)
cv::RandomizedTree::allocPosteriorsAligned	/usr/include/opencv2/features2d/features2d.hpp	/^  void allocPosteriorsAligned(int num_leaves, int num_classes);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_leaves, int num_classes)
cv::RandomizedTree::applyQuantization	/usr/include/opencv2/features2d/features2d.hpp	/^  inline void applyQuantization(int num_quant_bits) { makePosteriors2(num_quant_bits); }$/;"	f	class:cv::RandomizedTree	access:public	signature:(int num_quant_bits)
cv::RandomizedTree::classes	/usr/include/opencv2/features2d/features2d.hpp	/^  int classes() { return classes_; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::classes_	/usr/include/opencv2/features2d/features2d.hpp	/^  int classes_;$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::compressLeaves	/usr/include/opencv2/features2d/features2d.hpp	/^  void compressLeaves(size_t reduced_num_dim);$/;"	p	class:cv::RandomizedTree	access:private	signature:(size_t reduced_num_dim)
cv::RandomizedTree::convertPosteriorsToChar	/usr/include/opencv2/features2d/features2d.hpp	/^  void convertPosteriorsToChar();$/;"	p	class:cv::RandomizedTree	access:private	signature:()
cv::RandomizedTree::createNodes	/usr/include/opencv2/features2d/features2d.hpp	/^  void createNodes(int num_nodes, RNG &rng);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_nodes, RNG &rng)
cv::RandomizedTree::depth	/usr/include/opencv2/features2d/features2d.hpp	/^  int depth() { return depth_; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::depth_	/usr/include/opencv2/features2d/features2d.hpp	/^  int depth_;$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::discardFloatPosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void discardFloatPosteriors() { freePosteriors(1); }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::estimateQuantPercForPosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void estimateQuantPercForPosteriors(float perc[2]);$/;"	p	class:cv::RandomizedTree	access:private	signature:(float perc[2])
cv::RandomizedTree::finalize	/usr/include/opencv2/features2d/features2d.hpp	/^  void finalize(size_t reduced_num_dim, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:private	signature:(size_t reduced_num_dim, int num_quant_bits)
cv::RandomizedTree::freePosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void freePosteriors(int which);    \/\/ which: 1=posteriors_, 2=posteriors2_, 3=both$/;"	p	class:cv::RandomizedTree	access:private	signature:(int which)
cv::RandomizedTree::getIndex	/usr/include/opencv2/features2d/features2d.hpp	/^  int getIndex(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(uchar* patch_data) const
cv::RandomizedTree::getPosterior	/usr/include/opencv2/features2d/features2d.hpp	/^  const float* getPosterior(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data) const
cv::RandomizedTree::getPosterior	/usr/include/opencv2/features2d/features2d.hpp	/^  float* getPosterior(uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data)
cv::RandomizedTree::getPosterior2	/usr/include/opencv2/features2d/features2d.hpp	/^  const uchar* getPosterior2(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data) const
cv::RandomizedTree::getPosterior2	/usr/include/opencv2/features2d/features2d.hpp	/^  uchar* getPosterior2(uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data)
cv::RandomizedTree::getPosteriorByIndex	/usr/include/opencv2/features2d/features2d.hpp	/^  inline const float* getPosteriorByIndex(int index) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index) const
cv::RandomizedTree::getPosteriorByIndex	/usr/include/opencv2/features2d/features2d.hpp	/^  inline float* getPosteriorByIndex(int index);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index)
cv::RandomizedTree::getPosteriorByIndex	/usr/include/opencv2/features2d/features2d.hpp	/^inline const float* RandomizedTree::getPosteriorByIndex(int index) const$/;"	f	class:cv::RandomizedTree	signature:(int index) const
cv::RandomizedTree::getPosteriorByIndex	/usr/include/opencv2/features2d/features2d.hpp	/^inline float* RandomizedTree::getPosteriorByIndex(int index)$/;"	f	class:cv::RandomizedTree	signature:(int index)
cv::RandomizedTree::getPosteriorByIndex2	/usr/include/opencv2/features2d/features2d.hpp	/^  inline const uchar* getPosteriorByIndex2(int index) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index) const
cv::RandomizedTree::getPosteriorByIndex2	/usr/include/opencv2/features2d/features2d.hpp	/^  inline uchar* getPosteriorByIndex2(int index);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index)
cv::RandomizedTree::getPosteriorByIndex2	/usr/include/opencv2/features2d/features2d.hpp	/^inline const uchar* RandomizedTree::getPosteriorByIndex2(int index) const$/;"	f	class:cv::RandomizedTree	signature:(int index) const
cv::RandomizedTree::getPosteriorByIndex2	/usr/include/opencv2/features2d/features2d.hpp	/^inline uchar* RandomizedTree::getPosteriorByIndex2(int index)$/;"	f	class:cv::RandomizedTree	signature:(int index)
cv::RandomizedTree::init	/usr/include/opencv2/features2d/features2d.hpp	/^  void init(int classes, int depth, RNG &rng);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int classes, int depth, RNG &rng)
cv::RandomizedTree::leaf_counts_	/usr/include/opencv2/features2d/features2d.hpp	/^  std::vector<int> leaf_counts_;$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::makePosteriors2	/usr/include/opencv2/features2d/features2d.hpp	/^  void makePosteriors2(int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_quant_bits)
cv::RandomizedTree::nodes_	/usr/include/opencv2/features2d/features2d.hpp	/^  std::vector<RTreeNode> nodes_;$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::num_leaves_	/usr/include/opencv2/features2d/features2d.hpp	/^  int num_leaves_;$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::posteriors2_	/usr/include/opencv2/features2d/features2d.hpp	/^  uchar **posteriors2_;     \/\/ 16-bytes aligned posteriors$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::posteriors_	/usr/include/opencv2/features2d/features2d.hpp	/^  float **posteriors_;        \/\/ 16-bytes aligned posteriors$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::quantizeVector	/usr/include/opencv2/features2d/features2d.hpp	/^  static void quantizeVector(float *src, int dim, int N, float bnds[2], uchar *dst);$/;"	p	class:cv::RandomizedTree	access:public	signature:(float *src, int dim, int N, float bnds[2], uchar *dst)
cv::RandomizedTree::quantizeVector	/usr/include/opencv2/features2d/features2d.hpp	/^  static void quantizeVector(float *vec, int dim, int N, float bnds[2], int clamp_mode=0);$/;"	p	class:cv::RandomizedTree	access:public	signature:(float *vec, int dim, int N, float bnds[2], int clamp_mode=0)
cv::RandomizedTree::read	/usr/include/opencv2/features2d/features2d.hpp	/^  void read(const char* file_name, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:public	signature:(const char* file_name, int num_quant_bits)
cv::RandomizedTree::read	/usr/include/opencv2/features2d/features2d.hpp	/^  void read(std::istream &is, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::istream &is, int num_quant_bits)
cv::RandomizedTree::savePosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void savePosteriors(std::string url, bool append=false);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::string url, bool append=false)
cv::RandomizedTree::savePosteriors2	/usr/include/opencv2/features2d/features2d.hpp	/^  void savePosteriors2(std::string url, bool append=false);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::string url, bool append=false)
cv::RandomizedTree::train	/usr/include/opencv2/features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set, RNG &rng,$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, PatchGenerator &make_patch, int depth, int views, size_t reduced_num_dim, int num_quant_bits)
cv::RandomizedTree::train	/usr/include/opencv2/features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set, RNG &rng,$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, int depth, int views, size_t reduced_num_dim, int num_quant_bits)
cv::RandomizedTree::write	/usr/include/opencv2/features2d/features2d.hpp	/^  void write(const char* file_name) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(const char* file_name) const
cv::RandomizedTree::write	/usr/include/opencv2/features2d/features2d.hpp	/^  void write(std::ostream &os) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::ostream &os) const
cv::RandomizedTree::~RandomizedTree	/usr/include/opencv2/features2d/features2d.hpp	/^  ~RandomizedTree();$/;"	p	class:cv::RandomizedTree	access:public	signature:()
cv::Range	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS Range$/;"	c	namespace:cv
cv::Range::Range	/usr/include/opencv2/core/core.hpp	/^    Range();$/;"	p	class:cv::Range	access:public	signature:()
cv::Range::Range	/usr/include/opencv2/core/core.hpp	/^    Range(const CvSlice& slice);$/;"	p	class:cv::Range	access:public	signature:(const CvSlice& slice)
cv::Range::Range	/usr/include/opencv2/core/core.hpp	/^    Range(int _start, int _end);$/;"	p	class:cv::Range	access:public	signature:(int _start, int _end)
cv::Range::Range	/usr/include/opencv2/core/operations.hpp	/^inline Range::Range() : start(0), end(0) {}$/;"	f	class:cv::Range	signature:()
cv::Range::Range	/usr/include/opencv2/core/operations.hpp	/^inline Range::Range(const CvSlice& slice) : start(slice.start_index), end(slice.end_index)$/;"	f	class:cv::Range	signature:(const CvSlice& slice)
cv::Range::Range	/usr/include/opencv2/core/operations.hpp	/^inline Range::Range(int _start, int _end) : start(_start), end(_end) {}$/;"	f	class:cv::Range	signature:(int _start, int _end)
cv::Range::all	/usr/include/opencv2/core/core.hpp	/^    static Range all();$/;"	p	class:cv::Range	access:public	signature:()
cv::Range::all	/usr/include/opencv2/core/operations.hpp	/^inline Range Range::all() { return Range(INT_MIN, INT_MAX); }$/;"	f	class:cv::Range	signature:()
cv::Range::empty	/usr/include/opencv2/core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Range	access:public	signature:() const
cv::Range::empty	/usr/include/opencv2/core/operations.hpp	/^inline bool Range::empty() const { return start == end; }$/;"	f	class:cv::Range	signature:() const
cv::Range::end	/usr/include/opencv2/core/core.hpp	/^    int start, end;$/;"	m	class:cv::Range	access:public
cv::Range::operator CvSlice	/usr/include/opencv2/core/core.hpp	/^    operator CvSlice() const;$/;"	p	class:cv::Range	access:public	signature:() const
cv::Range::operator CvSlice	/usr/include/opencv2/core/operations.hpp	/^inline Range::operator CvSlice() const$/;"	f	class:cv::Range	signature:() const
cv::Range::size	/usr/include/opencv2/core/core.hpp	/^    int size() const;$/;"	p	class:cv::Range	access:public	signature:() const
cv::Range::size	/usr/include/opencv2/core/operations.hpp	/^inline int Range::size() const { return end - start; }$/;"	f	class:cv::Range	signature:() const
cv::Range::start	/usr/include/opencv2/core/core.hpp	/^    int start, end;$/;"	m	class:cv::Range	access:public
cv::Rect	/usr/include/opencv2/core/core.hpp	/^typedef Rect_<int> Rect;$/;"	t	namespace:cv
cv::Rect_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Rect_$/;"	c	namespace:cv
cv::Rect_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Rect_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Rect_::Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_();$/;"	p	class:cv::Rect_	access:public	signature:()
cv::Rect_::Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);$/;"	p	class:cv::Rect_	access:public	signature:(_Tp _x, _Tp _y, _Tp _width, _Tp _height)
cv::Rect_::Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_(const CvRect& r);$/;"	p	class:cv::Rect_	access:public	signature:(const CvRect& r)
cv::Rect_::Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& org, const Size_<_Tp>& sz)
cv::Rect_::Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
cv::Rect_::Rect_	/usr/include/opencv2/core/core.hpp	/^    Rect_(const Rect_& r);$/;"	p	class:cv::Rect_	access:public	signature:(const Rect_& r)
cv::Rect_::Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_() : x(0), y(0), width(0), height(0) {}$/;"	f	class:cv::Rect_	signature:()
cv::Rect_::Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height) : x(_x), y(_y), width(_width), height(_height) {}$/;"	f	class:cv::Rect_	signature:(_Tp _x, _Tp _y, _Tp _width, _Tp _height)
cv::Rect_::Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const CvRect& r) : x((_Tp)r.x), y((_Tp)r.y), width((_Tp)r.width), height((_Tp)r.height) {}$/;"	f	class:cv::Rect_	signature:(const CvRect& r)
cv::Rect_::Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz) :$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& org, const Size_<_Tp>& sz)
cv::Rect_::Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
cv::Rect_::Rect_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Rect_<_Tp>& r) : x(r.x), y(r.y), width(r.width), height(r.height) {}$/;"	f	class:cv::Rect_	signature:(const Rect_<_Tp>& r)
cv::Rect_::area	/usr/include/opencv2/core/core.hpp	/^    _Tp area() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::area	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp Rect_<_Tp>::area() const { return width*height; }$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::br	/usr/include/opencv2/core/core.hpp	/^    Point_<_Tp> br() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::br	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::br() const { return Point_<_Tp>(x+width, y+height); }$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::contains	/usr/include/opencv2/core/core.hpp	/^    bool contains(const Point_<_Tp>& pt) const;$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& pt) const
cv::Rect_::contains	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool Rect_<_Tp>::contains(const Point_<_Tp>& pt) const$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& pt) const
cv::Rect_::height	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
cv::Rect_::operator =	/usr/include/opencv2/core/core.hpp	/^    Rect_& operator = ( const Rect_& r );$/;"	p	class:cv::Rect_	access:public	signature:( const Rect_& r )
cv::Rect_::operator =	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>& Rect_<_Tp>::operator = ( const Rect_<_Tp>& r )$/;"	f	class:cv::Rect_	signature:( const Rect_<_Tp>& r )
cv::Rect_::operator CvRect	/usr/include/opencv2/core/core.hpp	/^    operator CvRect() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::operator CvRect	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::operator CvRect() const$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::operator Rect_<_Tp2>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp2> operator Rect_<_Tp2>() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::operator Rect_<_Tp2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Rect_<_Tp>::operator Rect_<_Tp2>() const$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::size	/usr/include/opencv2/core/core.hpp	/^    Size_<_Tp> size() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::size	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp> Rect_<_Tp>::size() const { return Size_<_Tp>(width, height); }$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::tl	/usr/include/opencv2/core/core.hpp	/^    Point_<_Tp> tl() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::tl	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::tl() const { return Point_<_Tp>(x,y); }$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Rect_	access:public
cv::Rect_::width	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
cv::Rect_::x	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
cv::Rect_::y	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
cv::Rodrigues	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_AS(RodriguesJ) void Rodrigues(const Mat& src, CV_OUT Mat& dst, CV_OUT Mat& jacobian);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, CV_OUT Mat& jacobian)
cv::Rodrigues	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void Rodrigues(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
cv::RotatedRect	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS RotatedRect$/;"	c	namespace:cv
cv::RotatedRect::RotatedRect	/usr/include/opencv2/core/core.hpp	/^    RotatedRect();$/;"	p	class:cv::RotatedRect	access:public	signature:()
cv::RotatedRect::RotatedRect	/usr/include/opencv2/core/core.hpp	/^    RotatedRect(const CvBox2D& box);$/;"	p	class:cv::RotatedRect	access:public	signature:(const CvBox2D& box)
cv::RotatedRect::RotatedRect	/usr/include/opencv2/core/core.hpp	/^    RotatedRect(const Point2f& _center, const Size2f& _size, float _angle);$/;"	p	class:cv::RotatedRect	access:public	signature:(const Point2f& _center, const Size2f& _size, float _angle)
cv::RotatedRect::RotatedRect	/usr/include/opencv2/core/operations.hpp	/^inline RotatedRect::RotatedRect() { angle = 0; }$/;"	f	class:cv::RotatedRect	signature:()
cv::RotatedRect::RotatedRect	/usr/include/opencv2/core/operations.hpp	/^inline RotatedRect::RotatedRect(const CvBox2D& box)$/;"	f	class:cv::RotatedRect	signature:(const CvBox2D& box)
cv::RotatedRect::RotatedRect	/usr/include/opencv2/core/operations.hpp	/^inline RotatedRect::RotatedRect(const Point2f& _center, const Size2f& _size, float _angle)$/;"	f	class:cv::RotatedRect	signature:(const Point2f& _center, const Size2f& _size, float _angle)
cv::RotatedRect::angle	/usr/include/opencv2/core/core.hpp	/^    float angle;    \/\/< the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle. $/;"	m	class:cv::RotatedRect	access:public
cv::RotatedRect::boundingRect	/usr/include/opencv2/core/core.hpp	/^    Rect boundingRect() const;$/;"	p	class:cv::RotatedRect	access:public	signature:() const
cv::RotatedRect::center	/usr/include/opencv2/core/core.hpp	/^    Point2f center; \/\/< the rectangle mass center$/;"	m	class:cv::RotatedRect	access:public
cv::RotatedRect::operator CvBox2D	/usr/include/opencv2/core/core.hpp	/^    operator CvBox2D() const;$/;"	p	class:cv::RotatedRect	access:public	signature:() const
cv::RotatedRect::operator CvBox2D	/usr/include/opencv2/core/operations.hpp	/^inline RotatedRect::operator CvBox2D() const$/;"	f	class:cv::RotatedRect	signature:() const
cv::RotatedRect::points	/usr/include/opencv2/core/core.hpp	/^    void points(Point2f pts[]) const;$/;"	p	class:cv::RotatedRect	access:public	signature:(Point2f pts[]) const
cv::RotatedRect::size	/usr/include/opencv2/core/core.hpp	/^    Size2f size;    \/\/< width and height of the rectangle$/;"	m	class:cv::RotatedRect	access:public
cv::SIFT	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SIFT$/;"	c	namespace:cv
cv::SIFT::CommonParams	/usr/include/opencv2/features2d/features2d.hpp	/^    struct CV_EXPORTS CommonParams$/;"	s	class:cv::SIFT	access:public
cv::SIFT::CommonParams::AVERAGE_ANGLE	/usr/include/opencv2/features2d/features2d.hpp	/^        enum{ FIRST_ANGLE = 0, AVERAGE_ANGLE = 1 };$/;"	e	enum:cv::SIFT::CommonParams::__anon73
cv::SIFT::CommonParams::CommonParams	/usr/include/opencv2/features2d/features2d.hpp	/^        CommonParams( int _nOctaves, int _nOctaveLayers, int _firstOctave, int _angleMode );$/;"	p	struct:cv::SIFT::CommonParams	access:public	signature:( int _nOctaves, int _nOctaveLayers, int _firstOctave, int _angleMode )
cv::SIFT::CommonParams::CommonParams	/usr/include/opencv2/features2d/features2d.hpp	/^        CommonParams();$/;"	p	struct:cv::SIFT::CommonParams	access:public	signature:()
cv::SIFT::CommonParams::DEFAULT_FIRST_OCTAVE	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int DEFAULT_FIRST_OCTAVE = -1;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::DEFAULT_NOCTAVES	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int DEFAULT_NOCTAVES = 4;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int DEFAULT_NOCTAVE_LAYERS = 3;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::FIRST_ANGLE	/usr/include/opencv2/features2d/features2d.hpp	/^        enum{ FIRST_ANGLE = 0, AVERAGE_ANGLE = 1 };$/;"	e	enum:cv::SIFT::CommonParams::__anon73
cv::SIFT::CommonParams::angleMode	/usr/include/opencv2/features2d/features2d.hpp	/^        int angleMode;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::firstOctave	/usr/include/opencv2/features2d/features2d.hpp	/^        int nOctaves, nOctaveLayers, firstOctave;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::nOctaveLayers	/usr/include/opencv2/features2d/features2d.hpp	/^        int nOctaves, nOctaveLayers, firstOctave;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::nOctaves	/usr/include/opencv2/features2d/features2d.hpp	/^        int nOctaves, nOctaveLayers, firstOctave;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::DescriptorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    struct CV_EXPORTS DescriptorParams$/;"	s	class:cv::SIFT	access:public
cv::SIFT::DescriptorParams::DEFAULT_IS_NORMALIZE	/usr/include/opencv2/features2d/features2d.hpp	/^        static const bool DEFAULT_IS_NORMALIZE = true;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
cv::SIFT::DescriptorParams::DESCRIPTOR_SIZE	/usr/include/opencv2/features2d/features2d.hpp	/^        static const int DESCRIPTOR_SIZE = 128;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
cv::SIFT::DescriptorParams::DescriptorParams	/usr/include/opencv2/features2d/features2d.hpp	/^        DescriptorParams( double _magnification, bool _isNormalize, bool _recalculateAngles );$/;"	p	struct:cv::SIFT::DescriptorParams	access:public	signature:( double _magnification, bool _isNormalize, bool _recalculateAngles )
cv::SIFT::DescriptorParams::DescriptorParams	/usr/include/opencv2/features2d/features2d.hpp	/^        DescriptorParams();$/;"	p	struct:cv::SIFT::DescriptorParams	access:public	signature:()
cv::SIFT::DescriptorParams::GET_DEFAULT_MAGNIFICATION	/usr/include/opencv2/features2d/features2d.hpp	/^        static double GET_DEFAULT_MAGNIFICATION() { return 3.0; }$/;"	f	struct:cv::SIFT::DescriptorParams	access:public	signature:()
cv::SIFT::DescriptorParams::isNormalize	/usr/include/opencv2/features2d/features2d.hpp	/^        bool isNormalize;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
cv::SIFT::DescriptorParams::magnification	/usr/include/opencv2/features2d/features2d.hpp	/^        double magnification;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
cv::SIFT::DescriptorParams::recalculateAngles	/usr/include/opencv2/features2d/features2d.hpp	/^        bool recalculateAngles;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
cv::SIFT::DetectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    struct CV_EXPORTS DetectorParams$/;"	s	class:cv::SIFT	access:public
cv::SIFT::DetectorParams::DetectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^        DetectorParams( double _threshold, double _edgeThreshold );$/;"	p	struct:cv::SIFT::DetectorParams	access:public	signature:( double _threshold, double _edgeThreshold )
cv::SIFT::DetectorParams::DetectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^        DetectorParams();$/;"	p	struct:cv::SIFT::DetectorParams	access:public	signature:()
cv::SIFT::DetectorParams::GET_DEFAULT_EDGE_THRESHOLD	/usr/include/opencv2/features2d/features2d.hpp	/^        static double GET_DEFAULT_EDGE_THRESHOLD() { return 10.0; }$/;"	f	struct:cv::SIFT::DetectorParams	access:public	signature:()
cv::SIFT::DetectorParams::GET_DEFAULT_THRESHOLD	/usr/include/opencv2/features2d/features2d.hpp	/^        static double GET_DEFAULT_THRESHOLD() { return 0.04 \/ SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS \/ 2.0; }$/;"	f	struct:cv::SIFT::DetectorParams	access:public	signature:()
cv::SIFT::DetectorParams::edgeThreshold	/usr/include/opencv2/features2d/features2d.hpp	/^        double threshold, edgeThreshold;$/;"	m	struct:cv::SIFT::DetectorParams	access:public
cv::SIFT::DetectorParams::threshold	/usr/include/opencv2/features2d/features2d.hpp	/^        double threshold, edgeThreshold;$/;"	m	struct:cv::SIFT::DetectorParams	access:public
cv::SIFT::SIFT	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT( const CommonParams& _commParams,$/;"	p	class:cv::SIFT	access:public	signature:( const CommonParams& _commParams, const DetectorParams& _detectorParams = DetectorParams(), const DescriptorParams& _descriptorParams = DescriptorParams() )
cv::SIFT::SIFT	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT( double _magnification, bool _isNormalize=true,$/;"	p	class:cv::SIFT	access:public	signature:( double _magnification, bool _isNormalize=true, bool _recalculateAngles = true, int _nOctaves=CommonParams::DEFAULT_NOCTAVES, int _nOctaveLayers=CommonParams::DEFAULT_NOCTAVE_LAYERS, int _firstOctave=CommonParams::DEFAULT_FIRST_OCTAVE, int _angleMode=CommonParams::FIRST_ANGLE )
cv::SIFT::SIFT	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT( double _threshold, double _edgeThreshold,$/;"	p	class:cv::SIFT	access:public	signature:( double _threshold, double _edgeThreshold, int _nOctaves=CommonParams::DEFAULT_NOCTAVES, int _nOctaveLayers=CommonParams::DEFAULT_NOCTAVE_LAYERS, int _firstOctave=CommonParams::DEFAULT_FIRST_OCTAVE, int _angleMode=CommonParams::FIRST_ANGLE )
cv::SIFT::SIFT	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT();$/;"	p	class:cv::SIFT	access:public	signature:()
cv::SIFT::commParams	/usr/include/opencv2/features2d/features2d.hpp	/^    CommonParams commParams;$/;"	m	class:cv::SIFT	access:protected
cv::SIFT::descriptorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    DescriptorParams descriptorParams;$/;"	m	class:cv::SIFT	access:protected
cv::SIFT::descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int descriptorSize() const { return DescriptorParams::DESCRIPTOR_SIZE; }$/;"	f	class:cv::SIFT	access:public	signature:() const
cv::SIFT::detectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    DetectorParams detectorParams;$/;"	m	class:cv::SIFT	access:protected
cv::SIFT::getCommonParams	/usr/include/opencv2/features2d/features2d.hpp	/^    CommonParams getCommonParams () const { return commParams; }$/;"	f	class:cv::SIFT	access:public	signature:() const
cv::SIFT::getDescriptorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    DescriptorParams getDescriptorParams () const { return descriptorParams; }$/;"	f	class:cv::SIFT	access:public	signature:() const
cv::SIFT::getDetectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    DetectorParams getDetectorParams () const { return detectorParams; }$/;"	f	class:cv::SIFT	access:public	signature:() const
cv::SIFT::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SIFT	access:public	signature:(const Mat& img, const Mat& mask, vector<KeyPoint>& keypoints) const
cv::SIFT::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SIFT	access:public	signature:(const Mat& img, const Mat& mask, vector<KeyPoint>& keypoints, Mat& descriptors, bool useProvidedKeypoints=false) const
cv::SURF	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS_W SURF : public CvSURFParams$/;"	c	namespace:cv	inherits:CvSURFParams
cv::SURF::SURF	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP SURF();$/;"	p	class:cv::SURF	access:public	signature:()
cv::SURF::SURF	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP SURF(double _hessianThreshold, int _nOctaves=4,$/;"	p	class:cv::SURF	access:public	signature:(double _hessianThreshold, int _nOctaves=4, int _nOctaveLayers=2, bool _extended=false)
cv::SURF::descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP int descriptorSize() const;$/;"	p	class:cv::SURF	access:public	signature:() const
cv::SURF::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SURF	access:public	signature:(const Mat& img, const Mat& mask, CV_OUT vector<KeyPoint>& keypoints) const
cv::SURF::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SURF	access:public	signature:(const Mat& img, const Mat& mask, CV_OUT vector<KeyPoint>& keypoints, CV_OUT vector<float>& descriptors, bool useProvidedKeypoints=false) const
cv::SVD	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS SVD$/;"	c	namespace:cv
cv::SVD::FULL_UV	/usr/include/opencv2/core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon145
cv::SVD::MODIFY_A	/usr/include/opencv2/core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon145
cv::SVD::NO_UV	/usr/include/opencv2/core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon145
cv::SVD::SVD	/usr/include/opencv2/core/core.hpp	/^    SVD( const Mat& src, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( const Mat& src, int flags=0 )
cv::SVD::SVD	/usr/include/opencv2/core/core.hpp	/^    SVD();$/;"	p	class:cv::SVD	access:public	signature:()
cv::SVD::SVD	/usr/include/opencv2/core/mat.hpp	/^inline SVD::SVD( const Mat& m, int flags ) { operator ()(m, flags); }$/;"	f	class:cv::SVD	signature:( const Mat& m, int flags )
cv::SVD::SVD	/usr/include/opencv2/core/mat.hpp	/^inline SVD::SVD() {}$/;"	f	class:cv::SVD	signature:()
cv::SVD::backSubst	/usr/include/opencv2/core/core.hpp	/^    static void backSubst( const Mat& w, const Mat& u, const Mat& vt,$/;"	p	class:cv::SVD	access:public	signature:( const Mat& w, const Mat& u, const Mat& vt, const Mat& rhs, CV_OUT Mat& dst )
cv::SVD::backSubst	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int m, int n, int nm, int nb> static void backSubst( const Matx<_Tp, nm, 1>& w,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u, const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs, Matx<_Tp, n, nb>& dst )
cv::SVD::backSubst	/usr/include/opencv2/core/core.hpp	/^    void backSubst( const Mat& rhs, CV_OUT Mat& dst ) const;$/;"	p	class:cv::SVD	access:public	signature:( const Mat& rhs, CV_OUT Mat& dst ) const
cv::SVD::backSubst	/usr/include/opencv2/core/mat.hpp	/^SVD::backSubst( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u,$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u, const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs, Matx<_Tp, n, nb>& dst )
cv::SVD::compute	/usr/include/opencv2/core/core.hpp	/^    static void compute( const Mat& src, CV_OUT Mat& w, CV_OUT Mat& u, CV_OUT Mat& vt, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( const Mat& src, CV_OUT Mat& w, CV_OUT Mat& u, CV_OUT Mat& vt, int flags=0 )
cv::SVD::compute	/usr/include/opencv2/core/core.hpp	/^    static void compute( const Mat& src, CV_OUT Mat& w, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( const Mat& src, CV_OUT Mat& w, int flags=0 )
cv::SVD::compute	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int m, int n, int nm> static void compute( const Matx<_Tp, m, n>& a,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )
cv::SVD::compute	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int m, int n, int nm> static void compute( const Matx<_Tp, m, n>& a,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )
cv::SVD::compute	/usr/include/opencv2/core/mat.hpp	/^    SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )
cv::SVD::compute	/usr/include/opencv2/core/mat.hpp	/^SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )
cv::SVD::operator ()	/usr/include/opencv2/core/core.hpp	/^    SVD& operator ()( const Mat& src, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( const Mat& src, int flags=0 )
cv::SVD::solveZ	/usr/include/opencv2/core/core.hpp	/^    static void solveZ( const Mat& src, CV_OUT Mat& dst );$/;"	p	class:cv::SVD	access:public	signature:( const Mat& src, CV_OUT Mat& dst )
cv::SVD::solveZ	/usr/include/opencv2/core/mat.hpp	/^inline void SVD::solveZ( const Mat& m, Mat& dst )$/;"	f	class:cv::SVD	signature:( const Mat& m, Mat& dst )
cv::SVD::u	/usr/include/opencv2/core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
cv::SVD::vt	/usr/include/opencv2/core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
cv::SVD::w	/usr/include/opencv2/core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
cv::SVM	/usr/include/opencv2/ml/ml.hpp	/^typedef CvSVM SVM;$/;"	t	namespace:cv
cv::SVMKernel	/usr/include/opencv2/ml/ml.hpp	/^typedef CvSVMKernel SVMKernel;$/;"	t	namespace:cv
cv::SVMParams	/usr/include/opencv2/ml/ml.hpp	/^typedef CvSVMParams SVMParams;$/;"	t	namespace:cv
cv::SVMSolver	/usr/include/opencv2/ml/ml.hpp	/^typedef CvSVMSolver SVMSolver;$/;"	t	namespace:cv
cv::Scalar	/usr/include/opencv2/core/core.hpp	/^typedef Scalar_<double> Scalar;$/;"	t	namespace:cv
cv::Scalar_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Scalar_ : public Vec<_Tp, 4>$/;"	c	namespace:cv	inherits:Vec
cv::Scalar_::Scalar_	/usr/include/opencv2/core/core.hpp	/^    Scalar_();$/;"	p	class:cv::Scalar_	access:public	signature:()
cv::Scalar_::Scalar_	/usr/include/opencv2/core/core.hpp	/^    Scalar_(_Tp v0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0)
cv::Scalar_::Scalar_	/usr/include/opencv2/core/core.hpp	/^    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0)
cv::Scalar_::Scalar_	/usr/include/opencv2/core/core.hpp	/^    Scalar_(const CvScalar& s);$/;"	p	class:cv::Scalar_	access:public	signature:(const CvScalar& s)
cv::Scalar_::Scalar_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_()$/;"	f	class:cv::Scalar_	signature:()
cv::Scalar_::Scalar_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0)$/;"	f	class:cv::Scalar_	signature:(_Tp v0)
cv::Scalar_::Scalar_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Scalar_	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
cv::Scalar_::Scalar_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(const CvScalar& s)$/;"	f	class:cv::Scalar_	signature:(const CvScalar& s)
cv::Scalar_::all	/usr/include/opencv2/core/core.hpp	/^    static Scalar_<_Tp> all(_Tp v0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0)
cv::Scalar_::all	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::all(_Tp v0)$/;"	f	class:cv::Scalar_	signature:(_Tp v0)
cv::Scalar_::conj	/usr/include/opencv2/core/core.hpp	/^    Scalar_<_Tp> conj() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
cv::Scalar_::conj	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::conj() const$/;"	f	class:cv::Scalar_	signature:() const
cv::Scalar_::isReal	/usr/include/opencv2/core/core.hpp	/^    bool isReal() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
cv::Scalar_::isReal	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool Scalar_<_Tp>::isReal() const$/;"	f	class:cv::Scalar_	signature:() const
cv::Scalar_::mul	/usr/include/opencv2/core/core.hpp	/^    Scalar_<_Tp> mul(const Scalar_<_Tp>& t, double scale=1 ) const;$/;"	p	class:cv::Scalar_	access:public	signature:(const Scalar_<_Tp>& t, double scale=1 ) const
cv::Scalar_::mul	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::mul(const Scalar_<_Tp>& t, double scale ) const$/;"	f	class:cv::Scalar_	signature:(const Scalar_<_Tp>& t, double scale ) const
cv::Scalar_::operator CvScalar	/usr/include/opencv2/core/core.hpp	/^    operator CvScalar() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
cv::Scalar_::operator CvScalar	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::operator CvScalar() const$/;"	f	class:cv::Scalar_	signature:() const
cv::Scalar_::operator Scalar_<T2>	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> operator Scalar_<T2>() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
cv::Scalar_::operator Scalar_<T2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename T2> inline Scalar_<_Tp>::operator Scalar_<T2>() const$/;"	f	class:cv::Scalar_	signature:() const
cv::Scharr	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(scharr) void Scharr( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, int dx, int dy, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
cv::SelfSimDescriptor	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS SelfSimDescriptor$/;"	c	namespace:cv
cv::SelfSimDescriptor::DEFAULT_LARGE_SIZE	/usr/include/opencv2/contrib/contrib.hpp	/^        enum { DEFAULT_SMALL_SIZE = 5, DEFAULT_LARGE_SIZE = 41,$/;"	e	enum:cv::SelfSimDescriptor::__anon57
cv::SelfSimDescriptor::DEFAULT_NUM_ANGLES	/usr/include/opencv2/contrib/contrib.hpp	/^            DEFAULT_NUM_ANGLES = 20, DEFAULT_START_DISTANCE_BUCKET = 3,$/;"	e	enum:cv::SelfSimDescriptor::__anon57
cv::SelfSimDescriptor::DEFAULT_NUM_DISTANCE_BUCKETS	/usr/include/opencv2/contrib/contrib.hpp	/^            DEFAULT_NUM_DISTANCE_BUCKETS = 7 };$/;"	e	enum:cv::SelfSimDescriptor::__anon57
cv::SelfSimDescriptor::DEFAULT_SMALL_SIZE	/usr/include/opencv2/contrib/contrib.hpp	/^        enum { DEFAULT_SMALL_SIZE = 5, DEFAULT_LARGE_SIZE = 41,$/;"	e	enum:cv::SelfSimDescriptor::__anon57
cv::SelfSimDescriptor::DEFAULT_START_DISTANCE_BUCKET	/usr/include/opencv2/contrib/contrib.hpp	/^            DEFAULT_NUM_ANGLES = 20, DEFAULT_START_DISTANCE_BUCKET = 3,$/;"	e	enum:cv::SelfSimDescriptor::__anon57
cv::SelfSimDescriptor::SSD	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void SSD(const Mat& img, Point pt, Mat& ssd) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const Mat& img, Point pt, Mat& ssd) const
cv::SelfSimDescriptor::SelfSimDescriptor	/usr/include/opencv2/contrib/contrib.hpp	/^        SelfSimDescriptor();$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:()
cv::SelfSimDescriptor::SelfSimDescriptor	/usr/include/opencv2/contrib/contrib.hpp	/^        SelfSimDescriptor(const SelfSimDescriptor& ss);$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const SelfSimDescriptor& ss)
cv::SelfSimDescriptor::SelfSimDescriptor	/usr/include/opencv2/contrib/contrib.hpp	/^        SelfSimDescriptor(int _ssize, int _lsize,$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(int _ssize, int _lsize, int _startDistanceBucket=DEFAULT_START_DISTANCE_BUCKET, int _numberOfDistanceBuckets=DEFAULT_NUM_DISTANCE_BUCKETS, int _nangles=DEFAULT_NUM_ANGLES)
cv::SelfSimDescriptor::compute	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void compute(const Mat& img, vector<float>& descriptors, Size winStride=Size(),$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const Mat& img, vector<float>& descriptors, Size winStride=Size(), const vector<Point>& locations=vector<Point>()) const
cv::SelfSimDescriptor::computeLogPolarMapping	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void computeLogPolarMapping(Mat& mappingMask) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(Mat& mappingMask) const
cv::SelfSimDescriptor::getDescriptorSize	/usr/include/opencv2/contrib/contrib.hpp	/^        size_t getDescriptorSize() const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:() const
cv::SelfSimDescriptor::getGridSize	/usr/include/opencv2/contrib/contrib.hpp	/^        Size getGridSize( Size imgsize, Size winStride ) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:( Size imgsize, Size winStride ) const
cv::SelfSimDescriptor::largeSize	/usr/include/opencv2/contrib/contrib.hpp	/^        int largeSize;$/;"	m	class:cv::SelfSimDescriptor	access:public
cv::SelfSimDescriptor::numberOfAngles	/usr/include/opencv2/contrib/contrib.hpp	/^        int numberOfAngles;$/;"	m	class:cv::SelfSimDescriptor	access:public
cv::SelfSimDescriptor::numberOfDistanceBuckets	/usr/include/opencv2/contrib/contrib.hpp	/^        int numberOfDistanceBuckets;$/;"	m	class:cv::SelfSimDescriptor	access:public
cv::SelfSimDescriptor::operator =	/usr/include/opencv2/contrib/contrib.hpp	/^        SelfSimDescriptor& operator = (const SelfSimDescriptor& ss);$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const SelfSimDescriptor& ss)
cv::SelfSimDescriptor::smallSize	/usr/include/opencv2/contrib/contrib.hpp	/^        int smallSize;$/;"	m	class:cv::SelfSimDescriptor	access:public
cv::SelfSimDescriptor::startDistanceBucket	/usr/include/opencv2/contrib/contrib.hpp	/^        int startDistanceBucket;$/;"	m	class:cv::SelfSimDescriptor	access:public
cv::SelfSimDescriptor::~SelfSimDescriptor	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual ~SelfSimDescriptor();$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:()
cv::Seq	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Seq$/;"	c	namespace:cv
cv::Seq::Seq	/usr/include/opencv2/core/core.hpp	/^    Seq();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::Seq	/usr/include/opencv2/core/core.hpp	/^    Seq(MemStorage& storage, int headerSize = sizeof(CvSeq));$/;"	p	class:cv::Seq	access:public	signature:(MemStorage& storage, int headerSize = sizeof(CvSeq))
cv::Seq::Seq	/usr/include/opencv2/core/core.hpp	/^    Seq(const CvSeq* seq);$/;"	p	class:cv::Seq	access:public	signature:(const CvSeq* seq)
cv::Seq::Seq	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq( MemStorage& storage,$/;"	f	class:cv::Seq	signature:( MemStorage& storage, int headerSize )
cv::Seq::Seq	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq( const CvSeq* _seq ) : seq((CvSeq*)_seq)$/;"	f	class:cv::Seq	signature:( const CvSeq* _seq )
cv::Seq::Seq	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq() : seq(0) {}$/;"	f	class:cv::Seq	signature:()
cv::Seq::back	/usr/include/opencv2/core/core.hpp	/^    _Tp& back();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::back	/usr/include/opencv2/core/core.hpp	/^    const _Tp& back() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::back()$/;"	f	class:cv::Seq	signature:()
cv::Seq::back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::back() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::begin	/usr/include/opencv2/core/core.hpp	/^    SeqIterator<_Tp> begin() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::begin	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::begin() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::channels	/usr/include/opencv2/core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::channels	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::channels() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::clear	/usr/include/opencv2/core/core.hpp	/^    void clear();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::clear	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::clear()$/;"	f	class:cv::Seq	signature:()
cv::Seq::const_iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SeqIterator<_Tp> const_iterator;$/;"	t	class:cv::Seq	access:public
cv::Seq::copyTo	/usr/include/opencv2/core/core.hpp	/^    void copyTo(vector<_Tp>& vec, const Range& range=Range::all()) const;$/;"	p	class:cv::Seq	access:public	signature:(vector<_Tp>& vec, const Range& range=Range::all()) const
cv::Seq::copyTo	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::copyTo(vector<_Tp>& vec, const Range& range) const$/;"	f	class:cv::Seq	signature:(vector<_Tp>& vec, const Range& range) const
cv::Seq::depth	/usr/include/opencv2/core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::depth	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::depth() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::elemSize	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::elemSize	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::elemSize() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::empty	/usr/include/opencv2/core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::empty	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool Seq<_Tp>::empty() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::end	/usr/include/opencv2/core/core.hpp	/^    SeqIterator<_Tp> end() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::end	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::end() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::front	/usr/include/opencv2/core/core.hpp	/^    _Tp& front();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::front	/usr/include/opencv2/core/core.hpp	/^    const _Tp& front() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::front()$/;"	f	class:cv::Seq	signature:()
cv::Seq::front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::front() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::index	/usr/include/opencv2/core/core.hpp	/^    size_t index(const _Tp& elem) const;$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem) const
cv::Seq::index	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::index(const _Tp& elem) const$/;"	f	class:cv::Seq	signature:(const _Tp& elem) const
cv::Seq::insert	/usr/include/opencv2/core/core.hpp	/^    void insert(int idx, const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(int idx, const _Tp& elem)
cv::Seq::insert	/usr/include/opencv2/core/core.hpp	/^    void insert(int idx, const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(int idx, const _Tp* elems, size_t count)
cv::Seq::insert	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp& elem)$/;"	f	class:cv::Seq	signature:(int idx, const _Tp& elem)
cv::Seq::insert	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp* elems, size_t count)$/;"	f	class:cv::Seq	signature:(int idx, const _Tp* elems, size_t count)
cv::Seq::iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SeqIterator<_Tp> iterator;$/;"	t	class:cv::Seq	access:public
cv::Seq::operator []	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator [](int idx);$/;"	p	class:cv::Seq	access:public	signature:(int idx)
cv::Seq::operator []	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator[](int idx) const;$/;"	p	class:cv::Seq	access:public	signature:(int idx) const
cv::Seq::operator []	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::operator [](int idx)$/;"	f	class:cv::Seq	signature:(int idx)
cv::Seq::operator []	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::operator [](int idx) const$/;"	f	class:cv::Seq	signature:(int idx) const
cv::Seq::operator vector<_Tp>	/usr/include/opencv2/core/core.hpp	/^    operator vector<_Tp>() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::operator vector<_Tp>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::operator vector<_Tp>() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::pop_back	/usr/include/opencv2/core/core.hpp	/^    void pop_back();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::pop_back	/usr/include/opencv2/core/core.hpp	/^    void pop_back(_Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(_Tp* elems, size_t count)
cv::Seq::pop_back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_back()$/;"	f	class:cv::Seq	signature:()
cv::Seq::pop_back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_back(_Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(_Tp* elem, size_t count)
cv::Seq::pop_front	/usr/include/opencv2/core/core.hpp	/^    void pop_front();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::pop_front	/usr/include/opencv2/core/core.hpp	/^    void pop_front(_Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(_Tp* elems, size_t count)
cv::Seq::pop_front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_front()$/;"	f	class:cv::Seq	signature:()
cv::Seq::pop_front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_front(_Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(_Tp* elem, size_t count)
cv::Seq::push_back	/usr/include/opencv2/core/core.hpp	/^    void push_back(const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem)
cv::Seq::push_back	/usr/include/opencv2/core/core.hpp	/^    void push_back(const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp* elems, size_t count)
cv::Seq::push_back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp& elem)$/;"	f	class:cv::Seq	signature:(const _Tp& elem)
cv::Seq::push_back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(const _Tp* elem, size_t count)
cv::Seq::push_front	/usr/include/opencv2/core/core.hpp	/^    void push_front(const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem)
cv::Seq::push_front	/usr/include/opencv2/core/core.hpp	/^    void push_front(const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp* elems, size_t count)
cv::Seq::push_front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp& elem)$/;"	f	class:cv::Seq	signature:(const _Tp& elem)
cv::Seq::push_front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(const _Tp* elem, size_t count)
cv::Seq::remove	/usr/include/opencv2/core/core.hpp	/^    void remove(const Range& r);$/;"	p	class:cv::Seq	access:public	signature:(const Range& r)
cv::Seq::remove	/usr/include/opencv2/core/core.hpp	/^    void remove(int idx);$/;"	p	class:cv::Seq	access:public	signature:(int idx)
cv::Seq::remove	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::remove(const Range& r)$/;"	f	class:cv::Seq	signature:(const Range& r)
cv::Seq::remove	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::remove(int idx)$/;"	f	class:cv::Seq	signature:(int idx)
cv::Seq::seq	/usr/include/opencv2/core/core.hpp	/^    CvSeq* seq;$/;"	m	class:cv::Seq	access:public
cv::Seq::size	/usr/include/opencv2/core/core.hpp	/^    size_t size() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::size	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::size() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::type	/usr/include/opencv2/core/core.hpp	/^    int type() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::type	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::type() const$/;"	f	class:cv::Seq	signature:() const
cv::SeqIterator	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SeqIterator : public CvSeqReader$/;"	c	namespace:cv	inherits:CvSeqReader
cv::SeqIterator::SeqIterator	/usr/include/opencv2/core/core.hpp	/^    SeqIterator();$/;"	p	class:cv::SeqIterator	access:public	signature:()
cv::SeqIterator::SeqIterator	/usr/include/opencv2/core/core.hpp	/^    SeqIterator(const Seq<_Tp>& seq, bool seekEnd=false);$/;"	p	class:cv::SeqIterator	access:public	signature:(const Seq<_Tp>& seq, bool seekEnd=false)
cv::SeqIterator::SeqIterator	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator()$/;"	f	class:cv::SeqIterator	signature:()
cv::SeqIterator::SeqIterator	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator(const Seq<_Tp>& seq, bool seekEnd)$/;"	f	class:cv::SeqIterator	signature:(const Seq<_Tp>& seq, bool seekEnd)
cv::SeqIterator::index	/usr/include/opencv2/core/core.hpp	/^    int index;$/;"	m	class:cv::SeqIterator	access:public
cv::SeqIterator::operator *	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator *();$/;"	p	class:cv::SeqIterator	access:public	signature:()
cv::SeqIterator::operator *	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator *() const;$/;"	p	class:cv::SeqIterator	access:public	signature:() const
cv::SeqIterator::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp& SeqIterator<_Tp>::operator *()$/;"	f	class:cv::SeqIterator	signature:()
cv::SeqIterator::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline const _Tp& SeqIterator<_Tp>::operator *() const$/;"	f	class:cv::SeqIterator	signature:() const
cv::SeqIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    SeqIterator operator ++(int) const;$/;"	p	class:cv::SeqIterator	access:public	signature:(int) const
cv::SeqIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    SeqIterator& operator ++();$/;"	p	class:cv::SeqIterator	access:public	signature:()
cv::SeqIterator::operator ++	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator ++(int) const$/;"	f	class:cv::SeqIterator	signature:(int) const
cv::SeqIterator::operator ++	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator ++()$/;"	f	class:cv::SeqIterator	signature:()
cv::SeqIterator::operator +=	/usr/include/opencv2/core/core.hpp	/^    SeqIterator& operator +=(int);$/;"	p	class:cv::SeqIterator	access:public	signature:(int)
cv::SeqIterator::operator +=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator +=(int delta)$/;"	f	class:cv::SeqIterator	signature:(int delta)
cv::SeqIterator::operator --	/usr/include/opencv2/core/core.hpp	/^    SeqIterator operator --(int) const;$/;"	p	class:cv::SeqIterator	access:public	signature:(int) const
cv::SeqIterator::operator --	/usr/include/opencv2/core/core.hpp	/^    SeqIterator& operator --();$/;"	p	class:cv::SeqIterator	access:public	signature:()
cv::SeqIterator::operator --	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator --(int) const$/;"	f	class:cv::SeqIterator	signature:(int) const
cv::SeqIterator::operator --	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator --()$/;"	f	class:cv::SeqIterator	signature:()
cv::SeqIterator::operator -=	/usr/include/opencv2/core/core.hpp	/^    SeqIterator& operator -=(int);$/;"	p	class:cv::SeqIterator	access:public	signature:(int)
cv::SeqIterator::operator -=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator -=(int delta)$/;"	f	class:cv::SeqIterator	signature:(int delta)
cv::SeqIterator::seek	/usr/include/opencv2/core/core.hpp	/^    void seek(size_t pos);$/;"	p	class:cv::SeqIterator	access:public	signature:(size_t pos)
cv::SeqIterator::seek	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void SeqIterator<_Tp>::seek(size_t pos)$/;"	f	class:cv::SeqIterator	signature:(size_t pos)
cv::SeqIterator::tell	/usr/include/opencv2/core/core.hpp	/^    size_t tell() const;$/;"	p	class:cv::SeqIterator	access:public	signature:() const
cv::SeqIterator::tell	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline size_t SeqIterator<_Tp>::tell() const$/;"	f	class:cv::SeqIterator	signature:() const
cv::SiftDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SiftDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
cv::SiftDescriptorExtractor::SiftDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    SiftDescriptorExtractor( const SIFT::DescriptorParams& descriptorParams=SIFT::DescriptorParams(),$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( const SIFT::DescriptorParams& descriptorParams=SIFT::DescriptorParams(), const SIFT::CommonParams& commonParams=SIFT::CommonParams() )
cv::SiftDescriptorExtractor::SiftDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    SiftDescriptorExtractor( double magnification, bool isNormalize=true, bool recalculateAngles=true,$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( double magnification, bool isNormalize=true, bool recalculateAngles=true, int nOctaves=SIFT::CommonParams::DEFAULT_NOCTAVES, int nOctaveLayers=SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS, int firstOctave=SIFT::CommonParams::DEFAULT_FIRST_OCTAVE, int angleMode=SIFT::CommonParams::FIRST_ANGLE )
cv::SiftDescriptorExtractor::computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::SiftDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::SiftDescriptorExtractor::descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:() const
cv::SiftDescriptorExtractor::descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:() const
cv::SiftDescriptorExtractor::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( const FileNode &fn )
cv::SiftDescriptorExtractor::sift	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT sift;$/;"	m	class:cv::SiftDescriptorExtractor	access:protected
cv::SiftDescriptorExtractor::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
cv::SiftFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SiftFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::SiftFeatureDetector::SiftFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    SiftFeatureDetector( const SIFT::DetectorParams& detectorParams=SIFT::DetectorParams(),$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( const SIFT::DetectorParams& detectorParams=SIFT::DetectorParams(), const SIFT::CommonParams& commonParams=SIFT::CommonParams() )
cv::SiftFeatureDetector::SiftFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    SiftFeatureDetector( double threshold, double edgeThreshold,$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( double threshold, double edgeThreshold, int nOctaves=SIFT::CommonParams::DEFAULT_NOCTAVES, int nOctaveLayers=SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS, int firstOctave=SIFT::CommonParams::DEFAULT_FIRST_OCTAVE, int angleMode=SIFT::CommonParams::FIRST_ANGLE )
cv::SiftFeatureDetector::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SiftFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::SiftFeatureDetector::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( const FileNode& fn )
cv::SiftFeatureDetector::sift	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT sift;$/;"	m	class:cv::SiftFeatureDetector	access:protected
cv::SiftFeatureDetector::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( FileStorage& fs ) const
cv::Size	/usr/include/opencv2/core/core.hpp	/^typedef Size2i Size;$/;"	t	namespace:cv
cv::Size2f	/usr/include/opencv2/core/core.hpp	/^typedef Size_<float> Size2f;$/;"	t	namespace:cv
cv::Size2i	/usr/include/opencv2/core/core.hpp	/^typedef Size_<int> Size2i;$/;"	t	namespace:cv
cv::Size_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Size_$/;"	c	namespace:cv
cv::Size_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Size_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Size_::Size_	/usr/include/opencv2/core/core.hpp	/^    Size_();$/;"	p	class:cv::Size_	access:public	signature:()
cv::Size_::Size_	/usr/include/opencv2/core/core.hpp	/^    Size_(_Tp _width, _Tp _height);$/;"	p	class:cv::Size_	access:public	signature:(_Tp _width, _Tp _height)
cv::Size_::Size_	/usr/include/opencv2/core/core.hpp	/^    Size_(const CvSize& sz);$/;"	p	class:cv::Size_	access:public	signature:(const CvSize& sz)
cv::Size_::Size_	/usr/include/opencv2/core/core.hpp	/^    Size_(const CvSize2D32f& sz);$/;"	p	class:cv::Size_	access:public	signature:(const CvSize2D32f& sz)
cv::Size_::Size_	/usr/include/opencv2/core/core.hpp	/^    Size_(const Point_<_Tp>& pt);$/;"	p	class:cv::Size_	access:public	signature:(const Point_<_Tp>& pt)
cv::Size_::Size_	/usr/include/opencv2/core/core.hpp	/^    Size_(const Size_& sz);$/;"	p	class:cv::Size_	access:public	signature:(const Size_& sz)
cv::Size_::Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_()$/;"	f	class:cv::Size_	signature:()
cv::Size_::Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(_Tp _width, _Tp _height)$/;"	f	class:cv::Size_	signature:(_Tp _width, _Tp _height)
cv::Size_::Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize& sz)$/;"	f	class:cv::Size_	signature:(const CvSize& sz)
cv::Size_::Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize2D32f& sz)$/;"	f	class:cv::Size_	signature:(const CvSize2D32f& sz)
cv::Size_::Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const Point_<_Tp>& pt) : width(pt.x), height(pt.y) {}$/;"	f	class:cv::Size_	signature:(const Point_<_Tp>& pt)
cv::Size_::Size_	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const Size_& sz)$/;"	f	class:cv::Size_	signature:(const Size_& sz)
cv::Size_::area	/usr/include/opencv2/core/core.hpp	/^    _Tp area() const;$/;"	p	class:cv::Size_	access:public	signature:() const
cv::Size_::area	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp Size_<_Tp>::area() const { return width*height; }$/;"	f	class:cv::Size_	signature:() const
cv::Size_::height	/usr/include/opencv2/core/core.hpp	/^    _Tp width, height; \/\/ the width and the height$/;"	m	class:cv::Size_	access:public
cv::Size_::operator =	/usr/include/opencv2/core/core.hpp	/^    Size_& operator = (const Size_& sz);$/;"	p	class:cv::Size_	access:public	signature:(const Size_& sz)
cv::Size_::operator =	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>& Size_<_Tp>::operator = (const Size_<_Tp>& sz)$/;"	f	class:cv::Size_	signature:(const Size_<_Tp>& sz)
cv::Size_::operator CvSize	/usr/include/opencv2/core/core.hpp	/^    operator CvSize() const;$/;"	p	class:cv::Size_	access:public	signature:() const
cv::Size_::operator CvSize	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::operator CvSize() const$/;"	f	class:cv::Size_	signature:() const
cv::Size_::operator CvSize2D32f	/usr/include/opencv2/core/core.hpp	/^    operator CvSize2D32f() const;$/;"	p	class:cv::Size_	access:public	signature:() const
cv::Size_::operator CvSize2D32f	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::operator CvSize2D32f() const$/;"	f	class:cv::Size_	signature:() const
cv::Size_::operator Size_<_Tp2>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp2> operator Size_<_Tp2>() const;$/;"	p	class:cv::Size_	access:public	signature:() const
cv::Size_::operator Size_<_Tp2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Size_<_Tp>::operator Size_<_Tp2>() const$/;"	f	class:cv::Size_	signature:() const
cv::Size_::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Size_	access:public
cv::Size_::width	/usr/include/opencv2/core/core.hpp	/^    _Tp width, height; \/\/ the width and the height$/;"	m	class:cv::Size_	access:public
cv::Sobel	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(sobel) void Sobel( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, int dx, int dy, int ksize=3, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
cv::SparseMat	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS SparseMat$/;"	c	namespace:cv
cv::SparseMat::HASH_BIT	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon148
cv::SparseMat::HASH_SCALE	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon148
cv::SparseMat::Hdr	/usr/include/opencv2/core/core.hpp	/^    struct CV_EXPORTS Hdr$/;"	s	class:cv::SparseMat	access:public
cv::SparseMat::Hdr::Hdr	/usr/include/opencv2/core/core.hpp	/^        Hdr(int _dims, const int* _sizes, int _type);$/;"	p	struct:cv::SparseMat::Hdr	access:public	signature:(int _dims, const int* _sizes, int _type)
cv::SparseMat::Hdr::clear	/usr/include/opencv2/core/core.hpp	/^        void clear();$/;"	p	struct:cv::SparseMat::Hdr	access:public	signature:()
cv::SparseMat::Hdr::dims	/usr/include/opencv2/core/core.hpp	/^        int dims;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::freeList	/usr/include/opencv2/core/core.hpp	/^        size_t freeList;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::hashtab	/usr/include/opencv2/core/core.hpp	/^        vector<size_t> hashtab;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::nodeCount	/usr/include/opencv2/core/core.hpp	/^        size_t nodeCount;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::nodeSize	/usr/include/opencv2/core/core.hpp	/^        size_t nodeSize;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::pool	/usr/include/opencv2/core/core.hpp	/^        vector<uchar> pool;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::refcount	/usr/include/opencv2/core/core.hpp	/^        int refcount;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::size	/usr/include/opencv2/core/core.hpp	/^        int size[CV_MAX_DIM];$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::valueOffset	/usr/include/opencv2/core/core.hpp	/^        int valueOffset;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::MAGIC_VAL	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon148
cv::SparseMat::MAX_DIM	/usr/include/opencv2/core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon148
cv::SparseMat::Node	/usr/include/opencv2/core/core.hpp	/^    struct CV_EXPORTS Node$/;"	s	class:cv::SparseMat	access:public
cv::SparseMat::Node::hashval	/usr/include/opencv2/core/core.hpp	/^        size_t hashval;$/;"	m	struct:cv::SparseMat::Node	access:public
cv::SparseMat::Node::idx	/usr/include/opencv2/core/core.hpp	/^        int idx[CV_MAX_DIM];$/;"	m	struct:cv::SparseMat::Node	access:public
cv::SparseMat::Node::next	/usr/include/opencv2/core/core.hpp	/^        size_t next;$/;"	m	struct:cv::SparseMat::Node	access:public
cv::SparseMat::SparseMat	/usr/include/opencv2/core/core.hpp	/^    SparseMat();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::SparseMat	/usr/include/opencv2/core/core.hpp	/^    SparseMat(const CvSparseMat* m);$/;"	p	class:cv::SparseMat	access:public	signature:(const CvSparseMat* m)
cv::SparseMat::SparseMat	/usr/include/opencv2/core/core.hpp	/^    SparseMat(const Mat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const Mat& m)
cv::SparseMat::SparseMat	/usr/include/opencv2/core/core.hpp	/^    SparseMat(const SparseMat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const SparseMat& m)
cv::SparseMat::SparseMat	/usr/include/opencv2/core/core.hpp	/^    SparseMat(int dims, const int* _sizes, int _type);$/;"	p	class:cv::SparseMat	access:public	signature:(int dims, const int* _sizes, int _type)
cv::SparseMat::SparseMat	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::SparseMat()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::SparseMat	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::SparseMat(const SparseMat& m)$/;"	f	class:cv::SparseMat	signature:(const SparseMat& m)
cv::SparseMat::SparseMat	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::SparseMat(int _dims, const int* _sizes, int _type)$/;"	f	class:cv::SparseMat	signature:(int _dims, const int* _sizes, int _type)
cv::SparseMat::addref	/usr/include/opencv2/core/core.hpp	/^    void addref();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::addref	/usr/include/opencv2/core/mat.hpp	/^inline void SparseMat::addref()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::assignTo	/usr/include/opencv2/core/core.hpp	/^    void assignTo( SparseMat& m, int type=-1 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m, int type=-1 ) const
cv::SparseMat::assignTo	/usr/include/opencv2/core/mat.hpp	/^inline void SparseMat::assignTo( SparseMat& m, int type ) const$/;"	f	class:cv::SparseMat	signature:( SparseMat& m, int type ) const
cv::SparseMat::begin	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator begin() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::begin	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator begin();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::begin	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> SparseMatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::begin	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> SparseMatIterator_<_Tp> begin();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::begin	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator SparseMat::begin() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::begin	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator SparseMat::begin()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::begin() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::begin()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::channels	/usr/include/opencv2/core/core.hpp	/^    int channels() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::channels	/usr/include/opencv2/core/mat.hpp	/^inline int SparseMat::channels() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::clear	/usr/include/opencv2/core/core.hpp	/^    void clear();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::clone	/usr/include/opencv2/core/core.hpp	/^    SparseMat clone() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::clone	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat SparseMat::clone() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::const_iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SparseMatConstIterator const_iterator;$/;"	t	class:cv::SparseMat	access:public
cv::SparseMat::convertTo	/usr/include/opencv2/core/core.hpp	/^    void convertTo( Mat& m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( Mat& m, int rtype, double alpha=1, double beta=0 ) const
cv::SparseMat::convertTo	/usr/include/opencv2/core/core.hpp	/^    void convertTo( SparseMat& m, int rtype, double alpha=1 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m, int rtype, double alpha=1 ) const
cv::SparseMat::copyTo	/usr/include/opencv2/core/core.hpp	/^    void copyTo( Mat& m ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( Mat& m ) const
cv::SparseMat::copyTo	/usr/include/opencv2/core/core.hpp	/^    void copyTo( SparseMat& m ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m ) const
cv::SparseMat::create	/usr/include/opencv2/core/core.hpp	/^    void create(int dims, const int* _sizes, int _type);$/;"	p	class:cv::SparseMat	access:public	signature:(int dims, const int* _sizes, int _type)
cv::SparseMat::depth	/usr/include/opencv2/core/core.hpp	/^    int depth() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::depth	/usr/include/opencv2/core/mat.hpp	/^inline int SparseMat::depth() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::dims	/usr/include/opencv2/core/core.hpp	/^    int dims() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::dims	/usr/include/opencv2/core/mat.hpp	/^inline int SparseMat::dims() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::elemSize	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::elemSize	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::elemSize() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::elemSize1	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::elemSize1	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::elemSize1() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::end	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator end() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::end	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator end();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::end	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> SparseMatConstIterator_<_Tp> end() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::end	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> SparseMatIterator_<_Tp> end();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::end	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator SparseMat::end() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::end	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator SparseMat::end()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::end() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::end()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::erase	/usr/include/opencv2/core/core.hpp	/^    void erase(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0)
cv::SparseMat::erase	/usr/include/opencv2/core/core.hpp	/^    void erase(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
cv::SparseMat::erase	/usr/include/opencv2/core/core.hpp	/^    void erase(int i0, int i1, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0)
cv::SparseMat::find	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* find(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0) const
cv::SparseMat::find	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
cv::SparseMat::find	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0) const
cv::SparseMat::find	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0) const
cv::SparseMat::find	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval) const
cv::SparseMat::find	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval) const
cv::SparseMat::find	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval) const
cv::SparseMat::find	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval) const
cv::SparseMat::flags	/usr/include/opencv2/core/core.hpp	/^    int flags;$/;"	m	class:cv::SparseMat	access:public
cv::SparseMat::hash	/usr/include/opencv2/core/core.hpp	/^    size_t hash(const int* idx) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx) const
cv::SparseMat::hash	/usr/include/opencv2/core/core.hpp	/^    size_t hash(int i0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0) const
cv::SparseMat::hash	/usr/include/opencv2/core/core.hpp	/^    size_t hash(int i0, int i1) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1) const
cv::SparseMat::hash	/usr/include/opencv2/core/core.hpp	/^    size_t hash(int i0, int i1, int i2) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2) const
cv::SparseMat::hash	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::hash(const int* idx) const$/;"	f	class:cv::SparseMat	signature:(const int* idx) const
cv::SparseMat::hash	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::hash(int i0) const$/;"	f	class:cv::SparseMat	signature:(int i0) const
cv::SparseMat::hash	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::hash(int i0, int i1) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1) const
cv::SparseMat::hash	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::hash(int i0, int i1, int i2) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2) const
cv::SparseMat::hdr	/usr/include/opencv2/core/core.hpp	/^    Hdr* hdr;$/;"	m	class:cv::SparseMat	access:public
cv::SparseMat::iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SparseMatIterator iterator;$/;"	t	class:cv::SparseMat	access:public
cv::SparseMat::newNode	/usr/include/opencv2/core/core.hpp	/^    uchar* newNode(const int* idx, size_t hashval);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t hashval)
cv::SparseMat::node	/usr/include/opencv2/core/core.hpp	/^    Node* node(size_t nidx);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t nidx)
cv::SparseMat::node	/usr/include/opencv2/core/core.hpp	/^    const Node* node(size_t nidx) const;$/;"	p	class:cv::SparseMat	access:public	signature:(size_t nidx) const
cv::SparseMat::node	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::Node* SparseMat::node(size_t nidx)$/;"	f	class:cv::SparseMat	signature:(size_t nidx)
cv::SparseMat::node	/usr/include/opencv2/core/mat.hpp	/^inline const SparseMat::Node* SparseMat::node(size_t nidx) const$/;"	f	class:cv::SparseMat	signature:(size_t nidx) const
cv::SparseMat::nzcount	/usr/include/opencv2/core/core.hpp	/^    size_t nzcount() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::nzcount	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::nzcount() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMat& operator = (const Mat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const Mat& m)
cv::SparseMat::operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMat& operator = (const SparseMat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const SparseMat& m)
cv::SparseMat::operator =	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat& SparseMat::operator = (const Mat& m)$/;"	f	class:cv::SparseMat	signature:(const Mat& m)
cv::SparseMat::operator =	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat& SparseMat::operator = (const SparseMat& m)$/;"	f	class:cv::SparseMat	signature:(const SparseMat& m)
cv::SparseMat::operator CvSparseMat*	/usr/include/opencv2/core/core.hpp	/^    operator CvSparseMat*() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(const int* idx, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, bool createMissing, size_t* hashval=0)
cv::SparseMat::ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, bool createMissing, size_t* hashval=0)
cv::SparseMat::ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0, int i1, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, bool createMissing, size_t* hashval=0)
cv::SparseMat::ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, bool createMissing, size_t* hashval=0)
cv::SparseMat::ref	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& ref(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0)
cv::SparseMat::ref	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
cv::SparseMat::ref	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, int i1, size_t* hashval=0);   $/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0)
cv::SparseMat::ref	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, size_t* hashval=0);   $/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0)
cv::SparseMat::ref	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(const int* idx, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval)
cv::SparseMat::ref	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, int i2, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval)
cv::SparseMat::ref	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval)
cv::SparseMat::ref	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval)
cv::SparseMat::release	/usr/include/opencv2/core/core.hpp	/^    void release();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::release	/usr/include/opencv2/core/mat.hpp	/^inline void SparseMat::release()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::removeNode	/usr/include/opencv2/core/core.hpp	/^    void removeNode(size_t hidx, size_t nidx, size_t previdx);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t hidx, size_t nidx, size_t previdx)
cv::SparseMat::resizeHashTab	/usr/include/opencv2/core/core.hpp	/^    void resizeHashTab(size_t newsize);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t newsize)
cv::SparseMat::size	/usr/include/opencv2/core/core.hpp	/^    const int* size() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::size	/usr/include/opencv2/core/core.hpp	/^    int size(int i) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i) const
cv::SparseMat::size	/usr/include/opencv2/core/mat.hpp	/^inline const int* SparseMat::size() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::size	/usr/include/opencv2/core/mat.hpp	/^inline int SparseMat::size(int i) const$/;"	f	class:cv::SparseMat	signature:(int i) const
cv::SparseMat::type	/usr/include/opencv2/core/core.hpp	/^    int type() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::type	/usr/include/opencv2/core/mat.hpp	/^inline int SparseMat::type() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp value(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0) const
cv::SparseMat::value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
cv::SparseMat::value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0) const
cv::SparseMat::value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0) const
cv::SparseMat::value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& value(Node* n);$/;"	p	class:cv::SparseMat	access:public	signature:(Node* n)
cv::SparseMat::value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& value(const Node* n) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const Node* n) const
cv::SparseMat::value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval) const
cv::SparseMat::value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval) const
cv::SparseMat::value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval) const
cv::SparseMat::value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval) const
cv::SparseMat::value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::value(Node* n)$/;"	f	class:cv::SparseMat	signature:(Node* n)
cv::SparseMat::value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& SparseMat::value(const Node* n) const$/;"	f	class:cv::SparseMat	signature:(const Node* n) const
cv::SparseMat::~SparseMat	/usr/include/opencv2/core/core.hpp	/^    ~SparseMat();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::~SparseMat	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::~SparseMat()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMatConstIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS SparseMatConstIterator$/;"	c	namespace:cv
cv::SparseMatConstIterator::SparseMatConstIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
cv::SparseMatConstIterator::SparseMatConstIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator(const SparseMat* _m);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMat* _m)
cv::SparseMatConstIterator::SparseMatConstIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator(const SparseMatConstIterator& it);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMatConstIterator& it)
cv::SparseMatConstIterator::SparseMatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator::SparseMatConstIterator()$/;"	f	class:cv::SparseMatConstIterator	signature:()
cv::SparseMatConstIterator::SparseMatConstIterator	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator::SparseMatConstIterator(const SparseMatConstIterator& it)$/;"	f	class:cv::SparseMatConstIterator	signature:(const SparseMatConstIterator& it)
cv::SparseMatConstIterator::hashidx	/usr/include/opencv2/core/core.hpp	/^    size_t hashidx;$/;"	m	class:cv::SparseMatConstIterator	access:public
cv::SparseMatConstIterator::m	/usr/include/opencv2/core/core.hpp	/^    const SparseMat* m;$/;"	m	class:cv::SparseMatConstIterator	access:public
cv::SparseMatConstIterator::node	/usr/include/opencv2/core/core.hpp	/^    const SparseMat::Node* node() const;$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:() const
cv::SparseMatConstIterator::node	/usr/include/opencv2/core/mat.hpp	/^inline const SparseMat::Node* SparseMatConstIterator::node() const$/;"	f	class:cv::SparseMatConstIterator	signature:() const
cv::SparseMatConstIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator operator ++(int);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(int)
cv::SparseMatConstIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator& operator ++();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
cv::SparseMatConstIterator::operator ++	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator SparseMatConstIterator::operator ++(int)$/;"	f	class:cv::SparseMatConstIterator	signature:(int)
cv::SparseMatConstIterator::operator --	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator operator --(int);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(int)
cv::SparseMatConstIterator::operator --	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator& operator --();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
cv::SparseMatConstIterator::operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator& operator = (const SparseMatConstIterator& it);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMatConstIterator& it)
cv::SparseMatConstIterator::operator =	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator& SparseMatConstIterator::operator = (const SparseMatConstIterator& it)$/;"	f	class:cv::SparseMatConstIterator	signature:(const SparseMatConstIterator& it)
cv::SparseMatConstIterator::ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::SparseMatConstIterator	access:public
cv::SparseMatConstIterator::seekEnd	/usr/include/opencv2/core/core.hpp	/^    void seekEnd();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
cv::SparseMatConstIterator::seekEnd	/usr/include/opencv2/core/mat.hpp	/^inline void SparseMatConstIterator::seekEnd()$/;"	f	class:cv::SparseMatConstIterator	signature:()
cv::SparseMatConstIterator::value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& value() const;$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:() const
cv::SparseMatConstIterator::value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& SparseMatConstIterator::value() const$/;"	f	class:cv::SparseMatConstIterator	signature:() const
cv::SparseMatConstIterator_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMatConstIterator_ : public SparseMatConstIterator$/;"	c	namespace:cv	inherits:SparseMatConstIterator
cv::SparseMatConstIterator_::SparseMatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_();$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:()
cv::SparseMatConstIterator_::SparseMatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_(const SparseMatConstIterator_& it);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMatConstIterator_& it)
cv::SparseMatConstIterator_::SparseMatConstIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_(const SparseMat_<_Tp>* _m);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMat_<_Tp>* _m)
cv::SparseMatConstIterator_::SparseMatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_()$/;"	f	class:cv::SparseMatConstIterator_	signature:()
cv::SparseMatConstIterator_::SparseMatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMatConstIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMatConstIterator_<_Tp>& it)
cv::SparseMatConstIterator_::SparseMatConstIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat_<_Tp>* _m)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMat_<_Tp>* _m)
cv::SparseMatConstIterator_::iterator_category	/usr/include/opencv2/core/core.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	class:cv::SparseMatConstIterator_	access:public
cv::SparseMatConstIterator_::operator *	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator *() const;$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:() const
cv::SparseMatConstIterator_::operator *	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator *() const$/;"	f	class:cv::SparseMatConstIterator_	signature:() const
cv::SparseMatConstIterator_::operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_ operator ++(int);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(int)
cv::SparseMatConstIterator_::operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_& operator ++();$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:()
cv::SparseMatConstIterator_::operator ++	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator ++()$/;"	f	class:cv::SparseMatConstIterator_	signature:()
cv::SparseMatConstIterator_::operator ++	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::SparseMatConstIterator_	signature:(int)
cv::SparseMatConstIterator_::operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_& operator = (const SparseMatConstIterator_& it);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMatConstIterator_& it)
cv::SparseMatConstIterator_::operator =	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator = (const SparseMatConstIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMatConstIterator_<_Tp>& it)
cv::SparseMatIterator	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS SparseMatIterator : public SparseMatConstIterator$/;"	c	namespace:cv	inherits:SparseMatConstIterator
cv::SparseMatIterator::SparseMatIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator();$/;"	p	class:cv::SparseMatIterator	access:public	signature:()
cv::SparseMatIterator::SparseMatIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator(SparseMat* _m);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(SparseMat* _m)
cv::SparseMatIterator::SparseMatIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator(SparseMat* _m, const int* idx);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(SparseMat* _m, const int* idx)
cv::SparseMatIterator::SparseMatIterator	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator(const SparseMatIterator& it);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(const SparseMatIterator& it)
cv::SparseMatIterator::SparseMatIterator	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator()$/;"	f	class:cv::SparseMatIterator	signature:()
cv::SparseMatIterator::SparseMatIterator	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator(SparseMat* _m)$/;"	f	class:cv::SparseMatIterator	signature:(SparseMat* _m)
cv::SparseMatIterator::SparseMatIterator	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator(const SparseMatIterator& it)$/;"	f	class:cv::SparseMatIterator	signature:(const SparseMatIterator& it)
cv::SparseMatIterator::node	/usr/include/opencv2/core/core.hpp	/^    SparseMat::Node* node() const;$/;"	p	class:cv::SparseMatIterator	access:public	signature:() const
cv::SparseMatIterator::node	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::Node* SparseMatIterator::node() const$/;"	f	class:cv::SparseMatIterator	signature:() const
cv::SparseMatIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator operator ++(int);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(int)
cv::SparseMatIterator::operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator& operator ++();$/;"	p	class:cv::SparseMatIterator	access:public	signature:()
cv::SparseMatIterator::operator ++	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator SparseMatIterator::operator ++(int)$/;"	f	class:cv::SparseMatIterator	signature:(int)
cv::SparseMatIterator::operator ++	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator& SparseMatIterator::operator ++()$/;"	f	class:cv::SparseMatIterator	signature:()
cv::SparseMatIterator::operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator& operator = (const SparseMatIterator& it);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(const SparseMatIterator& it)
cv::SparseMatIterator::operator =	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator& SparseMatIterator::operator = (const SparseMatIterator& it)$/;"	f	class:cv::SparseMatIterator	signature:(const SparseMatIterator& it)
cv::SparseMatIterator::value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& value() const;$/;"	p	class:cv::SparseMatIterator	access:public	signature:() const
cv::SparseMatIterator::value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMatIterator::value() const$/;"	f	class:cv::SparseMatIterator	signature:() const
cv::SparseMatIterator_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMatIterator_ : public SparseMatConstIterator_<_Tp>$/;"	c	namespace:cv	inherits:SparseMatConstIterator_
cv::SparseMatIterator_::SparseMatIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_();$/;"	p	class:cv::SparseMatIterator_	access:public	signature:()
cv::SparseMatIterator_::SparseMatIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_(SparseMat_<_Tp>* _m);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(SparseMat_<_Tp>* _m)
cv::SparseMatIterator_::SparseMatIterator_	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_(const SparseMatIterator_& it);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(const SparseMatIterator_& it)
cv::SparseMatIterator_::SparseMatIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_()$/;"	f	class:cv::SparseMatIterator_	signature:()
cv::SparseMatIterator_::SparseMatIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat_<_Tp>* _m)$/;"	f	class:cv::SparseMatIterator_	signature:(SparseMat_<_Tp>* _m)
cv::SparseMatIterator_::SparseMatIterator_	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_(const SparseMatIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatIterator_	signature:(const SparseMatIterator_<_Tp>& it)
cv::SparseMatIterator_::iterator_category	/usr/include/opencv2/core/core.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	class:cv::SparseMatIterator_	access:public
cv::SparseMatIterator_::operator *	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator *() const;$/;"	p	class:cv::SparseMatIterator_	access:public	signature:() const
cv::SparseMatIterator_::operator *	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::operator *() const$/;"	f	class:cv::SparseMatIterator_	signature:() const
cv::SparseMatIterator_::operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_ operator ++(int);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(int)
cv::SparseMatIterator_::operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_& operator ++();$/;"	p	class:cv::SparseMatIterator_	access:public	signature:()
cv::SparseMatIterator_::operator ++	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::operator ++()$/;"	f	class:cv::SparseMatIterator_	signature:()
cv::SparseMatIterator_::operator ++	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::SparseMatIterator_	signature:(int)
cv::SparseMatIterator_::operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_& operator = (const SparseMatIterator_& it);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(const SparseMatIterator_& it)
cv::SparseMatIterator_::operator =	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::operator = (const SparseMatIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatIterator_	signature:(const SparseMatIterator_<_Tp>& it)
cv::SparseMat_	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMat_ : public SparseMat$/;"	c	namespace:cv	inherits:SparseMat
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_();$/;"	p	class:cv::SparseMat_	access:public	signature:()
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_(const CvSparseMat* m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const CvSparseMat* m)
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_(const Mat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const Mat& m)
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_(const SparseMat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat& m)
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_(const SparseMat_& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat_& m)
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/core.hpp	/^    SparseMat_(int dims, const int* _sizes);$/;"	p	class:cv::SparseMat_	access:public	signature:(int dims, const int* _sizes)
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_()$/;"	f	class:cv::SparseMat_	signature:()
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const CvSparseMat* m)$/;"	f	class:cv::SparseMat_	signature:(const CvSparseMat* m)
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const Mat& m)$/;"	f	class:cv::SparseMat_	signature:(const Mat& m)
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat& m)
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat_<_Tp>& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat_<_Tp>& m)
cv::SparseMat_::SparseMat_	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(int _dims, const int* _sizes)$/;"	f	class:cv::SparseMat_	signature:(int _dims, const int* _sizes)
cv::SparseMat_::begin	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::begin	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_<_Tp> begin();$/;"	p	class:cv::SparseMat_	access:public	signature:()
cv::SparseMat_::begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::begin() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::begin	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::begin()$/;"	f	class:cv::SparseMat_	signature:()
cv::SparseMat_::channels	/usr/include/opencv2/core/core.hpp	/^    int channels() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::channels	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::channels() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::clone	/usr/include/opencv2/core/core.hpp	/^    SparseMat_ clone() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::clone	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::clone() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::const_iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SparseMatConstIterator_<_Tp> const_iterator;$/;"	t	class:cv::SparseMat_	access:public
cv::SparseMat_::create	/usr/include/opencv2/core/core.hpp	/^    void create(int dims, const int* _sizes);$/;"	p	class:cv::SparseMat_	access:public	signature:(int dims, const int* _sizes)
cv::SparseMat_::create	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::create(int _dims, const int* _sizes)$/;"	f	class:cv::SparseMat_	signature:(int _dims, const int* _sizes)
cv::SparseMat_::depth	/usr/include/opencv2/core/core.hpp	/^    int depth() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::depth	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::depth() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::end	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_<_Tp> end() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::end	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_<_Tp> end();$/;"	p	class:cv::SparseMat_	access:public	signature:()
cv::SparseMat_::end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::end() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::end()$/;"	f	class:cv::SparseMat_	signature:()
cv::SparseMat_::iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SparseMatIterator_<_Tp> iterator;$/;"	t	class:cv::SparseMat_	access:public
cv::SparseMat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp operator()(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(const int* idx, size_t* hashval=0) const
cv::SparseMat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp operator()(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
cv::SparseMat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp operator()(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, size_t* hashval=0) const
cv::SparseMat_::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp operator()(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, size_t* hashval=0) const
cv::SparseMat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator()(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(const int* idx, size_t* hashval) const
cv::SparseMat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, int i2, size_t* hashval) const
cv::SparseMat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, size_t* hashval) const
cv::SparseMat_::operator ()	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, size_t* hashval) const
cv::SparseMat_::operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMat_& operator = (const Mat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const Mat& m)
cv::SparseMat_::operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMat_& operator = (const SparseMat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat& m)
cv::SparseMat_::operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMat_& operator = (const SparseMat_& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat_& m)
cv::SparseMat_::operator =	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator = (const Mat& m)$/;"	f	class:cv::SparseMat_	signature:(const Mat& m)
cv::SparseMat_::operator =	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator = (const SparseMat& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat& m)
cv::SparseMat_::operator =	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator = (const SparseMat_<_Tp>& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat_<_Tp>& m)
cv::SparseMat_::operator CvSparseMat*	/usr/include/opencv2/core/core.hpp	/^    operator CvSparseMat*() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::operator CvSparseMat*	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator CvSparseMat*() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::ref	/usr/include/opencv2/core/core.hpp	/^    _Tp& ref(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(const int* idx, size_t* hashval=0)
cv::SparseMat_::ref	/usr/include/opencv2/core/core.hpp	/^    _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
cv::SparseMat_::ref	/usr/include/opencv2/core/core.hpp	/^    _Tp& ref(int i0, int i1, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, size_t* hashval=0)
cv::SparseMat_::ref	/usr/include/opencv2/core/core.hpp	/^    _Tp& ref(int i0, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, size_t* hashval=0)
cv::SparseMat_::ref	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::ref(const int* idx, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(const int* idx, size_t* hashval)
cv::SparseMat_::ref	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, int i1, int i2, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, int i2, size_t* hashval)
cv::SparseMat_::ref	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, int i1, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, size_t* hashval)
cv::SparseMat_::ref	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, size_t* hashval)
cv::SparseMat_::type	/usr/include/opencv2/core/core.hpp	/^    int type() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::type	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::type() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SpinImageModel	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS SpinImageModel$/;"	c	namespace:cv
cv::SpinImageModel::SpinImageModel	/usr/include/opencv2/contrib/contrib.hpp	/^        SpinImageModel();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
cv::SpinImageModel::SpinImageModel	/usr/include/opencv2/contrib/contrib.hpp	/^        explicit SpinImageModel(const Mesh3D& mesh);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Mesh3D& mesh)
cv::SpinImageModel::T_GeometriccConsistency	/usr/include/opencv2/contrib/contrib.hpp	/^        float T_GeometriccConsistency;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::T_GroupingCorespondances	/usr/include/opencv2/contrib/contrib.hpp	/^        float T_GroupingCorespondances;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::binSize	/usr/include/opencv2/contrib/contrib.hpp	/^        float binSize;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::calcSpinMapCoo	/usr/include/opencv2/contrib/contrib.hpp	/^        static Point2f calcSpinMapCoo(const Point3f& point, const Point3f& vertex, const Point3f& normal);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& point, const Point3f& vertex, const Point3f& normal)
cv::SpinImageModel::compute	/usr/include/opencv2/contrib/contrib.hpp	/^        void compute();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
cv::SpinImageModel::defaultParams	/usr/include/opencv2/contrib/contrib.hpp	/^        void defaultParams();$/;"	p	class:cv::SpinImageModel	access:protected	signature:()
cv::SpinImageModel::gamma	/usr/include/opencv2/contrib/contrib.hpp	/^        float gamma;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::geometricConsistency	/usr/include/opencv2/contrib/contrib.hpp	/^        static float geometricConsistency(const Point3f& pointScene1, const Point3f& normalScene1,$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& pointScene1, const Point3f& normalScene1, const Point3f& pointModel1, const Point3f& normalModel1, const Point3f& pointScene2, const Point3f& normalScene2, const Point3f& pointModel2, const Point3f& normalModel2)
cv::SpinImageModel::getMesh	/usr/include/opencv2/contrib/contrib.hpp	/^        Mesh3D& getMesh() { return mesh; }$/;"	f	class:cv::SpinImageModel	access:public	signature:()
cv::SpinImageModel::getMesh	/usr/include/opencv2/contrib/contrib.hpp	/^        const Mesh3D& getMesh() const { return mesh; }$/;"	f	class:cv::SpinImageModel	access:public	signature:() const
cv::SpinImageModel::getSpinCount	/usr/include/opencv2/contrib/contrib.hpp	/^        size_t getSpinCount() const { return spinImages.rows; }$/;"	f	class:cv::SpinImageModel	access:public	signature:() const
cv::SpinImageModel::getSpinImage	/usr/include/opencv2/contrib/contrib.hpp	/^        Mat getSpinImage(size_t index) const { return spinImages.row((int)index); }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
cv::SpinImageModel::getSpinNormal	/usr/include/opencv2/contrib/contrib.hpp	/^        const Point3f& getSpinNormal(size_t index) const { return mesh.normals[subset[index]]; }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
cv::SpinImageModel::getSpinVertex	/usr/include/opencv2/contrib/contrib.hpp	/^        const Point3f& getSpinVertex(size_t index) const { return mesh.vtx[subset[index]]; }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
cv::SpinImageModel::groupingCreteria	/usr/include/opencv2/contrib/contrib.hpp	/^        static float groupingCreteria(const Point3f& pointScene1, const Point3f& normalScene1,$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& pointScene1, const Point3f& normalScene1, const Point3f& pointModel1, const Point3f& normalModel1, const Point3f& pointScene2, const Point3f& normalScene2, const Point3f& pointModel2, const Point3f& normalModel2, float gamma)
cv::SpinImageModel::imageWidth	/usr/include/opencv2/contrib/contrib.hpp	/^        int imageWidth;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::lambda	/usr/include/opencv2/contrib/contrib.hpp	/^        float lambda;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::match	/usr/include/opencv2/contrib/contrib.hpp	/^        void match(const SpinImageModel& scene, vector< vector<Vec2i> >& result);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const SpinImageModel& scene, vector< vector<Vec2i> >& result)
cv::SpinImageModel::matchSpinToModel	/usr/include/opencv2/contrib/contrib.hpp	/^        void matchSpinToModel(const Mat& spin, vector<int>& indeces,$/;"	p	class:cv::SpinImageModel	access:protected	signature:(const Mat& spin, vector<int>& indeces, vector<float>& corrCoeffs, bool useExtremeOutliers = true) const
cv::SpinImageModel::mesh	/usr/include/opencv2/contrib/contrib.hpp	/^        Mesh3D mesh;$/;"	m	class:cv::SpinImageModel	access:protected
cv::SpinImageModel::minNeighbors	/usr/include/opencv2/contrib/contrib.hpp	/^        int minNeighbors;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::normalRadius	/usr/include/opencv2/contrib/contrib.hpp	/^        float normalRadius;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::out	/usr/include/opencv2/contrib/contrib.hpp	/^        std::ostream* out;$/;"	m	class:cv::SpinImageModel	access:protected
cv::SpinImageModel::packRandomScaledSpins	/usr/include/opencv2/contrib/contrib.hpp	/^        Mat packRandomScaledSpins(bool separateScale = false, size_t xCount = 10, size_t yCount = 10) const;$/;"	p	class:cv::SpinImageModel	access:public	signature:(bool separateScale = false, size_t xCount = 10, size_t yCount = 10) const
cv::SpinImageModel::repackSpinImages	/usr/include/opencv2/contrib/contrib.hpp	/^        void repackSpinImages(const vector<uchar>& mask, Mat& spinImages, bool reAlloc = true) const;$/;"	p	class:cv::SpinImageModel	access:protected	signature:(const vector<uchar>& mask, Mat& spinImages, bool reAlloc = true) const
cv::SpinImageModel::selectRandomSubset	/usr/include/opencv2/contrib/contrib.hpp	/^        void selectRandomSubset(float ratio);$/;"	p	class:cv::SpinImageModel	access:public	signature:(float ratio)
cv::SpinImageModel::setLogger	/usr/include/opencv2/contrib/contrib.hpp	/^        void setLogger(std::ostream* log);$/;"	p	class:cv::SpinImageModel	access:public	signature:(std::ostream* log)
cv::SpinImageModel::setSubset	/usr/include/opencv2/contrib/contrib.hpp	/^        void setSubset(const vector<int>& subset);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const vector<int>& subset)
cv::SpinImageModel::spinCorrelation	/usr/include/opencv2/contrib/contrib.hpp	/^        static bool spinCorrelation(const Mat& spin1, const Mat& spin2, float lambda, float& result);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Mat& spin1, const Mat& spin2, float lambda, float& result)
cv::SpinImageModel::spinImages	/usr/include/opencv2/contrib/contrib.hpp	/^        Mat spinImages;$/;"	m	class:cv::SpinImageModel	access:protected
cv::SpinImageModel::subset	/usr/include/opencv2/contrib/contrib.hpp	/^        vector<int> subset;$/;"	m	class:cv::SpinImageModel	access:protected
cv::SpinImageModel::~SpinImageModel	/usr/include/opencv2/contrib/contrib.hpp	/^        ~SpinImageModel();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
cv::Split	/usr/include/opencv2/core/internal.hpp	/^        typedef tbb::split Split;$/;"	t	namespace:cv
cv::StarAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS StarAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
cv::StarAdjuster::StarAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^	StarAdjuster(double initial_thresh = 30.0);$/;"	p	class:cv::StarAdjuster	access:public	signature:(double initial_thresh = 30.0)
cv::StarAdjuster::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::StarAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::StarAdjuster::good	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual bool good() const;$/;"	p	class:cv::StarAdjuster	access:public	signature:() const
cv::StarAdjuster::params_	/usr/include/opencv2/features2d/features2d.hpp	/^	CvStarDetectorParams params_; \/\/todo use these instead of thresh_$/;"	m	class:cv::StarAdjuster	access:protected
cv::StarAdjuster::thresh_	/usr/include/opencv2/features2d/features2d.hpp	/^	double thresh_;$/;"	m	class:cv::StarAdjuster	access:protected
cv::StarAdjuster::tooFew	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::StarAdjuster	access:public	signature:(int min, int n_detected)
cv::StarAdjuster::tooMany	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::StarAdjuster	access:public	signature:(int max, int n_detected)
cv::StarDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS_W StarDetector : public CvStarDetectorParams$/;"	c	namespace:cv	inherits:CvStarDetectorParams
cv::StarDetector::StarDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP StarDetector();$/;"	p	class:cv::StarDetector	access:public	signature:()
cv::StarDetector::StarDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP StarDetector(int _maxSize, int _responseThreshold,$/;"	p	class:cv::StarDetector	access:public	signature:(int _maxSize, int _responseThreshold, int _lineThresholdProjected, int _lineThresholdBinarized, int _suppressNonmaxSize)
cv::StarDetector::operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& image,$/;"	p	class:cv::StarDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints) const
cv::StarFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS StarFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::StarFeatureDetector::StarFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    StarFeatureDetector( const CvStarDetectorParams& params=cvStarDetectorParams() );$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( const CvStarDetectorParams& params=cvStarDetectorParams() )
cv::StarFeatureDetector::StarFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    StarFeatureDetector( int maxSize, int responseThreshold=30, int lineThresholdProjected = 10,$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( int maxSize, int responseThreshold=30, int lineThresholdProjected = 10, int lineThresholdBinarized=8, int suppressNonmaxSize=5 )
cv::StarFeatureDetector::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::StarFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::StarFeatureDetector::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( const FileNode& fn )
cv::StarFeatureDetector::star	/usr/include/opencv2/features2d/features2d.hpp	/^    StarDetector star;$/;"	m	class:cv::StarFeatureDetector	access:protected
cv::StarFeatureDetector::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( FileStorage& fs ) const
cv::StatModel	/usr/include/opencv2/ml/ml.hpp	/^typedef CvStatModel StatModel;$/;"	t	namespace:cv
cv::StereoBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^class CV_EXPORTS_W StereoBM$/;"	c	namespace:cv
cv::StereoBM::BASIC_PRESET	/usr/include/opencv2/calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon71
cv::StereoBM::FISH_EYE_PRESET	/usr/include/opencv2/calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon71
cv::StereoBM::NARROW_PRESET	/usr/include/opencv2/calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon71
cv::StereoBM::PREFILTER_NORMALIZED_RESPONSE	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { PREFILTER_NORMALIZED_RESPONSE = 0, PREFILTER_XSOBEL = 1,$/;"	e	enum:cv::StereoBM::__anon71
cv::StereoBM::PREFILTER_XSOBEL	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { PREFILTER_NORMALIZED_RESPONSE = 0, PREFILTER_XSOBEL = 1,$/;"	e	enum:cv::StereoBM::__anon71
cv::StereoBM::StereoBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP StereoBM();$/;"	p	class:cv::StereoBM	access:public	signature:()
cv::StereoBM::StereoBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP StereoBM(int preset, int ndisparities=0, int SADWindowSize=21);$/;"	p	class:cv::StereoBM	access:public	signature:(int preset, int ndisparities=0, int SADWindowSize=21)
cv::StereoBM::init	/usr/include/opencv2/calib3d/calib3d.hpp	/^    void init(int preset, int ndisparities=0, int SADWindowSize=21);$/;"	p	class:cv::StereoBM	access:public	signature:(int preset, int ndisparities=0, int SADWindowSize=21)
cv::StereoBM::operator ()	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP_AS(compute) void operator()( const Mat& left, const Mat& right, Mat& disparity, int disptype=CV_16S );$/;"	p	class:cv::StereoBM	access:public	signature:( const Mat& left, const Mat& right, Mat& disparity, int disptype=CV_16S )
cv::StereoBM::state	/usr/include/opencv2/calib3d/calib3d.hpp	/^    Ptr<CvStereoBMState> state;$/;"	m	class:cv::StereoBM	access:public
cv::StereoSGBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^class CV_EXPORTS_W StereoSGBM$/;"	c	namespace:cv
cv::StereoSGBM::DISP_SCALE	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DISP_SHIFT=4, DISP_SCALE = (1<<DISP_SHIFT) };$/;"	e	enum:cv::StereoSGBM::__anon72
cv::StereoSGBM::DISP_SHIFT	/usr/include/opencv2/calib3d/calib3d.hpp	/^    enum { DISP_SHIFT=4, DISP_SCALE = (1<<DISP_SHIFT) };$/;"	e	enum:cv::StereoSGBM::__anon72
cv::StereoSGBM::P1	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int P1;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::P2	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int P2;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::SADWindowSize	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int SADWindowSize;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::StereoSGBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP StereoSGBM();$/;"	p	class:cv::StereoSGBM	access:public	signature:()
cv::StereoSGBM::StereoSGBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP StereoSGBM(int minDisparity, int numDisparities, int SADWindowSize,$/;"	p	class:cv::StereoSGBM	access:public	signature:(int minDisparity, int numDisparities, int SADWindowSize, int P1=0, int P2=0, int disp12MaxDiff=0, int preFilterCap=0, int uniquenessRatio=0, int speckleWindowSize=0, int speckleRange=0, bool fullDP=false)
cv::StereoSGBM::buffer	/usr/include/opencv2/calib3d/calib3d.hpp	/^    Mat buffer;$/;"	m	class:cv::StereoSGBM	access:protected
cv::StereoSGBM::disp12MaxDiff	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int disp12MaxDiff;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::fullDP	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW bool fullDP;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::minDisparity	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int minDisparity;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::numberOfDisparities	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int numberOfDisparities;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::operator ()	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP_AS(compute) virtual void operator()(const Mat& left, const Mat& right, Mat& disp);$/;"	p	class:cv::StereoSGBM	access:public	signature:(const Mat& left, const Mat& right, Mat& disp)
cv::StereoSGBM::preFilterCap	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int preFilterCap;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::speckleRange	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int speckleRange;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::speckleWindowSize	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int speckleWindowSize;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::uniquenessRatio	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int uniquenessRatio;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::~StereoSGBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^    virtual ~StereoSGBM();$/;"	p	class:cv::StereoSGBM	access:public	signature:()
cv::String	/usr/include/opencv2/core/core.hpp	/^typedef std::string String;$/;"	t	namespace:cv
cv::SurfAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SurfAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
cv::SurfAdjuster::SurfAdjuster	/usr/include/opencv2/features2d/features2d.hpp	/^    SurfAdjuster();$/;"	p	class:cv::SurfAdjuster	access:public	signature:()
cv::SurfAdjuster::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SurfAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::SurfAdjuster::good	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual bool good() const;$/;"	p	class:cv::SurfAdjuster	access:public	signature:() const
cv::SurfAdjuster::thresh_	/usr/include/opencv2/features2d/features2d.hpp	/^	double thresh_;$/;"	m	class:cv::SurfAdjuster	access:protected
cv::SurfAdjuster::tooFew	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::SurfAdjuster	access:public	signature:(int min, int n_detected)
cv::SurfAdjuster::tooMany	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::SurfAdjuster	access:public	signature:(int max, int n_detected)
cv::SurfDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SurfDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
cv::SurfDescriptorExtractor::SurfDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    SurfDescriptorExtractor( int nOctaves=4, int nOctaveLayers=2, bool extended=false );$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( int nOctaves=4, int nOctaveLayers=2, bool extended=false )
cv::SurfDescriptorExtractor::computeImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::SurfDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::SurfDescriptorExtractor::descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:() const
cv::SurfDescriptorExtractor::descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:() const
cv::SurfDescriptorExtractor::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( const FileNode &fn )
cv::SurfDescriptorExtractor::surf	/usr/include/opencv2/features2d/features2d.hpp	/^    SURF surf;$/;"	m	class:cv::SurfDescriptorExtractor	access:protected
cv::SurfDescriptorExtractor::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
cv::SurfFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS SurfFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::SurfFeatureDetector::SurfFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    SurfFeatureDetector( double hessianThreshold=400., int octaves=3, int octaveLayers=4 );$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( double hessianThreshold=400., int octaves=3, int octaveLayers=4 )
cv::SurfFeatureDetector::detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SurfFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::SurfFeatureDetector::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( const FileNode& fn )
cv::SurfFeatureDetector::surf	/usr/include/opencv2/features2d/features2d.hpp	/^    SURF surf;$/;"	m	class:cv::SurfFeatureDetector	access:protected
cv::SurfFeatureDetector::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( FileStorage& fs ) const
cv::THRESH_BINARY	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { THRESH_BINARY=0, THRESH_BINARY_INV=1, THRESH_TRUNC=2, THRESH_TOZERO=3,$/;"	e	enum:cv::__anon42
cv::THRESH_BINARY_INV	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { THRESH_BINARY=0, THRESH_BINARY_INV=1, THRESH_TRUNC=2, THRESH_TOZERO=3,$/;"	e	enum:cv::__anon42
cv::THRESH_MASK	/usr/include/opencv2/imgproc/imgproc.hpp	/^       THRESH_TOZERO_INV=4, THRESH_MASK=7, THRESH_OTSU=8 };$/;"	e	enum:cv::__anon42
cv::THRESH_OTSU	/usr/include/opencv2/imgproc/imgproc.hpp	/^       THRESH_TOZERO_INV=4, THRESH_MASK=7, THRESH_OTSU=8 };$/;"	e	enum:cv::__anon42
cv::THRESH_TOZERO	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { THRESH_BINARY=0, THRESH_BINARY_INV=1, THRESH_TRUNC=2, THRESH_TOZERO=3,$/;"	e	enum:cv::__anon42
cv::THRESH_TOZERO_INV	/usr/include/opencv2/imgproc/imgproc.hpp	/^       THRESH_TOZERO_INV=4, THRESH_MASK=7, THRESH_OTSU=8 };$/;"	e	enum:cv::__anon42
cv::THRESH_TRUNC	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { THRESH_BINARY=0, THRESH_BINARY_INV=1, THRESH_TRUNC=2, THRESH_TOZERO=3,$/;"	e	enum:cv::__anon42
cv::TM_CCOEFF	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
cv::TM_CCOEFF_NORMED	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
cv::TM_CCORR	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
cv::TM_CCORR_NORMED	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
cv::TM_SQDIFF	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
cv::TM_SQDIFF_NORMED	/usr/include/opencv2/imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon49
cv::TYPE_MASK	/usr/include/opencv2/core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon141
cv::TermCriteria	/usr/include/opencv2/core/core.hpp	/^class CV_EXPORTS TermCriteria$/;"	c	namespace:cv
cv::TermCriteria::COUNT	/usr/include/opencv2/core/core.hpp	/^        COUNT=1, \/\/!< the maximum number of iterations or elements to compute$/;"	e	enum:cv::TermCriteria::__anon144
cv::TermCriteria::EPS	/usr/include/opencv2/core/core.hpp	/^        EPS=2 \/\/!< the desired accuracy or change in parameters at which the iterative algorithm stops$/;"	e	enum:cv::TermCriteria::__anon144
cv::TermCriteria::MAX_ITER	/usr/include/opencv2/core/core.hpp	/^        MAX_ITER=COUNT, \/\/!< ditto$/;"	e	enum:cv::TermCriteria::__anon144
cv::TermCriteria::TermCriteria	/usr/include/opencv2/core/core.hpp	/^    TermCriteria();$/;"	p	class:cv::TermCriteria	access:public	signature:()
cv::TermCriteria::TermCriteria	/usr/include/opencv2/core/core.hpp	/^    TermCriteria(const CvTermCriteria& criteria);$/;"	p	class:cv::TermCriteria	access:public	signature:(const CvTermCriteria& criteria)
cv::TermCriteria::TermCriteria	/usr/include/opencv2/core/core.hpp	/^    TermCriteria(int _type, int _maxCount, double _epsilon);$/;"	p	class:cv::TermCriteria	access:public	signature:(int _type, int _maxCount, double _epsilon)
cv::TermCriteria::TermCriteria	/usr/include/opencv2/core/operations.hpp	/^inline TermCriteria::TermCriteria() : type(0), maxCount(0), epsilon(0) {}$/;"	f	class:cv::TermCriteria	signature:()
cv::TermCriteria::TermCriteria	/usr/include/opencv2/core/operations.hpp	/^inline TermCriteria::TermCriteria(const CvTermCriteria& criteria)$/;"	f	class:cv::TermCriteria	signature:(const CvTermCriteria& criteria)
cv::TermCriteria::TermCriteria	/usr/include/opencv2/core/operations.hpp	/^inline TermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon)$/;"	f	class:cv::TermCriteria	signature:(int _type, int _maxCount, double _epsilon)
cv::TermCriteria::epsilon	/usr/include/opencv2/core/core.hpp	/^    double epsilon; \/\/ the desired accuracy$/;"	m	class:cv::TermCriteria	access:public
cv::TermCriteria::maxCount	/usr/include/opencv2/core/core.hpp	/^    int maxCount; \/\/ the maximum number of iterations\/elements$/;"	m	class:cv::TermCriteria	access:public
cv::TermCriteria::operator CvTermCriteria	/usr/include/opencv2/core/core.hpp	/^    operator CvTermCriteria() const;$/;"	p	class:cv::TermCriteria	access:public	signature:() const
cv::TermCriteria::operator CvTermCriteria	/usr/include/opencv2/core/operations.hpp	/^inline TermCriteria::operator CvTermCriteria() const$/;"	f	class:cv::TermCriteria	signature:() const
cv::TermCriteria::type	/usr/include/opencv2/core/core.hpp	/^    int type; \/\/!< the type of termination criteria: COUNT, EPS or COUNT + EPS$/;"	m	class:cv::TermCriteria	access:public
cv::TickMeter	/usr/include/opencv2/contrib/contrib.hpp	/^    class CV_EXPORTS TickMeter$/;"	c	namespace:cv
cv::TickMeter::TickMeter	/usr/include/opencv2/contrib/contrib.hpp	/^        TickMeter();$/;"	p	class:cv::TickMeter	access:public	signature:()
cv::TickMeter::counter	/usr/include/opencv2/contrib/contrib.hpp	/^        int64 counter;$/;"	m	class:cv::TickMeter	access:private
cv::TickMeter::getCounter	/usr/include/opencv2/contrib/contrib.hpp	/^        int64 getCounter() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
cv::TickMeter::getTimeMicro	/usr/include/opencv2/contrib/contrib.hpp	/^        double getTimeMicro() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
cv::TickMeter::getTimeMilli	/usr/include/opencv2/contrib/contrib.hpp	/^        double getTimeMilli() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
cv::TickMeter::getTimeSec	/usr/include/opencv2/contrib/contrib.hpp	/^        double getTimeSec()   const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
cv::TickMeter::getTimeTicks	/usr/include/opencv2/contrib/contrib.hpp	/^        int64 getTimeTicks() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
cv::TickMeter::reset	/usr/include/opencv2/contrib/contrib.hpp	/^        void reset();$/;"	p	class:cv::TickMeter	access:public	signature:()
cv::TickMeter::start	/usr/include/opencv2/contrib/contrib.hpp	/^        void start();$/;"	p	class:cv::TickMeter	access:public	signature:()
cv::TickMeter::startTime	/usr/include/opencv2/contrib/contrib.hpp	/^        int64 startTime;$/;"	m	class:cv::TickMeter	access:private
cv::TickMeter::stop	/usr/include/opencv2/contrib/contrib.hpp	/^        void stop();$/;"	p	class:cv::TickMeter	access:public	signature:()
cv::TickMeter::sumTime	/usr/include/opencv2/contrib/contrib.hpp	/^        int64 sumTime;$/;"	m	class:cv::TickMeter	access:private
cv::TrackbarCallback	/usr/include/opencv2/highgui/highgui.hpp	/^typedef void (CV_CDECL *TrackbarCallback)(int pos, void* userdata);$/;"	t	namespace:cv
cv::TrainData	/usr/include/opencv2/ml/ml.hpp	/^typedef CvMLData TrainData;$/;"	t	namespace:cv
cv::Vec	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int cn> class CV_EXPORTS Vec : public Matx<_Tp, cn, 1>$/;"	c	namespace:cv	inherits:Matx
cv::Vec	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int cn> class CV_EXPORTS Vec;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Vec2b	/usr/include/opencv2/core/core.hpp	/^typedef Vec<uchar, 2> Vec2b;$/;"	t	namespace:cv
cv::Vec2d	/usr/include/opencv2/core/core.hpp	/^typedef Vec<double, 2> Vec2d;$/;"	t	namespace:cv
cv::Vec2f	/usr/include/opencv2/core/core.hpp	/^typedef Vec<float, 2> Vec2f;$/;"	t	namespace:cv
cv::Vec2i	/usr/include/opencv2/core/core.hpp	/^typedef Vec<int, 2> Vec2i;$/;"	t	namespace:cv
cv::Vec2s	/usr/include/opencv2/core/core.hpp	/^typedef Vec<short, 2> Vec2s;$/;"	t	namespace:cv
cv::Vec2w	/usr/include/opencv2/core/core.hpp	/^typedef Vec<ushort, 2> Vec2w;$/;"	t	namespace:cv
cv::Vec3b	/usr/include/opencv2/core/core.hpp	/^typedef Vec<uchar, 3> Vec3b;$/;"	t	namespace:cv
cv::Vec3d	/usr/include/opencv2/core/core.hpp	/^typedef Vec<double, 3> Vec3d;$/;"	t	namespace:cv
cv::Vec3f	/usr/include/opencv2/core/core.hpp	/^typedef Vec<float, 3> Vec3f;$/;"	t	namespace:cv
cv::Vec3i	/usr/include/opencv2/core/core.hpp	/^typedef Vec<int, 3> Vec3i;$/;"	t	namespace:cv
cv::Vec3s	/usr/include/opencv2/core/core.hpp	/^typedef Vec<short, 3> Vec3s;$/;"	t	namespace:cv
cv::Vec3w	/usr/include/opencv2/core/core.hpp	/^typedef Vec<ushort, 3> Vec3w;$/;"	t	namespace:cv
cv::Vec4b	/usr/include/opencv2/core/core.hpp	/^typedef Vec<uchar, 4> Vec4b;$/;"	t	namespace:cv
cv::Vec4d	/usr/include/opencv2/core/core.hpp	/^typedef Vec<double, 4> Vec4d;$/;"	t	namespace:cv
cv::Vec4f	/usr/include/opencv2/core/core.hpp	/^typedef Vec<float, 4> Vec4f;$/;"	t	namespace:cv
cv::Vec4i	/usr/include/opencv2/core/core.hpp	/^typedef Vec<int, 4> Vec4i;$/;"	t	namespace:cv
cv::Vec4s	/usr/include/opencv2/core/core.hpp	/^typedef Vec<short, 4> Vec4s;$/;"	t	namespace:cv
cv::Vec4w	/usr/include/opencv2/core/core.hpp	/^typedef Vec<ushort, 4> Vec4w;    $/;"	t	namespace:cv
cv::Vec6d	/usr/include/opencv2/core/core.hpp	/^typedef Vec<double, 6> Vec6d;$/;"	t	namespace:cv
cv::Vec6f	/usr/include/opencv2/core/core.hpp	/^typedef Vec<float, 6> Vec6f;$/;"	t	namespace:cv
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec();$/;"	p	class:cv::Vec	access:public	signature:()
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0); \/\/!< 1-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0)
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1); \/\/!< 2-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1)
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2); \/\/!< 3-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2)
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3); \/\/!< 4-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); \/\/!< 5-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); \/\/!< 6-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); \/\/!< 7-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); \/\/!< 8-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); \/\/!< 9-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); \/\/!< 10-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    Vec(const Vec<_Tp, cn>& v);$/;"	p	class:cv::Vec	access:public	signature:(const Vec<_Tp, cn>& v)
cv::Vec::Vec	/usr/include/opencv2/core/core.hpp	/^    explicit Vec(const _Tp* values);$/;"	p	class:cv::Vec	access:public	signature:(const _Tp* values)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec()$/;"	f	class:cv::Vec	signature:()
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0)$/;"	f	class:cv::Vec	signature:(_Tp v0)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const Vec<_Tp, cn>& v)$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& v)
cv::Vec::Vec	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const _Tp* values)$/;"	f	class:cv::Vec	signature:(const _Tp* values)
cv::Vec::all	/usr/include/opencv2/core/core.hpp	/^    static Vec all(_Tp alpha);$/;"	p	class:cv::Vec	access:public	signature:(_Tp alpha)
cv::Vec::all	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::all(_Tp alpha)$/;"	f	class:cv::Vec	signature:(_Tp alpha)
cv::Vec::channels	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon121
cv::Vec::cross	/usr/include/opencv2/core/core.hpp	/^    Vec cross(const Vec& v) const;$/;"	p	class:cv::Vec	access:public	signature:(const Vec& v) const
cv::Vec::cross	/usr/include/opencv2/core/operations.hpp	/^template<> inline Vec<double, 3> Vec<double, 3>::cross(const Vec<double, 3>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<double, 3>& v) const
cv::Vec::cross	/usr/include/opencv2/core/operations.hpp	/^template<> inline Vec<float, 3> Vec<float, 3>::cross(const Vec<float, 3>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<float, 3>& v) const
cv::Vec::cross	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::cross(const Vec<_Tp, cn>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& v) const
cv::Vec::depth	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon121
cv::Vec::mul	/usr/include/opencv2/core/core.hpp	/^    Vec mul(const Vec<_Tp, cn>& v) const;$/;"	p	class:cv::Vec	access:public	signature:(const Vec<_Tp, cn>& v) const
cv::Vec::mul	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::mul(const Vec<_Tp, cn>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& v) const
cv::Vec::operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int i);$/;"	p	class:cv::Vec	access:public	signature:(int i)
cv::Vec::operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int i) const;$/;"	p	class:cv::Vec	access:public	signature:(int i) const
cv::Vec::operator ()	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator ()(int i)$/;"	f	class:cv::Vec	signature:(int i)
cv::Vec::operator ()	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator ()(int i) const$/;"	f	class:cv::Vec	signature:(int i) const
cv::Vec::operator CvScalar	/usr/include/opencv2/core/core.hpp	/^    operator CvScalar() const;$/;"	p	class:cv::Vec	access:public	signature:() const
cv::Vec::operator CvScalar	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::operator CvScalar() const$/;"	f	class:cv::Vec	signature:() const
cv::Vec::operator Vec<T2, cn>	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> operator Vec<T2, cn>() const;$/;"	p	class:cv::Vec	access:public	signature:() const
cv::Vec::operator Vec<T2, cn>	/usr/include/opencv2/core/operations.hpp	/^inline Vec<_Tp, cn>::operator Vec<T2, cn>() const$/;"	f	class:cv::Vec	signature:() const
cv::Vec::operator []	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator[](int i);$/;"	p	class:cv::Vec	access:public	signature:(int i)
cv::Vec::operator []	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator [](int i) const;$/;"	p	class:cv::Vec	access:public	signature:(int i) const
cv::Vec::operator []	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator [](int i)$/;"	f	class:cv::Vec	signature:(int i)
cv::Vec::operator []	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator [](int i) const$/;"	f	class:cv::Vec	signature:(int i) const
cv::Vec::type	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon121
cv::Vec::value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Vec	access:public
cv::VecCommaInitializer	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp, int m> class CV_EXPORTS VecCommaInitializer : public MatxCommaInitializer<_Tp, m, 1>$/;"	c	namespace:cv	inherits:MatxCommaInitializer
cv::VecCommaInitializer::VecCommaInitializer	/usr/include/opencv2/core/core.hpp	/^    VecCommaInitializer(Vec<_Tp, m>* _vec);$/;"	p	class:cv::VecCommaInitializer	access:public	signature:(Vec<_Tp, m>* _vec)
cv::VecCommaInitializer::VecCommaInitializer	/usr/include/opencv2/core/operations.hpp	/^VecCommaInitializer<_Tp, cn>::VecCommaInitializer(Vec<_Tp, cn>* _vec)$/;"	f	class:cv::VecCommaInitializer	signature:(Vec<_Tp, cn>* _vec)
cv::VecCommaInitializer::operator *	/usr/include/opencv2/core/core.hpp	/^    Vec<_Tp, m> operator *() const;$/;"	p	class:cv::VecCommaInitializer	access:public	signature:() const
cv::VecCommaInitializer::operator *	/usr/include/opencv2/core/operations.hpp	/^Vec<_Tp, cn> VecCommaInitializer<_Tp, cn>::operator *() const$/;"	f	class:cv::VecCommaInitializer	signature:() const
cv::VecCommaInitializer::operator ,	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> VecCommaInitializer<_Tp, m>& operator , (T2 val);$/;"	p	class:cv::VecCommaInitializer	access:public	signature:(T2 val)
cv::VecCommaInitializer::operator ,	/usr/include/opencv2/core/operations.hpp	/^VecCommaInitializer<_Tp, cn>& VecCommaInitializer<_Tp, cn>::operator , (_T2 value)$/;"	f	class:cv::VecCommaInitializer	signature:(_T2 value)
cv::VecReaderProxy	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int numflag> class CV_EXPORTS VecReaderProxy$/;"	c	namespace:cv
cv::VecReaderProxy	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS VecReaderProxy<_Tp,1>$/;"	c	namespace:cv
cv::VecReaderProxy::VecReaderProxy	/usr/include/opencv2/core/operations.hpp	/^    VecReaderProxy( FileNodeIterator* _it ) : it(_it) {}$/;"	f	class:cv::VecReaderProxy	access:public	signature:( FileNodeIterator* _it )
cv::VecReaderProxy::it	/usr/include/opencv2/core/operations.hpp	/^    FileNodeIterator* it;$/;"	m	class:cv::VecReaderProxy	access:public
cv::VecReaderProxy::operator ()	/usr/include/opencv2/core/operations.hpp	/^    void operator()(vector<_Tp>& vec, size_t count) const$/;"	f	class:cv::VecReaderProxy	access:public	signature:(vector<_Tp>& vec, size_t count) const
cv::VecWriterProxy	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int numflag> class CV_EXPORTS VecWriterProxy$/;"	c	namespace:cv
cv::VecWriterProxy	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS VecWriterProxy<_Tp,1>$/;"	c	namespace:cv
cv::VecWriterProxy::VecWriterProxy	/usr/include/opencv2/core/operations.hpp	/^    VecWriterProxy( FileStorage* _fs ) : fs(_fs) {}$/;"	f	class:cv::VecWriterProxy	access:public	signature:( FileStorage* _fs )
cv::VecWriterProxy::fs	/usr/include/opencv2/core/operations.hpp	/^    FileStorage* fs;$/;"	m	class:cv::VecWriterProxy	access:public
cv::VecWriterProxy::operator ()	/usr/include/opencv2/core/operations.hpp	/^    void operator()(const vector<_Tp>& vec) const$/;"	f	class:cv::VecWriterProxy	access:public	signature:(const vector<_Tp>& vec) const
cv::Vector	/usr/include/opencv2/core/operations.hpp	/^template <typename _Tp> class CV_EXPORTS Vector$/;"	c	namespace:cv
cv::Vector::Hdr	/usr/include/opencv2/core/operations.hpp	/^    struct CV_EXPORTS Hdr$/;"	s	class:cv::Vector	access:public
cv::Vector::Hdr::Hdr	/usr/include/opencv2/core/operations.hpp	/^        Hdr() : data(0), datastart(0), refcount(0), size(0), capacity(0) {};$/;"	f	struct:cv::Vector::Hdr	access:public	signature:()
cv::Vector::Hdr::capacity	/usr/include/opencv2/core/operations.hpp	/^        size_t capacity;$/;"	m	struct:cv::Vector::Hdr	access:public
cv::Vector::Hdr::data	/usr/include/opencv2/core/operations.hpp	/^        _Tp* data;$/;"	m	struct:cv::Vector::Hdr	access:public
cv::Vector::Hdr::datastart	/usr/include/opencv2/core/operations.hpp	/^        _Tp* datastart;$/;"	m	struct:cv::Vector::Hdr	access:public
cv::Vector::Hdr::refcount	/usr/include/opencv2/core/operations.hpp	/^        int* refcount;$/;"	m	struct:cv::Vector::Hdr	access:public
cv::Vector::Hdr::size	/usr/include/opencv2/core/operations.hpp	/^        size_t size;$/;"	m	struct:cv::Vector::Hdr	access:public
cv::Vector::Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector() {}$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(_Tp* _data, size_t _size, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(_Tp* _data, size_t _size, bool _copyData=false)
cv::Vector::Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(const Vector& d) { *this = d; }$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d)
cv::Vector::Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(const Vector& d, const Range& r_)$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d, const Range& r_)
cv::Vector::Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(const std::vector<_Tp>& vec, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(const std::vector<_Tp>& vec, bool _copyData=false)
cv::Vector::Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(size_t _size)  { resize(_size); }$/;"	f	class:cv::Vector	access:public	signature:(size_t _size)
cv::Vector::Vector	/usr/include/opencv2/core/operations.hpp	/^    Vector(size_t _size, const _Tp& val)$/;"	f	class:cv::Vector	access:public	signature:(size_t _size, const _Tp& val)
cv::Vector::Vector	/usr/include/opencv2/core/operations.hpp	/^    template<int n> Vector(const Vec<_Tp, n>& vec)$/;"	f	class:cv::Vector	access:public	signature:(const Vec<_Tp, n>& vec)
cv::Vector::addref	/usr/include/opencv2/core/operations.hpp	/^    void addref() { if( hdr.refcount ) CV_XADD(hdr.refcount, 1); }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::back	/usr/include/opencv2/core/operations.hpp	/^    _Tp& back() { CV_DbgAssert(!empty()); return hdr.data[hdr.size-1]; }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::back	/usr/include/opencv2/core/operations.hpp	/^    const _Tp& back() const { CV_DbgAssert(!empty()); return hdr.data[hdr.size-1]; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::begin	/usr/include/opencv2/core/operations.hpp	/^    _Tp* begin() { return hdr.data; }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::begin	/usr/include/opencv2/core/operations.hpp	/^    const _Tp* begin() const { return hdr.data; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::capacity	/usr/include/opencv2/core/operations.hpp	/^    size_t capacity() const { return hdr.capacity; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::clear	/usr/include/opencv2/core/operations.hpp	/^    void clear() { resize(0); }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::clone	/usr/include/opencv2/core/operations.hpp	/^    Vector<_Tp> clone() const$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::const_iterator	/usr/include/opencv2/core/operations.hpp	/^    typedef const _Tp* const_iterator;$/;"	t	class:cv::Vector	access:public
cv::Vector::const_reference	/usr/include/opencv2/core/operations.hpp	/^    typedef const _Tp& const_reference;$/;"	t	class:cv::Vector	access:public
cv::Vector::copyTo	/usr/include/opencv2/core/operations.hpp	/^    void copyTo(Vector<_Tp>& vec) const$/;"	f	class:cv::Vector	access:public	signature:(Vector<_Tp>& vec) const
cv::Vector::copyTo	/usr/include/opencv2/core/operations.hpp	/^    void copyTo(std::vector<_Tp>& vec) const$/;"	f	class:cv::Vector	access:public	signature:(std::vector<_Tp>& vec) const
cv::Vector::empty	/usr/include/opencv2/core/operations.hpp	/^    bool empty() const { return hdr.size == 0; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::end	/usr/include/opencv2/core/operations.hpp	/^    _Tp* end() { return hdr.data + hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::end	/usr/include/opencv2/core/operations.hpp	/^    const _Tp* end() const { return hdr.data + hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::front	/usr/include/opencv2/core/operations.hpp	/^    _Tp& front() { CV_DbgAssert(!empty()); return hdr.data[0]; }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::front	/usr/include/opencv2/core/operations.hpp	/^    const _Tp& front() const { CV_DbgAssert(!empty()); return hdr.data[0]; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::hdr	/usr/include/opencv2/core/operations.hpp	/^    Hdr hdr;$/;"	m	class:cv::Vector	access:protected
cv::Vector::iterator	/usr/include/opencv2/core/operations.hpp	/^    typedef _Tp* iterator;$/;"	t	class:cv::Vector	access:public
cv::Vector::operator ()	/usr/include/opencv2/core/operations.hpp	/^    Vector operator() (const Range& r) const { return Vector(*this, r); }$/;"	f	class:cv::Vector	access:public	signature:(const Range& r) const
cv::Vector::operator =	/usr/include/opencv2/core/operations.hpp	/^    Vector<_Tp>& operator = (const Vector& d)$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d)
cv::Vector::operator CvMat	/usr/include/opencv2/core/operations.hpp	/^    operator CvMat() const$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::operator []	/usr/include/opencv2/core/operations.hpp	/^    _Tp& operator [] (size_t i) { CV_DbgAssert( i < size() ); return hdr.data[i]; }$/;"	f	class:cv::Vector	access:public	signature:(size_t i)
cv::Vector::operator []	/usr/include/opencv2/core/operations.hpp	/^    const _Tp& operator [] (size_t i) const { CV_DbgAssert( i < size() ); return hdr.data[i]; }$/;"	f	class:cv::Vector	access:public	signature:(size_t i) const
cv::Vector::pop_back	/usr/include/opencv2/core/operations.hpp	/^    Vector<_Tp>& pop_back()$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::push_back	/usr/include/opencv2/core/operations.hpp	/^    Vector<_Tp>& push_back(const _Tp& elem)$/;"	f	class:cv::Vector	access:public	signature:(const _Tp& elem)
cv::Vector::reference	/usr/include/opencv2/core/operations.hpp	/^    typedef _Tp& reference;$/;"	t	class:cv::Vector	access:public
cv::Vector::release	/usr/include/opencv2/core/operations.hpp	/^    void release()$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::reserve	/usr/include/opencv2/core/operations.hpp	/^    void reserve(size_t newCapacity)$/;"	f	class:cv::Vector	access:public	signature:(size_t newCapacity)
cv::Vector::resize	/usr/include/opencv2/core/operations.hpp	/^    void resize(size_t newSize)$/;"	f	class:cv::Vector	access:public	signature:(size_t newSize)
cv::Vector::set	/usr/include/opencv2/core/operations.hpp	/^    void set(_Tp* _data, size_t _size, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(_Tp* _data, size_t _size, bool _copyData=false)
cv::Vector::size	/usr/include/opencv2/core/operations.hpp	/^    size_t size() const { return hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::type	/usr/include/opencv2/core/operations.hpp	/^    int type() const { return DataType<_Tp>::type; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::value_type	/usr/include/opencv2/core/operations.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Vector	access:public
cv::Vector::~Vector	/usr/include/opencv2/core/operations.hpp	/^    ~Vector()  { release(); }$/;"	f	class:cv::Vector	access:public	signature:()
cv::VectorDescriptorMatch	/usr/include/opencv2/features2d/features2d.hpp	/^typedef VectorDescriptorMatcher VectorDescriptorMatch;$/;"	t	namespace:cv
cv::VectorDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^class CV_EXPORTS VectorDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
cv::VectorDescriptorMatcher::VectorDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    VectorDescriptorMatcher( const Ptr<DescriptorExtractor>& extractor, const Ptr<DescriptorMatcher>& matcher );$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const Ptr<DescriptorExtractor>& extractor, const Ptr<DescriptorMatcher>& matcher )
cv::VectorDescriptorMatcher::add	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& imgCollection,$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const vector<Mat>& imgCollection, vector<vector<KeyPoint> >& pointCollection )
cv::VectorDescriptorMatcher::clear	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
cv::VectorDescriptorMatcher::clone	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::VectorDescriptorMatcher::extractor	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> extractor;$/;"	m	class:cv::VectorDescriptorMatcher	access:protected
cv::VectorDescriptorMatcher::isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
cv::VectorDescriptorMatcher::knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::VectorDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::VectorDescriptorMatcher::matcher	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<DescriptorMatcher> matcher;$/;"	m	class:cv::VectorDescriptorMatcher	access:protected
cv::VectorDescriptorMatcher::radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::VectorDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::VectorDescriptorMatcher::read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const FileNode& fn )
cv::VectorDescriptorMatcher::train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
cv::VectorDescriptorMatcher::write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
cv::VectorDescriptorMatcher::~VectorDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~VectorDescriptorMatcher();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
cv::VideoCapture	/usr/include/opencv2/highgui/highgui.hpp	/^class CV_EXPORTS_W VideoCapture$/;"	c	namespace:cv
cv::VideoCapture::VideoCapture	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP VideoCapture();$/;"	p	class:cv::VideoCapture	access:public	signature:()
cv::VideoCapture::VideoCapture	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP VideoCapture(const string& filename);$/;"	p	class:cv::VideoCapture	access:public	signature:(const string& filename)
cv::VideoCapture::VideoCapture	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP VideoCapture(int device);$/;"	p	class:cv::VideoCapture	access:public	signature:(int device)
cv::VideoCapture::cap	/usr/include/opencv2/highgui/highgui.hpp	/^    Ptr<CvCapture> cap;$/;"	m	class:cv::VideoCapture	access:protected
cv::VideoCapture::get	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual double get(int propId);$/;"	p	class:cv::VideoCapture	access:public	signature:(int propId)
cv::VideoCapture::grab	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool grab();$/;"	p	class:cv::VideoCapture	access:public	signature:()
cv::VideoCapture::isOpened	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::VideoCapture	access:public	signature:() const
cv::VideoCapture::open	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool open(const string& filename);$/;"	p	class:cv::VideoCapture	access:public	signature:(const string& filename)
cv::VideoCapture::open	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool open(int device);$/;"	p	class:cv::VideoCapture	access:public	signature:(int device)
cv::VideoCapture::operator >>	/usr/include/opencv2/highgui/highgui.hpp	/^    virtual VideoCapture& operator >> (CV_OUT Mat& image);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image)
cv::VideoCapture::read	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool read(CV_OUT Mat& image);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image)
cv::VideoCapture::release	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual void release();$/;"	p	class:cv::VideoCapture	access:public	signature:()
cv::VideoCapture::retrieve	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool retrieve(CV_OUT Mat& image, int channel=0);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image, int channel=0)
cv::VideoCapture::set	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool set(int propId, double value);$/;"	p	class:cv::VideoCapture	access:public	signature:(int propId, double value)
cv::VideoCapture::~VideoCapture	/usr/include/opencv2/highgui/highgui.hpp	/^    virtual ~VideoCapture();$/;"	p	class:cv::VideoCapture	access:public	signature:()
cv::VideoWriter	/usr/include/opencv2/highgui/highgui.hpp	/^class CV_EXPORTS_W VideoWriter$/;"	c	namespace:cv
cv::VideoWriter::VideoWriter	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP VideoWriter();$/;"	p	class:cv::VideoWriter	access:public	signature:()
cv::VideoWriter::VideoWriter	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP VideoWriter(const string& filename, int fourcc, double fps,$/;"	p	class:cv::VideoWriter	access:public	signature:(const string& filename, int fourcc, double fps, Size frameSize, bool isColor=true)
cv::VideoWriter::isOpened	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::VideoWriter	access:public	signature:() const
cv::VideoWriter::open	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool open(const string& filename, int fourcc, double fps,$/;"	p	class:cv::VideoWriter	access:public	signature:(const string& filename, int fourcc, double fps, Size frameSize, bool isColor=true)
cv::VideoWriter::operator <<	/usr/include/opencv2/highgui/highgui.hpp	/^    virtual VideoWriter& operator << (const Mat& image);$/;"	p	class:cv::VideoWriter	access:public	signature:(const Mat& image)
cv::VideoWriter::write	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual void write(const Mat& image);$/;"	p	class:cv::VideoWriter	access:public	signature:(const Mat& image)
cv::VideoWriter::writer	/usr/include/opencv2/highgui/highgui.hpp	/^    Ptr<CvVideoWriter> writer;$/;"	m	class:cv::VideoWriter	access:protected
cv::VideoWriter::~VideoWriter	/usr/include/opencv2/highgui/highgui.hpp	/^    virtual ~VideoWriter();$/;"	p	class:cv::VideoWriter	access:public	signature:()
cv::WARP_INVERSE_MAP	/usr/include/opencv2/imgproc/imgproc.hpp	/^    WARP_INVERSE_MAP=16$/;"	e	enum:cv::__anon40
cv::WINDOW_AUTOSIZE	/usr/include/opencv2/highgui/highgui.hpp	/^enum { WINDOW_AUTOSIZE=1 };$/;"	e	enum:cv::__anon1
cv::WImage	/usr/include/opencv2/core/wimage.hpp	/^class WImage$/;"	c	namespace:cv
cv::WImage1_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<short, 1>        WImage1_16s;$/;"	t	namespace:cv
cv::WImage1_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<ushort, 1>        WImage1_16u;$/;"	t	namespace:cv
cv::WImage1_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<uchar, 1>        WImage1_b;$/;"	t	namespace:cv
cv::WImage1_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<float, 1>        WImage1_f;$/;"	t	namespace:cv
cv::WImage3_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<short, 3>        WImage3_16s;$/;"	t	namespace:cv
cv::WImage3_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<ushort, 3>        WImage3_16u;$/;"	t	namespace:cv
cv::WImage3_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<uchar, 3>        WImage3_b;$/;"	t	namespace:cv
cv::WImage3_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageC<float, 3>        WImage3_f;$/;"	t	namespace:cv
cv::WImage::BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef T BaseType;$/;"	t	class:cv::WImage	access:public
cv::WImage::ChannelSize	/usr/include/opencv2/core/wimage.hpp	/^    int ChannelSize() const {return sizeof(T); }  \/\/ number of bytes per channel$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::Channels	/usr/include/opencv2/core/wimage.hpp	/^    int Channels() const {return image_->nChannels; }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::CopyFrom	/usr/include/opencv2/core/wimage.hpp	/^    void CopyFrom(const WImage<T>& src) { cvCopy(src.Ipl(), image_); }$/;"	f	class:cv::WImage	access:public	signature:(const WImage<T>& src)
cv::WImage::Depth	/usr/include/opencv2/core/wimage.hpp	/^    int Depth() const;$/;"	p	class:cv::WImage	access:public	signature:() const
cv::WImage::Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<double>::Depth() const {return IPL_DEPTH_64F; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<float>::Depth() const {return IPL_DEPTH_32F; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<int>::Depth() const {return IPL_DEPTH_32S; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<short>::Depth() const {return IPL_DEPTH_16S; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<signed char>::Depth() const {return IPL_DEPTH_8S; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<uchar>::Depth() const {return IPL_DEPTH_8U; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	/usr/include/opencv2/core/wimage.hpp	/^inline int WImage<ushort>::Depth() const {return IPL_DEPTH_16U; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Height	/usr/include/opencv2/core/wimage.hpp	/^    int Height() const {return image_->height; }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::ImageData	/usr/include/opencv2/core/wimage.hpp	/^    T* ImageData() { return reinterpret_cast<T*>(image_->imageData); }$/;"	f	class:cv::WImage	access:public	signature:()
cv::WImage::ImageData	/usr/include/opencv2/core/wimage.hpp	/^    const T* ImageData() const {$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::Ipl	/usr/include/opencv2/core/wimage.hpp	/^    IplImage* Ipl() {return image_; }$/;"	f	class:cv::WImage	access:public	signature:()
cv::WImage::Ipl	/usr/include/opencv2/core/wimage.hpp	/^    const IplImage* Ipl() const {return image_; }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::PixelSize	/usr/include/opencv2/core/wimage.hpp	/^    int PixelSize() const {return Channels() * ChannelSize(); }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::Row	/usr/include/opencv2/core/wimage.hpp	/^    inline T* Row(int r) {$/;"	f	class:cv::WImage	access:public	signature:(int r)
cv::WImage::Row	/usr/include/opencv2/core/wimage.hpp	/^    inline const T* Row(int r) const {$/;"	f	class:cv::WImage	access:public	signature:(int r) const
cv::WImage::SetIpl	/usr/include/opencv2/core/wimage.hpp	/^    void SetIpl(IplImage* image) {$/;"	f	class:cv::WImage	access:protected	signature:(IplImage* image)
cv::WImage::SetZero	/usr/include/opencv2/core/wimage.hpp	/^    void SetZero() { cvSetZero(image_); }$/;"	f	class:cv::WImage	access:public	signature:()
cv::WImage::View	/usr/include/opencv2/core/wimage.hpp	/^    WImageView<T> View(int c, int r, int width, int height);$/;"	p	class:cv::WImage	access:public	signature:(int c, int r, int width, int height)
cv::WImage::View	/usr/include/opencv2/core/wimage.hpp	/^WImageView<T> WImage<T>::View(int c, int r, int width, int height) {$/;"	f	class:cv::WImage	signature:(int c, int r, int width, int height)
cv::WImage::WImage	/usr/include/opencv2/core/wimage.hpp	/^    WImage(const WImage&);$/;"	p	class:cv::WImage	access:protected	signature:(const WImage&)
cv::WImage::WImage	/usr/include/opencv2/core/wimage.hpp	/^    explicit WImage(IplImage* img) : image_(img) {$/;"	f	class:cv::WImage	access:protected	signature:(IplImage* img)
cv::WImage::Width	/usr/include/opencv2/core/wimage.hpp	/^    int Width() const {return image_->width; }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::WidthStep	/usr/include/opencv2/core/wimage.hpp	/^    int WidthStep() const {return image_->widthStep; }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::image_	/usr/include/opencv2/core/wimage.hpp	/^    IplImage* image_;$/;"	m	class:cv::WImage	access:protected
cv::WImage::operator ()	/usr/include/opencv2/core/wimage.hpp	/^    inline T* operator() (int c, int r)  {$/;"	f	class:cv::WImage	access:public	signature:(int c, int r)
cv::WImage::operator ()	/usr/include/opencv2/core/wimage.hpp	/^    inline const T* operator() (int c, int r) const  {$/;"	f	class:cv::WImage	access:public	signature:(int c, int r) const
cv::WImage::operator =	/usr/include/opencv2/core/wimage.hpp	/^    void operator=(const WImage&);$/;"	p	class:cv::WImage	access:protected	signature:(const WImage&)
cv::WImage::~WImage	/usr/include/opencv2/core/wimage.hpp	/^    virtual ~WImage() = 0;$/;"	p	class:cv::WImage	access:public	signature:()
cv::WImage::~WImage	/usr/include/opencv2/core/wimage.hpp	/^template<typename T> inline WImage<T>::~WImage() {}$/;"	f	class:cv::WImage	signature:()
cv::WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^class WImageBuffer : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
cv::WImageBuffer1_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<short, 1>  WImageBuffer1_16s;$/;"	t	namespace:cv
cv::WImageBuffer1_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<ushort, 1>  WImageBuffer1_16u;$/;"	t	namespace:cv
cv::WImageBuffer1_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<uchar, 1>  WImageBuffer1_b;$/;"	t	namespace:cv
cv::WImageBuffer1_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<float, 1>  WImageBuffer1_f;$/;"	t	namespace:cv
cv::WImageBuffer3_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<short, 3>  WImageBuffer3_16s;$/;"	t	namespace:cv
cv::WImageBuffer3_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<ushort, 3>  WImageBuffer3_16u;$/;"	t	namespace:cv
cv::WImageBuffer3_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<uchar, 3>  WImageBuffer3_b;$/;"	t	namespace:cv
cv::WImageBuffer3_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBufferC<float, 3>  WImageBuffer3_f;$/;"	t	namespace:cv
cv::WImageBuffer::Allocate	/usr/include/opencv2/core/wimage.hpp	/^    void Allocate(int width, int height, int nchannels);$/;"	p	class:cv::WImageBuffer	access:public	signature:(int width, int height, int nchannels)
cv::WImageBuffer::Allocate	/usr/include/opencv2/core/wimage.hpp	/^inline void WImageBuffer<T>::Allocate(int width, int height, int nchannels)$/;"	f	class:cv::WImageBuffer	signature:(int width, int height, int nchannels)
cv::WImageBuffer::BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageBuffer	access:public
cv::WImageBuffer::CloneFrom	/usr/include/opencv2/core/wimage.hpp	/^    void CloneFrom(const WImage<T>& src) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(const WImage<T>& src)
cv::WImageBuffer::IsNull	/usr/include/opencv2/core/wimage.hpp	/^    bool IsNull() const {return WImage<T>::image_ == NULL; }$/;"	f	class:cv::WImageBuffer	access:public	signature:() const
cv::WImageBuffer::ReleaseImage	/usr/include/opencv2/core/wimage.hpp	/^    void ReleaseImage() {$/;"	f	class:cv::WImageBuffer	access:public	signature:()
cv::WImageBuffer::SetIpl	/usr/include/opencv2/core/wimage.hpp	/^    void SetIpl(IplImage* img) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(IplImage* img)
cv::WImageBuffer::WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^    WImageBuffer() : WImage<T>(0) {}$/;"	f	class:cv::WImageBuffer	access:public	signature:()
cv::WImageBuffer::WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^    WImageBuffer(const WImageBuffer&);$/;"	p	class:cv::WImageBuffer	access:private	signature:(const WImageBuffer&)
cv::WImageBuffer::WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^    WImageBuffer(int width, int height, int nchannels) : WImage<T>(0) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(int width, int height, int nchannels)
cv::WImageBuffer::WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^    explicit WImageBuffer(IplImage* img) : WImage<T>(img) {}$/;"	f	class:cv::WImageBuffer	access:public	signature:(IplImage* img)
cv::WImageBuffer::operator =	/usr/include/opencv2/core/wimage.hpp	/^    void operator=(const WImageBuffer&);$/;"	p	class:cv::WImageBuffer	access:private	signature:(const WImageBuffer&)
cv::WImageBuffer::~WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^    ~WImageBuffer() {$/;"	f	class:cv::WImageBuffer	access:public	signature:()
cv::WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^class WImageBufferC : public WImageC<T, C>$/;"	c	namespace:cv	inherits:WImageC
cv::WImageBufferC::Allocate	/usr/include/opencv2/core/wimage.hpp	/^    void Allocate(int width, int height);$/;"	p	class:cv::WImageBufferC	access:public	signature:(int width, int height)
cv::WImageBufferC::Allocate	/usr/include/opencv2/core/wimage.hpp	/^inline void WImageBufferC<T, C>::Allocate(int width, int height)$/;"	f	class:cv::WImageBufferC	signature:(int width, int height)
cv::WImageBufferC::BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageBufferC	access:public
cv::WImageBufferC::CloneFrom	/usr/include/opencv2/core/wimage.hpp	/^    void CloneFrom(const WImageC<T, C>& src) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(const WImageC<T, C>& src)
cv::WImageBufferC::IsNull	/usr/include/opencv2/core/wimage.hpp	/^    bool IsNull() const {return WImage<T>::image_ == NULL; }$/;"	f	class:cv::WImageBufferC	access:public	signature:() const
cv::WImageBufferC::ReleaseImage	/usr/include/opencv2/core/wimage.hpp	/^    void ReleaseImage() {$/;"	f	class:cv::WImageBufferC	access:public	signature:()
cv::WImageBufferC::SetIpl	/usr/include/opencv2/core/wimage.hpp	/^    void SetIpl(IplImage* img) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(IplImage* img)
cv::WImageBufferC::WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^    WImageBufferC() : WImageC<T, C>(0) {}$/;"	f	class:cv::WImageBufferC	access:public	signature:()
cv::WImageBufferC::WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^    WImageBufferC(const WImageBufferC&);$/;"	p	class:cv::WImageBufferC	access:private	signature:(const WImageBufferC&)
cv::WImageBufferC::WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^    WImageBufferC(int width, int height) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(int width, int height)
cv::WImageBufferC::WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^    explicit WImageBufferC(IplImage* img) : WImageC<T, C>(img) {}$/;"	f	class:cv::WImageBufferC	access:public	signature:(IplImage* img)
cv::WImageBufferC::kChannels	/usr/include/opencv2/core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageBufferC::__anon102
cv::WImageBufferC::operator =	/usr/include/opencv2/core/wimage.hpp	/^    void operator=(const WImageBufferC&);$/;"	p	class:cv::WImageBufferC	access:private	signature:(const WImageBufferC&)
cv::WImageBufferC::~WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^    ~WImageBufferC() {$/;"	f	class:cv::WImageBufferC	access:public	signature:()
cv::WImageBuffer_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBuffer<short>      WImageBuffer_16s;$/;"	t	namespace:cv
cv::WImageBuffer_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBuffer<ushort>      WImageBuffer_16u;$/;"	t	namespace:cv
cv::WImageBuffer_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBuffer<uchar>      WImageBuffer_b;$/;"	t	namespace:cv
cv::WImageBuffer_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageBuffer<float>      WImageBuffer_f;$/;"	t	namespace:cv
cv::WImageC	/usr/include/opencv2/core/wimage.hpp	/^class WImageC : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
cv::WImageC::BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageC	access:public
cv::WImageC::Channels	/usr/include/opencv2/core/wimage.hpp	/^    int Channels() const {return C; }$/;"	f	class:cv::WImageC	access:public	signature:() const
cv::WImageC::CopyFrom	/usr/include/opencv2/core/wimage.hpp	/^    void CopyFrom(const WImageC<T, C>& src) {$/;"	f	class:cv::WImageC	access:public	signature:(const WImageC<T, C>& src)
cv::WImageC::SetIpl	/usr/include/opencv2/core/wimage.hpp	/^    void SetIpl(IplImage* image) {$/;"	f	class:cv::WImageC	access:protected	signature:(IplImage* image)
cv::WImageC::View	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC<T, C> View(int c, int r, int width, int height);$/;"	p	class:cv::WImageC	access:public	signature:(int c, int r, int width, int height)
cv::WImageC::View	/usr/include/opencv2/core/wimage.hpp	/^WImageViewC<T, C> WImageC<T, C>::View(int c, int r, int width, int height) {$/;"	f	class:cv::WImageC	signature:(int c, int r, int width, int height)
cv::WImageC::WImageC	/usr/include/opencv2/core/wimage.hpp	/^    WImageC(const WImageC&);$/;"	p	class:cv::WImageC	access:protected	signature:(const WImageC&)
cv::WImageC::WImageC	/usr/include/opencv2/core/wimage.hpp	/^    explicit WImageC(IplImage* img) : WImage<T>(img) {$/;"	f	class:cv::WImageC	access:public	signature:(IplImage* img)
cv::WImageC::kChannels	/usr/include/opencv2/core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageC::__anon101
cv::WImageC::operator =	/usr/include/opencv2/core/wimage.hpp	/^    void operator=(const WImageC&);$/;"	p	class:cv::WImageC	access:protected	signature:(const WImageC&)
cv::WImageC::~WImageC	/usr/include/opencv2/core/wimage.hpp	/^    virtual ~WImageC() = 0;$/;"	p	class:cv::WImageC	access:public	signature:()
cv::WImageC::~WImageC	/usr/include/opencv2/core/wimage.hpp	/^template<typename T, int C> inline WImageC<T, C>::~WImageC() {}$/;"	f	class:cv::WImageC	signature:()
cv::WImageView	/usr/include/opencv2/core/wimage.hpp	/^class WImageView : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
cv::WImageView1_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<short, 1>    WImageView1_16s;$/;"	t	namespace:cv
cv::WImageView1_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<ushort, 1>    WImageView1_16u;$/;"	t	namespace:cv
cv::WImageView1_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<uchar, 1>    WImageView1_b;$/;"	t	namespace:cv
cv::WImageView1_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<float, 1>    WImageView1_f;$/;"	t	namespace:cv
cv::WImageView3_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<short, 3>    WImageView3_16s;$/;"	t	namespace:cv
cv::WImageView3_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<ushort, 3>    WImageView3_16u;$/;"	t	namespace:cv
cv::WImageView3_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<uchar, 3>    WImageView3_b;$/;"	t	namespace:cv
cv::WImageView3_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageViewC<float, 3>    WImageView3_f;$/;"	t	namespace:cv
cv::WImageView::BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageView	access:public
cv::WImageView::WImageView	/usr/include/opencv2/core/wimage.hpp	/^    WImageView(IplImage* img) : WImage<T>(img) {}$/;"	f	class:cv::WImageView	access:public	signature:(IplImage* img)
cv::WImageView::WImageView	/usr/include/opencv2/core/wimage.hpp	/^    WImageView(T* data, int width, int height, int channels, int width_step = -1);$/;"	p	class:cv::WImageView	access:public	signature:(T* data, int width, int height, int channels, int width_step = -1)
cv::WImageView::WImageView	/usr/include/opencv2/core/wimage.hpp	/^    WImageView(WImage<T>* img, int c, int r, int width, int height);$/;"	p	class:cv::WImageView	access:public	signature:(WImage<T>* img, int c, int r, int width, int height)
cv::WImageView::WImageView	/usr/include/opencv2/core/wimage.hpp	/^    WImageView(const WImage<T>& img) : WImage<T>(0) {$/;"	f	class:cv::WImageView	access:public	signature:(const WImage<T>& img)
cv::WImageView::WImageView	/usr/include/opencv2/core/wimage.hpp	/^WImageView<T>::WImageView(T* data, int width, int height, int nchannels, int width_step)$/;"	f	class:cv::WImageView	signature:(T* data, int width, int height, int nchannels, int width_step)
cv::WImageView::WImageView	/usr/include/opencv2/core/wimage.hpp	/^WImageView<T>::WImageView(WImage<T>* img, int c, int r, int width, int height)$/;"	f	class:cv::WImageView	signature:(WImage<T>* img, int c, int r, int width, int height)
cv::WImageView::header_	/usr/include/opencv2/core/wimage.hpp	/^    IplImage header_;$/;"	m	class:cv::WImageView	access:protected
cv::WImageView::operator =	/usr/include/opencv2/core/wimage.hpp	/^    WImageView& operator=(const WImage<T>& img) {$/;"	f	class:cv::WImageView	access:public	signature:(const WImage<T>& img)
cv::WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^class WImageViewC : public WImageC<T, C>$/;"	c	namespace:cv	inherits:WImageC
cv::WImageViewC::BaseType	/usr/include/opencv2/core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageViewC	access:public
cv::WImageViewC::WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC();$/;"	p	class:cv::WImageViewC	access:public	signature:()
cv::WImageViewC::WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC(IplImage* img) : WImageC<T, C>(img) {}$/;"	f	class:cv::WImageViewC	access:public	signature:(IplImage* img)
cv::WImageViewC::WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC(T* data, int width, int height, int width_step = -1);$/;"	p	class:cv::WImageViewC	access:public	signature:(T* data, int width, int height, int width_step = -1)
cv::WImageViewC::WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC(WImageC<T, C>* img,$/;"	p	class:cv::WImageViewC	access:public	signature:(WImageC<T, C>* img, int c, int r, int width, int height)
cv::WImageViewC::WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC(const WImageC<T, C>& img) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageC<T, C>& img)
cv::WImageViewC::WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC(const WImageViewC<T, C>& img) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageViewC<T, C>& img)
cv::WImageViewC::WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC() : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	signature:()
cv::WImageViewC::WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC(T* data, int width, int height, int width_step)$/;"	f	class:cv::WImageViewC	signature:(T* data, int width, int height, int width_step)
cv::WImageViewC::WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC(WImageC<T, C>* img, int c, int r, int width, int height)$/;"	f	class:cv::WImageViewC	signature:(WImageC<T, C>* img, int c, int r, int width, int height)
cv::WImageViewC::header_	/usr/include/opencv2/core/wimage.hpp	/^    IplImage header_;$/;"	m	class:cv::WImageViewC	access:protected
cv::WImageViewC::kChannels	/usr/include/opencv2/core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageViewC::__anon103
cv::WImageViewC::operator =	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC& operator=(const WImageC<T, C>& img) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageC<T, C>& img)
cv::WImageViewC::operator =	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC& operator=(const WImageViewC<T, C>& img) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageViewC<T, C>& img)
cv::WImageViewC::~WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    virtual ~WImageViewC() {}$/;"	f	class:cv::WImageViewC	access:public	signature:()
cv::WImageView_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageView<short>        WImageView_16s;$/;"	t	namespace:cv
cv::WImageView_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageView<ushort>        WImageView_16u;$/;"	t	namespace:cv
cv::WImageView_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageView<uchar>        WImageView_b;$/;"	t	namespace:cv
cv::WImageView_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImageView<float>        WImageView_f;$/;"	t	namespace:cv
cv::WImage_16s	/usr/include/opencv2/core/wimage.hpp	/^typedef WImage<short>            WImage_16s;$/;"	t	namespace:cv
cv::WImage_16u	/usr/include/opencv2/core/wimage.hpp	/^typedef WImage<ushort>            WImage_16u;$/;"	t	namespace:cv
cv::WImage_b	/usr/include/opencv2/core/wimage.hpp	/^typedef WImage<uchar>            WImage_b;$/;"	t	namespace:cv
cv::WImage_f	/usr/include/opencv2/core/wimage.hpp	/^typedef WImage<float>            WImage_f;$/;"	t	namespace:cv
cv::WString	/usr/include/opencv2/core/core.hpp	/^typedef std::basic_string<wchar_t> WString;$/;"	t	namespace:cv
cv::WriteStructContext	/usr/include/opencv2/core/operations.hpp	/^class CV_EXPORTS WriteStructContext$/;"	c	namespace:cv
cv::WriteStructContext::WriteStructContext	/usr/include/opencv2/core/operations.hpp	/^    WriteStructContext(FileStorage& _fs, const string& name,$/;"	p	class:cv::WriteStructContext	access:public	signature:(FileStorage& _fs, const string& name, int flags, const string& typeName=string())
cv::WriteStructContext::fs	/usr/include/opencv2/core/operations.hpp	/^    FileStorage* fs;$/;"	m	class:cv::WriteStructContext	access:public
cv::WriteStructContext::~WriteStructContext	/usr/include/opencv2/core/operations.hpp	/^    ~WriteStructContext();$/;"	p	class:cv::WriteStructContext	access:public	signature:()
cv::YAPE	/usr/include/opencv2/features2d/features2d.hpp	/^typedef LDetector YAPE;$/;"	t	namespace:cv
cv::abs	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr abs(const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
cv::abs	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr abs(const MatExpr& e);$/;"	p	namespace:cv	signature:(const MatExpr& e)
cv::abs	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr abs(const Mat_<_Tp>& m)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& m)
cv::abs	/usr/include/opencv2/core/operations.hpp	/^double abs(const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a)
cv::absdiff	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void absdiff(const Mat& src1, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst)
cv::absdiff	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void absdiff(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst)
cv::accumulate	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulate( const Mat& src, CV_IN_OUT Mat& dst, const Mat& mask=Mat() );$/;"	p	namespace:cv	signature:( const Mat& src, CV_IN_OUT Mat& dst, const Mat& mask=Mat() )
cv::accumulateProduct	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateProduct( const Mat& src1, const Mat& src2,$/;"	p	namespace:cv	signature:( const Mat& src1, const Mat& src2, CV_IN_OUT Mat& dst, const Mat& mask=Mat() )
cv::accumulateSquare	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateSquare( const Mat& src, CV_IN_OUT Mat& dst, const Mat& mask=Mat() );$/;"	p	namespace:cv	signature:( const Mat& src, CV_IN_OUT Mat& dst, const Mat& mask=Mat() )
cv::accumulateWeighted	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateWeighted( const Mat& src, CV_IN_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_IN_OUT Mat& dst, double alpha, const Mat& mask=Mat() )
cv::adaptiveThreshold	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void adaptiveThreshold( const Mat& src, CV_OUT Mat& dst, double maxValue,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C )
cv::add	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void add(const Mat& src1, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst)
cv::add	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void add(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask CV_WRAP_DEFAULT(Mat()));$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask CV_WRAP_DEFAULT(Mat()))
cv::add	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void add(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
cv::addText	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void addText( const Mat& img, const string& text, Point org, CvFont font);$/;"	p	namespace:cv	signature:( const Mat& img, const string& text, Point org, CvFont font)
cv::addWeighted	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void addWeighted(const Mat& src1, double alpha, const Mat& src2,$/;"	p	namespace:cv	signature:(const Mat& src1, double alpha, const Mat& src2, double beta, double gamma, CV_OUT Mat& dst)
cv::alignPtr	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> static inline _Tp* alignPtr(_Tp* ptr, int n=(int)sizeof(_Tp))$/;"	f	namespace:cv	signature:(_Tp* ptr, int n=(int)sizeof(_Tp))
cv::alignSize	/usr/include/opencv2/core/core.hpp	/^static inline size_t alignSize(size_t sz, int n)$/;"	f	namespace:cv	signature:(size_t sz, int n)
cv::allocate	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> static inline _Tp* allocate(size_t n)$/;"	f	namespace:cv	signature:(size_t n)
cv::approxPolyDP	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void approxPolyDP( const Mat& curve,$/;"	p	namespace:cv	signature:( const Mat& curve, CV_OUT vector<Point2f>& approxCurve, double epsilon, bool closed )
cv::approxPolyDP	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void approxPolyDP( const Mat& curve,$/;"	p	namespace:cv	signature:( const Mat& curve, CV_OUT vector<Point>& approxCurve, double epsilon, bool closed )
cv::arcLength	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double arcLength( const Mat& curve, bool closed );$/;"	p	namespace:cv	signature:( const Mat& curve, bool closed )
cv::bilateralFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void bilateralFilter( const Mat& src, CV_OUT Mat& dst, int d,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int d, double sigmaColor, double sigmaSpace, int borderType=BORDER_DEFAULT )
cv::bitwise_and	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_and(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
cv::bitwise_and	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_and(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
cv::bitwise_not	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_not(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
cv::bitwise_or	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_or(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
cv::bitwise_or	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_or(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
cv::bitwise_xor	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_xor(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
cv::bitwise_xor	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void bitwise_xor(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
cv::blur	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void blur( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT )
cv::borderInterpolate	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W int borderInterpolate( int p, int len, int borderType );$/;"	p	namespace:cv	signature:( int p, int len, int borderType )
cv::boundingRect	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Rect boundingRect( const Mat& points );$/;"	p	namespace:cv	signature:( const Mat& points )
cv::boxFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void boxFilter( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, Size ksize, Point anchor=Point(-1,-1), bool normalize=true, int borderType=BORDER_DEFAULT )
cv::buildPyramid	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void buildPyramid( const Mat& src, CV_OUT vector<Mat>& dst, int maxlevel );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT vector<Mat>& dst, int maxlevel )
cv::calcBackProject	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void calcBackProject( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, const Mat& hist, Mat& backProject, const float** ranges, double scale=1, bool uniform=true )
cv::calcBackProject	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void calcBackProject( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, const SparseMat& hist, Mat& backProject, const float** ranges, double scale=1, bool uniform=true )
cv::calcCovarMatrix	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void calcCovarMatrix( const Mat* samples, int nsamples, Mat& covar, Mat& mean,$/;"	p	namespace:cv	signature:( const Mat* samples, int nsamples, Mat& covar, Mat& mean, int flags, int ctype=CV_64F)
cv::calcCovarMatrix	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void calcCovarMatrix( const Mat& samples, CV_OUT Mat& covar, CV_OUT Mat& mean,$/;"	p	namespace:cv	signature:( const Mat& samples, CV_OUT Mat& covar, CV_OUT Mat& mean, int flags, int ctype=CV_64F)
cv::calcGlobalOrientation	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W double calcGlobalOrientation( const Mat& orientation, const Mat& mask,$/;"	p	namespace:cv	signature:( const Mat& orientation, const Mat& mask, const Mat& mhi, double timestamp, double duration )
cv::calcHist	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void calcHist( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, const Mat& mask, Mat& hist, int dims, const int* histSize, const float** ranges, bool uniform=true, bool accumulate=false )
cv::calcHist	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void calcHist( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, const Mat& mask, SparseMat& hist, int dims, const int* histSize, const float** ranges, bool uniform=true, bool accumulate=false )
cv::calcMotionGradient	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W void calcMotionGradient( const Mat& mhi, CV_OUT Mat& mask,$/;"	p	namespace:cv	signature:( const Mat& mhi, CV_OUT Mat& mask, CV_OUT Mat& orientation, double delta1, double delta2, int apertureSize=3 )
cv::calcOpticalFlowFarneback	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W void calcOpticalFlowFarneback( const Mat& prev, const Mat& next,$/;"	p	namespace:cv	signature:( const Mat& prev, const Mat& next, CV_OUT Mat& flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags )
cv::calcOpticalFlowPyrLK	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W void calcOpticalFlowPyrLK( const Mat& prevImg, const Mat& nextImg,$/;"	p	namespace:cv	signature:( const Mat& prevImg, const Mat& nextImg, const vector<Point2f>& prevPts, CV_OUT vector<Point2f>& nextPts, CV_OUT vector<uchar>& status, CV_OUT vector<float>& err, Size winSize=Size(15,15), int maxLevel=3, TermCriteria criteria=TermCriteria( TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), double derivLambda=0.5, int flags=0 )
cv::calibrateCamera	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W double calibrateCamera( const vector<vector<Point3f> >& objectPoints,$/;"	p	namespace:cv	signature:( const vector<vector<Point3f> >& objectPoints, const vector<vector<Point2f> >& imagePoints, Size imageSize, CV_IN_OUT Mat& cameraMatrix, CV_IN_OUT Mat& distCoeffs, CV_OUT vector<Mat>& rvecs, CV_OUT vector<Mat>& tvecs, int flags=0 )
cv::calibrationMatrixValues	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void calibrationMatrixValues( const Mat& cameraMatrix,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, CV_OUT double& fovx, CV_OUT double& fovy, CV_OUT double& focalLength, CV_OUT Point2d& principalPoint, CV_OUT double& aspectRatio )
cv::cartToPolar	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void cartToPolar(const Mat& x, const Mat& y,$/;"	p	namespace:cv	signature:(const Mat& x, const Mat& y, CV_OUT Mat& magnitude, CV_OUT Mat& angle, bool angleInDegrees=false)
cv::chamerMatching	/usr/include/opencv2/contrib/contrib.hpp	/^    CV_EXPORTS int chamerMatching( Mat& img, Mat& templ,$/;"	p	namespace:cv	signature:( Mat& img, Mat& templ, vector<vector<Point> >& results, vector<float>& cost, double templScale=1, int maxMatches = 20, double minMatchDistance = 1.0, int padX = 3, int padY = 3, int scales = 5, double minScale = 0.6, double maxScale = 1.6, double orientationWeight = 0.5, double truncate = 20)
cv::checkHardwareSupport	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W bool checkHardwareSupport(int feature);$/;"	p	namespace:cv	signature:(int feature)
cv::checkRange	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W bool checkRange(const Mat& a, bool quiet=true, CV_OUT Point* pt=0,$/;"	p	namespace:cv	signature:(const Mat& a, bool quiet=true, CV_OUT Point* pt=0, double minVal=-DBL_MAX, double maxVal=DBL_MAX)
cv::circle	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void circle(Mat& img, Point center, int radius,$/;"	p	namespace:cv	signature:(Mat& img, Point center, int radius, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
cv::clearSeq	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  clearSeq( CvSeq* seq );$/;"	p	namespace:cv	signature:( CvSeq* seq )
cv::clipLine	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS bool clipLine(Size imgSize, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2);$/;"	p	namespace:cv	signature:(Size imgSize, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2)
cv::clipLine	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W bool clipLine(Rect imgRect, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2);$/;"	p	namespace:cv	signature:(Rect imgRect, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2)
cv::compare	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void compare(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, int cmpop);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, int cmpop)
cv::compare	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void compare(const Mat& src1, double s, CV_OUT Mat& dst, int cmpop);$/;"	p	namespace:cv	signature:(const Mat& src1, double s, CV_OUT Mat& dst, int cmpop)
cv::compareHist	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS double compareHist( const SparseMat& H1, const SparseMat& H2, int method );$/;"	p	namespace:cv	signature:( const SparseMat& H1, const SparseMat& H2, int method )
cv::compareHist	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double compareHist( const Mat& H1, const Mat& H2, int method );$/;"	p	namespace:cv	signature:( const Mat& H1, const Mat& H2, int method )
cv::completeSymm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void completeSymm(Mat& mtx, bool lowerToUpper=false);$/;"	p	namespace:cv	signature:(Mat& mtx, bool lowerToUpper=false)
cv::composeRT	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_AS(composeRT_J) void composeRT( const Mat& rvec1, const Mat& tvec1,$/;"	p	namespace:cv	signature:( const Mat& rvec1, const Mat& tvec1, const Mat& rvec2, const Mat& tvec2, CV_OUT Mat& rvec3, CV_OUT Mat& tvec3, CV_OUT Mat& dr3dr1, CV_OUT Mat& dr3dt1, CV_OUT Mat& dr3dr2, CV_OUT Mat& dr3dt2, CV_OUT Mat& dt3dr1, CV_OUT Mat& dt3dt1, CV_OUT Mat& dt3dr2, CV_OUT Mat& dt3dt2 )
cv::composeRT	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void composeRT( const Mat& rvec1, const Mat& tvec1,$/;"	p	namespace:cv	signature:( const Mat& rvec1, const Mat& tvec1, const Mat& rvec2, const Mat& tvec2, CV_OUT Mat& rvec3, CV_OUT Mat& tvec3 )
cv::computeCorrespondEpilines	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void computeCorrespondEpilines( const Mat& points1,$/;"	p	namespace:cv	signature:( const Mat& points1, int whichImage, const Mat& F, CV_OUT vector<Vec3f>& lines )
cv::computeRecallPrecisionCurve	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void computeRecallPrecisionCurve( const vector<vector<DMatch> >& matches1to2,$/;"	p	namespace:cv	signature:( const vector<vector<DMatch> >& matches1to2, const vector<vector<uchar> >& correctMatches1to2Mask, vector<Point2f>& recallPrecisionCurve )
cv::contourArea	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double contourArea( const Mat& contour, bool oriented=false );$/;"	p	namespace:cv	signature:( const Mat& contour, bool oriented=false )
cv::convertMaps	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void convertMaps( const Mat& map1, const Mat& map2,$/;"	p	namespace:cv	signature:( const Mat& map1, const Mat& map2, CV_OUT Mat& dstmap1, CV_OUT Mat& dstmap2, int dstmap1type, bool nninterpolation=false )
cv::convertPointsHomogeneous	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void convertPointsHomogeneous( const Mat& src, CV_OUT vector<Point2f>& dst );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT vector<Point2f>& dst )
cv::convertPointsHomogeneous	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void convertPointsHomogeneous( const Mat& src, CV_OUT vector<Point3f>& dst );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT vector<Point3f>& dst )
cv::convertScaleAbs	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void convertScaleAbs(const Mat& src, CV_OUT Mat& dst, double alpha=1, double beta=0);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, double alpha=1, double beta=0)
cv::convexHull	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void convexHull( const Mat& points, CV_OUT vector<Point2f>& hull, bool clockwise=false );$/;"	p	namespace:cv	signature:( const Mat& points, CV_OUT vector<Point2f>& hull, bool clockwise=false )
cv::convexHull	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void convexHull( const Mat& points, CV_OUT vector<Point>& hull, bool clockwise=false );$/;"	p	namespace:cv	signature:( const Mat& points, CV_OUT vector<Point>& hull, bool clockwise=false )
cv::convexHull	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void convexHull( const Mat& points, CV_OUT vector<int>& hull, bool clockwise=false );$/;"	p	namespace:cv	signature:( const Mat& points, CV_OUT vector<int>& hull, bool clockwise=false )
cv::copyMakeBorder	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void copyMakeBorder( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int top, int bottom, int left, int right, int borderType, const Scalar& value=Scalar() )
cv::cornerEigenValsAndVecs	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerEigenValsAndVecs( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int blockSize, int ksize, int borderType=BORDER_DEFAULT )
cv::cornerHarris	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerHarris( const Mat& src, CV_OUT Mat& dst, int blockSize,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int blockSize, int ksize, double k, int borderType=BORDER_DEFAULT )
cv::cornerMinEigenVal	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerMinEigenVal( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int blockSize, int ksize=3, int borderType=BORDER_DEFAULT )
cv::cornerSubPix	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void cornerSubPix( const Mat& image, vector<Point2f>& corners,$/;"	p	namespace:cv	signature:( const Mat& image, vector<Point2f>& corners, Size winSize, Size zeroZone, TermCriteria criteria )
cv::countNonZero	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W int countNonZero( const Mat& src );$/;"	p	namespace:cv	signature:( const Mat& src )
cv::createBoxFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createBoxFilter( int srcType, int dstType, Size ksize,$/;"	p	namespace:cv	signature:( int srcType, int dstType, Size ksize, Point anchor=Point(-1,-1), bool normalize=true, int borderType=BORDER_DEFAULT)
cv::createButton	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS int createButton( const string& bar_name, ButtonCallback on_change , void* userdata CV_DEFAULT(NULL), int type CV_DEFAULT(CV_PUSH_BUTTON), bool initial_button_state CV_DEFAULT(0));$/;"	p	namespace:cv	signature:( const string& bar_name, ButtonCallback on_change , void* userdata CV_DEFAULT(NULL), int type CV_DEFAULT(CV_PUSH_BUTTON), bool initial_button_state CV_DEFAULT(0))
cv::createDerivFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createDerivFilter( int srcType, int dstType,$/;"	p	namespace:cv	signature:( int srcType, int dstType, int dx, int dy, int ksize, int borderType=BORDER_DEFAULT )
cv::createGaussianFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createGaussianFilter( int type, Size ksize,$/;"	p	namespace:cv	signature:( int type, Size ksize, double sigma1, double sigma2=0, int borderType=BORDER_DEFAULT)
cv::createLinearFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, const Mat& kernel, Point _anchor=Point(-1,-1), double delta=0, int _rowBorderType=BORDER_DEFAULT, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
cv::createMorphologyFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createMorphologyFilter(int op, int type, const Mat& kernel,$/;"	p	namespace:cv	signature:(int op, int type, const Mat& kernel, Point anchor=Point(-1,-1), int _rowBorderType=BORDER_CONSTANT, int _columnBorderType=-1, const Scalar& _borderValue=morphologyDefaultBorderValue())
cv::createOpenGLCallback	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void createOpenGLCallback(const string& winname, CvOpenGLCallback callbackOpenGL, void* userdata CV_DEFAULT(0));$/;"	p	namespace:cv	signature:(const string& winname, CvOpenGLCallback callbackOpenGL, void* userdata CV_DEFAULT(0))
cv::createSeparableLinearFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createSeparableLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, const Mat& rowKernel, const Mat& columnKernel, Point _anchor=Point(-1,-1), double delta=0, int _rowBorderType=BORDER_DEFAULT, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
cv::createTrackbar	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS int createTrackbar( const string& trackbarname, const string& winname,$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname, int* value, int count, TrackbarCallback onChange CV_DEFAULT(0), void* userdata CV_DEFAULT(0))
cv::cubeRoot	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W float cubeRoot(float val);$/;"	p	namespace:cv	signature:(float val)
cv::cv2eigen	/usr/include/opencv2/core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, 1, Eigen::Dynamic>& dst )
cv::cv2eigen	/usr/include/opencv2/core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, Eigen::Dynamic, 1>& dst )
cv::cv2eigen	/usr/include/opencv2/core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, Eigen::Dynamic, Eigen::Dynamic>& dst )
cv::cv2eigen	/usr/include/opencv2/core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& dst )
cv::cvarrToMat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS Mat cvarrToMat(const CvArr* arr, bool copyData=false,$/;"	p	namespace:cv	signature:(const CvArr* arr, bool copyData=false, bool allowND=true, int coiMode=0)
cv::cvarrToMatND	/usr/include/opencv2/core/mat.hpp	/^static inline Mat cvarrToMatND(const CvArr* arr, bool copyData=false, int coiMode=0)$/;"	f	namespace:cv	signature:(const CvArr* arr, bool copyData=false, int coiMode=0)
cv::cvtColor	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void cvtColor( const Mat& src, CV_OUT Mat& dst, int code, int dstCn=0 );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int code, int dstCn=0 )
cv::dct	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void dct(const Mat& src, CV_OUT Mat& dst, int flags=0);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags=0)
cv::deallocate	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> static inline void deallocate(_Tp* ptr, size_t)$/;"	f	namespace:cv	signature:(_Tp* ptr, size_t)
cv::decomposeProjectionMatrix	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void decomposeProjectionMatrix( const Mat& projMatrix, Mat& cameraMatrix,$/;"	p	namespace:cv	signature:( const Mat& projMatrix, Mat& cameraMatrix, Mat& rotMatrix, Mat& transVect )
cv::decomposeProjectionMatrix	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void decomposeProjectionMatrix( const Mat& projMatrix, CV_OUT Mat& cameraMatrix,$/;"	p	namespace:cv	signature:( const Mat& projMatrix, CV_OUT Mat& cameraMatrix, CV_OUT Mat& rotMatrix, CV_OUT Mat& transVect, CV_OUT Mat& rotMatrixX, CV_OUT Mat& rotMatrixY, CV_OUT Mat& rotMatrixZ, CV_OUT Vec3d& eulerAngles )
cv::destroyWindow	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W void destroyWindow( const string& winname );$/;"	p	namespace:cv	signature:( const string& winname )
cv::determinant	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double determinant(const Mat& mtx);$/;"	p	namespace:cv	signature:(const Mat& mtx)
cv::determinant	/usr/include/opencv2/core/operations.hpp	/^double determinant(const Matx<_Tp, m, m>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, m>& a)
cv::dft	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void dft(const Mat& src, CV_OUT Mat& dst, int flags=0, int nonzeroRows=0);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags=0, int nonzeroRows=0)
cv::dilate	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void dilate( const Mat& src, CV_OUT Mat& dst, const Mat& kernel,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
cv::displayOverlay	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void displayOverlay(const string& winname, const string& text, int delayms);$/;"	p	namespace:cv	signature:(const string& winname, const string& text, int delayms)
cv::displayStatusBar	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void displayStatusBar(const string& winname, const string& text, int delayms);$/;"	p	namespace:cv	signature:(const string& winname, const string& text, int delayms)
cv::distanceTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^    void distanceTransform( const Mat& src, CV_OUT Mat& dst, Mat& labels,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, Mat& labels, int distanceType, int maskSize )
cv::distanceTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void distanceTransform( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int distanceType, int maskSize )
cv::divide	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void divide(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, double scale=1);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, double scale=1)
cv::divide	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void divide(double scale, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(double scale, const Mat& src2, CV_OUT Mat& dst)
cv::dot	/usr/include/opencv2/core/operations.hpp	/^dot(const Vector<_Tp>& v1, const Vector<_Tp>& v2)$/;"	f	namespace:cv	signature:(const Vector<_Tp>& v1, const Vector<_Tp>& v2)
cv::drawChessboardCorners	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void drawChessboardCorners( Mat& image, Size patternSize,$/;"	p	namespace:cv	signature:( Mat& image, Size patternSize, const vector<Point2f>& corners, bool patternWasFound )
cv::drawChessboardCorners	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void drawChessboardCorners( Mat& image, Size patternSize,$/;"	p	namespace:cv	signature:( Mat& image, Size patternSize, const Mat& corners, bool patternWasFound )
cv::drawContours	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void drawContours( Mat& image, const vector<vector<Point> >& contours,$/;"	p	namespace:cv	signature:( Mat& image, const vector<vector<Point> >& contours, int contourIdx, const Scalar& color, int thickness=1, int lineType=8, const vector<Vec4i>& hierarchy=vector<Vec4i>(), int maxLevel=INT_MAX, Point offset=Point() )
cv::drawKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void drawKeypoints( const Mat& image, const vector<KeyPoint>& keypoints, Mat& outImg,$/;"	p	namespace:cv	signature:( const Mat& image, const vector<KeyPoint>& keypoints, Mat& outImg, const Scalar& color=Scalar::all(-1), int flags=DrawMatchesFlags::DEFAULT )
cv::drawMatches	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void drawMatches( const Mat& img1, const vector<KeyPoint>& keypoints1,$/;"	p	namespace:cv	signature:( const Mat& img1, const vector<KeyPoint>& keypoints1, const Mat& img2, const vector<KeyPoint>& keypoints2, const vector<DMatch>& matches1to2, Mat& outImg, const Scalar& matchColor=Scalar::all(-1), const Scalar& singlePointColor=Scalar::all(-1), const vector<char>& matchesMask=vector<char>(), int flags=DrawMatchesFlags::DEFAULT )
cv::drawMatches	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void drawMatches( const Mat& img1, const vector<KeyPoint>& keypoints1,$/;"	p	namespace:cv	signature:( const Mat& img1, const vector<KeyPoint>& keypoints1, const Mat& img2, const vector<KeyPoint>& keypoints2, const vector<vector<DMatch> >& matches1to2, Mat& outImg, const Scalar& matchColor=Scalar::all(-1), const Scalar& singlePointColor=Scalar::all(-1), const vector<vector<char> >& matchesMask=vector<vector<char> >(), int flags=DrawMatchesFlags::DEFAULT )
cv::eigen	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS bool eigen(const Mat& src, CV_OUT Mat& eigenvalues, CV_OUT Mat& eigenvectors,$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& eigenvalues, CV_OUT Mat& eigenvectors, int lowindex=-1, int highindex=-1)
cv::eigen	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS bool eigen(const Mat& src, CV_OUT Mat& eigenvalues, int lowindex=-1,$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& eigenvalues, int lowindex=-1, int highindex=-1)
cv::eigen2cv	/usr/include/opencv2/core/eigen.hpp	/^void eigen2cv( const Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& src, Mat& dst )$/;"	f	namespace:cv	signature:( const Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& src, Mat& dst )
cv::ellipse	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void ellipse(Mat& img, Point center, Size axes,$/;"	p	namespace:cv	signature:(Mat& img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
cv::ellipse	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void ellipse(Mat& img, const RotatedRect& box, const Scalar& color,$/;"	p	namespace:cv	signature:(Mat& img, const RotatedRect& box, const Scalar& color, int thickness=1, int lineType=8)
cv::ellipse2Poly	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void ellipse2Poly( Point center, Size axes, int angle,$/;"	p	namespace:cv	signature:( Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, CV_OUT vector<Point>& pts )
cv::equalizeHist	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void equalizeHist( const Mat& src, CV_OUT Mat& dst );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst )
cv::erode	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void erode( const Mat& src, CV_OUT Mat& dst, const Mat& kernel,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
cv::error	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void error( const Exception& exc );$/;"	p	namespace:cv	signature:( const Exception& exc )
cv::estimateAffine3D	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS int estimateAffine3D(const Mat& from, const Mat& to, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:(const Mat& from, const Mat& to, CV_OUT Mat& dst, CV_OUT vector<uchar>& outliers, double param1 = 3.0, double param2 = 0.99)
cv::estimateRigidTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat estimateRigidTransform( const Mat& A, const Mat& B,$/;"	p	namespace:cv	signature:( const Mat& A, const Mat& B, bool fullAffine )
cv::evaluateFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void evaluateFeatureDetector( const Mat& img1, const Mat& img2, const Mat& H1to2,$/;"	p	namespace:cv	signature:( const Mat& img1, const Mat& img2, const Mat& H1to2, vector<KeyPoint>* keypoints1, vector<KeyPoint>* keypoints2, float& repeatability, int& correspCount, const Ptr<FeatureDetector>& fdetector=Ptr<FeatureDetector>() )
cv::evaluateGenericDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void evaluateGenericDescriptorMatcher( const Mat& img1, const Mat& img2, const Mat& H1to2,$/;"	p	namespace:cv	signature:( const Mat& img1, const Mat& img2, const Mat& H1to2, vector<KeyPoint>& keypoints1, vector<KeyPoint>& keypoints2, vector<vector<DMatch> >* matches1to2, vector<vector<uchar> >* correctMatches1to2Mask, vector<Point2f>& recallPrecisionCurve, const Ptr<GenericDescriptorMatcher>& dmatch=Ptr<GenericDescriptorMatcher>() )
cv::exp	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void exp(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
cv::extractImageCOI	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void extractImageCOI(const CvArr* arr, CV_OUT Mat& coiimg, int coi=-1);$/;"	p	namespace:cv	signature:(const CvArr* arr, CV_OUT Mat& coiimg, int coi=-1)
cv::fastAtan2	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W float fastAtan2(float y, float x);$/;"	p	namespace:cv	signature:(float y, float x)
cv::fastFree	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void fastFree(void* ptr);$/;"	p	namespace:cv	signature:(void* ptr)
cv::fastMalloc	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void* fastMalloc(size_t bufSize);$/;"	p	namespace:cv	signature:(size_t bufSize)
cv::fillConvexPoly	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void fillConvexPoly(Mat& img, const Point* pts, int npts,$/;"	p	namespace:cv	signature:(Mat& img, const Point* pts, int npts, const Scalar& color, int lineType=8, int shift=0)
cv::fillPoly	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void fillPoly(Mat& img, const Point** pts,$/;"	p	namespace:cv	signature:(Mat& img, const Point** pts, const int* npts, int ncontours, const Scalar& color, int lineType=8, int shift=0, Point offset=Point() )
cv::filter2D	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void filter2D( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, const Mat& kernel, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT )
cv::filterSpeckles	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void filterSpeckles( Mat& img, double newVal, int maxSpeckleSize, double maxDiff, Mat& buf );$/;"	p	namespace:cv	signature:( Mat& img, double newVal, int maxSpeckleSize, double maxDiff, Mat& buf )
cv::filterSpeckles	/usr/include/opencv2/gpu/gpu.hpp	/^    CV_EXPORTS void filterSpeckles( Mat& img, uchar newVal, int maxSpeckleSize, uchar diffThreshold, Mat& buf);$/;"	p	namespace:cv	signature:( Mat& img, uchar newVal, int maxSpeckleSize, uchar diffThreshold, Mat& buf)
cv::find4QuadCornerSubpix	/usr/include/opencv2/contrib/contrib.hpp	/^    CV_EXPORTS bool find4QuadCornerSubpix(const Mat& img, std::vector<Point2f>& corners, Size region_size);$/;"	p	namespace:cv	signature:(const Mat& img, std::vector<Point2f>& corners, Size region_size)
cv::findChessboardCorners	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W bool findChessboardCorners( const Mat& image, Size patternSize,$/;"	p	namespace:cv	signature:( const Mat& image, Size patternSize, CV_OUT vector<Point2f>& corners, int flags=CALIB_CB_ADAPTIVE_THRESH+ CALIB_CB_NORMALIZE_IMAGE )
cv::findContours	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void findContours( Mat& image, CV_OUT vector<vector<Point> >& contours,$/;"	p	namespace:cv	signature:( Mat& image, CV_OUT vector<vector<Point> >& contours, int mode, int method, Point offset=Point())
cv::findContours	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void findContours( Mat& image, CV_OUT vector<vector<Point> >& contours,$/;"	p	namespace:cv	signature:( Mat& image, CV_OUT vector<vector<Point> >& contours, vector<Vec4i>& hierarchy, int mode, int method, Point offset=Point())
cv::findFundamentalMat	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS Mat findFundamentalMat( const Mat& points1, const Mat& points2,$/;"	p	namespace:cv	signature:( const Mat& points1, const Mat& points2, CV_OUT vector<uchar>& mask, int method=FM_RANSAC, double param1=3., double param2=0.99 )
cv::findFundamentalMat	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat findFundamentalMat( const Mat& points1, const Mat& points2,$/;"	p	namespace:cv	signature:( const Mat& points1, const Mat& points2, int method=FM_RANSAC, double param1=3., double param2=0.99 )
cv::findHomography	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_AS(findHomographyAndOutliers) Mat findHomography( const Mat& srcPoints,$/;"	p	namespace:cv	signature:( const Mat& srcPoints, const Mat& dstPoints, vector<uchar>& mask, int method=0, double ransacReprojThreshold=3 )
cv::findHomography	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat findHomography( const Mat& srcPoints,$/;"	p	namespace:cv	signature:( const Mat& srcPoints, const Mat& dstPoints, int method=0, double ransacReprojThreshold=3 )
cv::fitEllipse	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W RotatedRect fitEllipse( const Mat& points );$/;"	p	namespace:cv	signature:( const Mat& points )
cv::fitLine	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void fitLine( const Mat& points, CV_OUT Vec4f& line, int distType,$/;"	p	namespace:cv	signature:( const Mat& points, CV_OUT Vec4f& line, int distType, double param, double reps, double aeps )
cv::fitLine	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void fitLine( const Mat& points, CV_OUT Vec6f& line, int distType,$/;"	p	namespace:cv	signature:( const Mat& points, CV_OUT Vec6f& line, int distType, double param, double reps, double aeps )
cv::flann	/usr/include/opencv2/flann/flann.hpp	/^namespace flann$/;"	n	namespace:cv
cv::flann::CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<char> { static int type() { return CV_8S; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<double> { static int type() { return CV_64F; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<float> { static int type() { return CV_32F; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<int> { static int type() { return CV_32S; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<short> { static int type() { return CV_16S; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<unsigned char> { static int type() { return CV_8U; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<unsigned short> { static int type() { return CV_16U; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	/usr/include/opencv2/flann/flann.hpp	/^template <typename T> struct CvType {};$/;"	s	namespace:cv::flann
cv::flann::CvType::type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<char> { static int type() { return CV_8S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<double> { static int type() { return CV_64F; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<float> { static int type() { return CV_32F; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<int> { static int type() { return CV_32S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<short> { static int type() { return CV_16S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<unsigned char> { static int type() { return CV_8U; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<unsigned short> { static int type() { return CV_16U; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::Index	/usr/include/opencv2/flann/flann.hpp	/^typedef Index_<float> Index;$/;"	t	namespace:cv::flann
cv::flann::Index_	/usr/include/opencv2/flann/flann.hpp	/^class CV_EXPORTS Index_ {$/;"	c	namespace:cv::flann
cv::flann::Index_::Index_	/usr/include/opencv2/flann/flann.hpp	/^	Index_(const Mat& features, const IndexParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& features, const IndexParams& params)
cv::flann::Index_::Index_	/usr/include/opencv2/flann/flann.hpp	/^Index_<T>::Index_(const Mat& dataset, const IndexParams& params)$/;"	f	class:cv::flann::Index_	signature:(const Mat& dataset, const IndexParams& params)
cv::flann::Index_::getIndexParameters	/usr/include/opencv2/flann/flann.hpp	/^	const IndexParams* getIndexParameters() { return nnIndex->getParameters(); }$/;"	f	class:cv::flann::Index_	access:public	signature:()
cv::flann::Index_::knnSearch	/usr/include/opencv2/flann/flann.hpp	/^	void knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const SearchParams& params)
cv::flann::Index_::knnSearch	/usr/include/opencv2/flann/flann.hpp	/^	void knnSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const vector<T>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& params)
cv::flann::Index_::knnSearch	/usr/include/opencv2/flann/flann.hpp	/^void Index_<T>::knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const SearchParams& searchParams)
cv::flann::Index_::knnSearch	/usr/include/opencv2/flann/flann.hpp	/^void Index_<T>::knnSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const vector<T>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& searchParams)
cv::flann::Index_::nnIndex	/usr/include/opencv2/flann/flann.hpp	/^	::cvflann::Index<T>* nnIndex;$/;"	m	class:cv::flann::Index_	access:private
cv::flann::Index_::radiusSearch	/usr/include/opencv2/flann/flann.hpp	/^	int radiusSearch(const Mat& query, Mat& indices, Mat& dists, float radius, const SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& query, Mat& indices, Mat& dists, float radius, const SearchParams& params)
cv::flann::Index_::radiusSearch	/usr/include/opencv2/flann/flann.hpp	/^	int radiusSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const vector<T>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& params)
cv::flann::Index_::radiusSearch	/usr/include/opencv2/flann/flann.hpp	/^int Index_<T>::radiusSearch(const Mat& query, Mat& indices, Mat& dists, float radius, const SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const Mat& query, Mat& indices, Mat& dists, float radius, const SearchParams& searchParams)
cv::flann::Index_::radiusSearch	/usr/include/opencv2/flann/flann.hpp	/^int Index_<T>::radiusSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const vector<T>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& searchParams)
cv::flann::Index_::save	/usr/include/opencv2/flann/flann.hpp	/^	void save(std::string filename) { nnIndex->save(filename); }$/;"	f	class:cv::flann::Index_	access:public	signature:(std::string filename)
cv::flann::Index_::size	/usr/include/opencv2/flann/flann.hpp	/^	int size() const { return nnIndex->size(); }$/;"	f	class:cv::flann::Index_	access:public	signature:() const
cv::flann::Index_::veclen	/usr/include/opencv2/flann/flann.hpp	/^	int veclen() const { return nnIndex->veclen(); }$/;"	f	class:cv::flann::Index_	access:public	signature:() const
cv::flann::Index_::~Index_	/usr/include/opencv2/flann/flann.hpp	/^	~Index_();$/;"	p	class:cv::flann::Index_	access:public	signature:()
cv::flann::Index_::~Index_	/usr/include/opencv2/flann/flann.hpp	/^Index_<T>::~Index_()$/;"	f	class:cv::flann::Index_	signature:()
cv::flann::hierarchicalClustering	/usr/include/opencv2/flann/flann.hpp	/^int hierarchicalClustering(const Mat& features, Mat& centers, const KMeansIndexParams& params)$/;"	f	namespace:cv::flann	signature:(const Mat& features, Mat& centers, const KMeansIndexParams& params)
cv::flip	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void flip(const Mat& src, CV_OUT Mat& dst, int flipCode);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flipCode)
cv::floodFill	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(floodFillMask) int floodFill( Mat& image, Mat& mask,$/;"	p	namespace:cv	signature:( Mat& image, Mat& mask, Point seedPoint, Scalar newVal, CV_OUT Rect* rect=0, Scalar loDiff=Scalar(), Scalar upDiff=Scalar(), int flags=4 )
cv::floodFill	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W int floodFill( Mat& image,$/;"	p	namespace:cv	signature:( Mat& image, Point seedPoint, Scalar newVal, CV_OUT Rect* rect=0, Scalar loDiff=Scalar(), Scalar upDiff=Scalar(), int flags=4 )
cv::fontQt	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS CvFont fontQt(const string& nameFont, int pointSize CV_DEFAULT(-1), Scalar color CV_DEFAULT(Scalar::all(0)), int weight CV_DEFAULT(CV_FONT_NORMAL),  int style CV_DEFAULT(CV_STYLE_NORMAL), int spacing CV_DEFAULT(0));$/;"	p	namespace:cv	signature:(const string& nameFont, int pointSize CV_DEFAULT(-1), Scalar color CV_DEFAULT(Scalar::all(0)), int weight CV_DEFAULT(CV_FONT_NORMAL), int style CV_DEFAULT(CV_STYLE_NORMAL), int spacing CV_DEFAULT(0))
cv::format	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS string format( const char* fmt, ... );$/;"	p	namespace:cv	signature:( const char* fmt, ... )
cv::format	/usr/include/opencv2/core/operations.hpp	/^static inline Formatted format(const Mat& mtx, const char* fmt,$/;"	f	namespace:cv	signature:(const Mat& mtx, const char* fmt, const vector<int>& params=vector<int>())
cv::format	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Formatted format(const vector<Point3_<_Tp> >& vec,$/;"	f	namespace:cv	signature:(const vector<Point3_<_Tp> >& vec, const char* fmt, const vector<int>& params=vector<int>())
cv::format	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Formatted format(const vector<Point_<_Tp> >& vec,$/;"	f	namespace:cv	signature:(const vector<Point_<_Tp> >& vec, const char* fmt, const vector<int>& params=vector<int>())
cv::fromUtf16	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS string fromUtf16(const WString& str);$/;"	p	namespace:cv	signature:(const WString& str)
cv::gcd	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp gcd(_Tp a, _Tp b)$/;"	f	namespace:cv	signature:(_Tp a, _Tp b)
cv::gemm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void gemm(const Mat& src1, const Mat& src2, double alpha,$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, double alpha, const Mat& src3, double gamma, CV_OUT Mat& dst, int flags=0)
cv::getAffineTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Mat getAffineTransform( const Point2f src[], const Point2f dst[] );$/;"	p	namespace:cv	signature:( const Point2f src[], const Point2f dst[] )
cv::getCPUTickCount	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS int64 getCPUTickCount();$/;"	p	namespace:cv	signature:()
cv::getColumnSumFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getColumnSumFilter( int sumType, int dstType,$/;"	p	namespace:cv	signature:( int sumType, int dstType, int ksize, int anchor=-1, double scale=1)
cv::getConvertElem	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS ConvertData getConvertElem(int fromType, int toType);$/;"	p	namespace:cv	signature:(int fromType, int toType)
cv::getConvertScaleElem	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS ConvertScaleData getConvertScaleElem(int fromType, int toType);$/;"	p	namespace:cv	signature:(int fromType, int toType)
cv::getData	/usr/include/opencv2/features2d/features2d.hpp	/^inline uchar* getData(IplImage* image)$/;"	f	namespace:cv	signature:(IplImage* image)
cv::getDefaultNewCameraMatrix	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getDefaultNewCameraMatrix( const Mat& cameraMatrix, Size imgsize=Size(),$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix, Size imgsize=Size(), bool centerPrincipalPoint=false )
cv::getDerivKernels	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void getDerivKernels( CV_OUT Mat& kx, CV_OUT Mat& ky,$/;"	p	namespace:cv	signature:( CV_OUT Mat& kx, CV_OUT Mat& ky, int dx, int dy, int ksize, bool normalize=false, int ktype=CV_32F )
cv::getElemSize	/usr/include/opencv2/core/core.hpp	/^static inline size_t getElemSize(int type) { return CV_ELEM_SIZE(type); }$/;"	f	namespace:cv	signature:(int type)
cv::getGaussianKernel	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getGaussianKernel( int ksize, double sigma, int ktype=CV_64F );$/;"	p	namespace:cv	signature:( int ksize, double sigma, int ktype=CV_64F )
cv::getKernelType	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS int getKernelType(const Mat& kernel, Point anchor);$/;"	p	namespace:cv	signature:(const Mat& kernel, Point anchor)
cv::getLinearColumnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getLinearColumnFilter(int bufType, int dstType,$/;"	p	namespace:cv	signature:(int bufType, int dstType, const Mat& kernel, int anchor, int symmetryType, double delta=0, int bits=0)
cv::getLinearFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseFilter> getLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, const Mat& kernel, Point anchor=Point(-1,-1), double delta=0, int bits=0)
cv::getLinearRowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getLinearRowFilter(int srcType, int bufType,$/;"	p	namespace:cv	signature:(int srcType, int bufType, const Mat& kernel, int anchor, int symmetryType)
cv::getMorphologyColumnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getMorphologyColumnFilter(int op, int type, int ksize, int anchor=-1);$/;"	p	namespace:cv	signature:(int op, int type, int ksize, int anchor=-1)
cv::getMorphologyFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseFilter> getMorphologyFilter(int op, int type, const Mat& kernel,$/;"	p	namespace:cv	signature:(int op, int type, const Mat& kernel, Point anchor=Point(-1,-1))
cv::getMorphologyRowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getMorphologyRowFilter(int op, int type, int ksize, int anchor=-1);$/;"	p	namespace:cv	signature:(int op, int type, int ksize, int anchor=-1)
cv::getNumThreads	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS int getNumThreads();$/;"	p	namespace:cv	signature:()
cv::getOptimalDFTSize	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W int getOptimalDFTSize(int vecsize);$/;"	p	namespace:cv	signature:(int vecsize)
cv::getOptimalNewCameraMatrix	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat getOptimalNewCameraMatrix( const Mat& cameraMatrix, const Mat& distCoeffs,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix, const Mat& distCoeffs, Size imageSize, double alpha, Size newImgSize=Size(), CV_OUT Rect* validPixROI=0)
cv::getPerspectiveTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Mat getPerspectiveTransform( const Point2f src[], const Point2f dst[] );$/;"	p	namespace:cv	signature:( const Point2f src[], const Point2f dst[] )
cv::getRecall	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS float getRecall( const vector<Point2f>& recallPrecisionCurve, float l_precision );$/;"	p	namespace:cv	signature:( const vector<Point2f>& recallPrecisionCurve, float l_precision )
cv::getRectSubPix	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void getRectSubPix( const Mat& image, Size patchSize,$/;"	p	namespace:cv	signature:( const Mat& image, Size patchSize, Point2f center, CV_OUT Mat& patch, int patchType=-1 )
cv::getRotationMatrix2D	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getRotationMatrix2D( Point2f center, double angle, double scale );$/;"	p	namespace:cv	signature:( Point2f center, double angle, double scale )
cv::getRowSumFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getRowSumFilter(int srcType, int sumType,$/;"	p	namespace:cv	signature:(int srcType, int sumType, int ksize, int anchor=-1)
cv::getSeqElem	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS schar*  getSeqElem( const CvSeq* seq, int index );$/;"	p	namespace:cv	signature:( const CvSeq* seq, int index )
cv::getStructuringElement	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getStructuringElement(int shape, Size ksize, Point anchor=Point(-1,-1));$/;"	p	namespace:cv	signature:(int shape, Size ksize, Point anchor=Point(-1,-1))
cv::getTextSize	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W Size getTextSize(const string& text, int fontFace,$/;"	p	namespace:cv	signature:(const string& text, int fontFace, double fontScale, int thickness, CV_OUT int* baseLine)
cv::getThreadNum	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS int getThreadNum();$/;"	p	namespace:cv	signature:()
cv::getTickCount	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS int64 getTickCount();$/;"	p	namespace:cv	signature:()
cv::getTickFrequency	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double getTickFrequency();$/;"	p	namespace:cv	signature:()
cv::getTrackbarPos	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W int getTrackbarPos( const string& trackbarname, const string& winname );$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname )
cv::getValidDisparityROI	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Rect getValidDisparityROI( Rect roi1, Rect roi2,$/;"	p	namespace:cv	signature:( Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int SADWindowSize )
cv::getWindowProperty	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W double getWindowProperty(const string& winname, int prop_id);\/\/YV$/;"	p	namespace:cv	signature:(const string& winname, int prop_id)
cv::goodFeaturesToTrack	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void goodFeaturesToTrack( const Mat& image, CV_OUT vector<Point2f>& corners,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT vector<Point2f>& corners, int maxCorners, double qualityLevel, double minDistance, const Mat& mask=Mat(), int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
cv::gpu	/usr/include/opencv2/gpu/devmem2d.hpp	/^    namespace gpu$/;"	n	namespace:cv
cv::gpu	/usr/include/opencv2/gpu/gpu.hpp	/^    namespace gpu$/;"	n	namespace:cv
cv::gpu	/usr/include/opencv2/gpu/matrix_operations.hpp	/^namespace gpu$/;"	n	namespace:cv
cv::gpu	/usr/include/opencv2/gpu/stream_accessor.hpp	/^    namespace gpu$/;"	n	namespace:cv
cv::gpu::BaseColumnFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS BaseColumnFilter_GPU$/;"	c	namespace:cv::gpu
cv::gpu::BaseColumnFilter_GPU::BaseColumnFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            BaseColumnFilter_GPU(int ksize_, int anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:(int ksize_, int anchor_)
cv::gpu::BaseColumnFilter_GPU::anchor	/usr/include/opencv2/gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseColumnFilter_GPU	access:public
cv::gpu::BaseColumnFilter_GPU::ksize	/usr/include/opencv2/gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseColumnFilter_GPU	access:public
cv::gpu::BaseColumnFilter_GPU::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst) = 0;$/;"	p	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst)
cv::gpu::BaseColumnFilter_GPU::~BaseColumnFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual ~BaseColumnFilter_GPU() {}$/;"	f	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:()
cv::gpu::BaseFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS BaseFilter_GPU$/;"	c	namespace:cv::gpu
cv::gpu::BaseFilter_GPU::BaseFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            BaseFilter_GPU(const Size& ksize_, const Point& anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseFilter_GPU	access:public	signature:(const Size& ksize_, const Point& anchor_)
cv::gpu::BaseFilter_GPU::anchor	/usr/include/opencv2/gpu/gpu.hpp	/^            Point anchor;$/;"	m	class:cv::gpu::BaseFilter_GPU	access:public
cv::gpu::BaseFilter_GPU::ksize	/usr/include/opencv2/gpu/gpu.hpp	/^            Size ksize;$/;"	m	class:cv::gpu::BaseFilter_GPU	access:public
cv::gpu::BaseFilter_GPU::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst) = 0;$/;"	p	class:cv::gpu::BaseFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst)
cv::gpu::BaseFilter_GPU::~BaseFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual ~BaseFilter_GPU() {}$/;"	f	class:cv::gpu::BaseFilter_GPU	access:public	signature:()
cv::gpu::BaseRowFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS BaseRowFilter_GPU$/;"	c	namespace:cv::gpu
cv::gpu::BaseRowFilter_GPU::BaseRowFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            BaseRowFilter_GPU(int ksize_, int anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:(int ksize_, int anchor_)
cv::gpu::BaseRowFilter_GPU::anchor	/usr/include/opencv2/gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseRowFilter_GPU	access:public
cv::gpu::BaseRowFilter_GPU::ksize	/usr/include/opencv2/gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseRowFilter_GPU	access:public
cv::gpu::BaseRowFilter_GPU::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst) = 0;$/;"	p	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst)
cv::gpu::BaseRowFilter_GPU::~BaseRowFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual ~BaseRowFilter_GPU() {}$/;"	f	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:()
cv::gpu::Canny	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void Canny(const GpuMat& image, GpuMat& edges, double threshold1, double threshold2, int apertureSize = 3);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, GpuMat& edges, double threshold1, double threshold2, int apertureSize = 3)
cv::gpu::CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS CudaMem$/;"	c	namespace:cv::gpu
cv::gpu::CudaMem::ALLOC_PAGE_LOCKED	/usr/include/opencv2/gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon152
cv::gpu::CudaMem::ALLOC_WRITE_COMBINED	/usr/include/opencv2/gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon152
cv::gpu::CudaMem::ALLOC_ZEROCOPY	/usr/include/opencv2/gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon152
cv::gpu::CudaMem::CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
cv::gpu::CudaMem::CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED)
cv::gpu::CudaMem::CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem(const CudaMem& m);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const CudaMem& m)
cv::gpu::CudaMem::CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem(int rows, int cols, int type, int _alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(int rows, int cols, int type, int _alloc_type = ALLOC_PAGE_LOCKED)
cv::gpu::CudaMem::CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            explicit CudaMem(const Mat& m, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const Mat& m, int alloc_type = ALLOC_PAGE_LOCKED)
cv::gpu::CudaMem::CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem()  : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0) {}$/;"	f	class:cv::gpu::CudaMem	signature:()
cv::gpu::CudaMem::CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(Size _size, int _type, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(Size _size, int _type, int _alloc_type)
cv::gpu::CudaMem::CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(const CudaMem& m) : flags(m.flags), rows(m.rows), cols(m.cols), step(m.step), data(m.data), refcount(m.refcount), datastart(m.datastart), dataend(m.dataend), alloc_type(m.alloc_type)$/;"	f	class:cv::gpu::CudaMem	signature:(const CudaMem& m)
cv::gpu::CudaMem::CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(const Mat& m, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(const Mat& m, int _alloc_type)
cv::gpu::CudaMem::CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(int _rows, int _cols, int _type, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(int _rows, int _cols, int _type, int _alloc_type)
cv::gpu::CudaMem::alloc_type	/usr/include/opencv2/gpu/gpu.hpp	/^            int alloc_type;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::canMapHostMemory	/usr/include/opencv2/gpu/gpu.hpp	/^            static bool canMapHostMemory();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
cv::gpu::CudaMem::channels	/usr/include/opencv2/gpu/gpu.hpp	/^            int channels() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::channels	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int CudaMem::channels() const { return CV_MAT_CN(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::clone	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem clone() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::clone	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem CudaMem::clone() const$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::cols	/usr/include/opencv2/gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::create	/usr/include/opencv2/gpu/gpu.hpp	/^            void create(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED)
cv::gpu::CudaMem::create	/usr/include/opencv2/gpu/gpu.hpp	/^            void create(int rows, int cols, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(int rows, int cols, int type, int alloc_type = ALLOC_PAGE_LOCKED)
cv::gpu::CudaMem::create	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline void CudaMem::create(Size _size, int _type, int _alloc_type) { create(_size.height, _size.width, _type, _alloc_type); }$/;"	f	class:cv::gpu::CudaMem	signature:(Size _size, int _type, int _alloc_type)
cv::gpu::CudaMem::createGpuMatHeader	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat createGpuMatHeader() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::createMatHeader	/usr/include/opencv2/gpu/gpu.hpp	/^            Mat createMatHeader() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::createMatHeader	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline Mat CudaMem::createMatHeader() const { return Mat(size(), type(), data); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::data	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* data;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::dataend	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* dataend;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::datastart	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* datastart;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::depth	/usr/include/opencv2/gpu/gpu.hpp	/^            int depth() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::depth	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int CudaMem::depth() const { return CV_MAT_DEPTH(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::elemSize	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t elemSize() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::elemSize	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t CudaMem::elemSize() const { return CV_ELEM_SIZE(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::elemSize1	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t elemSize1() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::elemSize1	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t CudaMem::elemSize1() const { return CV_ELEM_SIZE1(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::empty	/usr/include/opencv2/gpu/gpu.hpp	/^            bool empty() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::empty	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline bool CudaMem::empty() const { return data == 0; }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::flags	/usr/include/opencv2/gpu/gpu.hpp	/^            int flags;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::isContinuous	/usr/include/opencv2/gpu/gpu.hpp	/^            bool isContinuous() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::isContinuous	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline bool CudaMem::isContinuous() const { return (flags & Mat::CONTINUOUS_FLAG) != 0; }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::operator =	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem& operator = (const CudaMem& m);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const CudaMem& m)
cv::gpu::CudaMem::operator =	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem& CudaMem::operator = (const CudaMem& m)$/;"	f	class:cv::gpu::CudaMem	signature:(const CudaMem& m)
cv::gpu::CudaMem::operator GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            operator GpuMat() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::operator GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::operator GpuMat() const { return createGpuMatHeader(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::operator Mat	/usr/include/opencv2/gpu/gpu.hpp	/^            operator Mat() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::operator Mat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::operator Mat() const { return createMatHeader(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::refcount	/usr/include/opencv2/gpu/gpu.hpp	/^            int* refcount;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::release	/usr/include/opencv2/gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
cv::gpu::CudaMem::rows	/usr/include/opencv2/gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::size	/usr/include/opencv2/gpu/gpu.hpp	/^            Size size() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::size	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline Size CudaMem::size() const { return Size(cols, rows); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::step	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t step;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::step1	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t step1() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::step1	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t CudaMem::step1() const { return step\/elemSize1(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::type	/usr/include/opencv2/gpu/gpu.hpp	/^            int type() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::type	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int CudaMem::type() const { return CV_MAT_TYPE(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::~CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            ~CudaMem();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
cv::gpu::CudaMem::~CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::~CudaMem()$/;"	f	class:cv::gpu::CudaMem	signature:()
cv::gpu::DevMem2D	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef DevMem2D_<unsigned char> DevMem2D;$/;"	t	namespace:cv::gpu
cv::gpu::DevMem2D_	/usr/include/opencv2/gpu/devmem2d.hpp	/^        template <typename T> struct DevMem2D_$/;"	s	namespace:cv::gpu
cv::gpu::DevMem2D_::DevMem2D_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            DevMem2D_() : cols(0), rows(0), data(0), step(0) {}$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:()
cv::gpu::DevMem2D_::DevMem2D_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            DevMem2D_(int rows_, int cols_, T *data_, size_t step_)$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int rows_, int cols_, T *data_, size_t step_)
cv::gpu::DevMem2D_::DevMem2D_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            explicit DevMem2D_(const DevMem2D_<U>& d)$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(const DevMem2D_<U>& d)
cv::gpu::DevMem2D_::cols	/usr/include/opencv2/gpu/devmem2d.hpp	/^            int cols;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
cv::gpu::DevMem2D_::data	/usr/include/opencv2/gpu/devmem2d.hpp	/^            T* data;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
cv::gpu::DevMem2D_::elemSize	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ size_t elemSize() const { return elem_size; }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:() const
cv::gpu::DevMem2D_::elem_size	/usr/include/opencv2/gpu/devmem2d.hpp	/^            enum { elem_size = sizeof(elem_type) };$/;"	e	enum:cv::gpu::DevMem2D_::__anon168
cv::gpu::DevMem2D_::elem_type	/usr/include/opencv2/gpu/devmem2d.hpp	/^            typedef T elem_type;$/;"	t	struct:cv::gpu::DevMem2D_	access:public
cv::gpu::DevMem2D_::ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return (T*)( (char*)data + y * step ); }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int y = 0)
cv::gpu::DevMem2D_::ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return (const T*)( (const char*)data + y * step ); }            $/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int y = 0) const
cv::gpu::DevMem2D_::rows	/usr/include/opencv2/gpu/devmem2d.hpp	/^            int rows;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
cv::gpu::DevMem2D_::step	/usr/include/opencv2/gpu/devmem2d.hpp	/^            size_t step;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
cv::gpu::DevMem2Df	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef DevMem2D_<float> DevMem2Df;$/;"	t	namespace:cv::gpu
cv::gpu::DevMem2Di	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef DevMem2D_<int> DevMem2Di;$/;"	t	namespace:cv::gpu
cv::gpu::DisparityBilateralFilter	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS DisparityBilateralFilter$/;"	c	namespace:cv::gpu
cv::gpu::DisparityBilateralFilter::DEFAULT_ITERS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_ITERS  = 1 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon164
cv::gpu::DisparityBilateralFilter::DEFAULT_NDISP	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NDISP  = 64 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon162
cv::gpu::DisparityBilateralFilter::DEFAULT_RADIUS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_RADIUS = 3 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon163
cv::gpu::DisparityBilateralFilter::DisparityBilateralFilter	/usr/include/opencv2/gpu/gpu.hpp	/^            DisparityBilateralFilter(int ndisp, int radius, int iters, float edge_threshold, float max_disc_threshold, float sigma_range);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(int ndisp, int radius, int iters, float edge_threshold, float max_disc_threshold, float sigma_range)
cv::gpu::DisparityBilateralFilter::DisparityBilateralFilter	/usr/include/opencv2/gpu/gpu.hpp	/^            explicit DisparityBilateralFilter(int ndisp = DEFAULT_NDISP, int radius = DEFAULT_RADIUS, int iters = DEFAULT_ITERS);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(int ndisp = DEFAULT_NDISP, int radius = DEFAULT_RADIUS, int iters = DEFAULT_ITERS)
cv::gpu::DisparityBilateralFilter::edge_threshold	/usr/include/opencv2/gpu/gpu.hpp	/^            float edge_threshold;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::iters	/usr/include/opencv2/gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::max_disc_threshold	/usr/include/opencv2/gpu/gpu.hpp	/^            float max_disc_threshold;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::ndisp	/usr/include/opencv2/gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& disparity, const GpuMat& image, GpuMat& dst);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(const GpuMat& disparity, const GpuMat& image, GpuMat& dst)
cv::gpu::DisparityBilateralFilter::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& disparity, const GpuMat& image, GpuMat& dst, Stream& stream);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(const GpuMat& disparity, const GpuMat& image, GpuMat& dst, Stream& stream)
cv::gpu::DisparityBilateralFilter::radius	/usr/include/opencv2/gpu/gpu.hpp	/^            int radius;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::sigma_range	/usr/include/opencv2/gpu/gpu.hpp	/^            float sigma_range;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::table_color	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat table_color;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::table_space	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat table_space;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::FilterEngine_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS FilterEngine_GPU$/;"	c	namespace:cv::gpu
cv::gpu::FilterEngine_GPU::apply	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual void apply(const GpuMat& src, GpuMat& dst, Rect roi = Rect(0,0,-1,-1)) = 0;$/;"	p	class:cv::gpu::FilterEngine_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst, Rect roi = Rect(0,0,-1,-1))
cv::gpu::FilterEngine_GPU::~FilterEngine_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual ~FilterEngine_GPU() {}$/;"	f	class:cv::gpu::FilterEngine_GPU	access:public	signature:()
cv::gpu::GaussianBlur	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void GaussianBlur(const GpuMat& src, GpuMat& dst, Size ksize, double sigma1, double sigma2 = 0);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size ksize, double sigma1, double sigma2 = 0)
cv::gpu::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS GpuMat$/;"	c	namespace:cv::gpu
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(Size size, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(Size size, int type, const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type, const Scalar& s)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(Size size, int type, void* data, size_t step = Mat::AUTO_STEP);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type, void* data, size_t step = Mat::AUTO_STEP)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(const GpuMat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(const GpuMat& m, const Range& rowRange, const Range& colRange);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m, const Range& rowRange, const Range& colRange)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(const GpuMat& m, const Rect& roi);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m, const Rect& roi)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(int rows, int cols, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(int rows, int cols, int type, const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type, const Scalar& s)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat(int rows, int cols, int type, void* data, size_t step = Mat::AUTO_STEP);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type, void* data, size_t step = Mat::AUTO_STEP)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            explicit GpuMat (const Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Mat& m)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat() : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0) {}$/;"	f	class:cv::gpu::GpuMat	signature:()
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(Size _size, int _type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0)$/;"	f	class:cv::gpu::GpuMat	signature:(Size _size, int _type)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(Size _size, int _type, const Scalar& _s)$/;"	f	class:cv::gpu::GpuMat	signature:(Size _size, int _type, const Scalar& _s)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(Size _size, int _type, void* _data, size_t _step)$/;"	f	class:cv::gpu::GpuMat	signature:(Size _size, int _type, void* _data, size_t _step)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(const GpuMat& m)$/;"	f	class:cv::gpu::GpuMat	signature:(const GpuMat& m)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(const GpuMat& m, const Range& rowRange, const Range& colRange)$/;"	f	class:cv::gpu::GpuMat	signature:(const GpuMat& m, const Range& rowRange, const Range& colRange)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(const GpuMat& m, const Rect& roi)$/;"	f	class:cv::gpu::GpuMat	signature:(const GpuMat& m, const Rect& roi)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(const Mat& m)$/;"	f	class:cv::gpu::GpuMat	signature:(const Mat& m)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(int _rows, int _cols, int _type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0)$/;"	f	class:cv::gpu::GpuMat	signature:(int _rows, int _cols, int _type)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(int _rows, int _cols, int _type, const Scalar& _s)$/;"	f	class:cv::gpu::GpuMat	signature:(int _rows, int _cols, int _type, const Scalar& _s)
cv::gpu::GpuMat::GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::GpuMat(int _rows, int _cols, int _type, void* _data, size_t _step)$/;"	f	class:cv::gpu::GpuMat	signature:(int _rows, int _cols, int _type, void* _data, size_t _step)
cv::gpu::GpuMat::adjustROI	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
cv::gpu::GpuMat::adjustROI	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat& GpuMat::adjustROI( int dtop, int dbottom, int dleft, int dright )$/;"	f	class:cv::gpu::GpuMat	signature:( int dtop, int dbottom, int dleft, int dright )
cv::gpu::GpuMat::assignTo	/usr/include/opencv2/gpu/gpu.hpp	/^            void assignTo( GpuMat& m, int type=-1 ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, int type=-1 ) const
cv::gpu::GpuMat::assignTo	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline void GpuMat::assignTo( GpuMat& m, int type ) const$/;"	f	class:cv::gpu::GpuMat	signature:( GpuMat& m, int type ) const
cv::gpu::GpuMat::channels	/usr/include/opencv2/gpu/gpu.hpp	/^            int channels() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::channels	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int GpuMat::channels() const { return CV_MAT_CN(flags); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::clone	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat clone() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::clone	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::clone() const$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::col	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat col(int x) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int x) const
cv::gpu::GpuMat::col	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::col(int x) const { return GpuMat(*this, Range::all(), Range(x, x+1)); }$/;"	f	class:cv::gpu::GpuMat	signature:(int x) const
cv::gpu::GpuMat::colRange	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat colRange(const Range& r) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Range& r) const
cv::gpu::GpuMat::colRange	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat colRange(int startcol, int endcol) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int startcol, int endcol) const
cv::gpu::GpuMat::colRange	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::colRange(const Range& r) const { return GpuMat(*this, Range::all(), r); }$/;"	f	class:cv::gpu::GpuMat	signature:(const Range& r) const
cv::gpu::GpuMat::colRange	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::colRange(int startcol, int endcol) const { return GpuMat(*this, Range::all(), Range(startcol, endcol)); }$/;"	f	class:cv::gpu::GpuMat	signature:(int startcol, int endcol) const
cv::gpu::GpuMat::cols	/usr/include/opencv2/gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::convertTo	/usr/include/opencv2/gpu/gpu.hpp	/^            void convertTo( GpuMat& m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, int rtype, double alpha=1, double beta=0 ) const
cv::gpu::GpuMat::copyTo	/usr/include/opencv2/gpu/gpu.hpp	/^            void copyTo( GpuMat& m ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m ) const
cv::gpu::GpuMat::copyTo	/usr/include/opencv2/gpu/gpu.hpp	/^            void copyTo( GpuMat& m, const GpuMat& mask ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, const GpuMat& mask ) const
cv::gpu::GpuMat::create	/usr/include/opencv2/gpu/gpu.hpp	/^            void create(Size size, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type)
cv::gpu::GpuMat::create	/usr/include/opencv2/gpu/gpu.hpp	/^            void create(int rows, int cols, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type)
cv::gpu::GpuMat::create	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline void GpuMat::create(Size _size, int _type) { create(_size.height, _size.width, _type); }$/;"	f	class:cv::gpu::GpuMat	signature:(Size _size, int _type)
cv::gpu::GpuMat::data	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* data;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::dataend	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* dataend;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::datastart	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* datastart;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::depth	/usr/include/opencv2/gpu/gpu.hpp	/^            int depth() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::depth	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int GpuMat::depth() const { return CV_MAT_DEPTH(flags); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::download	/usr/include/opencv2/gpu/gpu.hpp	/^            void download(CudaMem& m, Stream& stream) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(CudaMem& m, Stream& stream) const
cv::gpu::GpuMat::download	/usr/include/opencv2/gpu/gpu.hpp	/^            void download(cv::Mat& m) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(cv::Mat& m) const
cv::gpu::GpuMat::elemSize	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t elemSize() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::elemSize	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t GpuMat::elemSize() const { return CV_ELEM_SIZE(flags); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::elemSize1	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t elemSize1() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::elemSize1	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t GpuMat::elemSize1() const { return CV_ELEM_SIZE1(flags); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::empty	/usr/include/opencv2/gpu/gpu.hpp	/^            bool empty() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::empty	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline bool GpuMat::empty() const { return data == 0; }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::flags	/usr/include/opencv2/gpu/gpu.hpp	/^            int flags;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::isContinuous	/usr/include/opencv2/gpu/gpu.hpp	/^            bool isContinuous() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::isContinuous	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline bool GpuMat::isContinuous() const { return (flags & Mat::CONTINUOUS_FLAG) != 0; }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::locateROI	/usr/include/opencv2/gpu/gpu.hpp	/^            void locateROI( Size& wholeSize, Point& ofs ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( Size& wholeSize, Point& ofs ) const
cv::gpu::GpuMat::locateROI	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline void GpuMat::locateROI( Size& wholeSize, Point& ofs ) const$/;"	f	class:cv::gpu::GpuMat	signature:( Size& wholeSize, Point& ofs ) const
cv::gpu::GpuMat::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat operator()( Range rowRange, Range colRange ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( Range rowRange, Range colRange ) const
cv::gpu::GpuMat::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat operator()( const Rect& roi ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( const Rect& roi ) const
cv::gpu::GpuMat::operator ()	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::operator()( Range rowRange, Range colRange ) const { return GpuMat(*this, rowRange, colRange); }$/;"	f	class:cv::gpu::GpuMat	signature:( Range rowRange, Range colRange ) const
cv::gpu::GpuMat::operator ()	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::operator()( const Rect& roi ) const { return GpuMat(*this, roi); }$/;"	f	class:cv::gpu::GpuMat	signature:( const Rect& roi ) const
cv::gpu::GpuMat::operator =	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat& operator = (const GpuMat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m)
cv::gpu::GpuMat::operator =	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat& operator = (const Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Mat& m)
cv::gpu::GpuMat::operator =	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat& operator = (const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Scalar& s)
cv::gpu::GpuMat::operator =	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat& GpuMat::operator = (const GpuMat& m)$/;"	f	class:cv::gpu::GpuMat	signature:(const GpuMat& m)
cv::gpu::GpuMat::operator =	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat& GpuMat::operator = (const Mat& m) { upload(m); return *this; }$/;"	f	class:cv::gpu::GpuMat	signature:(const Mat& m)
cv::gpu::GpuMat::operator DevMem2D_<T>	/usr/include/opencv2/gpu/gpu.hpp	/^            template <class T> operator DevMem2D_<T>() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::operator DevMem2D_<T>	/usr/include/opencv2/gpu/matrix_operations.hpp	/^template <class T> inline GpuMat::operator DevMem2D_<T>() const { return DevMem2D_<T>(rows, cols, (T*)data, step); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::operator Mat	/usr/include/opencv2/gpu/gpu.hpp	/^            operator Mat() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::operator Mat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^ inline GpuMat::operator Mat() const$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::operator PtrStep_<T>	/usr/include/opencv2/gpu/gpu.hpp	/^            template <class T> operator PtrStep_<T>() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::operator PtrStep_<T>	/usr/include/opencv2/gpu/matrix_operations.hpp	/^template <class T> inline GpuMat::operator PtrStep_<T>() const { return PtrStep_<T>(static_cast< DevMem2D_<T> >(*this)); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::ptr	/usr/include/opencv2/gpu/gpu.hpp	/^            const uchar* ptr(int y = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0) const
cv::gpu::GpuMat::ptr	/usr/include/opencv2/gpu/gpu.hpp	/^            template<typename _Tp> _Tp* ptr(int y = 0);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0)
cv::gpu::GpuMat::ptr	/usr/include/opencv2/gpu/gpu.hpp	/^            template<typename _Tp> const _Tp* ptr(int y = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0) const
cv::gpu::GpuMat::ptr	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* ptr(int y = 0);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0)
cv::gpu::GpuMat::ptr	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline const uchar* GpuMat::ptr(int y) const$/;"	f	class:cv::gpu::GpuMat	signature:(int y) const
cv::gpu::GpuMat::ptr	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline uchar* GpuMat::ptr(int y)$/;"	f	class:cv::gpu::GpuMat	signature:(int y)
cv::gpu::GpuMat::ptr	/usr/include/opencv2/gpu/matrix_operations.hpp	/^template<typename _Tp> inline _Tp* GpuMat::ptr(int y)$/;"	f	class:cv::gpu::GpuMat	signature:(int y)
cv::gpu::GpuMat::ptr	/usr/include/opencv2/gpu/matrix_operations.hpp	/^template<typename _Tp> inline const _Tp* GpuMat::ptr(int y) const$/;"	f	class:cv::gpu::GpuMat	signature:(int y) const
cv::gpu::GpuMat::refcount	/usr/include/opencv2/gpu/gpu.hpp	/^            int* refcount;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::release	/usr/include/opencv2/gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
cv::gpu::GpuMat::reshape	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat reshape(int cn, int rows = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int cn, int rows = 0) const
cv::gpu::GpuMat::row	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat row(int y) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y) const
cv::gpu::GpuMat::row	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::row(int y) const { return GpuMat(*this, Range(y, y+1), Range::all()); }$/;"	f	class:cv::gpu::GpuMat	signature:(int y) const
cv::gpu::GpuMat::rowRange	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat rowRange(const Range& r) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Range& r) const
cv::gpu::GpuMat::rowRange	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat rowRange(int startrow, int endrow) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int startrow, int endrow) const
cv::gpu::GpuMat::rowRange	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::rowRange(const Range& r) const { return GpuMat(*this, r, Range::all()); }$/;"	f	class:cv::gpu::GpuMat	signature:(const Range& r) const
cv::gpu::GpuMat::rowRange	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::rowRange(int startrow, int endrow) const { return GpuMat(*this, Range(startrow, endrow), Range::all()); }$/;"	f	class:cv::gpu::GpuMat	signature:(int startrow, int endrow) const
cv::gpu::GpuMat::rows	/usr/include/opencv2/gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::setTo	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat& setTo(const Scalar& s, const GpuMat& mask = GpuMat());$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Scalar& s, const GpuMat& mask = GpuMat())
cv::gpu::GpuMat::size	/usr/include/opencv2/gpu/gpu.hpp	/^            Size size() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::size	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline Size GpuMat::size() const { return Size(cols, rows); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::step	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t step;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::step1	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t step1() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::step1	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t GpuMat::step1() const { return step\/elemSize1(); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::swap	/usr/include/opencv2/gpu/gpu.hpp	/^            void swap(GpuMat& mat);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(GpuMat& mat)
cv::gpu::GpuMat::swap	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline void GpuMat::swap(GpuMat& b)$/;"	f	class:cv::gpu::GpuMat	signature:(GpuMat& b)
cv::gpu::GpuMat::t	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat t() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::t	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::t() const$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::type	/usr/include/opencv2/gpu/gpu.hpp	/^            int type() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::type	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int GpuMat::type() const { return CV_MAT_TYPE(flags); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::upload	/usr/include/opencv2/gpu/gpu.hpp	/^            void upload(const CudaMem& m, Stream& stream);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const CudaMem& m, Stream& stream)
cv::gpu::GpuMat::upload	/usr/include/opencv2/gpu/gpu.hpp	/^            void upload(const cv::Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const cv::Mat& m)
cv::gpu::GpuMat::~GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            ~GpuMat();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
cv::gpu::GpuMat::~GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::~GpuMat() { release(); }$/;"	f	class:cv::gpu::GpuMat	signature:()
cv::gpu::HOGDescriptor	/usr/include/opencv2/gpu/gpu.hpp	/^        struct CV_EXPORTS HOGDescriptor$/;"	s	namespace:cv::gpu
cv::gpu::HOGDescriptor::DEFAULT_NLEVELS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NLEVELS = 64 };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon166
cv::gpu::HOGDescriptor::DEFAULT_WIN_SIGMA	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_WIN_SIGMA = -1 };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon165
cv::gpu::HOGDescriptor::DESCR_FORMAT_COL_BY_COL	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DESCR_FORMAT_ROW_BY_ROW, DESCR_FORMAT_COL_BY_COL };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon167
cv::gpu::HOGDescriptor::DESCR_FORMAT_ROW_BY_ROW	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DESCR_FORMAT_ROW_BY_ROW, DESCR_FORMAT_COL_BY_COL };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon167
cv::gpu::HOGDescriptor::HOGDescriptor	/usr/include/opencv2/gpu/gpu.hpp	/^            HOGDescriptor(Size win_size=Size(64, 128), Size block_size=Size(16, 16), $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(Size win_size=Size(64, 128), Size block_size=Size(16, 16), Size block_stride=Size(8, 8), Size cell_size=Size(8, 8), int nbins=9, double win_sigma=DEFAULT_WIN_SIGMA, double threshold_L2hys=0.2, bool gamma_correction=true, int nlevels=DEFAULT_NLEVELS)
cv::gpu::HOGDescriptor::block_hists	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat block_hists;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::block_size	/usr/include/opencv2/gpu/gpu.hpp	/^            Size block_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::block_stride	/usr/include/opencv2/gpu/gpu.hpp	/^            Size block_stride;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::cell_size	/usr/include/opencv2/gpu/gpu.hpp	/^            Size cell_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::checkDetectorSize	/usr/include/opencv2/gpu/gpu.hpp	/^            bool checkDetectorSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
cv::gpu::HOGDescriptor::computeBlockHistograms	/usr/include/opencv2/gpu/gpu.hpp	/^            void computeBlockHistograms(const GpuMat& img);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(const GpuMat& img)
cv::gpu::HOGDescriptor::computeGradient	/usr/include/opencv2/gpu/gpu.hpp	/^            void computeGradient(const GpuMat& img, GpuMat& grad, GpuMat& qangle);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(const GpuMat& img, GpuMat& grad, GpuMat& qangle)
cv::gpu::HOGDescriptor::detect	/usr/include/opencv2/gpu/gpu.hpp	/^            void detect(const GpuMat& img, vector<Point>& found_locations, double hit_threshold=0, $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, vector<Point>& found_locations, double hit_threshold=0, Size win_stride=Size(), Size padding=Size())
cv::gpu::HOGDescriptor::detectMultiScale	/usr/include/opencv2/gpu/gpu.hpp	/^            void detectMultiScale(const GpuMat& img, vector<Rect>& found_locations, $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, vector<Rect>& found_locations, double hit_threshold=0, Size win_stride=Size(), Size padding=Size(), double scale0=1.05, int group_threshold=2)
cv::gpu::HOGDescriptor::detector	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat detector;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::free_coef	/usr/include/opencv2/gpu/gpu.hpp	/^            float free_coef;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::gamma_correction	/usr/include/opencv2/gpu/gpu.hpp	/^            bool gamma_correction;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::getBlockHistogramSize	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t getBlockHistogramSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
cv::gpu::HOGDescriptor::getDefaultPeopleDetector	/usr/include/opencv2/gpu/gpu.hpp	/^            static vector<float> getDefaultPeopleDetector();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
cv::gpu::HOGDescriptor::getDescriptorSize	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t getDescriptorSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
cv::gpu::HOGDescriptor::getDescriptors	/usr/include/opencv2/gpu/gpu.hpp	/^            void getDescriptors(const GpuMat& img, Size win_stride, GpuMat& descriptors, $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, Size win_stride, GpuMat& descriptors, int descr_format=DESCR_FORMAT_COL_BY_COL)
cv::gpu::HOGDescriptor::getPeopleDetector_48x96	/usr/include/opencv2/gpu/gpu.hpp	/^            static vector<float> getPeopleDetector_48x96();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
cv::gpu::HOGDescriptor::getPeopleDetector_64x128	/usr/include/opencv2/gpu/gpu.hpp	/^            static vector<float> getPeopleDetector_64x128();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
cv::gpu::HOGDescriptor::getWinSigma	/usr/include/opencv2/gpu/gpu.hpp	/^            double getWinSigma() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
cv::gpu::HOGDescriptor::grad	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat grad, qangle;            $/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::labels	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat labels;        $/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::labels_host	/usr/include/opencv2/gpu/gpu.hpp	/^            Mat labels_host;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::nbins	/usr/include/opencv2/gpu/gpu.hpp	/^            int nbins;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::nlevels	/usr/include/opencv2/gpu/gpu.hpp	/^            int nlevels;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::numPartsWithin	/usr/include/opencv2/gpu/gpu.hpp	/^            static Size numPartsWithin(Size size, Size part_size, Size stride);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(Size size, Size part_size, Size stride)
cv::gpu::HOGDescriptor::numPartsWithin	/usr/include/opencv2/gpu/gpu.hpp	/^            static int numPartsWithin(int size, int part_size, int stride);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(int size, int part_size, int stride)
cv::gpu::HOGDescriptor::qangle	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat grad, qangle;            $/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::setSVMDetector	/usr/include/opencv2/gpu/gpu.hpp	/^            void setSVMDetector(const vector<float>& detector);$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const vector<float>& detector)
cv::gpu::HOGDescriptor::threshold_L2hys	/usr/include/opencv2/gpu/gpu.hpp	/^            double threshold_L2hys;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::win_sigma	/usr/include/opencv2/gpu/gpu.hpp	/^            double win_sigma;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::win_size	/usr/include/opencv2/gpu/gpu.hpp	/^            Size win_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::LUT	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void LUT(const GpuMat& src, const Mat& lut, GpuMat& dst);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const Mat& lut, GpuMat& dst)
cv::gpu::Laplacian	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void Laplacian(const GpuMat& src, GpuMat& dst, int ddepth, int ksize = 1, double scale = 1);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int ksize = 1, double scale = 1)
cv::gpu::PtrElemStep	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrElemStep_<unsigned char> PtrElemStep;$/;"	t	namespace:cv::gpu
cv::gpu::PtrElemStep_	/usr/include/opencv2/gpu/devmem2d.hpp	/^        template<typename T> struct PtrElemStep_ : public PtrStep_<T>$/;"	s	namespace:cv::gpu	inherits:PtrStep_
cv::gpu::PtrElemStep_::ElemStepTypeCheck	/usr/include/opencv2/gpu/devmem2d.hpp	/^            StaticCheck<256 % sizeof(T) == 0>  ElemStepTypeCheck;$/;"	m	struct:cv::gpu::PtrElemStep_	access:private
cv::gpu::PtrElemStep_::PtrElemStep_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            PtrElemStep_(const DevMem2D_<T>& mem) : PtrStep_<T>(mem) $/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(const DevMem2D_<T>& mem)
cv::gpu::PtrElemStep_::ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return PtrStep_<T>::data + y * PtrStep_<T>::step; }$/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(int y = 0)
cv::gpu::PtrElemStep_::ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return PtrStep_<T>::data + y * PtrStep_<T>::step; }$/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(int y = 0) const
cv::gpu::PtrElemStepf	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrElemStep_<float> PtrElemStepf;$/;"	t	namespace:cv::gpu
cv::gpu::PtrElemStepi	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrElemStep_<int> PtrElemStepi;$/;"	t	namespace:cv::gpu
cv::gpu::PtrStep	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrStep_<unsigned char> PtrStep;$/;"	t	namespace:cv::gpu
cv::gpu::PtrStep_	/usr/include/opencv2/gpu/devmem2d.hpp	/^        template<typename T> struct PtrStep_$/;"	s	namespace:cv::gpu
cv::gpu::PtrStep_::PtrStep_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            PtrStep_() : data(0), step(0) {}            $/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:()
cv::gpu::PtrStep_::PtrStep_	/usr/include/opencv2/gpu/devmem2d.hpp	/^            PtrStep_(const DevMem2D_<T>& mem) : data(mem.data), step(mem.step) {}$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(const DevMem2D_<T>& mem)
cv::gpu::PtrStep_::data	/usr/include/opencv2/gpu/devmem2d.hpp	/^            T* data;$/;"	m	struct:cv::gpu::PtrStep_	access:public
cv::gpu::PtrStep_::elemSize	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ size_t elemSize() const { return elem_size; }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:() const
cv::gpu::PtrStep_::elem_size	/usr/include/opencv2/gpu/devmem2d.hpp	/^            enum { elem_size = sizeof(elem_type) };$/;"	e	enum:cv::gpu::PtrStep_::__anon169
cv::gpu::PtrStep_::elem_type	/usr/include/opencv2/gpu/devmem2d.hpp	/^            typedef T elem_type;$/;"	t	struct:cv::gpu::PtrStep_	access:public
cv::gpu::PtrStep_::ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return (T*)( (char*)data + y * step); }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(int y = 0)
cv::gpu::PtrStep_::ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return (const T*)( (const char*)data + y * step); }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(int y = 0) const
cv::gpu::PtrStep_::step	/usr/include/opencv2/gpu/devmem2d.hpp	/^            size_t step;$/;"	m	struct:cv::gpu::PtrStep_	access:public
cv::gpu::PtrStepf	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrStep_<float> PtrStepf;$/;"	t	namespace:cv::gpu
cv::gpu::PtrStepi	/usr/include/opencv2/gpu/devmem2d.hpp	/^        typedef PtrStep_<int> PtrStepi;$/;"	t	namespace:cv::gpu
cv::gpu::Scharr	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void Scharr(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, double scale = 1);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, double scale = 1)
cv::gpu::Sobel	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void Sobel(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1)
cv::gpu::StaticCheck	/usr/include/opencv2/gpu/devmem2d.hpp	/^        template <> struct StaticCheck<true>{};            $/;"	s	namespace:cv::gpu
cv::gpu::StereoBM_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS StereoBM_GPU$/;"	c	namespace:cv::gpu
cv::gpu::StereoBM_GPU::BASIC_PRESET	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { BASIC_PRESET = 0, PREFILTER_XSOBEL = 1 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon153
cv::gpu::StereoBM_GPU::DEFAULT_NDISP	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NDISP = 64, DEFAULT_WINSZ = 19 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon154
cv::gpu::StereoBM_GPU::DEFAULT_WINSZ	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NDISP = 64, DEFAULT_WINSZ = 19 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon154
cv::gpu::StereoBM_GPU::PREFILTER_XSOBEL	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { BASIC_PRESET = 0, PREFILTER_XSOBEL = 1 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon153
cv::gpu::StereoBM_GPU::StereoBM_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            StereoBM_GPU();$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:()
cv::gpu::StereoBM_GPU::StereoBM_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            StereoBM_GPU(int preset, int ndisparities = DEFAULT_NDISP, int winSize = DEFAULT_WINSZ);$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:(int preset, int ndisparities = DEFAULT_NDISP, int winSize = DEFAULT_WINSZ)
cv::gpu::StereoBM_GPU::avergeTexThreshold	/usr/include/opencv2/gpu/gpu.hpp	/^            float avergeTexThreshold;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
cv::gpu::StereoBM_GPU::checkIfGpuCallReasonable	/usr/include/opencv2/gpu/gpu.hpp	/^            static bool checkIfGpuCallReasonable();$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:()
cv::gpu::StereoBM_GPU::leBuf	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
cv::gpu::StereoBM_GPU::minSSD	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
cv::gpu::StereoBM_GPU::ndisp	/usr/include/opencv2/gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
cv::gpu::StereoBM_GPU::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator() ( const GpuMat& left, const GpuMat& right, GpuMat& disparity);$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:( const GpuMat& left, const GpuMat& right, GpuMat& disparity)
cv::gpu::StereoBM_GPU::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator() ( const GpuMat& left, const GpuMat& right, GpuMat& disparity, const Stream & stream);$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:( const GpuMat& left, const GpuMat& right, GpuMat& disparity, const Stream & stream)
cv::gpu::StereoBM_GPU::preset	/usr/include/opencv2/gpu/gpu.hpp	/^            int preset;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
cv::gpu::StereoBM_GPU::riBuf	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
cv::gpu::StereoBM_GPU::winSize	/usr/include/opencv2/gpu/gpu.hpp	/^            int winSize;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
cv::gpu::StereoBeliefPropagation	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS StereoBeliefPropagation$/;"	c	namespace:cv::gpu
cv::gpu::StereoBeliefPropagation::DEFAULT_ITERS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_ITERS  = 5  };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon156
cv::gpu::StereoBeliefPropagation::DEFAULT_LEVELS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_LEVELS = 5  };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon157
cv::gpu::StereoBeliefPropagation::DEFAULT_NDISP	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NDISP  = 64 };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon155
cv::gpu::StereoBeliefPropagation::StereoBeliefPropagation	/usr/include/opencv2/gpu/gpu.hpp	/^            StereoBeliefPropagation(int ndisp, int iters, int levels,$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int ndisp, int iters, int levels, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int msg_type = CV_32F)
cv::gpu::StereoBeliefPropagation::StereoBeliefPropagation	/usr/include/opencv2/gpu/gpu.hpp	/^            explicit StereoBeliefPropagation(int ndisp  = DEFAULT_NDISP,$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int ndisp = DEFAULT_NDISP, int iters = DEFAULT_ITERS, int levels = DEFAULT_LEVELS, int msg_type = CV_32F)
cv::gpu::StereoBeliefPropagation::d	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::d2	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::data_weight	/usr/include/opencv2/gpu/gpu.hpp	/^            float data_weight;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::datas	/usr/include/opencv2/gpu/gpu.hpp	/^            std::vector<GpuMat> datas;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::disc_single_jump	/usr/include/opencv2/gpu/gpu.hpp	/^            float disc_single_jump;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::estimateRecommendedParams	/usr/include/opencv2/gpu/gpu.hpp	/^            static void estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int width, int height, int& ndisp, int& iters, int& levels)
cv::gpu::StereoBeliefPropagation::iters	/usr/include/opencv2/gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::l	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::l2	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::levels	/usr/include/opencv2/gpu/gpu.hpp	/^            int levels;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::max_data_term	/usr/include/opencv2/gpu/gpu.hpp	/^            float max_data_term;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::max_disc_term	/usr/include/opencv2/gpu/gpu.hpp	/^            float max_disc_term;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::msg_type	/usr/include/opencv2/gpu/gpu.hpp	/^            int msg_type;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::ndisp	/usr/include/opencv2/gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& data, GpuMat& disparity);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& data, GpuMat& disparity)
cv::gpu::StereoBeliefPropagation::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& data, GpuMat& disparity, Stream& stream);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& data, GpuMat& disparity, Stream& stream)
cv::gpu::StereoBeliefPropagation::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity)
cv::gpu::StereoBeliefPropagation::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream)
cv::gpu::StereoBeliefPropagation::out	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat out;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::r	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::r2	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::u	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::u2	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoConstantSpaceBP	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS StereoConstantSpaceBP$/;"	c	namespace:cv::gpu
cv::gpu::StereoConstantSpaceBP::DEFAULT_ITERS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_ITERS    = 8   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon159
cv::gpu::StereoConstantSpaceBP::DEFAULT_LEVELS	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_LEVELS   = 4   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon160
cv::gpu::StereoConstantSpaceBP::DEFAULT_NDISP	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NDISP    = 128 };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon158
cv::gpu::StereoConstantSpaceBP::DEFAULT_NR_PLANE	/usr/include/opencv2/gpu/gpu.hpp	/^            enum { DEFAULT_NR_PLANE = 4   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon161
cv::gpu::StereoConstantSpaceBP::StereoConstantSpaceBP	/usr/include/opencv2/gpu/gpu.hpp	/^            StereoConstantSpaceBP(int ndisp, int iters, int levels, int nr_plane,$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int ndisp, int iters, int levels, int nr_plane, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int min_disp_th = 0, int msg_type = CV_32F)
cv::gpu::StereoConstantSpaceBP::StereoConstantSpaceBP	/usr/include/opencv2/gpu/gpu.hpp	/^            explicit StereoConstantSpaceBP(int ndisp    = DEFAULT_NDISP,$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int ndisp = DEFAULT_NDISP, int iters = DEFAULT_ITERS, int levels = DEFAULT_LEVELS, int nr_plane = DEFAULT_NR_PLANE, int msg_type = CV_32F)
cv::gpu::StereoConstantSpaceBP::d	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::data_cost	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat data_cost;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::data_cost_selected	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat data_cost_selected;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::data_weight	/usr/include/opencv2/gpu/gpu.hpp	/^            float data_weight;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::disc_single_jump	/usr/include/opencv2/gpu/gpu.hpp	/^            float disc_single_jump;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::disp_selected_pyr	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat disp_selected_pyr[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::estimateRecommendedParams	/usr/include/opencv2/gpu/gpu.hpp	/^            static void estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane);$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane)
cv::gpu::StereoConstantSpaceBP::iters	/usr/include/opencv2/gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::l	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::levels	/usr/include/opencv2/gpu/gpu.hpp	/^            int levels;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::max_data_term	/usr/include/opencv2/gpu/gpu.hpp	/^            float max_data_term;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::max_disc_term	/usr/include/opencv2/gpu/gpu.hpp	/^            float max_disc_term;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::min_disp_th	/usr/include/opencv2/gpu/gpu.hpp	/^            int min_disp_th;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::msg_type	/usr/include/opencv2/gpu/gpu.hpp	/^            int msg_type;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::ndisp	/usr/include/opencv2/gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::nr_plane	/usr/include/opencv2/gpu/gpu.hpp	/^            int nr_plane;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity);$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity)
cv::gpu::StereoConstantSpaceBP::operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream);$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream)
cv::gpu::StereoConstantSpaceBP::out	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat out;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::r	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::temp	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat temp;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::u	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::use_local_init_data_cost	/usr/include/opencv2/gpu/gpu.hpp	/^            bool use_local_init_data_cost;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::Stream	/usr/include/opencv2/gpu/gpu.hpp	/^        class CV_EXPORTS Stream$/;"	c	namespace:cv::gpu
cv::gpu::Stream::Stream	/usr/include/opencv2/gpu/gpu.hpp	/^            Stream();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
cv::gpu::Stream::Stream	/usr/include/opencv2/gpu/gpu.hpp	/^            Stream(const Stream&);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Stream&)
cv::gpu::Stream::create	/usr/include/opencv2/gpu/gpu.hpp	/^            void create();$/;"	p	class:cv::gpu::Stream	access:private	signature:()
cv::gpu::Stream::enqueueConvert	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueConvert(const GpuMat& src, GpuMat& dst, int type, double a = 1, double b = 0);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, GpuMat& dst, int type, double a = 1, double b = 0)
cv::gpu::Stream::enqueueCopy	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueCopy(const GpuMat& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, GpuMat& dst)
cv::gpu::Stream::enqueueDownload	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueDownload(const GpuMat& src, CudaMem& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, CudaMem& dst)
cv::gpu::Stream::enqueueDownload	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueDownload(const GpuMat& src, Mat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, Mat& dst)
cv::gpu::Stream::enqueueMemSet	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueMemSet(const GpuMat& src, Scalar val);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, Scalar val)
cv::gpu::Stream::enqueueMemSet	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueMemSet(const GpuMat& src, Scalar val, const GpuMat& mask);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, Scalar val, const GpuMat& mask)
cv::gpu::Stream::enqueueUpload	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueUpload(const CudaMem& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const CudaMem& src, GpuMat& dst)
cv::gpu::Stream::enqueueUpload	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueUpload(const Mat& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Mat& src, GpuMat& dst)
cv::gpu::Stream::impl	/usr/include/opencv2/gpu/gpu.hpp	/^            Impl *impl;$/;"	m	class:cv::gpu::Stream	access:private
cv::gpu::Stream::operator =	/usr/include/opencv2/gpu/gpu.hpp	/^            Stream& operator=(const Stream&);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Stream&)
cv::gpu::Stream::queryIfComplete	/usr/include/opencv2/gpu/gpu.hpp	/^            bool queryIfComplete();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
cv::gpu::Stream::release	/usr/include/opencv2/gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::Stream	access:private	signature:()
cv::gpu::Stream::waitForCompletion	/usr/include/opencv2/gpu/gpu.hpp	/^            void waitForCompletion();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
cv::gpu::Stream::~Stream	/usr/include/opencv2/gpu/gpu.hpp	/^            ~Stream();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
cv::gpu::StreamAccessor	/usr/include/opencv2/gpu/stream_accessor.hpp	/^        struct StreamAccessor$/;"	s	namespace:cv::gpu
cv::gpu::StreamAccessor::getStream	/usr/include/opencv2/gpu/stream_accessor.hpp	/^            CV_EXPORTS static cudaStream_t getStream(const Stream& stream);$/;"	p	struct:cv::gpu::StreamAccessor	access:public	signature:(const Stream& stream)
cv::gpu::absdiff	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void absdiff(const GpuMat& a, const GpuMat& b, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c)
cv::gpu::absdiff	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void absdiff(const GpuMat& a, const Scalar& s, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& s, GpuMat& c)
cv::gpu::add	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void add(const GpuMat& a, const GpuMat& b, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c)
cv::gpu::add	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void add(const GpuMat& a, const Scalar& sc, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c)
cv::gpu::bitwise_and	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_and(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream)
cv::gpu::bitwise_and	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_and(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat())
cv::gpu::bitwise_not	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_not(const GpuMat& src, GpuMat& dst, const GpuMat& mask, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const GpuMat& mask, const Stream& stream)
cv::gpu::bitwise_not	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_not(const GpuMat& src, GpuMat& dst, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const GpuMat& mask=GpuMat())
cv::gpu::bitwise_or	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_or(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream)
cv::gpu::bitwise_or	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_or(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat())
cv::gpu::bitwise_xor	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_xor(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, const Stream& stream)
cv::gpu::bitwise_xor	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_xor(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat())
cv::gpu::blur	/usr/include/opencv2/gpu/gpu.hpp	/^        static inline void blur(const GpuMat& src, GpuMat& dst, Size ksize, Point anchor = Point(-1,-1)) { boxFilter(src, dst, -1, ksize, anchor); }$/;"	f	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size ksize, Point anchor = Point(-1,-1))
cv::gpu::boxFilter	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void boxFilter(const GpuMat& src, GpuMat& dst, int ddepth, Size ksize, Point anchor = Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, Size ksize, Point anchor = Point(-1,-1))
cv::gpu::cartToPolar	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cartToPolar(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees = false)
cv::gpu::cartToPolar	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cartToPolar(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees, const Stream& stream)
cv::gpu::compare	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void compare(const GpuMat& a, const GpuMat& b, GpuMat& c, int cmpop);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, int cmpop)
cv::gpu::copyMakeBorder	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void copyMakeBorder(const GpuMat& src, GpuMat& dst, int top, int bottom, int left, int right, const Scalar& value = Scalar());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int top, int bottom, int left, int right, const Scalar& value = Scalar())
cv::gpu::cornerHarris	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cornerHarris(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101)
cv::gpu::cornerMinEigenVal	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cornerMinEigenVal(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, int borderType=BORDER_REFLECT101)
cv::gpu::countNonZero	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS int countNonZero(const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
cv::gpu::countNonZero	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS int countNonZero(const GpuMat& src, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& buf)
cv::gpu::createBoxFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createBoxFilter_GPU(int srcType, int dstType, const Size& ksize, $/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, const Point& anchor = Point(-1,-1))
cv::gpu::createDerivFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createDerivFilter_GPU(int srcType, int dstType, int dx, int dy, int ksize);$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, int dx, int dy, int ksize)
cv::gpu::createFilter2D_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createFilter2D_GPU(const Ptr<BaseFilter_GPU> filter2D);$/;"	p	namespace:cv::gpu	signature:(const Ptr<BaseFilter_GPU> filter2D)
cv::gpu::createGaussianFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createGaussianFilter_GPU(int type, Size ksize, double sigma1, double sigma2 = 0);$/;"	p	namespace:cv::gpu	signature:(int type, Size ksize, double sigma1, double sigma2 = 0)
cv::gpu::createLinearFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createLinearFilter_GPU(int srcType, int dstType, const Mat& kernel, $/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& kernel, const Point& anchor = Point(-1,-1))
cv::gpu::createMorphologyFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createMorphologyFilter_GPU(int op, int type, const Mat& kernel, $/;"	p	namespace:cv::gpu	signature:(int op, int type, const Mat& kernel, const Point& anchor = Point(-1,-1), int iterations = 1)
cv::gpu::createSeparableFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createSeparableFilter_GPU(const Ptr<BaseRowFilter_GPU>& rowFilter, $/;"	p	namespace:cv::gpu	signature:(const Ptr<BaseRowFilter_GPU>& rowFilter, const Ptr<BaseColumnFilter_GPU>& columnFilter)
cv::gpu::createSeparableLinearFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createSeparableLinearFilter_GPU(int srcType, int dstType, const Mat& rowKernel, $/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& rowKernel, const Mat& columnKernel, const Point& anchor = Point(-1,-1))
cv::gpu::cvtColor	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cvtColor(const GpuMat& src, GpuMat& dst, int code, int dcn = 0);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int code, int dcn = 0)
cv::gpu::cvtColor	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cvtColor(const GpuMat& src, GpuMat& dst, int code, int dcn, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int code, int dcn, const Stream& stream)
cv::gpu::dilate	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void dilate( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1);$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1)
cv::gpu::divide	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void divide(const GpuMat& a, const GpuMat& b, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c)
cv::gpu::divide	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void divide(const GpuMat& a, const Scalar& sc, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c)
cv::gpu::drawColorDisp	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void drawColorDisp(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp)
cv::gpu::drawColorDisp	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void drawColorDisp(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp, const Stream& stream)
cv::gpu::erode	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void erode( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1);$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1)
cv::gpu::error	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void error(const char *error_string, const char *file, const int line, const char *func);$/;"	p	namespace:cv::gpu	signature:(const char *error_string, const char *file, const int line, const char *func)
cv::gpu::evenLevels	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void evenLevels(GpuMat& levels, int nLevels, int lowerLevel, int upperLevel);$/;"	p	namespace:cv::gpu	signature:(GpuMat& levels, int nLevels, int lowerLevel, int upperLevel)
cv::gpu::exp	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void exp(const GpuMat& a, GpuMat& b);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b)
cv::gpu::filter2D	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void filter2D(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernel, Point anchor=Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernel, Point anchor=Point(-1,-1))
cv::gpu::flip	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void flip(const GpuMat& a, GpuMat& b, int flipCode);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b, int flipCode)
cv::gpu::getBoxFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getBoxFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1, -1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1, -1))
cv::gpu::getColumnSumFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseColumnFilter_GPU> getColumnSumFilter_GPU(int sumType, int dstType, int ksize, int anchor = -1);$/;"	p	namespace:cv::gpu	signature:(int sumType, int dstType, int ksize, int anchor = -1)
cv::gpu::getComputeCapability	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void getComputeCapability(int device, int& major, int& minor);$/;"	p	namespace:cv::gpu	signature:(int device, int& major, int& minor)
cv::gpu::getCudaEnabledDeviceCount	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS int getCudaEnabledDeviceCount();$/;"	p	namespace:cv::gpu	signature:()
cv::gpu::getDevice	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS int getDevice();$/;"	p	namespace:cv::gpu	signature:()
cv::gpu::getDeviceName	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS string getDeviceName(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
cv::gpu::getGpuMemInfo	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void getGpuMemInfo(size_t& free, size_t& total);$/;"	p	namespace:cv::gpu	signature:(size_t& free, size_t& total)
cv::gpu::getLinearColumnFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseColumnFilter_GPU> getLinearColumnFilter_GPU(int bufType, int dstType, const Mat& columnKernel, $/;"	p	namespace:cv::gpu	signature:(int bufType, int dstType, const Mat& columnKernel, int anchor = -1)
cv::gpu::getLinearFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getLinearFilter_GPU(int srcType, int dstType, const Mat& kernel, const Size& ksize, $/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& kernel, const Size& ksize, Point anchor = Point(-1, -1))
cv::gpu::getLinearRowFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseRowFilter_GPU> getLinearRowFilter_GPU(int srcType, int bufType, const Mat& rowKernel, $/;"	p	namespace:cv::gpu	signature:(int srcType, int bufType, const Mat& rowKernel, int anchor = -1)
cv::gpu::getMaxFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMaxFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1))
cv::gpu::getMinFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMinFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1))
cv::gpu::getMorphologyFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMorphologyFilter_GPU(int op, int type, const Mat& kernel, const Size& ksize, $/;"	p	namespace:cv::gpu	signature:(int op, int type, const Mat& kernel, const Size& ksize, Point anchor=Point(-1,-1))
cv::gpu::getNumberOfSMs	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS int getNumberOfSMs(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
cv::gpu::getRowSumFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseRowFilter_GPU> getRowSumFilter_GPU(int srcType, int sumType, int ksize, int anchor = -1);$/;"	p	namespace:cv::gpu	signature:(int srcType, int sumType, int ksize, int anchor = -1)
cv::gpu::graphcut	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void graphcut(GpuMat& terminals, GpuMat& leftTransp, GpuMat& rightTransp, GpuMat& top, GpuMat& bottom, GpuMat& labels, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(GpuMat& terminals, GpuMat& leftTransp, GpuMat& rightTransp, GpuMat& top, GpuMat& bottom, GpuMat& labels, GpuMat& buf)
cv::gpu::hasAtomicsSupport	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS bool hasAtomicsSupport(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
cv::gpu::hasNativeDoubleSupport	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS bool hasNativeDoubleSupport(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
cv::gpu::histEven	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat hist[4], int histSize[4], int lowerLevel[4], int upperLevel[4]);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], int histSize[4], int lowerLevel[4], int upperLevel[4])
cv::gpu::histEven	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat& hist, int histSize, int lowerLevel, int upperLevel);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, int histSize, int lowerLevel, int upperLevel)
cv::gpu::histRange	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4]);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4])
cv::gpu::histRange	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat& hist, const GpuMat& levels);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, const GpuMat& levels)
cv::gpu::integral	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void integral(GpuMat& src, GpuMat& sum, GpuMat& sqsum);$/;"	p	namespace:cv::gpu	signature:(GpuMat& src, GpuMat& sum, GpuMat& sqsum)
cv::gpu::log	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void log(const GpuMat& a, GpuMat& b);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b)
cv::gpu::magnitude	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitude(const GpuMat& x, GpuMat& magnitude);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, GpuMat& magnitude)
cv::gpu::magnitude	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitude(const GpuMat& x, const GpuMat& y, GpuMat& magnitude);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude)
cv::gpu::magnitude	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitude(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, const Stream& stream)
cv::gpu::magnitudeSqr	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitudeSqr(const GpuMat& x, GpuMat& magnitude);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, GpuMat& magnitude)
cv::gpu::magnitudeSqr	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitudeSqr(const GpuMat& x, const GpuMat& y, GpuMat& magnitude);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude)
cv::gpu::magnitudeSqr	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitudeSqr(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, const Stream& stream)
cv::gpu::meanShiftFiltering	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftFiltering(const GpuMat& src, GpuMat& dst, int sp, int sr, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int sp, int sr, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
cv::gpu::meanShiftProc	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftProc(const GpuMat& src, GpuMat& dstr, GpuMat& dstsp, int sp, int sr, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dstr, GpuMat& dstsp, int sp, int sr, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
cv::gpu::meanShiftSegmentation	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftSegmentation(const GpuMat& src, Mat& dst, int sp, int sr, int minsize,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, Mat& dst, int sp, int sr, int minsize, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
cv::gpu::meanStdDev	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void meanStdDev(const GpuMat& mtx, Scalar& mean, Scalar& stddev);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& mtx, Scalar& mean, Scalar& stddev)
cv::gpu::merge	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void merge(const GpuMat* src, size_t n, GpuMat& dst);$/;"	p	namespace:cv::gpu	signature:(const GpuMat* src, size_t n, GpuMat& dst)
cv::gpu::merge	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void merge(const GpuMat* src, size_t n, GpuMat& dst, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat* src, size_t n, GpuMat& dst, const Stream& stream)
cv::gpu::merge	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void merge(const vector<GpuMat>& src, GpuMat& dst);$/;"	p	namespace:cv::gpu	signature:(const vector<GpuMat>& src, GpuMat& dst)
cv::gpu::merge	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void merge(const vector<GpuMat>& src, GpuMat& dst, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const vector<GpuMat>& src, GpuMat& dst, const Stream& stream)
cv::gpu::minMax	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void minMax(const GpuMat& src, double* minVal, double* maxVal, const GpuMat& mask, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal, const GpuMat& mask, GpuMat& buf)
cv::gpu::minMax	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void minMax(const GpuMat& src, double* minVal, double* maxVal=0, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal=0, const GpuMat& mask=GpuMat())
cv::gpu::minMaxLoc	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void minMaxLoc(const GpuMat& src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, const GpuMat& mask, GpuMat& valbuf, GpuMat& locbuf)
cv::gpu::minMaxLoc	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void minMaxLoc(const GpuMat& src, double* minVal, double* maxVal=0, Point* minLoc=0, Point* maxLoc=0, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal=0, Point* minLoc=0, Point* maxLoc=0, const GpuMat& mask=GpuMat())
cv::gpu::morphologyEx	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void morphologyEx( const GpuMat& src, GpuMat& dst, int op, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1);$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, int op, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1)
cv::gpu::multiply	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void multiply(const GpuMat& a, const GpuMat& b, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c)
cv::gpu::multiply	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void multiply(const GpuMat& a, const Scalar& sc, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c)
cv::gpu::norm	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS double norm(const GpuMat& src1, const GpuMat& src2, int normType=NORM_L2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, int normType=NORM_L2)
cv::gpu::norm	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS double norm(const GpuMat& src1, int normType=NORM_L2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, int normType=NORM_L2)
cv::gpu::nppError	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void nppError( int err, const char *file, const int line, const char *func);        $/;"	p	namespace:cv::gpu	signature:( int err, const char *file, const int line, const char *func)
cv::gpu::operator &	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS GpuMat operator & (const GpuMat& src1, const GpuMat& src2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2)
cv::gpu::operator ^	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS GpuMat operator ^ (const GpuMat& src1, const GpuMat& src2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2)
cv::gpu::operator |	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS GpuMat operator | (const GpuMat& src1, const GpuMat& src2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2)
cv::gpu::operator ~	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS GpuMat operator ~ (const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
cv::gpu::phase	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void phase(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees = false)
cv::gpu::phase	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void phase(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees, const Stream& stream)
cv::gpu::polarToCart	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void polarToCart(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees = false)
cv::gpu::polarToCart	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void polarToCart(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees, const Stream& stream)
cv::gpu::rectStdDev	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void rectStdDev(const GpuMat& src, const GpuMat& sqr, GpuMat& dst, const Rect& rect);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const GpuMat& sqr, GpuMat& dst, const Rect& rect)
cv::gpu::remap	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void remap(const GpuMat& src, GpuMat& dst, const GpuMat& xmap, const GpuMat& ymap);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const GpuMat& xmap, const GpuMat& ymap)
cv::gpu::reprojectImageTo3D	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void reprojectImageTo3D(const GpuMat& disp, GpuMat& xyzw, const Mat& Q);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& disp, GpuMat& xyzw, const Mat& Q)
cv::gpu::reprojectImageTo3D	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void reprojectImageTo3D(const GpuMat& disp, GpuMat& xyzw, const Mat& Q, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& disp, GpuMat& xyzw, const Mat& Q, const Stream& stream)
cv::gpu::resize	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void resize(const GpuMat& src, GpuMat& dst, Size dsize, double fx=0, double fy=0, int interpolation = INTER_LINEAR);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size dsize, double fx=0, double fy=0, int interpolation = INTER_LINEAR)
cv::gpu::rotate	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void rotate(const GpuMat& src, GpuMat& dst, Size dsize, double angle, double xShift = 0, double yShift = 0, int interpolation = INTER_LINEAR);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size dsize, double angle, double xShift = 0, double yShift = 0, int interpolation = INTER_LINEAR)
cv::gpu::sepFilter2D	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void sepFilter2D(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY, Point anchor = Point(-1,-1))
cv::gpu::setDevice	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void setDevice(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
cv::gpu::split	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, GpuMat* dst);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat* dst)
cv::gpu::split	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, GpuMat* dst, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat* dst, const Stream& stream)
cv::gpu::split	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, vector<GpuMat>& dst);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, vector<GpuMat>& dst)
cv::gpu::split	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, vector<GpuMat>& dst, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, vector<GpuMat>& dst, const Stream& stream)
cv::gpu::subtract	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void subtract(const GpuMat& a, const GpuMat& b, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c)
cv::gpu::subtract	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void subtract(const GpuMat& a, const Scalar& sc, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c)
cv::gpu::sum	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Scalar sum(const GpuMat& m);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& m)
cv::gpu::swap	/usr/include/opencv2/gpu/matrix_operations.hpp	/^static inline void swap( GpuMat& a, GpuMat& b ) { a.swap(b); }$/;"	f	namespace:cv::gpu	signature:( GpuMat& a, GpuMat& b )
cv::gpu::threshold	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS double threshold(const GpuMat& src, GpuMat& dst, double thresh);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, double thresh)
cv::gpu::transpose	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void transpose(const GpuMat& src1, GpuMat& dst);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, GpuMat& dst)
cv::gpu::warpAffine	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void warpAffine(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR)
cv::gpu::warpPerspective	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void warpPerspective(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR)
cv::grabCut	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void grabCut( const Mat& img, Mat& mask, Rect rect, $/;"	p	namespace:cv	signature:( const Mat& img, Mat& mask, Rect rect, Mat& bgdModel, Mat& fgdModel, int iterCount, int mode = GC_EVAL )
cv::groupRectangles	/usr/include/opencv2/objdetect/objdetect.hpp	/^CV_EXPORTS_W void groupRectangles(vector<Rect>& rectList, CV_OUT vector<int>& weights, int groupThreshold, double eps=0.2);$/;"	p	namespace:cv	signature:(vector<Rect>& rectList, CV_OUT vector<int>& weights, int groupThreshold, double eps=0.2)
cv::groupRectangles	/usr/include/opencv2/objdetect/objdetect.hpp	/^CV_EXPORTS_W void groupRectangles(vector<Rect>& rectList, int groupThreshold, double eps=0.2);$/;"	p	namespace:cv	signature:(vector<Rect>& rectList, int groupThreshold, double eps=0.2)
cv::hconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void hconcat(const Mat& src1, const Mat& src2, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, Mat& dst)
cv::hconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void hconcat(const Mat* src, size_t nsrc, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrc, Mat& dst)
cv::hconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void hconcat(const vector<Mat>& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const vector<Mat>& src, CV_OUT Mat& dst)
cv::idct	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void idct(const Mat& src, CV_OUT Mat& dst, int flags=0);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags=0)
cv::idft	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void idft(const Mat& src, CV_OUT Mat& dst, int flags=0, int nonzeroRows=0);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags=0, int nonzeroRows=0)
cv::imdecode	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W Mat imdecode( const Mat& buf, int flags );$/;"	p	namespace:cv	signature:( const Mat& buf, int flags )
cv::imencode	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W bool imencode( const string& ext, const Mat& img,$/;"	p	namespace:cv	signature:( const string& ext, const Mat& img, CV_OUT vector<uchar>& buf, const vector<int>& params=vector<int>())
cv::imread	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W Mat imread( const string& filename, int flags=1 );$/;"	p	namespace:cv	signature:( const string& filename, int flags=1 )
cv::imshow	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W void imshow( const string& winname, const Mat& mat );$/;"	p	namespace:cv	signature:( const string& winname, const Mat& mat )
cv::imwrite	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W bool imwrite( const string& filename, const Mat& img,$/;"	p	namespace:cv	signature:( const string& filename, const Mat& img, const vector<int>& params=vector<int>())
cv::inRange	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void inRange(const Mat& src, const Mat& lowerb,$/;"	p	namespace:cv	signature:(const Mat& src, const Mat& lowerb, const Mat& upperb, CV_OUT Mat& dst)
cv::inRange	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void inRange(const Mat& src, const Scalar& lowerb,$/;"	p	namespace:cv	signature:(const Mat& src, const Scalar& lowerb, const Scalar& upperb, CV_OUT Mat& dst)
cv::initCameraMatrix2D	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat initCameraMatrix2D( const vector<vector<Point3f> >& objectPoints,$/;"	p	namespace:cv	signature:( const vector<vector<Point3f> >& objectPoints, const vector<vector<Point2f> >& imagePoints, Size imageSize, double aspectRatio=1. )
cv::initUndistortRectifyMap	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void initUndistortRectifyMap( const Mat& cameraMatrix, const Mat& distCoeffs,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix, const Mat& distCoeffs, const Mat& R, const Mat& newCameraMatrix, Size size, int m1type, CV_OUT Mat& map1, CV_OUT Mat& map2 )
cv::initWideAngleProjMap	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W float initWideAngleProjMap( const Mat& cameraMatrix, const Mat& distCoeffs,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix, const Mat& distCoeffs, Size imageSize, int destImageWidth, int m1type, CV_OUT Mat& map1, CV_OUT Mat& map2, int projType=PROJ_SPHERICAL_EQRECT, double alpha=0)
cv::inpaint	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void inpaint( const Mat& src, const Mat& inpaintMask,$/;"	p	namespace:cv	signature:( const Mat& src, const Mat& inpaintMask, CV_OUT Mat& dst, double inpaintRange, int flags )
cv::insertImageCOI	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void insertImageCOI(const Mat& coiimg, CvArr* arr, int coi=-1);$/;"	p	namespace:cv	signature:(const Mat& coiimg, CvArr* arr, int coi=-1)
cv::integral	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(integral2) void integral( const Mat& src, CV_OUT Mat& sum, CV_OUT Mat& sqsum, int sdepth=-1 );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& sum, CV_OUT Mat& sqsum, int sdepth=-1 )
cv::integral	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(integral3) void integral( const Mat& src, CV_OUT Mat& sum, CV_OUT Mat& sqsum, CV_OUT Mat& tilted, int sdepth=-1 );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& sum, CV_OUT Mat& sqsum, CV_OUT Mat& tilted, int sdepth=-1 )
cv::integral	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void integral( const Mat& src, CV_OUT Mat& sum, int sdepth=-1 );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& sum, int sdepth=-1 )
cv::invert	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double invert(const Mat& src, CV_OUT Mat& dst, int flags=DECOMP_LU);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags=DECOMP_LU)
cv::invertAffineTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void invertAffineTransform( const Mat& M, CV_OUT Mat& iM );$/;"	p	namespace:cv	signature:( const Mat& M, CV_OUT Mat& iM )
cv::isContourConvex	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W bool isContourConvex( const Mat& contour );$/;"	p	namespace:cv	signature:( const Mat& contour )
cv::kmeans	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double kmeans( const Mat& data, int K, CV_OUT Mat& bestLabels,$/;"	p	namespace:cv	signature:( const Mat& data, int K, CV_OUT Mat& bestLabels, TermCriteria criteria, int attempts, int flags, CV_OUT Mat* centers=0 )
cv::line	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void line(Mat& img, Point pt1, Point pt2, const Scalar& color,$/;"	p	namespace:cv	signature:(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
cv::loadWindowParameters	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void loadWindowParameters(const string& windowName);$/;"	p	namespace:cv	signature:(const string& windowName)
cv::log	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void log(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
cv::magnitude	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void magnitude(const Mat& x, const Mat& y, CV_OUT Mat& magnitude);$/;"	p	namespace:cv	signature:(const Mat& x, const Mat& y, CV_OUT Mat& magnitude)
cv::matMulDeriv	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void matMulDeriv( const Mat& A, const Mat& B, CV_OUT Mat& dABdA, CV_OUT Mat& dABdB );$/;"	p	namespace:cv	signature:( const Mat& A, const Mat& B, CV_OUT Mat& dABdA, CV_OUT Mat& dABdB )
cv::matchShapes	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double matchShapes( const Mat& contour1,$/;"	p	namespace:cv	signature:( const Mat& contour1, const Mat& contour2, int method, double parameter )
cv::matchTemplate	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void matchTemplate( const Mat& image, const Mat& templ, CV_OUT Mat& result, int method );$/;"	p	namespace:cv	signature:( const Mat& image, const Mat& templ, CV_OUT Mat& result, int method )
cv::max	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void max(const Mat& src1, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst)
cv::max	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void max(const Mat& src1, double src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, double src2, CV_OUT Mat& dst)
cv::max	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr max(const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::max	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr max(const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::max	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr max(double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::max	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::max	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
cv::max	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(double s, const Mat_<_Tp>& a)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a)
cv::mean	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS Scalar mean(const Mat& src);$/;"	p	namespace:cv	signature:(const Mat& src)
cv::mean	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W Scalar mean(const Mat& src, const Mat& mask CV_WRAP_DEFAULT(Mat()));$/;"	p	namespace:cv	signature:(const Mat& src, const Mat& mask CV_WRAP_DEFAULT(Mat()))
cv::meanShift	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W int meanShift( const Mat& probImage, CV_IN_OUT Rect& window,$/;"	p	namespace:cv	signature:( const Mat& probImage, CV_IN_OUT Rect& window, TermCriteria criteria )
cv::meanStdDev	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void meanStdDev(const Mat& src, CV_OUT Scalar& mean, CV_OUT Scalar& stddev, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Scalar& mean, CV_OUT Scalar& stddev, const Mat& mask=Mat())
cv::medianBlur	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void medianBlur( const Mat& src, CV_OUT Mat& dst, int ksize );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ksize )
cv::merge	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void merge(const Mat* mv, size_t count, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat* mv, size_t count, CV_OUT Mat& dst)
cv::merge	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void merge(const vector<Mat>& mv, Mat& dst);$/;"	p	namespace:cv	signature:(const vector<Mat>& mv, Mat& dst)
cv::min	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void min(const Mat& src1, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst)
cv::min	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void min(const Mat& src1, double src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, double src2, CV_OUT Mat& dst)
cv::min	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr min(const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::min	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr min(const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::min	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr min(double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::min	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::min	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
cv::min	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(double s, const Mat_<_Tp>& a)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a)
cv::minAreaRect	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W RotatedRect minAreaRect( const Mat& points );$/;"	p	namespace:cv	signature:( const Mat& points )
cv::minEnclosingCircle	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void minEnclosingCircle( const Mat& points,$/;"	p	namespace:cv	signature:( const Mat& points, Point2f& center, float& radius )
cv::minMaxIdx	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void minMaxIdx(const Mat& src, double* minVal, double* maxVal,$/;"	p	namespace:cv	signature:(const Mat& src, double* minVal, double* maxVal, int* minIdx=0, int* maxIdx=0, const Mat& mask=Mat())
cv::minMaxLoc	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void minMaxLoc(const SparseMat& a, double* minVal,$/;"	p	namespace:cv	signature:(const SparseMat& a, double* minVal, double* maxVal, int* minIdx=0, int* maxIdx=0)
cv::minMaxLoc	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void minMaxLoc(const Mat& src, CV_OUT double* minVal,$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT double* minVal, CV_OUT double* maxVal=0, CV_OUT Point* minLoc=0, CV_OUT Point* maxLoc=0, const Mat& mask=Mat())
cv::mixChannels	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts,$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)
cv::mixChannels	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void mixChannels(const vector<Mat>& src, vector<Mat>& dst,$/;"	p	namespace:cv	signature:(const vector<Mat>& src, vector<Mat>& dst, const int* fromTo, int npairs)
cv::moments	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Moments moments( const Mat& array, bool binaryImage=false );$/;"	p	namespace:cv	signature:( const Mat& array, bool binaryImage=false )
cv::morphologyDefaultBorderValue	/usr/include/opencv2/imgproc/imgproc.hpp	/^static inline Scalar morphologyDefaultBorderValue() { return Scalar::all(DBL_MAX); }$/;"	f	namespace:cv	signature:()
cv::morphologyEx	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void morphologyEx( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int op, const Mat& kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
cv::mulSpectrums	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void mulSpectrums(const Mat& a, const Mat& b, CV_OUT Mat& c,$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b, CV_OUT Mat& c, int flags, bool conjB=false)
cv::mulTransposed	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void mulTransposed( const Mat& src, CV_OUT Mat& dst, bool aTa,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, bool aTa, const Mat& delta=Mat(), double scale=1, int rtype=-1 )
cv::multiply	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void multiply(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, double scale=1);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, double scale=1)
cv::namedWindow	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W void namedWindow( const string& winname, int flags CV_DEFAULT(WINDOW_AUTOSIZE) );$/;"	p	namespace:cv	signature:( const string& winname, int flags CV_DEFAULT(WINDOW_AUTOSIZE) )
cv::norm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS double norm( const SparseMat& src, int normType );$/;"	p	namespace:cv	signature:( const SparseMat& src, int normType )
cv::norm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS double norm(const Mat& src1, const Mat& src2, int normType=NORM_L2);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, int normType=NORM_L2)
cv::norm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS double norm(const Mat& src1, int normType=NORM_L2);$/;"	p	namespace:cv	signature:(const Mat& src1, int normType=NORM_L2)
cv::norm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double norm(const Mat& src1, const Mat& src2,$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, int normType, const Mat& mask CV_WRAP_DEFAULT(Mat()))
cv::norm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double norm(const Mat& src1, int normType, const Mat& mask CV_WRAP_DEFAULT(Mat()));$/;"	p	namespace:cv	signature:(const Mat& src1, int normType, const Mat& mask CV_WRAP_DEFAULT(Mat()))
cv::norm	/usr/include/opencv2/core/operations.hpp	/^double norm(const Matx<_Tp, m, n>& M)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& M)
cv::norm	/usr/include/opencv2/core/operations.hpp	/^double norm(const Matx<_Tp, m, n>& M, int normType)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& M, int normType)
cv::norm	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline double norm(const Point3_<_Tp>& pt)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& pt)
cv::norm	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline double norm(const Point_<_Tp>& pt)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& pt)
cv::normalize	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void normalize( const SparseMat& src, SparseMat& dst, double alpha, int normType );$/;"	p	namespace:cv	signature:( const SparseMat& src, SparseMat& dst, double alpha, int normType )
cv::normalize	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void normalize( const Mat& src, CV_OUT Mat& dst, double alpha=1, double beta=0,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, double alpha=1, double beta=0, int norm_type=NORM_L2, int rtype=-1, const Mat& mask=Mat())
cv::operator !	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator !(const Range& r)$/;"	f	namespace:cv	signature:(const Range& r)
cv::operator !=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator != (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator !=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator != (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator !=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator != (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator !=	/usr/include/opencv2/core/mat.hpp	/^operator != (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator !=	/usr/include/opencv2/core/mat.hpp	/^operator != (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
cv::operator !=	/usr/include/opencv2/core/mat.hpp	/^operator != (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
cv::operator !=	/usr/include/opencv2/core/mat.hpp	/^static inline bool operator != (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)$/;"	f	namespace:cv	signature:(const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
cv::operator !=	/usr/include/opencv2/core/operations.hpp	/^bool operator != (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator !=	/usr/include/opencv2/core/operations.hpp	/^bool operator != (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
cv::operator !=	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator != (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
cv::operator !=	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator != (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
cv::operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool operator != (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
cv::operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator != ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )$/;"	f	namespace:cv	signature:( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
cv::operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
cv::operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator &	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator &	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator &	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
cv::operator &	/usr/include/opencv2/core/operations.hpp	/^static inline Range operator & (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
cv::operator &	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator & (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
cv::operator &=	/usr/include/opencv2/core/mat.hpp	/^operator &= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator &=	/usr/include/opencv2/core/mat.hpp	/^operator &= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
cv::operator &=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator &= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator &=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator &= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator &=	/usr/include/opencv2/core/operations.hpp	/^static inline Range& operator &= (Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(Range& r1, const Range& r2)
cv::operator &=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator &= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Rect_<_Tp>& b )
cv::operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
cv::operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
cv::operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e, double s);$/;"	p	namespace:cv	signature:(const MatExpr& e, double s)
cv::operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
cv::operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (double s, const MatExpr& e);$/;"	p	namespace:cv	signature:(double s, const MatExpr& e)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator * (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator * (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator * (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, 4, 1> operator * (const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, double alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, double alpha)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, float alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, float alpha)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, int alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, int alpha)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (double alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(double alpha, const Matx<_Tp, m, n>& a)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (float alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(float alpha, const Matx<_Tp, m, n>& a)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (int alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(int alpha, const Matx<_Tp, m, n>& a)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Point_<_Tp> operator * (const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^Scalar operator * (const Matx<_Tp, 4, 4>& a, const Scalar& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 4, 4>& a, const Scalar& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^operator * (_Tp alpha, const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(_Tp alpha, const Vec<_Tp, cn>& a)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^operator * (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^operator * (const Vec<_Tp, 4>& a, const Vec<_Tp, 4>& b)$/;"	f	namespace:cv	signature:(const Vec<_Tp, 4>& a, const Vec<_Tp, 4>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^operator * (const Vec<_Tp, cn>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, _Tp alpha)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, double b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, float b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, int b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (double a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(double a, const Point3_<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (float a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(float a, const Point3_<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (int a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(int a, const Point3_<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, double b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, float b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, int b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (double a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(double a, const Point_<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (float a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(float a, const Point_<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (int a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(int a, const Point_<_Tp>& b)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp alpha, const Scalar_<_Tp>& a)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, _Tp alpha)
cv::operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator * (const Size_<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, _Tp b)
cv::operator *=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
cv::operator *=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator *=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
cv::operator *=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator *=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
cv::operator *=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, double s)$/;"	f	namespace:cv	signature:(const Mat& a, double s)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator *= (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, double alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, double alpha)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, float alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, float alpha)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, int alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, int alpha)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^Vec<_Tp, 2>& operator *= (Vec<_Tp, 2>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, 2>& a, _Tp alpha)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^Vec<_Tp, 3>& operator *= (Vec<_Tp, 3>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, 3>& a, _Tp alpha)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^Vec<_Tp, 4>& operator *= (Vec<_Tp, 4>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, 4>& a, _Tp alpha)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point3_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, double b)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point3_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, float b)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point3_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, int b)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, double b)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, float b)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, int b)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Vec<_Tp, 4>& a, const Vec<_Tp, 4>& b)$/;"	f	namespace:cv	signature:(Vec<_Tp, 4>& a, const Vec<_Tp, 4>& b)
cv::operator *=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator *= ( Scalar_<_Tp>& a, _Tp v )$/;"	f	namespace:cv	signature:( Scalar_<_Tp>& a, _Tp v )
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e, const Scalar& s);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Scalar& s)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Scalar& s, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Scalar& s, const MatExpr& e)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^operator + (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^operator + (const MatIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, ptrdiff_t ofs)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^operator + (ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^operator + (ptrdiff_t ofs, const MatIterator_<_Tp>& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatIterator_<_Tp>& a)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^static inline MatConstIterator operator + (const MatConstIterator& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, ptrdiff_t ofs)
cv::operator +	/usr/include/opencv2/core/mat.hpp	/^static inline MatConstIterator operator + (ptrdiff_t ofs, const MatConstIterator& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatConstIterator& a)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator + (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator + (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator + (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator + (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^operator + (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^static inline Range operator + (const Range& r1, int delta)$/;"	f	namespace:cv	signature:(const Range& r1, int delta)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^static inline Range operator + (int delta, const Range& r1)$/;"	f	namespace:cv	signature:(int delta, const Range& r1)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator + (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator + (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Point_<_Tp>& b)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Size_<_Tp>& b)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator + (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator + (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator +=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
cv::operator +=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator +=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
cv::operator +=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator +=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
cv::operator +=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator += (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator += (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp1, m, n>& operator += (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)$/;"	f	namespace:cv	signature:(Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^Vec<T1, 2>& operator += (Vec<T1, 2>& a, const Vec<T2, 2>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 2>& a, const Vec<T2, 2>& b)
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^Vec<T1, 3>& operator += (Vec<T1, 3>& a, const Vec<T2, 3>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 3>& a, const Vec<T2, 3>& b)
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^Vec<T1, 4>& operator += (Vec<T1, 4>& a, const Vec<T2, 4>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 4>& a, const Vec<T2, 4>& b)
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^operator += (Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^operator += (Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^operator += (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)$/;"	f	namespace:cv	signature:(Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Point_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Point_<_Tp>& b )
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Size_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Size_<_Tp>& b )
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator += (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator +=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp>& operator += (Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e);$/;"	p	namespace:cv	signature:(const MatExpr& e)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e, const Scalar& s);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Scalar& s)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Scalar& s, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Scalar& s, const MatExpr& e)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS ptrdiff_t operator - (const MatConstIterator& b, const MatConstIterator& a);$/;"	p	namespace:cv	signature:(const MatConstIterator& b, const MatConstIterator& a)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^operator - (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^operator - (const MatIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, ptrdiff_t ofs)
cv::operator -	/usr/include/opencv2/core/mat.hpp	/^static inline MatConstIterator operator - (const MatConstIterator& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, ptrdiff_t ofs)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator - (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^operator - (const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^operator - (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^static inline Range operator - (const Range& r1, int delta)$/;"	f	namespace:cv	signature:(const Range& r1, int delta)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^static inline ptrdiff_t operator - (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline ptrdiff_t operator - (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator - (const Rect_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Point_<_Tp>& b)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator - (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator -=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
cv::operator -=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator -=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
cv::operator -=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator -=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
cv::operator -=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator -=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator -= (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
cv::operator -=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator -= (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator -=	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp1, m, n>& operator -= (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)$/;"	f	namespace:cv	signature:(Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
cv::operator -=	/usr/include/opencv2/core/operations.hpp	/^operator -= (Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator -=	/usr/include/opencv2/core/operations.hpp	/^operator -= (Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator -=	/usr/include/opencv2/core/operations.hpp	/^operator -= (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)$/;"	f	namespace:cv	signature:(Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
cv::operator -=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Point_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Point_<_Tp>& b )
cv::operator -=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Size_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Size_<_Tp>& b )
cv::operator -=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator -= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator -=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp>& operator -= (Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
cv::operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
cv::operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e, double s);$/;"	p	namespace:cv	signature:(const MatExpr& e, double s)
cv::operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e1, const MatExpr& e2);    $/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
cv::operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (double s, const MatExpr& e);$/;"	p	namespace:cv	signature:(double s, const MatExpr& e)
cv::operator /	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator \/ (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
cv::operator /	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator \/ (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
cv::operator /	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator \/ (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator /	/usr/include/opencv2/core/operations.hpp	/^Scalar_<_Tp> operator \/ (_Tp a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(_Tp a, const Scalar_<_Tp>& b)
cv::operator /	/usr/include/opencv2/core/operations.hpp	/^Scalar_<_Tp> operator \/ (const Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, _Tp alpha)
cv::operator /	/usr/include/opencv2/core/operations.hpp	/^Scalar_<_Tp> operator \/ (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator /	/usr/include/opencv2/core/operations.hpp	/^Scalar_<double> operator \/ (const Scalar_<double>& a, double alpha)$/;"	f	namespace:cv	signature:(const Scalar_<double>& a, double alpha)
cv::operator /	/usr/include/opencv2/core/operations.hpp	/^Scalar_<float> operator \/ (const Scalar_<float>& a, float alpha)$/;"	f	namespace:cv	signature:(const Scalar_<float>& a, float alpha)
cv::operator /=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
cv::operator /=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator /=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
cv::operator /=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator /=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
cv::operator /=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, double s)$/;"	f	namespace:cv	signature:(const Mat& a, double s)
cv::operator /=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator \/= (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
cv::operator /=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator \/= (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator /=	/usr/include/opencv2/core/operations.hpp	/^Scalar_<_Tp>& operator \/= (Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, _Tp alpha)
cv::operator /=	/usr/include/opencv2/core/operations.hpp	/^Scalar_<_Tp>& operator \/= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator <	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator < (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator <	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator < (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator <	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator < (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator <	/usr/include/opencv2/core/mat.hpp	/^operator < (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator <	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator < (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
cv::operator <<	/usr/include/opencv2/contrib/contrib.hpp	/^    CV_EXPORTS std::ostream& operator<<(std::ostream& out, const TickMeter& tm);$/;"	p	namespace:cv	signature:(std::ostream& out, const TickMeter& tm)
cv::operator <<	/usr/include/opencv2/core/mat.hpp	/^operator << (const Mat_<_Tp>& m, T2 val)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& m, T2 val)
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS FileStorage& operator << (FileStorage& fs, const string& str);$/;"	p	namespace:cv	signature:(FileStorage& fs, const string& str)
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n> operator << (const Matx<_Tp, m, n>& mtx, _T2 val)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& mtx, _T2 val)
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^VecCommaInitializer<_Tp, cn> operator << (const Vec<_Tp, cn>& vec, _T2 val)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& vec, _T2 val)
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^operator << ( FileStorage& fs, const vector<_Tp>& vec )$/;"	f	namespace:cv	signature:( FileStorage& fs, const vector<_Tp>& vec )
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^static inline FileStorage& operator << (FileStorage& fs, const char* str)$/;"	f	namespace:cv	signature:(FileStorage& fs, const char* str)
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^static inline std::ostream& operator << (std::ostream& out, const Formatted& fmtd)$/;"	f	namespace:cv	signature:(std::ostream& out, const Formatted& fmtd)
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^static inline std::ostream& operator << (std::ostream& out, const Mat& mtx)$/;"	f	namespace:cv	signature:(std::ostream& out, const Mat& mtx)
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point3_<_Tp>& p)$/;"	f	namespace:cv	signature:(std::ostream& out, const Point3_<_Tp>& p)
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point_<_Tp>& p)$/;"	f	namespace:cv	signature:(std::ostream& out, const Point_<_Tp>& p)
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline FileStorage& operator << (FileStorage& fs, const _Tp& value)$/;"	f	namespace:cv	signature:(FileStorage& fs, const _Tp& value)
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,$/;"	f	namespace:cv	signature:(std::ostream& out, const vector<Point3_<_Tp> >& vec)
cv::operator <<	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,$/;"	f	namespace:cv	signature:(std::ostream& out, const vector<Point_<_Tp> >& vec)
cv::operator <=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator <=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator <=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator <=	/usr/include/opencv2/core/mat.hpp	/^operator <= (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator ==	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator == (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator ==	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator == (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator ==	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator == (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator ==	/usr/include/opencv2/core/mat.hpp	/^operator == (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator ==	/usr/include/opencv2/core/mat.hpp	/^operator == (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
cv::operator ==	/usr/include/opencv2/core/mat.hpp	/^operator == (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
cv::operator ==	/usr/include/opencv2/core/mat.hpp	/^static inline bool operator == (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)$/;"	f	namespace:cv	signature:(const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
cv::operator ==	/usr/include/opencv2/core/operations.hpp	/^bool operator == (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator ==	/usr/include/opencv2/core/operations.hpp	/^bool operator == (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
cv::operator ==	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator == (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
cv::operator ==	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator == (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
cv::operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool operator == (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
cv::operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator == ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )$/;"	f	namespace:cv	signature:( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
cv::operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
cv::operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator >	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator > (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator >	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator > (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator >	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator > (double s, const Mat& a);    $/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator >	/usr/include/opencv2/core/mat.hpp	/^operator > (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator >=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator >=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator >=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator >=	/usr/include/opencv2/core/mat.hpp	/^operator >= (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator >>	/usr/include/opencv2/core/operations.hpp	/^FileNodeIterator& operator >> (FileNodeIterator& it, vector<_Tp>& vec)$/;"	f	namespace:cv	signature:(FileNodeIterator& it, vector<_Tp>& vec)
cv::operator >>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline FileNodeIterator& operator >> (FileNodeIterator& it, _Tp& value)$/;"	f	namespace:cv	signature:(FileNodeIterator& it, _Tp& value)
cv::operator >>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline void operator >> (const FileNode& n, _Tp& value)$/;"	f	namespace:cv	signature:(const FileNode& n, _Tp& value)
cv::operator ^	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator ^	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator ^	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
cv::operator ^=	/usr/include/opencv2/core/mat.hpp	/^operator ^= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator ^=	/usr/include/opencv2/core/mat.hpp	/^operator ^= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
cv::operator ^=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator ^= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator ^=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator ^= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator |	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator |	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator |	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
cv::operator |	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator | (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
cv::operator |=	/usr/include/opencv2/core/mat.hpp	/^operator |= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator |=	/usr/include/opencv2/core/mat.hpp	/^operator |= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
cv::operator |=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator |= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator |=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator |= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator |=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator |= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Rect_<_Tp>& b )
cv::operator ~	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator ~(const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
cv::parallel_do	/usr/include/opencv2/core/internal.hpp	/^        void parallel_do( Iterator first, Iterator last, const Body& body )$/;"	f	namespace:cv	signature:( Iterator first, Iterator last, const Body& body )
cv::parallel_for	/usr/include/opencv2/core/internal.hpp	/^        void parallel_for( const BlockedRange& range, const Body& body )$/;"	f	namespace:cv	signature:( const BlockedRange& range, const Body& body )
cv::parallel_reduce	/usr/include/opencv2/core/internal.hpp	/^        void parallel_reduce( const BlockedRange& range, Body& body )$/;"	f	namespace:cv	signature:( const BlockedRange& range, Body& body )
cv::partition	/usr/include/opencv2/core/operations.hpp	/^partition( const vector<_Tp>& _vec, vector<int>& labels,$/;"	f	namespace:cv	signature:( const vector<_Tp>& _vec, vector<int>& labels, _EqPredicate predicate=_EqPredicate())
cv::perspectiveTransform	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void perspectiveTransform(const Mat& src, CV_OUT Mat& dst, const Mat& m );$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, const Mat& m )
cv::phase	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void phase(const Mat& x, const Mat& y, CV_OUT Mat& angle,$/;"	p	namespace:cv	signature:(const Mat& x, const Mat& y, CV_OUT Mat& angle, bool angleInDegrees=false)
cv::pointPolygonTest	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double pointPolygonTest( const Mat& contour,$/;"	p	namespace:cv	signature:( const Mat& contour, Point2f pt, bool measureDist )
cv::polarToCart	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void polarToCart(const Mat& magnitude, const Mat& angle,$/;"	p	namespace:cv	signature:(const Mat& magnitude, const Mat& angle, CV_OUT Mat& x, CV_OUT Mat& y, bool angleInDegrees=false)
cv::polylines	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void polylines(Mat& img, const Point** pts, const int* npts,$/;"	p	namespace:cv	signature:(Mat& img, const Point** pts, const int* npts, int ncontours, bool isClosed, const Scalar& color, int thickness=1, int lineType=8, int shift=0 )
cv::pow	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void pow(const Mat& src, double power, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, double power, CV_OUT Mat& dst)
cv::preCornerDetect	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void preCornerDetect( const Mat& src, CV_OUT Mat& dst, int ksize,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ksize, int borderType=BORDER_DEFAULT )
cv::process	/usr/include/opencv2/core/mat.hpp	/^process( const Mat_<T1>& m1, Mat_<T2>& m2, Op op )$/;"	f	namespace:cv	signature:( const Mat_<T1>& m1, Mat_<T2>& m2, Op op )
cv::process	/usr/include/opencv2/core/mat.hpp	/^process( const Mat_<T1>& m1, const Mat_<T2>& m2, Mat_<T3>& m3, Op op )$/;"	f	namespace:cv	signature:( const Mat_<T1>& m1, const Mat_<T2>& m2, Mat_<T3>& m3, Op op )
cv::projectPoints	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_AS(projectPointsJ) void projectPoints( const Mat& objectPoints,$/;"	p	namespace:cv	signature:( const Mat& objectPoints, const Mat& rvec, const Mat& tvec, const Mat& cameraMatrix, const Mat& distCoeffs, CV_OUT vector<Point2f>& imagePoints, CV_OUT Mat& dpdrot, CV_OUT Mat& dpdt, CV_OUT Mat& dpdf, CV_OUT Mat& dpdc, CV_OUT Mat& dpddist, double aspectRatio=0 )
cv::projectPoints	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void projectPoints( const Mat& objectPoints,$/;"	p	namespace:cv	signature:( const Mat& objectPoints, const Mat& rvec, const Mat& tvec, const Mat& cameraMatrix, const Mat& distCoeffs, CV_OUT vector<Point2f>& imagePoints )
cv::putText	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void putText( Mat& img, const string& text, Point org,$/;"	p	namespace:cv	signature:( Mat& img, const string& text, Point org, int fontFace, double fontScale, Scalar color, int thickness=1, int linetype=8, bool bottomLeftOrigin=false )
cv::pyrDown	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrDown( const Mat& src, CV_OUT Mat& dst, const Size& dstsize=Size());$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Size& dstsize=Size())
cv::pyrMeanShiftFiltering	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrMeanShiftFiltering( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, double sp, double sr, int maxLevel=1, TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) )
cv::pyrUp	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrUp( const Mat& src, CV_OUT Mat& dst, const Size& dstsize=Size());$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Size& dstsize=Size())
cv::randShuffle	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void randShuffle(Mat& dst, double iterFactor=1., RNG* rng=0);$/;"	p	namespace:cv	signature:(Mat& dst, double iterFactor=1., RNG* rng=0)
cv::randn	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void randn(CV_OUT Mat& dst, const Scalar& mean, const Scalar& stddev);$/;"	p	namespace:cv	signature:(CV_OUT Mat& dst, const Scalar& mean, const Scalar& stddev)
cv::randu	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void randu(CV_OUT Mat& dst, const Scalar& low, const Scalar& high);$/;"	p	namespace:cv	signature:(CV_OUT Mat& dst, const Scalar& low, const Scalar& high)
cv::randu	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> static inline _Tp randu() { return (_Tp)theRNG(); }$/;"	f	namespace:cv	signature:()
cv::read	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void read(const FileNode& node, SparseMat& mat, const SparseMat& default_mat=SparseMat() );    $/;"	p	namespace:cv	signature:(const FileNode& node, SparseMat& mat, const SparseMat& default_mat=SparseMat() )
cv::read	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void read(const FileNode& node, Mat& mat, const Mat& default_mat=Mat() );$/;"	p	namespace:cv	signature:(const FileNode& node, Mat& mat, const Mat& default_mat=Mat() )
cv::read	/usr/include/opencv2/core/operations.hpp	/^read( FileNode& node, vector<_Tp>& vec, const vector<_Tp>& default_value=vector<_Tp>() )$/;"	f	namespace:cv	signature:( FileNode& node, vector<_Tp>& vec, const vector<_Tp>& default_value=vector<_Tp>() )
cv::read	/usr/include/opencv2/core/operations.hpp	/^read( FileNodeIterator& it, vector<_Tp>& vec, size_t maxCount=(size_t)INT_MAX )$/;"	f	namespace:cv	signature:( FileNodeIterator& it, vector<_Tp>& vec, size_t maxCount=(size_t)INT_MAX )
cv::read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, bool& value, bool default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, bool& value, bool default_value)
cv::read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, double& value, double default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, double& value, double default_value)
cv::read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, float& value, float default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, float& value, float default_value)
cv::read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, int& value, int default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, int& value, int default_value)
cv::read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, schar& value, schar default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, schar& value, schar default_value)
cv::read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, short& value, short default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, short& value, short default_value)
cv::read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, string& value, const string& default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, string& value, const string& default_value)
cv::read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, uchar& value, uchar default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, uchar& value, uchar default_value)
cv::read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, ushort& value, ushort default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, ushort& value, ushort default_value)
cv::read	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void read(const FileNode& node, CV_OUT vector<KeyPoint>& keypoints);    $/;"	p	namespace:cv	signature:(const FileNode& node, CV_OUT vector<KeyPoint>& keypoints)
cv::rectangle	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void rectangle(Mat& img, Rect rec,$/;"	p	namespace:cv	signature:(Mat& img, Rect rec, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
cv::rectangle	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void rectangle(Mat& img, Point pt1, Point pt2,$/;"	p	namespace:cv	signature:(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
cv::rectify3Collinear	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W float rectify3Collinear( const Mat& cameraMatrix1, const Mat& distCoeffs1,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix1, const Mat& distCoeffs1, const Mat& cameraMatrix2, const Mat& distCoeffs2, const Mat& cameraMatrix3, const Mat& distCoeffs3, const vector<vector<Point2f> >& imgpt1, const vector<vector<Point2f> >& imgpt3, Size imageSize, const Mat& R12, const Mat& T12, const Mat& R13, const Mat& T13, CV_OUT Mat& R1, CV_OUT Mat& R2, CV_OUT Mat& R3, CV_OUT Mat& P1, CV_OUT Mat& P2, CV_OUT Mat& P3, CV_OUT Mat& Q, double alpha, Size newImgSize, CV_OUT Rect* roi1, CV_OUT Rect* roi2, int flags )
cv::redirectError	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS ErrorCallback redirectError( ErrorCallback errCallback,$/;"	p	namespace:cv	signature:( ErrorCallback errCallback, void* userdata=0, void** prevUserdata=0)
cv::reduce	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void reduce(const Mat& src, CV_OUT Mat& dst, int dim, int rtype, int dtype=-1);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int dim, int rtype, int dtype=-1)
cv::remap	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void remap( const Mat& src, CV_OUT Mat& dst, const Mat& map1, const Mat& map2,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& map1, const Mat& map2, int interpolation, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
cv::repeat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS Mat repeat(const Mat& src, int ny, int nx);$/;"	p	namespace:cv	signature:(const Mat& src, int ny, int nx)
cv::repeat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void repeat(const Mat& src, int ny, int nx, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, int ny, int nx, CV_OUT Mat& dst)
cv::reprojectImageTo3D	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void reprojectImageTo3D( const Mat& disparity,$/;"	p	namespace:cv	signature:( const Mat& disparity, CV_OUT Mat& _3dImage, const Mat& Q, bool handleMissingValues=false )
cv::resize	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void resize( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR )
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline int saturate_cast<int>(double v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline int saturate_cast<int>(float v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(double v)$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(float v)$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(int v)$/;"	f	namespace:cv	signature:(int v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(short v)$/;"	f	namespace:cv	signature:(short v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(uchar v)$/;"	f	namespace:cv	signature:(uchar v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline short saturate_cast<short>(double v)$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline short saturate_cast<short>(float v)$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline short saturate_cast<short>(int v)$/;"	f	namespace:cv	signature:(int v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline short saturate_cast<short>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline short saturate_cast<short>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(double v)$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(float v)$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(int v)$/;"	f	namespace:cv	signature:(int v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(schar v)$/;"	f	namespace:cv	signature:(schar v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(short v)$/;"	f	namespace:cv	signature:(short v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline unsigned saturate_cast<unsigned>(double v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline unsigned saturate_cast<unsigned>(float v){ return cvRound(v); }$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(double v)$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(float v)$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(int v)$/;"	f	namespace:cv	signature:(int v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(schar v)$/;"	f	namespace:cv	signature:(schar v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(short v)$/;"	f	namespace:cv	signature:(short v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(double v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(float v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(int v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(int v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(schar v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(schar v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(short v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(short v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(uchar v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(uchar v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(unsigned v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(unsigned v)
cv::saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(ushort v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(ushort v)
cv::saveWindowParameters	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void saveWindowParameters(const string& windowName);$/;"	p	namespace:cv	signature:(const string& windowName)
cv::scalarToRawData	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void scalarToRawData(const Scalar& s, void* buf, int type, int unroll_to=0);$/;"	p	namespace:cv	signature:(const Scalar& s, void* buf, int type, int unroll_to=0)
cv::scaleAdd	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void scaleAdd(const Mat& src1, double alpha, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, double alpha, const Mat& src2, CV_OUT Mat& dst)
cv::sepFilter2D	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void sepFilter2D( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT )
cv::seqInsertSlice	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqInsertSlice( CvSeq* seq, int before_index, const CvArr* from_arr );    $/;"	p	namespace:cv	signature:( CvSeq* seq, int before_index, const CvArr* from_arr )
cv::seqPop	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqPop( CvSeq* seq, void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, void* element=0)
cv::seqPopFront	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqPopFront( CvSeq* seq, void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, void* element=0)
cv::seqPopMulti	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqPopMulti( CvSeq* seq, void* elements,$/;"	p	namespace:cv	signature:( CvSeq* seq, void* elements, int count, int in_front=0 )
cv::seqPush	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS schar*  seqPush( CvSeq* seq, const void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, const void* element=0)
cv::seqPushFront	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS schar*  seqPushFront( CvSeq* seq, const void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, const void* element=0)
cv::seqRemove	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqRemove( CvSeq* seq, int index );$/;"	p	namespace:cv	signature:( CvSeq* seq, int index )
cv::seqRemoveSlice	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqRemoveSlice( CvSeq* seq, CvSlice slice );$/;"	p	namespace:cv	signature:( CvSeq* seq, CvSlice slice )
cv::setBreakOnError	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS bool setBreakOnError(bool flag);$/;"	p	namespace:cv	signature:(bool flag)
cv::setIdentity	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void setIdentity(Mat& mtx, const Scalar& s=Scalar(1));$/;"	p	namespace:cv	signature:(Mat& mtx, const Scalar& s=Scalar(1))
cv::setMouseCallback	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void setMouseCallback( const string& windowName, MouseCallback onMouse, void* param=0);$/;"	p	namespace:cv	signature:( const string& windowName, MouseCallback onMouse, void* param=0)
cv::setNumThreads	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void setNumThreads(int nthreads);$/;"	p	namespace:cv	signature:(int nthreads)
cv::setTrackbarPos	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W void setTrackbarPos( const string& trackbarname, const string& winname, int pos );$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname, int pos )
cv::setUseOptimized	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void setUseOptimized(bool onoff);$/;"	p	namespace:cv	signature:(bool onoff)
cv::setWindowProperty	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W void setWindowProperty(const string& winname, int prop_id, double prop_value);\/\/YV$/;"	p	namespace:cv	signature:(const string& winname, int prop_id, double prop_value)
cv::solve	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W bool solve(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, int flags=DECOMP_LU);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, int flags=DECOMP_LU)
cv::solveCubic	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W int solveCubic(const Mat& coeffs, CV_OUT Mat& roots);$/;"	p	namespace:cv	signature:(const Mat& coeffs, CV_OUT Mat& roots)
cv::solvePnP	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void solvePnP( const Mat& objectPoints,$/;"	p	namespace:cv	signature:( const Mat& objectPoints, const Mat& imagePoints, const Mat& cameraMatrix, const Mat& distCoeffs, CV_OUT Mat& rvec, CV_OUT Mat& tvec, bool useExtrinsicGuess=false )
cv::solvePoly	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double solvePoly(const Mat& coeffs, CV_OUT Mat& roots, int maxIters=300);$/;"	p	namespace:cv	signature:(const Mat& coeffs, CV_OUT Mat& roots, int maxIters=300)
cv::sort	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void sort(const Mat& src, CV_OUT Mat& dst, int flags);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags)
cv::sort	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, class _LT> void sort( vector<_Tp>& vec, _LT LT=_LT() )$/;"	f	namespace:cv	signature:( vector<_Tp>& vec, _LT LT=_LT() )
cv::sortIdx	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void sortIdx(const Mat& src, CV_OUT Mat& dst, int flags);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags)
cv::split	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void split(const Mat& src, Mat* mvbegin);$/;"	p	namespace:cv	signature:(const Mat& src, Mat* mvbegin)
cv::split	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void split(const Mat& m, vector<Mat>& mv);$/;"	p	namespace:cv	signature:(const Mat& m, vector<Mat>& mv)
cv::split	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> void split(const Mat& src, vector<Mat_<_Tp> >& mv)$/;"	f	namespace:cv	signature:(const Mat& src, vector<Mat_<_Tp> >& mv)
cv::sqrt	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void sqrt(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
cv::startLoop	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS  int startLoop(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[]);$/;"	p	namespace:cv	signature:(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[])
cv::startWindowThread	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W int startWindowThread();$/;"	p	namespace:cv	signature:()
cv::stereoCalibrate	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W double stereoCalibrate( const vector<vector<Point3f> >& objectPoints,$/;"	p	namespace:cv	signature:( const vector<vector<Point3f> >& objectPoints, const vector<vector<Point2f> >& imagePoints1, const vector<vector<Point2f> >& imagePoints2, CV_IN_OUT Mat& cameraMatrix1, CV_IN_OUT Mat& distCoeffs1, CV_IN_OUT Mat& cameraMatrix2, CV_IN_OUT Mat& distCoeffs2, Size imageSize, CV_OUT Mat& R, CV_OUT Mat& T, CV_OUT Mat& E, CV_OUT Mat& F, TermCriteria criteria = TermCriteria(TermCriteria::COUNT+ TermCriteria::EPS, 30, 1e-6), int flags=CALIB_FIX_INTRINSIC )
cv::stereoRectify	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void stereoRectify( const Mat& cameraMatrix1, const Mat& distCoeffs1,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix1, const Mat& distCoeffs1, const Mat& cameraMatrix2, const Mat& distCoeffs2, Size imageSize, const Mat& R, const Mat& T, CV_OUT Mat& R1, CV_OUT Mat& R2, CV_OUT Mat& P1, CV_OUT Mat& P2, CV_OUT Mat& Q, int flags=CALIB_ZERO_DISPARITY )
cv::stereoRectify	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void stereoRectify( const Mat& cameraMatrix1, const Mat& distCoeffs1,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix1, const Mat& distCoeffs1, const Mat& cameraMatrix2, const Mat& distCoeffs2, Size imageSize, const Mat& R, const Mat& T, CV_OUT Mat& R1, CV_OUT Mat& R2, CV_OUT Mat& P1, CV_OUT Mat& P2, CV_OUT Mat& Q, double alpha, Size newImageSize=Size(), CV_OUT Rect* validPixROI1=0, CV_OUT Rect* validPixROI2=0, int flags=CALIB_ZERO_DISPARITY )
cv::stereoRectifyUncalibrated	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W bool stereoRectifyUncalibrated( const Mat& points1, const Mat& points2,$/;"	p	namespace:cv	signature:( const Mat& points1, const Mat& points2, const Mat& F, Size imgSize, CV_OUT Mat& H1, CV_OUT Mat& H2, double threshold=5 )
cv::stopLoop	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS  void stopLoop();$/;"	p	namespace:cv	signature:()
cv::subtract	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void subtract(const Mat& src1, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst)
cv::subtract	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void subtract(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask CV_WRAP_DEFAULT(Mat()));$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask CV_WRAP_DEFAULT(Mat()))
cv::subtract	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void subtract(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
cv::subtract	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void subtract(const Scalar& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Scalar& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
cv::sum	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W Scalar sum(const Mat& src);$/;"	p	namespace:cv	signature:(const Mat& src)
cv::swap	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void swap(Mat& a, Mat& b);$/;"	p	namespace:cv	signature:(Mat& a, Mat& b)
cv::theRNG	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS RNG& theRNG();$/;"	p	namespace:cv	signature:()
cv::threshold	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double threshold( const Mat& src, CV_OUT Mat& dst, double thresh, double maxval, int type );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, double thresh, double maxval, int type )
cv::toUtf16	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS WString toUtf16(const string& str);$/;"	p	namespace:cv	signature:(const string& str)
cv::trace	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W Scalar trace(const Mat& mtx);$/;"	p	namespace:cv	signature:(const Mat& mtx)
cv::trace	/usr/include/opencv2/core/operations.hpp	/^double trace(const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a)
cv::transform	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void transform(const Mat& src, CV_OUT Mat& dst, const Mat& m );$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, const Mat& m )
cv::transpose	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void transpose(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
cv::undistort	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void undistort( const Mat& src, CV_OUT Mat& dst, const Mat& cameraMatrix,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& cameraMatrix, const Mat& distCoeffs, const Mat& newCameraMatrix=Mat() )
cv::undistortPoints	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void undistortPoints( const Mat& src, CV_OUT vector<Point2f>& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT vector<Point2f>& dst, const Mat& cameraMatrix, const Mat& distCoeffs, const Mat& R=Mat(), const Mat& P=Mat())
cv::undistortPoints	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void undistortPoints( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& cameraMatrix, const Mat& distCoeffs, const Mat& R=Mat(), const Mat& P=Mat())
cv::updateMotionHistory	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W void updateMotionHistory( const Mat& silhouette, Mat& mhi,$/;"	p	namespace:cv	signature:( const Mat& silhouette, Mat& mhi, double timestamp, double duration )
cv::useOptimized	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W bool useOptimized();$/;"	p	namespace:cv	signature:()
cv::validateDisparity	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void validateDisparity( Mat& disparity, const Mat& cost,$/;"	p	namespace:cv	signature:( Mat& disparity, const Mat& cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp=1 )
cv::vconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void vconcat(const Mat& src1, const Mat& src2, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, Mat& dst)
cv::vconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void vconcat(const Mat* src, size_t nsrc, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrc, Mat& dst)
cv::vconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void vconcat(const vector<Mat>& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const vector<Mat>& src, CV_OUT Mat& dst)
cv::waitKey	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W int waitKey(int delay=0);$/;"	p	namespace:cv	signature:(int delay=0)
cv::warpAffine	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void warpAffine( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
cv::warpPerspective	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void warpPerspective( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
cv::watershed	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void watershed( const Mat& image, Mat& markers );$/;"	p	namespace:cv	signature:( const Mat& image, Mat& markers )
cv::windowedMatchingMask	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS Mat windowedMatchingMask( const vector<KeyPoint>& keypoints1, const vector<KeyPoint>& keypoints2,$/;"	p	namespace:cv	signature:( const vector<KeyPoint>& keypoints1, const vector<KeyPoint>& keypoints2, float maxDeltaX, float maxDeltaY )
cv::write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void write( FileStorage& fs, const string& name, const SparseMat& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const SparseMat& value )
cv::write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, const Mat& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const Mat& value )
cv::write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, const string& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const string& value )
cv::write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, double value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, double value )
cv::write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, float value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, float value )
cv::write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, int value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, int value )
cv::write	/usr/include/opencv2/core/operations.hpp	/^inline void write(FileStorage& fs, const Range& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Range& r )
cv::write	/usr/include/opencv2/core/operations.hpp	/^inline void write(FileStorage& fs, const string& name, const Range& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Range& r )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<> inline void write( FileStorage& fs, const double& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const double& value )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<> inline void write( FileStorage& fs, const float& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const float& value )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<> inline void write( FileStorage& fs, const int& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const int& value )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<> inline void write( FileStorage& fs, const string& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const string& value )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline void write(FileStorage& fs, const Vec<_Tp, cn>& v )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Vec<_Tp, cn>& v )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline void write(FileStorage& fs, const string& name, const Vec<_Tp, cn>& v )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Vec<_Tp, cn>& v )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Complex<_Tp>& c )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Complex<_Tp>& c )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Point3_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Point3_<_Tp>& pt )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Point_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Point_<_Tp>& pt )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Rect_<_Tp>& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Rect_<_Tp>& r )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Scalar_<_Tp>& s )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Scalar_<_Tp>& s )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Size_<_Tp>& sz )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Size_<_Tp>& sz )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const _Tp& value)$/;"	f	namespace:cv	signature:(FileStorage& fs, const _Tp& value)
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Complex<_Tp>& c )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Complex<_Tp>& c )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point3_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Point3_<_Tp>& pt )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Point_<_Tp>& pt )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Rect_<_Tp>& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Rect_<_Tp>& r )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Scalar_<_Tp>& s )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Scalar_<_Tp>& s )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Size_<_Tp>& sz )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Size_<_Tp>& sz )
cv::write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline void write( FileStorage& fs, const vector<_Tp>& vec )$/;"	f	namespace:cv	signature:( FileStorage& fs, const vector<_Tp>& vec )
cv::write	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void write(FileStorage& fs, const string& name, const vector<KeyPoint>& keypoints);$/;"	p	namespace:cv	signature:(FileStorage& fs, const string& name, const vector<KeyPoint>& keypoints)
cv::writeScalar	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, const string& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& value )
cv::writeScalar	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, double value );$/;"	p	namespace:cv	signature:( FileStorage& fs, double value )
cv::writeScalar	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, float value );$/;"	p	namespace:cv	signature:( FileStorage& fs, float value )
cv::writeScalar	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, int value );$/;"	p	namespace:cv	signature:( FileStorage& fs, int value )
cvAXPY	/usr/include/opencv2/core/core_c.h	520;"	d
cvAbs	/usr/include/opencv2/core/core_c.h	598;"	d
cvAccMask	/usr/include/opencv2/legacy/compat.hpp	124;"	d
cvAddSearchPath	/usr/include/opencv2/highgui/highgui_c.h	379;"	d
cvAlign	/usr/include/opencv2/core/internal.hpp	/^CV_INLINE int cvAlign( int size, int align )$/;"	f	signature:( int size, int align )
cvAlignPtr	/usr/include/opencv2/core/internal.hpp	/^CV_INLINE void* cvAlignPtr( const void* ptr, int align CV_DEFAULT(32) )$/;"	f	signature:( const void* ptr, int align CV_DEFAULT(32) )
cvAttrList	/usr/include/opencv2/core/types_c.h	/^CV_INLINE CvAttrList cvAttrList( const char** attr CV_DEFAULT(NULL),$/;"	f	signature:( const char** attr CV_DEFAULT(NULL), CvAttrList* next CV_DEFAULT(NULL) )
cvBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^inline CvBlob cvBlob(float x,float y, float w, float h)$/;"	f	signature:(float x,float y, float w, float h)
cvCalcBackProject	/usr/include/opencv2/imgproc/imgproc_c.h	602;"	d
cvCalcBackProjectPatch	/usr/include/opencv2/imgproc/imgproc_c.h	610;"	d
cvCalcContoursCorrespondence	/usr/include/opencv2/legacy/legacy.hpp	/^CvSeq* cvCalcContoursCorrespondence( const CvSeq* contour1,$/;"	p	signature:( const CvSeq* contour1, const CvSeq* contour2, CvMemStorage* storage)
cvCalcEMD	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS  float  cvCalcEMD( const float* signature1, int size1,$/;"	p	signature:( const float* signature1, int size1, const float* signature2, int size2, int dims, int dist_type CV_DEFAULT(CV_DIST_L2), CvDistanceFunction dist_func CV_DEFAULT(0), float* lower_bound CV_DEFAULT(0), void* user_param CV_DEFAULT(0))
cvCalcHist	/usr/include/opencv2/imgproc/imgproc_c.h	/^CV_INLINE  void  cvCalcHist( IplImage** image, CvHistogram* hist,$/;"	f	signature:( IplImage** image, CvHistogram* hist, int accumulate CV_DEFAULT(0), const CvArr* mask CV_DEFAULT(NULL) )
cvCalcHistMask	/usr/include/opencv2/legacy/compat.hpp	130;"	d
cvCalibrateCamera	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvCalibrateCamera( int image_count, int* _point_counts,$/;"	p	signature:( int image_count, int* _point_counts, CvSize image_size, CvPoint2D32f* _image_points, CvPoint3D32f* _object_points, float* _distortion_coeffs, float* _camera_matrix, float* _translation_vectors, float* _rotation_matrices, int flags )
cvCalibrateCamera_64d	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvCalibrateCamera_64d( int image_count, int* _point_counts,$/;"	p	signature:( int image_count, int* _point_counts, CvSize image_size, CvPoint2D64f* _image_points, CvPoint3D64f* _object_points, double* _distortion_coeffs, double* _camera_matrix, double* _translation_vectors, double* _rotation_matrices, int flags )
cvCaptureFromAVI	/usr/include/opencv2/highgui/highgui_c.h	376;"	d
cvCaptureFromCAM	/usr/include/opencv2/highgui/highgui_c.h	375;"	d
cvCaptureFromFile	/usr/include/opencv2/highgui/highgui_c.h	374;"	d
cvCeil	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  int  cvCeil( double value )$/;"	f	signature:( double value )
cvCheckArray	/usr/include/opencv2/core/core_c.h	645;"	d
cvCircleAA	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvCircleAA( CvArr* img, CvPoint center, int radius,$/;"	p	signature:( CvArr* img, CvPoint center, int radius, double color, int scale CV_DEFAULT(0) )
cvCloneSeq	/usr/include/opencv2/core/core_c.h	/^CV_INLINE CvSeq* cvCloneSeq( const CvSeq* seq, CvMemStorage* storage CV_DEFAULT(NULL))$/;"	f	signature:( const CvSeq* seq, CvMemStorage* storage CV_DEFAULT(NULL))
cvContourBoundingRect	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS CvRect  cvContourBoundingRect( void* point_set, int update CV_DEFAULT(0));$/;"	p	signature:( void* point_set, int update CV_DEFAULT(0))
cvContourMoments	/usr/include/opencv2/legacy/compat.hpp	179;"	d
cvContourPerimeter	/usr/include/opencv2/imgproc/imgproc_c.h	/^CV_INLINE double cvContourPerimeter( const void* contour )$/;"	f	signature:( const void* contour )
cvConvert	/usr/include/opencv2/core/core_c.h	456;"	d
cvConvertPointsHomogenious	/usr/include/opencv2/legacy/compat.hpp	601;"	d
cvConvexHull	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvConvexHull( CvPoint* points, int num_points,$/;"	p	signature:( CvPoint* points, int num_points, CvRect* bound_rect, int orientation, int* hull, int* hullsize )
cvCopyImage	/usr/include/opencv2/legacy/compat.hpp	212;"	d
cvCreateAVIWriter	/usr/include/opencv2/highgui/highgui_c.h	377;"	d
cvCreateBlobDetectorCC	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobDetector* cvCreateBlobDetectorCC();$/;"	p	signature:()
cvCreateBlobDetectorSimple	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobDetector* cvCreateBlobDetectorSimple();$/;"	p	signature:()
cvCreateBlobTrackerAuto	/usr/include/opencv2/legacy/blobtrack.hpp	/^inline CvBlobTrackerAuto* cvCreateBlobTrackerAuto(int type, void* param)$/;"	f	signature:(int type, void* param)
cvCreateBlobTrackerAuto1	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackerAuto* cvCreateBlobTrackerAuto1(CvBlobTrackerAutoParam1* param = NULL);$/;"	p	signature:(CvBlobTrackerAutoParam1* param = NULL)
cvCreateBlobTrackerCC	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerCC();$/;"	p	signature:()
cvCreateBlobTrackerCCMSPF	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerCCMSPF();$/;"	p	signature:()
cvCreateBlobTrackerLHR	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerLHR(CvBlobTrackerParamLH* \/*param*\/ = NULL);$/;"	p	signature:(CvBlobTrackerParamLH* = NULL)
cvCreateBlobTrackerLHRS	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerLHRS(CvBlobTrackerParamLH* \/*param*\/ = NULL);$/;"	p	signature:(CvBlobTrackerParamLH* = NULL)
cvCreateBlobTrackerMS	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMS();$/;"	p	signature:()
cvCreateBlobTrackerMS1	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMS1(CvBlobTrackerParamMS* param);$/;"	p	signature:(CvBlobTrackerParamMS* param)
cvCreateBlobTrackerMS1ByList	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMS1ByList();$/;"	p	signature:()
cvCreateBlobTrackerMS2	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMS2(CvBlobTrackerParamMS* param);$/;"	p	signature:(CvBlobTrackerParamMS* param)
cvCreateBlobTrackerMSFG	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMSFG();$/;"	p	signature:()
cvCreateBlobTrackerMSFGS	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMSFGS();$/;"	p	signature:()
cvCreateBlobTrackerMSPF	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMSPF();$/;"	p	signature:()
cvCreateFGDetectorBase	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvFGDetector* cvCreateFGDetectorBase(int type, void *param);$/;"	p	signature:(int type, void *param)
cvCreateImageData	/usr/include/opencv2/legacy/compat.hpp	106;"	d
cvCreateModuleBlobTrackAnalysisHistP	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisHistP();$/;"	p	signature:()
cvCreateModuleBlobTrackAnalysisHistPV	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisHistPV();$/;"	p	signature:()
cvCreateModuleBlobTrackAnalysisHistPVS	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisHistPVS();$/;"	p	signature:()
cvCreateModuleBlobTrackAnalysisHistSS	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisHistSS();$/;"	p	signature:()
cvCreateModuleBlobTrackAnalysisIOR	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisIOR();$/;"	p	signature:()
cvCreateModuleBlobTrackAnalysisTrackDist	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisTrackDist();$/;"	p	signature:()
cvCreateModuleBlobTrackGen1	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackGen* cvCreateModuleBlobTrackGen1();$/;"	p	signature:()
cvCreateModuleBlobTrackGenYML	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackGen* cvCreateModuleBlobTrackGenYML();$/;"	p	signature:()
cvCreateModuleBlobTrackPostProcKalman	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackPostProc* cvCreateModuleBlobTrackPostProcKalman();$/;"	p	signature:()
cvCreateModuleBlobTrackPostProcTimeAverExp	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackPostProc* cvCreateModuleBlobTrackPostProcTimeAverExp();$/;"	p	signature:()
cvCreateModuleBlobTrackPostProcTimeAverRect	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackPostProc* cvCreateModuleBlobTrackPostProcTimeAverRect();$/;"	p	signature:()
cvCreateModuleBlobTrackPredictKalman	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackPredictor* cvCreateModuleBlobTrackPredictKalman();$/;"	p	signature:()
cvCreateProb	/usr/include/opencv2/legacy/blobtrack.hpp	/^inline CvProb* cvCreateProb(int type, int dim, CvSize size = cvSize(1,1), void* \/*param*\/ = NULL)$/;"	f	signature:(int type, int dim, CvSize size = cvSize(1,1), void* = NULL)
cvCreateProbHist	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvProb* cvCreateProbHist(int dim, CvSize size);$/;"	p	signature:(int dim, CvSize size)
cvCreateProbMG	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvProb* cvCreateProbMG(int dim, CvSize size, int sample_num);$/;"	p	signature:(int dim, CvSize size, int sample_num)
cvCreateProbMG2	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvProb* cvCreateProbMG2(int dim, CvSize size, int sample_num);$/;"	p	signature:(int dim, CvSize size, int sample_num)
cvCreateProbS	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvProb* cvCreateProbS(int dim, CvSize size, int sample_num);$/;"	p	signature:(int dim, CvSize size, int sample_num)
cvCreateSubdivDelaunay2D	/usr/include/opencv2/imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2D* cvCreateSubdivDelaunay2D( CvRect rect, CvMemStorage* storage )$/;"	f	signature:( CvRect rect, CvMemStorage* storage )
cvCreateTestSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvTestSeq* cvCreateTestSeq(char* pConfigfile, char** videos, int numvideo, float Scale = 1, int noise_type = CV_NOISE_NONE, double noise_ampl = 0);$/;"	p	signature:(char* pConfigfile, char** videos, int numvideo, float Scale = 1, int noise_type = CV_NOISE_NONE, double noise_ampl = 0)
cvCreateTracks_AreaErr	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvCreateTracks_AreaErr(CvBlobTrackSeq *TS1, CvBlobTrackSeq *TS2, int addW, int addH);$/;"	p	signature:(CvBlobTrackSeq *TS1, CvBlobTrackSeq *TS2, int addW, int addH)
cvCreateTracks_One	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvCreateTracks_One(CvBlobTrackSeq *TS);$/;"	p	signature:(CvBlobTrackSeq *TS)
cvCreateTracks_Same	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvCreateTracks_Same(CvBlobTrackSeq *TS1, CvBlobTrackSeq *TS2);$/;"	p	signature:(CvBlobTrackSeq *TS1, CvBlobTrackSeq *TS2)
cvCvtPixToPlane	/usr/include/opencv2/legacy/compat.hpp	140;"	d
cvCvtPlaneToPix	/usr/include/opencv2/legacy/compat.hpp	141;"	d
cvCvtScale	/usr/include/opencv2/core/core_c.h	454;"	d
cvCvtScaleAbs	/usr/include/opencv2/core/core_c.h	467;"	d
cvDecRefData	/usr/include/opencv2/core/core_c.h	/^CV_INLINE  void  cvDecRefData( CvArr* arr )$/;"	f	signature:( CvArr* arr )
cvDetectedBlob	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_INLINE CvDetectedBlob cvDetectedBlob( float x, float y, float w, float h, int ID = 0, float response = 0.0F )$/;"	f	signature:( float x, float y, float w, float h, int ID = 0, float response = 0.0F )
cvDrawCircle	/usr/include/opencv2/core/core_c.h	1330;"	d
cvDrawEllipse	/usr/include/opencv2/core/core_c.h	1331;"	d
cvDrawLine	/usr/include/opencv2/core/core_c.h	1329;"	d
cvDrawPolyLine	/usr/include/opencv2/core/core_c.h	1332;"	d
cvDrawRect	/usr/include/opencv2/core/core_c.h	1328;"	d
cvEllipseAA	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvEllipseAA( CvArr* img, CvPoint center, CvSize axes,$/;"	p	signature:( CvArr* img, CvPoint center, CvSize axes, double angle, double start_angle, double end_angle, double color, int scale CV_DEFAULT(0) )
cvEllipseBox	/usr/include/opencv2/core/core_c.h	/^CV_INLINE  void  cvEllipseBox( CvArr* img, CvBox2D box, CvScalar color,$/;"	f	signature:( CvArr* img, CvBox2D box, CvScalar color, int thickness CV_DEFAULT(1), int line_type CV_DEFAULT(8), int shift CV_DEFAULT(0) )
cvEndScanGraph	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS  void  cvEndScanGraph( CvGraphScanner* scanner );$/;"	p	signature:( CvGraphScanner* scanner )
cvFFT	/usr/include/opencv2/core/core_c.h	891;"	d
cvFillImage	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvFillImage( CvArr* mat, double color );$/;"	p	signature:( CvArr* mat, double color )
cvFindChessBoardCornerGuesses	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS int cvFindChessBoardCornerGuesses( const void* arr, void* thresharr,$/;"	p	signature:( const void* arr, void* thresharr, CvMemStorage* storage, CvSize pattern_size, CvPoint2D32f * corners, int *corner_count )
cvFindExtrinsicCameraParams	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvFindExtrinsicCameraParams( int point_count,$/;"	p	signature:( int point_count, CvSize image_size, CvPoint2D32f* _image_points, CvPoint3D32f* _object_points, float* focal_length, CvPoint2D32f principal_point, float* _distortion_coeffs, float* _rotation_vector, float* _translation_vector )
cvFindExtrinsicCameraParams_64d	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvFindExtrinsicCameraParams_64d( int point_count,$/;"	p	signature:( int point_count, CvSize image_size, CvPoint2D64f* _image_points, CvPoint3D64f* _object_points, double* focal_length, CvPoint2D64f principal_point, double* _distortion_coeffs, double* _rotation_vector, double* _translation_vector )
cvFindFace	/usr/include/opencv2/legacy/legacy.hpp	/^CvSeq * cvFindFace(IplImage * Image,CvMemStorage* storage);$/;"	p	signature:(IplImage * Image,CvMemStorage* storage)
cvFindFundamentalMatrix	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvFindFundamentalMatrix( int* points1, int* points2,$/;"	p	signature:( int* points1, int* points2, int numpoints, int method, float* matrix )
cvFitEllipse	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS  void  cvFitEllipse( const CvPoint2D32f* points, int count, CvBox2D* box );$/;"	p	signature:( const CvPoint2D32f* points, int count, CvBox2D* box )
cvFitLine2D	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS  void  cvFitLine2D( CvPoint2D32f* points, int count, int dist,$/;"	p	signature:( CvPoint2D32f* points, int count, int dist, void *param, float reps, float aeps, float* line )
cvFitLine3D	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS  void  cvFitLine3D( CvPoint3D32f* points, int count, int dist,$/;"	p	signature:( CvPoint3D32f* points, int count, int dist, void *param, float reps, float aeps, float* line )
cvFloor	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  int  cvFloor( double value )$/;"	f	signature:( double value )
cvFont	/usr/include/opencv2/core/core_c.h	/^CV_INLINE CvFont cvFont( double scale, int thickness CV_DEFAULT(1) )$/;"	f	signature:( double scale, int thickness CV_DEFAULT(1) )
cvFree	/usr/include/opencv2/core/core_c.h	70;"	d
cvFuncName	/usr/include/opencv2/core/core_c.h	1801;"	d
cvGetAt	/usr/include/opencv2/legacy/compat.hpp	182;"	d
cvGetCol	/usr/include/opencv2/core/core_c.h	/^CV_INLINE  CvMat*  cvGetCol( const CvArr* arr, CvMat* submat, int col )$/;"	f	signature:( const CvArr* arr, CvMat* submat, int col )
cvGetGraphVtx	/usr/include/opencv2/core/core_c.h	1191;"	d
cvGetHistValue_1D	/usr/include/opencv2/legacy/compat.hpp	261;"	d
cvGetHistValue_2D	/usr/include/opencv2/legacy/compat.hpp	263;"	d
cvGetHistValue_3D	/usr/include/opencv2/legacy/compat.hpp	265;"	d
cvGetHistValue_nD	/usr/include/opencv2/legacy/compat.hpp	267;"	d
cvGetImageRawData	/usr/include/opencv2/legacy/compat.hpp	109;"	d
cvGetMatSize	/usr/include/opencv2/core/internal.hpp	/^CV_INLINE  CvSize  cvGetMatSize( const CvMat* mat )$/;"	f	signature:( const CvMat* mat )
cvGetNextSparseNode	/usr/include/opencv2/core/core_c.h	/^CV_INLINE CvSparseNode* cvGetNextSparseNode( CvSparseMatIterator* mat_iterator )$/;"	f	signature:( CvSparseMatIterator* mat_iterator )
cvGetPtrAt	/usr/include/opencv2/legacy/compat.hpp	181;"	d
cvGetRow	/usr/include/opencv2/core/core_c.h	/^CV_INLINE  CvMat*  cvGetRow( const CvArr* arr, CvMat* submat, int row )$/;"	f	signature:( const CvArr* arr, CvMat* submat, int row )
cvGetSetElem	/usr/include/opencv2/core/core_c.h	/^CV_INLINE CvSetElem* cvGetSetElem( const CvSet* set_header, int index )$/;"	f	signature:( const CvSet* set_header, int index )
cvGetSubArr	/usr/include/opencv2/core/core_c.h	174;"	d
cvGraphEdgeIdx	/usr/include/opencv2/core/core_c.h	1197;"	d
cvGraphFindEdge	/usr/include/opencv2/core/core_c.h	1178;"	d
cvGraphFindEdgeByPtr	/usr/include/opencv2/core/core_c.h	1179;"	d
cvGraphGetEdgeCount	/usr/include/opencv2/core/core_c.h	1200;"	d
cvGraphGetVtxCount	/usr/include/opencv2/core/core_c.h	1199;"	d
cvGraphVtxIdx	/usr/include/opencv2/core/core_c.h	1194;"	d
cvHoughLines	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS  int  cvHoughLines( CvArr* image, double rho,$/;"	p	signature:( CvArr* image, double rho, double theta, int threshold, float* lines, int linesNumber )
cvHoughLinesP	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS  int  cvHoughLinesP( CvArr* image, double rho,$/;"	p	signature:( CvArr* image, double rho, double theta, int threshold, int lineLength, int lineGap, int* lines, int linesNumber )
cvHoughLinesSDiv	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS  int  cvHoughLinesSDiv( CvArr* image, double rho, int srn,$/;"	p	signature:( CvArr* image, double rho, int srn, double theta, int stn, int threshold, float* lines, int linesNumber )
cvIncRefData	/usr/include/opencv2/core/core_c.h	/^CV_INLINE  int  cvIncRefData( CvArr* arr )$/;"	f	signature:( CvArr* arr )
cvIntegralImage	/usr/include/opencv2/legacy/compat.hpp	116;"	d
cvInv	/usr/include/opencv2/core/core_c.h	747;"	d
cvInvSqrt	/usr/include/opencv2/core/types_c.h	341;"	d
cvIplDepth	/usr/include/opencv2/core/types_c.h	/^CV_INLINE int cvIplDepth( int type )$/;"	f	signature:( int type )
cvIsInf	/usr/include/opencv2/core/types_c.h	/^CV_INLINE int cvIsInf( double value )$/;"	f	signature:( double value )
cvIsNaN	/usr/include/opencv2/core/types_c.h	/^CV_INLINE int cvIsNaN( double value )$/;"	f	signature:( double value )
cvKMeans	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS  void  cvKMeans( int num_clusters, float** samples,$/;"	p	signature:( int num_clusters, float** samples, int num_samples, int vec_size, CvTermCriteria termcrit, int* cluster_idx )
cvKalmanUpdateByMeasurement	/usr/include/opencv2/video/tracking.hpp	238;"	d
cvKalmanUpdateByTime	/usr/include/opencv2/video/tracking.hpp	237;"	d
cvLineAA	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvLineAA( CvArr* img, CvPoint pt1, CvPoint pt2,$/;"	p	signature:( CvArr* img, CvPoint pt1, CvPoint pt2, double color, int scale CV_DEFAULT(0))
cvMahalonobis	/usr/include/opencv2/core/core_c.h	813;"	d
cvMake2DPoints	/usr/include/opencv2/legacy/compat.hpp	596;"	d
cvMake3DPoints	/usr/include/opencv2/legacy/compat.hpp	597;"	d
cvMat	/usr/include/opencv2/core/types_c.h	/^CV_INLINE CvMat cvMat( int rows, int cols, int type, void* data CV_DEFAULT(NULL))$/;"	f	signature:( int rows, int cols, int type, void* data CV_DEFAULT(NULL))
cvMatArray	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS CvMat cvMatArray( int rows, int cols, int type,$/;"	p	signature:( int rows, int cols, int type, int count, void* data CV_DEFAULT(0))
cvMatMul	/usr/include/opencv2/core/core_c.h	680;"	d
cvMatMulAdd	/usr/include/opencv2/core/core_c.h	679;"	d
cvMatMulAddEx	/usr/include/opencv2/core/core_c.h	690;"	d
cvMatMulAddS	/usr/include/opencv2/core/core_c.h	697;"	d
cvMatchContours	/usr/include/opencv2/legacy/compat.hpp	117;"	d
cvMean	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS double cvMean( const CvArr* image, const CvArr* mask CV_DEFAULT(0));$/;"	p	signature:( const CvArr* image, const CvArr* mask CV_DEFAULT(0))
cvMeanMask	/usr/include/opencv2/legacy/compat.hpp	185;"	d
cvMean_StdDev	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvMean_StdDev( const CvArr* image, double* mean, double* sdv,$/;"	p	signature:( const CvArr* image, double* mean, double* sdv, const CvArr* mask CV_DEFAULT(0))
cvMean_StdDevMask	/usr/include/opencv2/legacy/compat.hpp	186;"	d
cvMinAreaRect	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvMinAreaRect( CvPoint* points, int n,$/;"	p	signature:( CvPoint* points, int n, int left, int bottom, int right, int top, CvPoint2D32f* anchor, CvPoint2D32f* vect1, CvPoint2D32f* vect2 )
cvMinMaxLocMask	/usr/include/opencv2/legacy/compat.hpp	190;"	d
cvMirror	/usr/include/opencv2/core/core_c.h	720;"	d
cvMorphContours	/usr/include/opencv2/legacy/legacy.hpp	/^CvSeq* cvMorphContours( const CvSeq* contour1, const CvSeq* contour2,$/;"	p	signature:( const CvSeq* contour1, const CvSeq* contour2, CvSeq* corr, double alpha, CvMemStorage* storage )
cvMultiplyAccMask	/usr/include/opencv2/legacy/compat.hpp	126;"	d
cvNormMask	/usr/include/opencv2/legacy/compat.hpp	188;"	d
cvPoint	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvPoint  cvPoint( int x, int y )$/;"	f	signature:( int x, int y )
cvPoint2D32f	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvPoint2D32f  cvPoint2D32f( double x, double y )$/;"	f	signature:( double x, double y )
cvPoint2D64f	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvPoint2D64f  cvPoint2D64f( double x, double y )$/;"	f	signature:( double x, double y )
cvPoint3D32f	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvPoint3D32f  cvPoint3D32f( double x, double y, double z )$/;"	f	signature:( double x, double y, double z )
cvPoint3D64f	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvPoint3D64f  cvPoint3D64f( double x, double y, double z )$/;"	f	signature:( double x, double y, double z )
cvPointFrom32f	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvPoint  cvPointFrom32f( CvPoint2D32f point )$/;"	f	signature:( CvPoint2D32f point )
cvPointTo32f	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvPoint2D32f  cvPointTo32f( CvPoint point )$/;"	f	signature:( CvPoint point )
cvPolyLineAA	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvPolyLineAA( CvArr* img, CvPoint** pts, int* npts, int contours,$/;"	p	signature:( CvArr* img, CvPoint** pts, int* npts, int contours, int is_closed, double color, int scale CV_DEFAULT(0) )
cvPostBoostingFindFace	/usr/include/opencv2/legacy/legacy.hpp	/^CvSeq * cvPostBoostingFindFace(IplImage * Image,CvMemStorage* storage);$/;"	p	signature:(IplImage * Image,CvMemStorage* storage)
cvProject3D	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS  void  cvProject3D( CvPoint3D32f* points3D, int count,$/;"	p	signature:( CvPoint3D32f* points3D, int count, CvPoint2D32f* points2D, int xIndx CV_DEFAULT(0), int yIndx CV_DEFAULT(1))
cvProjectPoints	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvProjectPoints( int point_count, CvPoint3D64f* _object_points,$/;"	p	signature:( int point_count, CvPoint3D64f* _object_points, double* _rotation_vector, double* _translation_vector, double* focal_length, CvPoint2D64f principal_point, double* _distortion, CvPoint2D64f* _image_points, double* _deriv_points_rotation_matrix, double* _deriv_points_translation_vect, double* _deriv_points_focal, double* _deriv_points_principal_point, double* _deriv_points_distortion_coeffs )
cvProjectPointsSimple	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvProjectPointsSimple( int point_count, CvPoint3D64f* _object_points,$/;"	p	signature:( int point_count, CvPoint3D64f* _object_points, double* _rotation_matrix, double* _translation_vector, double* _camera_matrix, double* _distortion, CvPoint2D64f* _image_points )
cvPseudoInv	/usr/include/opencv2/legacy/compat.hpp	177;"	d
cvPseudoInverse	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS double cvPseudoInverse( const CvArr* src, CvArr* dst );$/;"	p	signature:( const CvArr* src, CvArr* dst )
cvQueryHistValue_1D	/usr/include/opencv2/legacy/compat.hpp	250;"	d
cvQueryHistValue_2D	/usr/include/opencv2/legacy/compat.hpp	252;"	d
cvQueryHistValue_3D	/usr/include/opencv2/legacy/compat.hpp	254;"	d
cvQueryHistValue_nD	/usr/include/opencv2/legacy/compat.hpp	256;"	d
cvROIToRect	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvRect  cvROIToRect( IplROI roi )$/;"	f	signature:( IplROI roi )
cvRand	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvRand( CvRandState* state, CvArr* arr );$/;"	p	signature:( CvRandState* state, CvArr* arr )
cvRandInit	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvRandInit( CvRandState* state, double param1,$/;"	p	signature:( CvRandState* state, double param1, double param2, int seed, int disttype CV_DEFAULT(CV_RAND_UNI))
cvRandInt	/usr/include/opencv2/core/types_c.h	/^CV_INLINE unsigned cvRandInt( CvRNG* rng )$/;"	f	signature:( CvRNG* rng )
cvRandNext	/usr/include/opencv2/legacy/compat.hpp	161;"	d
cvRandReal	/usr/include/opencv2/core/types_c.h	/^CV_INLINE double cvRandReal( CvRNG* rng )$/;"	f	signature:( CvRNG* rng )
cvRandSetRange	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvRandSetRange( CvRandState* state, double param1,$/;"	p	signature:( CvRandState* state, double param1, double param2, int index CV_DEFAULT(-1))
cvReadByName	/usr/include/opencv2/core/core_c.h	/^CV_INLINE void* cvReadByName( CvFileStorage* fs, const CvFileNode* map,$/;"	f	signature:( CvFileStorage* fs, const CvFileNode* map, const char* name, CvAttrList* attributes CV_DEFAULT(NULL) )
cvReadInt	/usr/include/opencv2/core/core_c.h	/^CV_INLINE int cvReadInt( const CvFileNode* node, int default_value CV_DEFAULT(0) )$/;"	f	signature:( const CvFileNode* node, int default_value CV_DEFAULT(0) )
cvReadIntByName	/usr/include/opencv2/core/core_c.h	/^CV_INLINE int cvReadIntByName( const CvFileStorage* fs, const CvFileNode* map,$/;"	f	signature:( const CvFileStorage* fs, const CvFileNode* map, const char* name, int default_value CV_DEFAULT(0) )
cvReadReal	/usr/include/opencv2/core/core_c.h	/^CV_INLINE double cvReadReal( const CvFileNode* node, double default_value CV_DEFAULT(0.) )$/;"	f	signature:( const CvFileNode* node, double default_value CV_DEFAULT(0.) )
cvReadRealByName	/usr/include/opencv2/core/core_c.h	/^CV_INLINE double cvReadRealByName( const CvFileStorage* fs, const CvFileNode* map,$/;"	f	signature:( const CvFileStorage* fs, const CvFileNode* map, const char* name, double default_value CV_DEFAULT(0.) )
cvReadString	/usr/include/opencv2/core/core_c.h	/^CV_INLINE const char* cvReadString( const CvFileNode* node,$/;"	f	signature:( const CvFileNode* node, const char* default_value CV_DEFAULT(NULL) )
cvReadStringByName	/usr/include/opencv2/core/core_c.h	/^CV_INLINE const char* cvReadStringByName( const CvFileStorage* fs, const CvFileNode* map,$/;"	f	signature:( const CvFileStorage* fs, const CvFileNode* map, const char* name, const char* default_value CV_DEFAULT(NULL) )
cvReadStructByName	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvReadStructByName(CvFileStorage* fs, CvFileNode* node, const char* name, void* addr, const char* desc);$/;"	p	signature:(CvFileStorage* fs, CvFileNode* node, const char* name, void* addr, const char* desc)
cvRealScalar	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvScalar  cvRealScalar( double val0 )$/;"	f	signature:( double val0 )
cvRect	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvRect  cvRect( int x, int y, int width, int height )$/;"	f	signature:( int x, int y, int width, int height )
cvRectIntersection	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_INLINE CvRect cvRectIntersection( const CvRect r1, const CvRect r2 )$/;"	f	signature:( const CvRect r1, const CvRect r2 )
cvRectToROI	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  IplROI  cvRectToROI( CvRect rect, int coi )$/;"	f	signature:( CvRect rect, int coi )
cvReleaseBlobDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvReleaseBlobDetector(CvBlobDetector** ppBD);$/;"	p	signature:(CvBlobDetector** ppBD)
cvReleaseBlobTrackAnalysis	/usr/include/opencv2/legacy/blobtrack.hpp	/^inline void cvReleaseBlobTrackAnalysis(CvBlobTrackAnalysis** pBTPP)$/;"	f	signature:(CvBlobTrackAnalysis** pBTPP)
cvReleaseBlobTrackGen	/usr/include/opencv2/legacy/blobtrack.hpp	/^inline void cvReleaseBlobTrackGen(CvBlobTrackGen** pBTGen)$/;"	f	signature:(CvBlobTrackGen** pBTGen)
cvReleaseBlobTrackPostProc	/usr/include/opencv2/legacy/blobtrack.hpp	/^inline void cvReleaseBlobTrackPostProc(CvBlobTrackPostProc** pBTPP)$/;"	f	signature:(CvBlobTrackPostProc** pBTPP)
cvReleaseBlobTracker	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvReleaseBlobTracker(CvBlobTracker**ppT );$/;"	p	signature:(CvBlobTracker**ppT )
cvReleaseBlobTrackerAuto	/usr/include/opencv2/legacy/blobtrack.hpp	/^inline void cvReleaseBlobTrackerAuto(CvBlobTrackerAuto** ppT)$/;"	f	signature:(CvBlobTrackerAuto** ppT)
cvReleaseBlobTrackerOne	/usr/include/opencv2/legacy/blobtrack.hpp	/^inline void cvReleaseBlobTrackerOne(CvBlobTrackerOne **ppT )$/;"	f	signature:(CvBlobTrackerOne **ppT )
cvReleaseFGDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvReleaseFGDetector(CvFGDetector** ppT );$/;"	p	signature:(CvFGDetector** ppT )
cvReleaseImageData	/usr/include/opencv2/legacy/compat.hpp	107;"	d
cvReleaseMatHeader	/usr/include/opencv2/legacy/compat.hpp	213;"	d
cvReleaseMatND	/usr/include/opencv2/core/core_c.h	/^CV_INLINE  void  cvReleaseMatND( CvMatND** mat )$/;"	f	signature:( CvMatND** mat )
cvReleaseProb	/usr/include/opencv2/legacy/blobtrack.hpp	/^inline void cvReleaseProb(CvProb** ppProb){ppProb[0]->Release();ppProb[0]=NULL;}$/;"	f	signature:(CvProb** ppProb)
cvReleaseTestSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvReleaseTestSeq(CvTestSeq** ppTestSeq);$/;"	p	signature:(CvTestSeq** ppTestSeq)
cvRemoveMemoryManager	/usr/include/opencv2/legacy/compat.hpp	193;"	d
cvReshapeND	/usr/include/opencv2/core/core_c.h	383;"	d
cvRodrigues	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvRodrigues( CvMat* rotation_matrix, CvMat* rotation_vector,$/;"	p	signature:( CvMat* rotation_matrix, CvMat* rotation_vector, CvMat* jacobian, int conv_type )
cvRound	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  int  cvRound( double value )$/;"	f	signature:( double value )
cvRunningAvgMask	/usr/include/opencv2/legacy/compat.hpp	127;"	d
cvSURFPoint	/usr/include/opencv2/features2d/features2d.hpp	/^CV_INLINE CvSURFPoint cvSURFPoint( CvPoint2D32f pt, int laplacian,$/;"	f	signature:( CvPoint2D32f pt, int laplacian, int size, float dir CV_DEFAULT(0), float hessian CV_DEFAULT(0))
cvScalar	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvScalar  cvScalar( double val0, double val1 CV_DEFAULT(0),$/;"	f	signature:( double val0, double val1 CV_DEFAULT(0), double val2 CV_DEFAULT(0), double val3 CV_DEFAULT(0))
cvScalarAll	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvScalar  cvScalarAll( double val0123 )$/;"	f	signature:( double val0123 )
cvScale	/usr/include/opencv2/core/core_c.h	455;"	d
cvSetAt	/usr/include/opencv2/legacy/compat.hpp	183;"	d
cvSetHistThresh	/usr/include/opencv2/legacy/compat.hpp	129;"	d
cvSetImageData	/usr/include/opencv2/legacy/compat.hpp	108;"	d
cvSetNew	/usr/include/opencv2/core/core_c.h	/^CV_INLINE  CvSetElem* cvSetNew( CvSet* set_header )$/;"	f	signature:( CvSet* set_header )
cvSetRemoveByPtr	/usr/include/opencv2/core/core_c.h	/^CV_INLINE  void cvSetRemoveByPtr( CvSet* set_header, void* elem )$/;"	f	signature:( CvSet* set_header, void* elem )
cvSize	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvSize  cvSize( int width, int height )$/;"	f	signature:( int width, int height )
cvSize2D32f	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvSize2D32f  cvSize2D32f( double width, double height )$/;"	f	signature:( double width, double height )
cvSlice	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvSlice  cvSlice( int start, int end )$/;"	f	signature:( int start, int end )
cvSqrt	/usr/include/opencv2/core/types_c.h	342;"	d
cvSquareAccMask	/usr/include/opencv2/legacy/compat.hpp	125;"	d
cvStackAlloc	/usr/include/opencv2/core/internal.hpp	288;"	d
cvStarDetectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^CV_INLINE CvStarDetectorParams cvStarDetectorParams($/;"	f	signature:( int maxSize CV_DEFAULT(45), int responseThreshold CV_DEFAULT(30), int lineThresholdProjected CV_DEFAULT(10), int lineThresholdBinarized CV_DEFAULT(8), int suppressNonmaxSize CV_DEFAULT(5))
cvStarKeypoint	/usr/include/opencv2/features2d/features2d.hpp	/^CV_INLINE CvStarKeypoint cvStarKeypoint(CvPoint pt, int size, float response)$/;"	f	signature:(CvPoint pt, int size, float response)
cvStartScanGraph	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvStartScanGraph( CvGraph* graph, CvGraphScanner* scanner,$/;"	p	signature:( CvGraph* graph, CvGraphScanner* scanner, CvGraphVtx* vtx CV_DEFAULT(NULL), int mask CV_DEFAULT(CV_GRAPH_ALL_ITEMS))
cvSubS	/usr/include/opencv2/core/core_c.h	/^CV_INLINE  void  cvSubS( const CvArr* src, CvScalar value, CvArr* dst,$/;"	f	signature:( const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask CV_DEFAULT(NULL))
cvSubdiv2DEdgeDst	/usr/include/opencv2/imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DPoint*  cvSubdiv2DEdgeDst( CvSubdiv2DEdge edge )$/;"	f	signature:( CvSubdiv2DEdge edge )
cvSubdiv2DEdgeOrg	/usr/include/opencv2/imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DPoint*  cvSubdiv2DEdgeOrg( CvSubdiv2DEdge edge )$/;"	f	signature:( CvSubdiv2DEdge edge )
cvSubdiv2DGetEdge	/usr/include/opencv2/imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DEdge  cvSubdiv2DGetEdge( CvSubdiv2DEdge edge, CvNextEdgeType type )$/;"	f	signature:( CvSubdiv2DEdge edge, CvNextEdgeType type )
cvSubdiv2DNextEdge	/usr/include/opencv2/imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DEdge  cvSubdiv2DNextEdge( CvSubdiv2DEdge edge )$/;"	f	signature:( CvSubdiv2DEdge edge )
cvSubdiv2DRotateEdge	/usr/include/opencv2/imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DEdge  cvSubdiv2DRotateEdge( CvSubdiv2DEdge edge, int rotate )$/;"	f	signature:( CvSubdiv2DEdge edge, int rotate )
cvSubdiv2DSymEdge	/usr/include/opencv2/imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DEdge  cvSubdiv2DSymEdge( CvSubdiv2DEdge edge )$/;"	f	signature:( CvSubdiv2DEdge edge )
cvSumPixels	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS double cvSumPixels( const CvArr* image );$/;"	p	signature:( const CvArr* image )
cvT	/usr/include/opencv2/core/core_c.h	710;"	d
cvTermCriteria	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  CvTermCriteria  cvTermCriteria( int type, int max_iter, double epsilon )$/;"	f	signature:( int type, int max_iter, double epsilon )
cvTestSeqAddIntensityVariation	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvTestSeqAddIntensityVariation(CvTestSeq* pTestSeq, float DI_per_frame, float MinI, float MaxI);$/;"	p	signature:(CvTestSeq* pTestSeq, float DI_per_frame, float MinI, float MaxI)
cvTestSeqAddNoise	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvTestSeqAddNoise(CvTestSeq* pTestSeq, int noise_type = CV_NOISE_NONE, double noise_ampl = 0);$/;"	p	signature:(CvTestSeq* pTestSeq, int noise_type = CV_NOISE_NONE, double noise_ampl = 0)
cvTestSeqFrameNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS int cvTestSeqFrameNum(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqGetFGMask	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS IplImage* cvTestSeqGetFGMask(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqGetImage	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS IplImage* cvTestSeqGetImage(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqGetImageSize	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS CvSize cvTestSeqGetImageSize(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqGetObjectNum	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS int cvTestSeqGetObjectNum(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqGetObjectPos	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS int cvTestSeqGetObjectPos(CvTestSeq* pTestSeq, int ObjIndex, CvPoint2D32f* pPos);$/;"	p	signature:(CvTestSeq* pTestSeq, int ObjIndex, CvPoint2D32f* pPos)
cvTestSeqGetObjectSize	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS int cvTestSeqGetObjectSize(CvTestSeq* pTestSeq, int ObjIndex, CvPoint2D32f* pSize);$/;"	p	signature:(CvTestSeq* pTestSeq, int ObjIndex, CvPoint2D32f* pSize)
cvTestSeqQueryFrame	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS IplImage* cvTestSeqQueryFrame(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqSetFrame	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvTestSeqSetFrame(CvTestSeq* pTestSeq, int n);$/;"	p	signature:(CvTestSeq* pTestSeq, int n)
cvTriangleArea	/usr/include/opencv2/imgproc/imgproc_c.h	/^CV_INLINE  double  cvTriangleArea( CvPoint2D32f a, CvPoint2D32f b, CvPoint2D32f c )$/;"	f	signature:( CvPoint2D32f a, CvPoint2D32f b, CvPoint2D32f c )
cvUnDistort	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvUnDistort( const CvArr* src, CvArr* dst,$/;"	p	signature:( const CvArr* src, CvArr* dst, const CvArr* undistortion_map, int interpolate )
cvUnDistortInit	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvUnDistortInit( const CvArr* src,$/;"	p	signature:( const CvArr* src, CvArr* undistortion_map, const float* A, const float* k, int interpolate )
cvUnDistortOnce	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvUnDistortOnce( const CvArr* src, CvArr* dst,$/;"	p	signature:( const CvArr* src, CvArr* dst, const float* intrinsic_matrix, const float* distortion_coeffs, int interpolate )
cvUnsupportedFormat	/usr/include/opencv2/core/internal.hpp	363;"	d
cvUpdateMHIByTime	/usr/include/opencv2/legacy/compat.hpp	122;"	d
cvWarpPerspectiveQMatrix	/usr/include/opencv2/legacy/compat.hpp	599;"	d
cvWriteStruct	/usr/include/opencv2/legacy/blobtrack.hpp	/^CV_EXPORTS void cvWriteStruct(CvFileStorage* fs, const char* name, void* addr, const char* desc, int num=1);$/;"	p	signature:(CvFileStorage* fs, const char* name, void* addr, const char* desc, int num=1)
cvWriteToAVI	/usr/include/opencv2/highgui/highgui_c.h	378;"	d
cvZero	/usr/include/opencv2/core/core_c.h	426;"	d
cv_Tn	/usr/include/opencv2/ml/ml.hpp	/^    int* cv_Tn;$/;"	m	struct:CvDTreeNode	access:public
cv_folds	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int   cv_folds;$/;"	m	struct:CvDTreeParams	access:public
cv_heap	/usr/include/opencv2/ml/ml.hpp	/^    CvSet* cv_heap;$/;"	m	struct:CvDTreeTrainData	access:public
cv_node_error	/usr/include/opencv2/ml/ml.hpp	/^    double* cv_node_error;$/;"	m	struct:CvDTreeNode	access:public
cv_node_risk	/usr/include/opencv2/ml/ml.hpp	/^    double* cv_node_risk;$/;"	m	struct:CvDTreeNode	access:public
cv_stricmp	/usr/include/opencv2/legacy/blobtrack.hpp	53;"	d
cv_stricmp	/usr/include/opencv2/legacy/blobtrack.hpp	60;"	d
cv_strnicmp	/usr/include/opencv2/legacy/blobtrack.hpp	54;"	d
cv_strnicmp	/usr/include/opencv2/legacy/blobtrack.hpp	61;"	d
cvarrToMat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS Mat cvarrToMat(const CvArr* arr, bool copyData=false,$/;"	p	namespace:cv	signature:(const CvArr* arr, bool copyData=false, bool allowND=true, int coiMode=0)
cvarrToMatND	/usr/include/opencv2/core/mat.hpp	/^static inline Mat cvarrToMatND(const CvArr* arr, bool copyData=false, int coiMode=0)$/;"	f	namespace:cv	signature:(const CvArr* arr, bool copyData=false, int coiMode=0)
cvbCartToPolar	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvbCartToPolar( const float* y, const float* x,$/;"	p	signature:( const float* y, const float* x, float* magnitude, float* angle, int len )
cvbFastArctan	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvbFastArctan( const float* y, const float* x, float* angle, int len );$/;"	p	signature:( const float* y, const float* x, float* angle, int len )
cvbFastExp	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvbFastExp( const float* x, double* y, int len );$/;"	p	signature:( const float* x, double* y, int len )
cvbFastLog	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvbFastLog( const double* x, float* y, int len );$/;"	p	signature:( const double* x, float* y, int len )
cvbInvSqrt	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvbInvSqrt( const float* x, float* y, int len );$/;"	p	signature:( const float* x, float* y, int len )
cvbRand	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvbRand( CvRandState* state, float* dst, int len );$/;"	p	signature:( CvRandState* state, float* dst, int len )
cvbReciprocal	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvbReciprocal( const float* x, float* y, int len );$/;"	p	signature:( const float* x, float* y, int len )
cvbSqrt	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void  cvbSqrt( const float* x, float* y, int len );$/;"	p	signature:( const float* x, float* y, int len )
cvflann	/usr/include/opencv2/flann/all_indices.h	/^namespace cvflann $/;"	n
cvflann	/usr/include/opencv2/flann/allocator.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/autotuned_index.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/composite_index.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/dist.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/flann_base.hpp	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/general.h	/^namespace cvflann {$/;"	n
cvflann	/usr/include/opencv2/flann/ground_truth.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/hdf5.h	/^namespace cvflann $/;"	n
cvflann	/usr/include/opencv2/flann/heap.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/index_testing.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/kdtree_index.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/kmeans_index.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/linear_index.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/logger.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/matrix.h	/^namespace cvflann $/;"	n
cvflann	/usr/include/opencv2/flann/nn_index.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/object_factory.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/random.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/result_set.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/sampling.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/saving.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/simplex_downhill.h	/^namespace cvflann$/;"	n
cvflann	/usr/include/opencv2/flann/timer.h	/^namespace cvflann$/;"	n
cvflann::AUTOTUNED	/usr/include/opencv2/flann/general.h	/^	AUTOTUNED = 255$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::AutotunedIndex	/usr/include/opencv2/flann/autotuned_index.h	/^class AutotunedIndex : public NNIndex<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::AutotunedIndex::AutotunedIndex	/usr/include/opencv2/flann/autotuned_index.h	/^    AutotunedIndex(const Matrix<ELEM_TYPE>& inputData, const AutotunedIndexParams& params = AutotunedIndexParams() ) :$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(const Matrix<ELEM_TYPE>& inputData, const AutotunedIndexParams& params = AutotunedIndexParams() )
cvflann::AutotunedIndex::CostData	/usr/include/opencv2/flann/autotuned_index.h	/^    struct CostData {$/;"	s	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::CostData::buildTimeCost	/usr/include/opencv2/flann/autotuned_index.h	/^        float buildTimeCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
cvflann::AutotunedIndex::CostData::memoryCost	/usr/include/opencv2/flann/autotuned_index.h	/^        float memoryCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
cvflann::AutotunedIndex::CostData::searchTimeCost	/usr/include/opencv2/flann/autotuned_index.h	/^        float searchTimeCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
cvflann::AutotunedIndex::CostData::timeCost	/usr/include/opencv2/flann/autotuned_index.h	/^        float timeCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
cvflann::AutotunedIndex::CostData::totalCost	/usr/include/opencv2/flann/autotuned_index.h	/^        float totalCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
cvflann::AutotunedIndex::KDTreeCostData	/usr/include/opencv2/flann/autotuned_index.h	/^    typedef pair<CostData, KDTreeIndexParams> KDTreeCostData;$/;"	t	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::KMeansCostData	/usr/include/opencv2/flann/autotuned_index.h	/^    typedef pair<CostData, KMeansIndexParams> KMeansCostData;$/;"	t	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::bestIndex	/usr/include/opencv2/flann/autotuned_index.h	/^	NNIndex<ELEM_TYPE>* bestIndex;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::bestParams	/usr/include/opencv2/flann/autotuned_index.h	/^	IndexParams* bestParams;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::bestSearchParams	/usr/include/opencv2/flann/autotuned_index.h	/^	SearchParams bestSearchParams;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::buildIndex	/usr/include/opencv2/flann/autotuned_index.h	/^	virtual void buildIndex()$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:()
cvflann::AutotunedIndex::dataset	/usr/include/opencv2/flann/autotuned_index.h	/^    const Matrix<ELEM_TYPE> dataset;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::estimateBuildParams	/usr/include/opencv2/flann/autotuned_index.h	/^    IndexParams* estimateBuildParams()$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:()
cvflann::AutotunedIndex::estimateSearchParams	/usr/include/opencv2/flann/autotuned_index.h	/^    float estimateSearchParams(SearchParams& searchParams)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(SearchParams& searchParams)
cvflann::AutotunedIndex::evaluate_kdtree	/usr/include/opencv2/flann/autotuned_index.h	/^     void evaluate_kdtree(CostData& cost, const KDTreeIndexParams& kdtree_params)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(CostData& cost, const KDTreeIndexParams& kdtree_params)
cvflann::AutotunedIndex::evaluate_kmeans	/usr/include/opencv2/flann/autotuned_index.h	/^    void evaluate_kmeans(CostData& cost, const KMeansIndexParams& kmeans_params)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(CostData& cost, const KMeansIndexParams& kmeans_params)
cvflann::AutotunedIndex::findNeighbors	/usr/include/opencv2/flann/autotuned_index.h	/^	virtual void findNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)
cvflann::AutotunedIndex::getParameters	/usr/include/opencv2/flann/autotuned_index.h	/^	const IndexParams* getParameters() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::getType	/usr/include/opencv2/flann/autotuned_index.h	/^    virtual flann_algorithm_t getType() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::gt_matches	/usr/include/opencv2/flann/autotuned_index.h	/^    Matrix<int> gt_matches;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::index_params	/usr/include/opencv2/flann/autotuned_index.h	/^    const AutotunedIndexParams& index_params;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::loadIndex	/usr/include/opencv2/flann/autotuned_index.h	/^    virtual void loadIndex(FILE* stream)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(FILE* stream)
cvflann::AutotunedIndex::optimizeKDTree	/usr/include/opencv2/flann/autotuned_index.h	/^    KDTreeCostData optimizeKDTree()$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:()
cvflann::AutotunedIndex::optimizeKMeans	/usr/include/opencv2/flann/autotuned_index.h	/^    KMeansCostData optimizeKMeans()$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:()
cvflann::AutotunedIndex::sampledDataset	/usr/include/opencv2/flann/autotuned_index.h	/^    Matrix<ELEM_TYPE> sampledDataset;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::saveIndex	/usr/include/opencv2/flann/autotuned_index.h	/^    virtual void saveIndex(FILE* stream)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(FILE* stream)
cvflann::AutotunedIndex::size	/usr/include/opencv2/flann/autotuned_index.h	/^	virtual size_t size() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::speedup	/usr/include/opencv2/flann/autotuned_index.h	/^    float speedup;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::testDataset	/usr/include/opencv2/flann/autotuned_index.h	/^    Matrix<ELEM_TYPE> testDataset;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::usedMemory	/usr/include/opencv2/flann/autotuned_index.h	/^ 	virtual int usedMemory() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::veclen	/usr/include/opencv2/flann/autotuned_index.h	/^	virtual size_t veclen() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::~AutotunedIndex	/usr/include/opencv2/flann/autotuned_index.h	/^    virtual ~AutotunedIndex()$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:()
cvflann::AutotunedIndexParams	/usr/include/opencv2/flann/autotuned_index.h	/^struct AutotunedIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::AutotunedIndexParams::AutotunedIndexParams	/usr/include/opencv2/flann/autotuned_index.h	/^	AutotunedIndexParams( float target_precision_ = 0.8, float build_weight_ = 0.01,$/;"	f	struct:cvflann::AutotunedIndexParams	access:public	signature:( float target_precision_ = 0.8, float build_weight_ = 0.01, float memory_weight_ = 0, float sample_fraction_ = 0.1)
cvflann::AutotunedIndexParams::build_weight	/usr/include/opencv2/flann/autotuned_index.h	/^	float build_weight;        \/\/ build tree time weighting factor$/;"	m	struct:cvflann::AutotunedIndexParams	access:public
cvflann::AutotunedIndexParams::getIndexType	/usr/include/opencv2/flann/autotuned_index.h	/^	flann_algorithm_t getIndexType() const { return algorithm; }$/;"	f	struct:cvflann::AutotunedIndexParams	access:public	signature:() const
cvflann::AutotunedIndexParams::memory_weight	/usr/include/opencv2/flann/autotuned_index.h	/^	float memory_weight;       \/\/ index memory weighting factor$/;"	m	struct:cvflann::AutotunedIndexParams	access:public
cvflann::AutotunedIndexParams::print	/usr/include/opencv2/flann/autotuned_index.h	/^	void print() const$/;"	f	struct:cvflann::AutotunedIndexParams	access:public	signature:() const
cvflann::AutotunedIndexParams::sample_fraction	/usr/include/opencv2/flann/autotuned_index.h	/^    float sample_fraction;     \/\/ what fraction of the dataset to use for autotuning$/;"	m	struct:cvflann::AutotunedIndexParams	access:public
cvflann::AutotunedIndexParams::target_precision	/usr/include/opencv2/flann/autotuned_index.h	/^	float target_precision;    \/\/ precision desired (used for autotuning, -1 otherwise)$/;"	m	struct:cvflann::AutotunedIndexParams	access:public
cvflann::BLOCKSIZE	/usr/include/opencv2/flann/allocator.h	/^const  size_t     BLOCKSIZE=8192;$/;"	m	namespace:cvflann
cvflann::BranchStruct	/usr/include/opencv2/flann/result_set.h	/^struct BranchStruct {$/;"	s	namespace:cvflann
cvflann::BranchStruct::make_branch	/usr/include/opencv2/flann/result_set.h	/^    static BranchStruct<T> make_branch(const T& aNode, float dist)$/;"	f	struct:cvflann::BranchStruct	access:public	signature:(const T& aNode, float dist)
cvflann::BranchStruct::mindistsq	/usr/include/opencv2/flann/result_set.h	/^	float mindistsq;     \/* Minimum distance to query for all nodes below. *\/$/;"	m	struct:cvflann::BranchStruct	access:public
cvflann::BranchStruct::node	/usr/include/opencv2/flann/result_set.h	/^	T node;           \/* Tree node at which search resumes *\/$/;"	m	struct:cvflann::BranchStruct	access:public
cvflann::BranchStruct::operator <	/usr/include/opencv2/flann/result_set.h	/^	bool operator<(const BranchStruct<T>& rhs)$/;"	f	struct:cvflann::BranchStruct	access:public	signature:(const BranchStruct<T>& rhs)
cvflann::CENTERS_GONZALES	/usr/include/opencv2/flann/general.h	/^	CENTERS_GONZALES = 1,$/;"	e	enum:cvflann::flann_centers_init_t
cvflann::CENTERS_KMEANSPP	/usr/include/opencv2/flann/general.h	/^	CENTERS_KMEANSPP = 2$/;"	e	enum:cvflann::flann_centers_init_t
cvflann::CENTERS_RANDOM	/usr/include/opencv2/flann/general.h	/^	CENTERS_RANDOM = 0,$/;"	e	enum:cvflann::flann_centers_init_t
cvflann::CHI_SQUARE	/usr/include/opencv2/flann/general.h	/^	CHI_SQUARE = 7,$/;"	e	enum:cvflann::flann_distance_t
cvflann::COMPOSITE	/usr/include/opencv2/flann/general.h	/^	COMPOSITE = 3,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::CS	/usr/include/opencv2/flann/general.h	/^	CS        = 7,$/;"	e	enum:cvflann::flann_distance_t
cvflann::CompositeIndex	/usr/include/opencv2/flann/composite_index.h	/^class CompositeIndex : public NNIndex<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::CompositeIndex::CompositeIndex	/usr/include/opencv2/flann/composite_index.h	/^	CompositeIndex(const Matrix<ELEM_TYPE>& inputData, const CompositeIndexParams& params = CompositeIndexParams() ) :$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(const Matrix<ELEM_TYPE>& inputData, const CompositeIndexParams& params = CompositeIndexParams() )
cvflann::CompositeIndex::buildIndex	/usr/include/opencv2/flann/composite_index.h	/^	void buildIndex()$/;"	f	class:cvflann::CompositeIndex	access:public	signature:()
cvflann::CompositeIndex::dataset	/usr/include/opencv2/flann/composite_index.h	/^    const Matrix<ELEM_TYPE> dataset;$/;"	m	class:cvflann::CompositeIndex	access:private
cvflann::CompositeIndex::findNeighbors	/usr/include/opencv2/flann/composite_index.h	/^	void findNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)
cvflann::CompositeIndex::getParameters	/usr/include/opencv2/flann/composite_index.h	/^	const IndexParams* getParameters() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
cvflann::CompositeIndex::getType	/usr/include/opencv2/flann/composite_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
cvflann::CompositeIndex::index_params	/usr/include/opencv2/flann/composite_index.h	/^    const IndexParams& index_params;$/;"	m	class:cvflann::CompositeIndex	access:private
cvflann::CompositeIndex::kdtree	/usr/include/opencv2/flann/composite_index.h	/^	KDTreeIndex<ELEM_TYPE, DIST_TYPE>* kdtree;$/;"	m	class:cvflann::CompositeIndex	access:private
cvflann::CompositeIndex::kmeans	/usr/include/opencv2/flann/composite_index.h	/^	KMeansIndex<ELEM_TYPE, DIST_TYPE>* kmeans;$/;"	m	class:cvflann::CompositeIndex	access:private
cvflann::CompositeIndex::loadIndex	/usr/include/opencv2/flann/composite_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(FILE* stream)
cvflann::CompositeIndex::saveIndex	/usr/include/opencv2/flann/composite_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(FILE* stream)
cvflann::CompositeIndex::size	/usr/include/opencv2/flann/composite_index.h	/^    size_t size() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
cvflann::CompositeIndex::usedMemory	/usr/include/opencv2/flann/composite_index.h	/^	int usedMemory() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
cvflann::CompositeIndex::veclen	/usr/include/opencv2/flann/composite_index.h	/^	size_t veclen() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
cvflann::CompositeIndex::~CompositeIndex	/usr/include/opencv2/flann/composite_index.h	/^	virtual ~CompositeIndex()$/;"	f	class:cvflann::CompositeIndex	access:public	signature:()
cvflann::CompositeIndexParams	/usr/include/opencv2/flann/composite_index.h	/^struct CompositeIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::CompositeIndexParams::CompositeIndexParams	/usr/include/opencv2/flann/composite_index.h	/^	CompositeIndexParams(int trees_ = 4, int branching_ = 32, int iterations_ = 11,$/;"	f	struct:cvflann::CompositeIndexParams	access:public	signature:(int trees_ = 4, int branching_ = 32, int iterations_ = 11, flann_centers_init_t centers_init_ = CENTERS_RANDOM, float cb_index_ = 0.2 )
cvflann::CompositeIndexParams::branching	/usr/include/opencv2/flann/composite_index.h	/^	int branching;             \/\/ branching factor (for kmeans tree)$/;"	m	struct:cvflann::CompositeIndexParams	access:public
cvflann::CompositeIndexParams::cb_index	/usr/include/opencv2/flann/composite_index.h	/^    float cb_index;            \/\/ cluster boundary index. Used when searching the kmeans tree$/;"	m	struct:cvflann::CompositeIndexParams	access:public
cvflann::CompositeIndexParams::centers_init	/usr/include/opencv2/flann/composite_index.h	/^	flann_centers_init_t centers_init;          \/\/ algorithm used for picking the initial cluster centers for kmeans tree$/;"	m	struct:cvflann::CompositeIndexParams	access:public
cvflann::CompositeIndexParams::getIndexType	/usr/include/opencv2/flann/composite_index.h	/^	flann_algorithm_t getIndexType() const { return algorithm; }$/;"	f	struct:cvflann::CompositeIndexParams	access:public	signature:() const
cvflann::CompositeIndexParams::iterations	/usr/include/opencv2/flann/composite_index.h	/^	int iterations;            \/\/ max iterations to perform in one kmeans clustering (kmeans tree)$/;"	m	struct:cvflann::CompositeIndexParams	access:public
cvflann::CompositeIndexParams::print	/usr/include/opencv2/flann/composite_index.h	/^	void print() const$/;"	f	struct:cvflann::CompositeIndexParams	access:public	signature:() const
cvflann::CompositeIndexParams::trees	/usr/include/opencv2/flann/composite_index.h	/^	int trees;                 \/\/ number of randomized trees to use (for kdtree)$/;"	m	struct:cvflann::CompositeIndexParams	access:public
cvflann::Datatype	/usr/include/opencv2/flann/saving.h	/^template <typename T> struct Datatype {};$/;"	s	namespace:cvflann
cvflann::Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<char> { static flann_datatype_t type() { return INT8; } };$/;"	s	namespace:cvflann
cvflann::Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<double> { static flann_datatype_t type() { return FLOAT64; } };$/;"	s	namespace:cvflann
cvflann::Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<float> { static flann_datatype_t type() { return FLOAT32; } };$/;"	s	namespace:cvflann
cvflann::Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<int> { static flann_datatype_t type() { return INT32; } };$/;"	s	namespace:cvflann
cvflann::Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<short> { static flann_datatype_t type() { return INT16; } };$/;"	s	namespace:cvflann
cvflann::Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned char> { static flann_datatype_t type() { return UINT8; } };$/;"	s	namespace:cvflann
cvflann::Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned int> { static flann_datatype_t type() { return UINT32; } };$/;"	s	namespace:cvflann
cvflann::Datatype	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned short> { static flann_datatype_t type() { return UINT16; } };$/;"	s	namespace:cvflann
cvflann::Datatype::type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<char> { static flann_datatype_t type() { return INT8; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<double> { static flann_datatype_t type() { return FLOAT64; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<float> { static flann_datatype_t type() { return FLOAT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<int> { static flann_datatype_t type() { return INT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<short> { static flann_datatype_t type() { return INT16; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned char> { static flann_datatype_t type() { return UINT8; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned int> { static flann_datatype_t type() { return UINT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned short> { static flann_datatype_t type() { return UINT16; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::DistType	/usr/include/opencv2/flann/general.h	/^struct DistType$/;"	s	namespace:cvflann
cvflann::DistType	/usr/include/opencv2/flann/general.h	/^struct DistType<int>$/;"	s	namespace:cvflann
cvflann::DistType	/usr/include/opencv2/flann/general.h	/^struct DistType<unsigned char>$/;"	s	namespace:cvflann
cvflann::DistType::type	/usr/include/opencv2/flann/general.h	/^	typedef ELEM_TYPE type;$/;"	t	struct:cvflann::DistType	access:public
cvflann::DistType::type	/usr/include/opencv2/flann/general.h	/^	typedef float type;$/;"	t	struct:cvflann::DistType	access:public
cvflann::EUCLIDEAN	/usr/include/opencv2/flann/general.h	/^	EUCLIDEAN = 1,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANNException	/usr/include/opencv2/flann/general.h	/^class FLANNException : public std::runtime_error {$/;"	c	namespace:cvflann	inherits:std::runtime_error
cvflann::FLANNException::FLANNException	/usr/include/opencv2/flann/general.h	/^   FLANNException(const char* message) : std::runtime_error(message) { }$/;"	f	class:cvflann::FLANNException	access:public	signature:(const char* message)
cvflann::FLANNException::FLANNException	/usr/include/opencv2/flann/general.h	/^   FLANNException(const std::string& message) : std::runtime_error(message) { }$/;"	f	class:cvflann::FLANNException	access:public	signature:(const std::string& message)
cvflann::FLANN_SIGNATURE	/usr/include/opencv2/flann/saving.h	/^CV_EXPORTS const char* FLANN_SIGNATURE();$/;"	p	namespace:cvflann	signature:()
cvflann::FLANN_VERSION	/usr/include/opencv2/flann/saving.h	/^CV_EXPORTS const char* FLANN_VERSION();$/;"	p	namespace:cvflann	signature:()
cvflann::FLOAT32	/usr/include/opencv2/flann/general.h	/^	FLOAT32 = 8,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::FLOAT64	/usr/include/opencv2/flann/general.h	/^	FLOAT64 = 9$/;"	e	enum:cvflann::flann_datatype_t
cvflann::HELLINGER	/usr/include/opencv2/flann/general.h	/^	HELLINGER = 6,$/;"	e	enum:cvflann::flann_distance_t
cvflann::HIK	/usr/include/opencv2/flann/general.h	/^	HIK       = 5,$/;"	e	enum:cvflann::flann_distance_t
cvflann::Heap	/usr/include/opencv2/flann/heap.h	/^class Heap {$/;"	c	namespace:cvflann
cvflann::Heap::Heap	/usr/include/opencv2/flann/heap.h	/^	Heap(int size)$/;"	f	class:cvflann::Heap	access:public	signature:(int size)
cvflann::Heap::clear	/usr/include/opencv2/flann/heap.h	/^	void clear()$/;"	f	class:cvflann::Heap	access:public	signature:()
cvflann::Heap::count	/usr/include/opencv2/flann/heap.h	/^	int count;$/;"	m	class:cvflann::Heap	access:private
cvflann::Heap::empty	/usr/include/opencv2/flann/heap.h	/^	bool empty()$/;"	f	class:cvflann::Heap	access:public	signature:()
cvflann::Heap::heap	/usr/include/opencv2/flann/heap.h	/^	T* heap;$/;"	m	class:cvflann::Heap	access:private
cvflann::Heap::heapify	/usr/include/opencv2/flann/heap.h	/^	void heapify(int parent)$/;"	f	class:cvflann::Heap	access:public	signature:(int parent)
cvflann::Heap::insert	/usr/include/opencv2/flann/heap.h	/^	void insert(T value)$/;"	f	class:cvflann::Heap	access:public	signature:(T value)
cvflann::Heap::length	/usr/include/opencv2/flann/heap.h	/^    int length;$/;"	m	class:cvflann::Heap	access:private
cvflann::Heap::popMin	/usr/include/opencv2/flann/heap.h	/^	bool popMin(T& value)$/;"	f	class:cvflann::Heap	access:public	signature:(T& value)
cvflann::Heap::size	/usr/include/opencv2/flann/heap.h	/^	int size()$/;"	f	class:cvflann::Heap	access:public	signature:()
cvflann::Heap::~Heap	/usr/include/opencv2/flann/heap.h	/^	~Heap()$/;"	f	class:cvflann::Heap	access:public	signature:()
cvflann::INT16	/usr/include/opencv2/flann/general.h	/^	INT16 = 1,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::INT32	/usr/include/opencv2/flann/general.h	/^	INT32 = 2,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::INT64	/usr/include/opencv2/flann/general.h	/^	INT64 = 3,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::INT8	/usr/include/opencv2/flann/general.h	/^	INT8 = 0,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::Index	/usr/include/opencv2/flann/flann_base.hpp	/^class CV_EXPORTS Index {$/;"	c	namespace:cvflann
cvflann::Index::Index	/usr/include/opencv2/flann/flann_base.hpp	/^	Index(const Matrix<T>& features, const IndexParams& params);$/;"	p	class:cvflann::Index	access:public	signature:(const Matrix<T>& features, const IndexParams& params)
cvflann::Index::Index	/usr/include/opencv2/flann/flann_base.hpp	/^Index<T>::Index(const Matrix<T>& dataset, const IndexParams& params)$/;"	f	class:cvflann::Index	signature:(const Matrix<T>& dataset, const IndexParams& params)
cvflann::Index::buildIndex	/usr/include/opencv2/flann/flann_base.hpp	/^	void buildIndex();$/;"	p	class:cvflann::Index	access:public	signature:()
cvflann::Index::buildIndex	/usr/include/opencv2/flann/flann_base.hpp	/^void Index<T>::buildIndex()$/;"	f	class:cvflann::Index	signature:()
cvflann::Index::built	/usr/include/opencv2/flann/flann_base.hpp	/^    bool built;$/;"	m	class:cvflann::Index	access:private
cvflann::Index::getIndex	/usr/include/opencv2/flann/flann_base.hpp	/^	NNIndex<T>* getIndex() { return nnIndex; }$/;"	f	class:cvflann::Index	access:public	signature:()
cvflann::Index::getIndexParameters	/usr/include/opencv2/flann/flann_base.hpp	/^	const IndexParams* getIndexParameters() { return nnIndex->getParameters(); }$/;"	f	class:cvflann::Index	access:public	signature:()
cvflann::Index::knnSearch	/usr/include/opencv2/flann/flann_base.hpp	/^	void knnSearch(const Matrix<T>& queries, Matrix<int>& indices, Matrix<float>& dists, int knn, const SearchParams& params);$/;"	p	class:cvflann::Index	access:public	signature:(const Matrix<T>& queries, Matrix<int>& indices, Matrix<float>& dists, int knn, const SearchParams& params)
cvflann::Index::knnSearch	/usr/include/opencv2/flann/flann_base.hpp	/^void Index<T>::knnSearch(const Matrix<T>& queries, Matrix<int>& indices, Matrix<float>& dists, int knn, const SearchParams& searchParams)$/;"	f	class:cvflann::Index	signature:(const Matrix<T>& queries, Matrix<int>& indices, Matrix<float>& dists, int knn, const SearchParams& searchParams)
cvflann::Index::nnIndex	/usr/include/opencv2/flann/flann_base.hpp	/^	NNIndex<T>* nnIndex;$/;"	m	class:cvflann::Index	access:private
cvflann::Index::radiusSearch	/usr/include/opencv2/flann/flann_base.hpp	/^	int radiusSearch(const Matrix<T>& query, Matrix<int>& indices, Matrix<float>& dists, float radius, const SearchParams& params);$/;"	p	class:cvflann::Index	access:public	signature:(const Matrix<T>& query, Matrix<int>& indices, Matrix<float>& dists, float radius, const SearchParams& params)
cvflann::Index::radiusSearch	/usr/include/opencv2/flann/flann_base.hpp	/^int Index<T>::radiusSearch(const Matrix<T>& query, Matrix<int>& indices, Matrix<float>& dists, float radius, const SearchParams& searchParams)$/;"	f	class:cvflann::Index	signature:(const Matrix<T>& query, Matrix<int>& indices, Matrix<float>& dists, float radius, const SearchParams& searchParams)
cvflann::Index::save	/usr/include/opencv2/flann/flann_base.hpp	/^	void save(std::string filename);$/;"	p	class:cvflann::Index	access:public	signature:(std::string filename)
cvflann::Index::save	/usr/include/opencv2/flann/flann_base.hpp	/^void Index<T>::save(string filename)$/;"	f	class:cvflann::Index	signature:(string filename)
cvflann::Index::size	/usr/include/opencv2/flann/flann_base.hpp	/^	int size() const;$/;"	p	class:cvflann::Index	access:public	signature:() const
cvflann::Index::size	/usr/include/opencv2/flann/flann_base.hpp	/^int Index<T>::size() const$/;"	f	class:cvflann::Index	signature:() const
cvflann::Index::veclen	/usr/include/opencv2/flann/flann_base.hpp	/^	int veclen() const;$/;"	p	class:cvflann::Index	access:public	signature:() const
cvflann::Index::veclen	/usr/include/opencv2/flann/flann_base.hpp	/^int Index<T>::veclen() const$/;"	f	class:cvflann::Index	signature:() const
cvflann::Index::~Index	/usr/include/opencv2/flann/flann_base.hpp	/^	~Index();$/;"	p	class:cvflann::Index	access:public	signature:()
cvflann::Index::~Index	/usr/include/opencv2/flann/flann_base.hpp	/^Index<T>::~Index()$/;"	f	class:cvflann::Index	signature:()
cvflann::IndexHeader	/usr/include/opencv2/flann/saving.h	/^struct CV_EXPORTS IndexHeader$/;"	s	namespace:cvflann
cvflann::IndexHeader::cols	/usr/include/opencv2/flann/saving.h	/^	int cols;$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexHeader::data_type	/usr/include/opencv2/flann/saving.h	/^	flann_datatype_t data_type;$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexHeader::index_type	/usr/include/opencv2/flann/saving.h	/^	flann_algorithm_t index_type;$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexHeader::rows	/usr/include/opencv2/flann/saving.h	/^	int rows;$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexHeader::signature	/usr/include/opencv2/flann/saving.h	/^	char signature[16];$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexHeader::version	/usr/include/opencv2/flann/saving.h	/^	char version[16];$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexParams	/usr/include/opencv2/flann/general.h	/^struct CV_EXPORTS IndexParams {$/;"	s	namespace:cvflann
cvflann::IndexParams::IndexParams	/usr/include/opencv2/flann/general.h	/^	IndexParams(flann_algorithm_t algorithm_) : algorithm(algorithm_) {};$/;"	f	struct:cvflann::IndexParams	access:protected	signature:(flann_algorithm_t algorithm_)
cvflann::IndexParams::algorithm	/usr/include/opencv2/flann/general.h	/^	flann_algorithm_t algorithm;$/;"	m	struct:cvflann::IndexParams	access:public
cvflann::IndexParams::getIndexType	/usr/include/opencv2/flann/general.h	/^	virtual flann_algorithm_t getIndexType() const = 0;$/;"	p	struct:cvflann::IndexParams	access:public	signature:() const
cvflann::IndexParams::print	/usr/include/opencv2/flann/general.h	/^	virtual void print() const = 0;$/;"	p	struct:cvflann::IndexParams	access:public	signature:() const
cvflann::IndexParams::~IndexParams	/usr/include/opencv2/flann/general.h	/^	virtual ~IndexParams() {}$/;"	f	struct:cvflann::IndexParams	access:public	signature:()
cvflann::KDTREE	/usr/include/opencv2/flann/general.h	/^	KDTREE = 1,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::KDTreeIndex	/usr/include/opencv2/flann/kdtree_index.h	/^class KDTreeIndex : public NNIndex<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::KDTreeIndex::Branch	/usr/include/opencv2/flann/kdtree_index.h	/^    typedef BranchSt* Branch;$/;"	t	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::BranchSt	/usr/include/opencv2/flann/kdtree_index.h	/^    typedef BranchStruct<Tree> BranchSt;$/;"	t	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::KDTreeIndex	/usr/include/opencv2/flann/kdtree_index.h	/^	KDTreeIndex(const Matrix<ELEM_TYPE>& inputData, const KDTreeIndexParams& params = KDTreeIndexParams() ) :$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(const Matrix<ELEM_TYPE>& inputData, const KDTreeIndexParams& params = KDTreeIndexParams() )
cvflann::KDTreeIndex::RAND_DIM	/usr/include/opencv2/flann/kdtree_index.h	/^		RAND_DIM=5$/;"	e	enum:cvflann::KDTreeIndex::__anon185
cvflann::KDTreeIndex::SAMPLE_MEAN	/usr/include/opencv2/flann/kdtree_index.h	/^		SAMPLE_MEAN = 100,$/;"	e	enum:cvflann::KDTreeIndex::__anon185
cvflann::KDTreeIndex::Tree	/usr/include/opencv2/flann/kdtree_index.h	/^	typedef TreeSt* Tree;$/;"	t	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::TreeSt	/usr/include/opencv2/flann/kdtree_index.h	/^	struct TreeSt {$/;"	s	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::TreeSt::child1	/usr/include/opencv2/flann/kdtree_index.h	/^		TreeSt *child1, *child2;$/;"	m	struct:cvflann::KDTreeIndex::TreeSt	access:public
cvflann::KDTreeIndex::TreeSt::child2	/usr/include/opencv2/flann/kdtree_index.h	/^		TreeSt *child1, *child2;$/;"	m	struct:cvflann::KDTreeIndex::TreeSt	access:public
cvflann::KDTreeIndex::TreeSt::divfeat	/usr/include/opencv2/flann/kdtree_index.h	/^		int divfeat;$/;"	m	struct:cvflann::KDTreeIndex::TreeSt	access:public
cvflann::KDTreeIndex::TreeSt::divval	/usr/include/opencv2/flann/kdtree_index.h	/^		DIST_TYPE divval;$/;"	m	struct:cvflann::KDTreeIndex::TreeSt	access:public
cvflann::KDTreeIndex::buildIndex	/usr/include/opencv2/flann/kdtree_index.h	/^	void buildIndex()$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:()
cvflann::KDTreeIndex::chooseDivision	/usr/include/opencv2/flann/kdtree_index.h	/^	void chooseDivision(Tree node, int first, int last)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(Tree node, int first, int last)
cvflann::KDTreeIndex::dataset	/usr/include/opencv2/flann/kdtree_index.h	/^	const Matrix<ELEM_TYPE> dataset;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::divideTree	/usr/include/opencv2/flann/kdtree_index.h	/^	Tree divideTree(int first, int last)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(int first, int last)
cvflann::KDTreeIndex::findNeighbors	/usr/include/opencv2/flann/kdtree_index.h	/^    void findNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)
cvflann::KDTreeIndex::getExactNeighbors	/usr/include/opencv2/flann/kdtree_index.h	/^	void getExactNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec)
cvflann::KDTreeIndex::getNeighbors	/usr/include/opencv2/flann/kdtree_index.h	/^	void getNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, int maxCheck)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, int maxCheck)
cvflann::KDTreeIndex::getParameters	/usr/include/opencv2/flann/kdtree_index.h	/^	const IndexParams* getParameters() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
cvflann::KDTreeIndex::getType	/usr/include/opencv2/flann/kdtree_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
cvflann::KDTreeIndex::index_params	/usr/include/opencv2/flann/kdtree_index.h	/^    const IndexParams& index_params;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::loadIndex	/usr/include/opencv2/flann/kdtree_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(FILE* stream)
cvflann::KDTreeIndex::load_tree	/usr/include/opencv2/flann/kdtree_index.h	/^    void load_tree(FILE* stream, Tree& tree)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(FILE* stream, Tree& tree)
cvflann::KDTreeIndex::mean	/usr/include/opencv2/flann/kdtree_index.h	/^    DIST_TYPE* mean;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::numTrees	/usr/include/opencv2/flann/kdtree_index.h	/^	int numTrees;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::pool	/usr/include/opencv2/flann/kdtree_index.h	/^	PooledAllocator pool;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::saveIndex	/usr/include/opencv2/flann/kdtree_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(FILE* stream)
cvflann::KDTreeIndex::save_tree	/usr/include/opencv2/flann/kdtree_index.h	/^    void save_tree(FILE* stream, Tree tree)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(FILE* stream, Tree tree)
cvflann::KDTreeIndex::searchLevel	/usr/include/opencv2/flann/kdtree_index.h	/^	void searchLevel(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, Tree node, float mindistsq, int& checkCount, int maxCheck,$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, Tree node, float mindistsq, int& checkCount, int maxCheck, Heap<BranchSt>* heap, vector<bool>& checked)
cvflann::KDTreeIndex::searchLevelExact	/usr/include/opencv2/flann/kdtree_index.h	/^	void searchLevelExact(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, Tree node, float mindistsq)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, Tree node, float mindistsq)
cvflann::KDTreeIndex::selectDivision	/usr/include/opencv2/flann/kdtree_index.h	/^	int selectDivision(DIST_TYPE* v)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(DIST_TYPE* v)
cvflann::KDTreeIndex::size	/usr/include/opencv2/flann/kdtree_index.h	/^    size_t size() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
cvflann::KDTreeIndex::size_	/usr/include/opencv2/flann/kdtree_index.h	/^	size_t size_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::subdivide	/usr/include/opencv2/flann/kdtree_index.h	/^	void subdivide(Tree node, int first, int last)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(Tree node, int first, int last)
cvflann::KDTreeIndex::trees	/usr/include/opencv2/flann/kdtree_index.h	/^    Tree* trees;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::usedMemory	/usr/include/opencv2/flann/kdtree_index.h	/^	int usedMemory() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
cvflann::KDTreeIndex::var	/usr/include/opencv2/flann/kdtree_index.h	/^    DIST_TYPE* var;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::veclen	/usr/include/opencv2/flann/kdtree_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
cvflann::KDTreeIndex::veclen_	/usr/include/opencv2/flann/kdtree_index.h	/^	size_t veclen_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::vind	/usr/include/opencv2/flann/kdtree_index.h	/^	int* vind;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::~KDTreeIndex	/usr/include/opencv2/flann/kdtree_index.h	/^	~KDTreeIndex()$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:()
cvflann::KDTreeIndexParams	/usr/include/opencv2/flann/kdtree_index.h	/^struct CV_EXPORTS KDTreeIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::KDTreeIndexParams::KDTreeIndexParams	/usr/include/opencv2/flann/kdtree_index.h	/^	KDTreeIndexParams(int trees_ = 4) : IndexParams(KDTREE), trees(trees_) {};$/;"	f	struct:cvflann::KDTreeIndexParams	access:public	signature:(int trees_ = 4)
cvflann::KDTreeIndexParams::getIndexType	/usr/include/opencv2/flann/kdtree_index.h	/^	flann_algorithm_t getIndexType() const { return algorithm; }$/;"	f	struct:cvflann::KDTreeIndexParams	access:public	signature:() const
cvflann::KDTreeIndexParams::print	/usr/include/opencv2/flann/kdtree_index.h	/^	void print() const$/;"	f	struct:cvflann::KDTreeIndexParams	access:public	signature:() const
cvflann::KDTreeIndexParams::trees	/usr/include/opencv2/flann/kdtree_index.h	/^	int trees;                 \/\/ number of randomized trees to use (for kdtree)$/;"	m	struct:cvflann::KDTreeIndexParams	access:public
cvflann::KL	/usr/include/opencv2/flann/general.h	/^	KL        = 8,$/;"	e	enum:cvflann::flann_distance_t
cvflann::KMEANS	/usr/include/opencv2/flann/general.h	/^	KMEANS = 2,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::KMeansIndex	/usr/include/opencv2/flann/kmeans_index.h	/^class KMeansIndex : public NNIndex<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::KMeansIndex::BranchSt	/usr/include/opencv2/flann/kmeans_index.h	/^    typedef BranchStruct<KMeansNode> BranchSt;$/;"	t	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::KMeansIndex	/usr/include/opencv2/flann/kmeans_index.h	/^	KMeansIndex(const Matrix<ELEM_TYPE>& inputData, const KMeansIndexParams& params = KMeansIndexParams() )$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(const Matrix<ELEM_TYPE>& inputData, const KMeansIndexParams& params = KMeansIndexParams() )
cvflann::KMeansIndex::KMeansNode	/usr/include/opencv2/flann/kmeans_index.h	/^    typedef KMeansNodeSt* KMeansNode;$/;"	t	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::KMeansNodeSt	/usr/include/opencv2/flann/kmeans_index.h	/^	struct KMeansNodeSt	{$/;"	s	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::KMeansNodeSt::childs	/usr/include/opencv2/flann/kmeans_index.h	/^		KMeansNodeSt** childs;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
cvflann::KMeansIndex::KMeansNodeSt::indices	/usr/include/opencv2/flann/kmeans_index.h	/^		int* indices;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
cvflann::KMeansIndex::KMeansNodeSt::level	/usr/include/opencv2/flann/kmeans_index.h	/^		int level;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
cvflann::KMeansIndex::KMeansNodeSt::mean_radius	/usr/include/opencv2/flann/kmeans_index.h	/^		DIST_TYPE mean_radius;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
cvflann::KMeansIndex::KMeansNodeSt::pivot	/usr/include/opencv2/flann/kmeans_index.h	/^		DIST_TYPE* pivot;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
cvflann::KMeansIndex::KMeansNodeSt::radius	/usr/include/opencv2/flann/kmeans_index.h	/^		DIST_TYPE radius;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
cvflann::KMeansIndex::KMeansNodeSt::size	/usr/include/opencv2/flann/kmeans_index.h	/^		int size;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
cvflann::KMeansIndex::KMeansNodeSt::variance	/usr/include/opencv2/flann/kmeans_index.h	/^		DIST_TYPE variance;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
cvflann::KMeansIndex::branching	/usr/include/opencv2/flann/kmeans_index.h	/^	int branching;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::buildIndex	/usr/include/opencv2/flann/kmeans_index.h	/^	void buildIndex()$/;"	f	class:cvflann::KMeansIndex	access:public	signature:()
cvflann::KMeansIndex::cb_index	/usr/include/opencv2/flann/kmeans_index.h	/^    float cb_index;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::centersAlgFunction	/usr/include/opencv2/flann/kmeans_index.h	/^	typedef void (KMeansIndex::*centersAlgFunction)(int, int*, int, int*, int&);$/;"	t	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::chooseCenters	/usr/include/opencv2/flann/kmeans_index.h	/^    centersAlgFunction chooseCenters;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::chooseCentersGonzales	/usr/include/opencv2/flann/kmeans_index.h	/^    void chooseCentersGonzales(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
cvflann::KMeansIndex::chooseCentersKMeanspp	/usr/include/opencv2/flann/kmeans_index.h	/^    void chooseCentersKMeanspp(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
cvflann::KMeansIndex::chooseCentersRandom	/usr/include/opencv2/flann/kmeans_index.h	/^    void chooseCentersRandom(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
cvflann::KMeansIndex::computeClustering	/usr/include/opencv2/flann/kmeans_index.h	/^	void computeClustering(KMeansNode node, int* indices, int indices_length, int branching, int level)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, int* indices, int indices_length, int branching, int level)
cvflann::KMeansIndex::computeNodeStatistics	/usr/include/opencv2/flann/kmeans_index.h	/^	void computeNodeStatistics(KMeansNode node, int* indices, int indices_length) {$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, int* indices, int indices_length)
cvflann::KMeansIndex::dataset	/usr/include/opencv2/flann/kmeans_index.h	/^    const Matrix<ELEM_TYPE> dataset;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::exploreNodeBranches	/usr/include/opencv2/flann/kmeans_index.h	/^	int exploreNodeBranches(KMeansNode node, const ELEM_TYPE* q, float* domain_distances, Heap<BranchSt>* heap)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, const ELEM_TYPE* q, float* domain_distances, Heap<BranchSt>* heap)
cvflann::KMeansIndex::findExactNN	/usr/include/opencv2/flann/kmeans_index.h	/^	void findExactNN(KMeansNode node, ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec)
cvflann::KMeansIndex::findNN	/usr/include/opencv2/flann/kmeans_index.h	/^	void findNN(KMeansNode node, ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, int& checks, int maxChecks,$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, int& checks, int maxChecks, Heap<BranchSt>* heap)
cvflann::KMeansIndex::findNeighbors	/usr/include/opencv2/flann/kmeans_index.h	/^    void findNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)
cvflann::KMeansIndex::free_centers	/usr/include/opencv2/flann/kmeans_index.h	/^    void free_centers(KMeansNode node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node)
cvflann::KMeansIndex::getCenterOrdering	/usr/include/opencv2/flann/kmeans_index.h	/^	void getCenterOrdering(KMeansNode node, const ELEM_TYPE* q, int* sort_indices)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, const ELEM_TYPE* q, int* sort_indices)
cvflann::KMeansIndex::getClusterCenters	/usr/include/opencv2/flann/kmeans_index.h	/^    int getClusterCenters(Matrix<DIST_TYPE>& centers)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(Matrix<DIST_TYPE>& centers)
cvflann::KMeansIndex::getDistanceToBorder	/usr/include/opencv2/flann/kmeans_index.h	/^	float getDistanceToBorder(float* p, float* c, float* q)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(float* p, float* c, float* q)
cvflann::KMeansIndex::getMinVarianceClusters	/usr/include/opencv2/flann/kmeans_index.h	/^	int getMinVarianceClusters(KMeansNode root, KMeansNode* clusters, int clusters_length, float& varianceValue)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode root, KMeansNode* clusters, int clusters_length, float& varianceValue)
cvflann::KMeansIndex::getParameters	/usr/include/opencv2/flann/kmeans_index.h	/^	const IndexParams* getParameters() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
cvflann::KMeansIndex::getType	/usr/include/opencv2/flann/kmeans_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
cvflann::KMeansIndex::index_params	/usr/include/opencv2/flann/kmeans_index.h	/^    const IndexParams& index_params;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::indices	/usr/include/opencv2/flann/kmeans_index.h	/^	int* indices;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::loadIndex	/usr/include/opencv2/flann/kmeans_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(FILE* stream)
cvflann::KMeansIndex::load_tree	/usr/include/opencv2/flann/kmeans_index.h	/^    void load_tree(FILE* stream, KMeansNode& node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(FILE* stream, KMeansNode& node)
cvflann::KMeansIndex::max_iter	/usr/include/opencv2/flann/kmeans_index.h	/^	int max_iter;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::memoryCounter	/usr/include/opencv2/flann/kmeans_index.h	/^	int memoryCounter;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::pool	/usr/include/opencv2/flann/kmeans_index.h	/^	PooledAllocator pool;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::root	/usr/include/opencv2/flann/kmeans_index.h	/^	KMeansNode root;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::saveIndex	/usr/include/opencv2/flann/kmeans_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(FILE* stream)
cvflann::KMeansIndex::save_tree	/usr/include/opencv2/flann/kmeans_index.h	/^    void save_tree(FILE* stream, KMeansNode node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(FILE* stream, KMeansNode node)
cvflann::KMeansIndex::set_cb_index	/usr/include/opencv2/flann/kmeans_index.h	/^    void set_cb_index( float index)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:( float index)
cvflann::KMeansIndex::size	/usr/include/opencv2/flann/kmeans_index.h	/^	size_t size() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
cvflann::KMeansIndex::size_	/usr/include/opencv2/flann/kmeans_index.h	/^    size_t size_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::usedMemory	/usr/include/opencv2/flann/kmeans_index.h	/^	int usedMemory() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
cvflann::KMeansIndex::veclen	/usr/include/opencv2/flann/kmeans_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
cvflann::KMeansIndex::veclen_	/usr/include/opencv2/flann/kmeans_index.h	/^    size_t veclen_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::~KMeansIndex	/usr/include/opencv2/flann/kmeans_index.h	/^	virtual ~KMeansIndex()$/;"	f	class:cvflann::KMeansIndex	access:public	signature:()
cvflann::KMeansIndexParams	/usr/include/opencv2/flann/kmeans_index.h	/^struct CV_EXPORTS KMeansIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::KMeansIndexParams::KMeansIndexParams	/usr/include/opencv2/flann/kmeans_index.h	/^	KMeansIndexParams(int branching_ = 32, int iterations_ = 11,$/;"	f	struct:cvflann::KMeansIndexParams	access:public	signature:(int branching_ = 32, int iterations_ = 11, flann_centers_init_t centers_init_ = CENTERS_RANDOM, float cb_index_ = 0.2 )
cvflann::KMeansIndexParams::branching	/usr/include/opencv2/flann/kmeans_index.h	/^	int branching;             \/\/ branching factor (for kmeans tree)$/;"	m	struct:cvflann::KMeansIndexParams	access:public
cvflann::KMeansIndexParams::cb_index	/usr/include/opencv2/flann/kmeans_index.h	/^    float cb_index;            \/\/ cluster boundary index. Used when searching the kmeans tree$/;"	m	struct:cvflann::KMeansIndexParams	access:public
cvflann::KMeansIndexParams::centers_init	/usr/include/opencv2/flann/kmeans_index.h	/^	flann_centers_init_t centers_init;          \/\/ algorithm used for picking the initial cluster centers for kmeans tree$/;"	m	struct:cvflann::KMeansIndexParams	access:public
cvflann::KMeansIndexParams::getIndexType	/usr/include/opencv2/flann/kmeans_index.h	/^	flann_algorithm_t getIndexType() const { return KMEANS; }$/;"	f	struct:cvflann::KMeansIndexParams	access:public	signature:() const
cvflann::KMeansIndexParams::iterations	/usr/include/opencv2/flann/kmeans_index.h	/^	int iterations;            \/\/ max iterations to perform in one kmeans clustering (kmeans tree)$/;"	m	struct:cvflann::KMeansIndexParams	access:public
cvflann::KMeansIndexParams::print	/usr/include/opencv2/flann/kmeans_index.h	/^	void print() const$/;"	f	struct:cvflann::KMeansIndexParams	access:public	signature:() const
cvflann::KNNResultSet	/usr/include/opencv2/flann/result_set.h	/^class KNNResultSet : public ResultSet<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:ResultSet
cvflann::KNNResultSet::KNNResultSet	/usr/include/opencv2/flann/result_set.h	/^	KNNResultSet(int capacity_, ELEM_TYPE* target_ = NULL, int veclen_ = 0 ) :$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(int capacity_, ELEM_TYPE* target_ = NULL, int veclen_ = 0 )
cvflann::KNNResultSet::addPoint	/usr/include/opencv2/flann/result_set.h	/^	bool addPoint(const ELEM_TYPE* point, int index)$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(const ELEM_TYPE* point, int index)
cvflann::KNNResultSet::capacity	/usr/include/opencv2/flann/result_set.h	/^    int capacity;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNResultSet::count	/usr/include/opencv2/flann/result_set.h	/^	int count;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNResultSet::dists	/usr/include/opencv2/flann/result_set.h	/^	float* dists;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNResultSet::full	/usr/include/opencv2/flann/result_set.h	/^	bool full() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
cvflann::KNNResultSet::getDistances	/usr/include/opencv2/flann/result_set.h	/^    float* getDistances()$/;"	f	class:cvflann::KNNResultSet	access:public	signature:()
cvflann::KNNResultSet::getNeighbors	/usr/include/opencv2/flann/result_set.h	/^	int* getNeighbors()$/;"	f	class:cvflann::KNNResultSet	access:public	signature:()
cvflann::KNNResultSet::indices	/usr/include/opencv2/flann/result_set.h	/^	int* indices;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNResultSet::init	/usr/include/opencv2/flann/result_set.h	/^	void init(const ELEM_TYPE* target_, int veclen_)$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(const ELEM_TYPE* target_, int veclen_)
cvflann::KNNResultSet::size	/usr/include/opencv2/flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
cvflann::KNNResultSet::target	/usr/include/opencv2/flann/result_set.h	/^	const ELEM_TYPE* target;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNResultSet::target_end	/usr/include/opencv2/flann/result_set.h	/^	const ELEM_TYPE* target_end;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNResultSet::veclen	/usr/include/opencv2/flann/result_set.h	/^    int veclen;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNResultSet::worstDist	/usr/include/opencv2/flann/result_set.h	/^	float worstDist() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
cvflann::KNNResultSet::~KNNResultSet	/usr/include/opencv2/flann/result_set.h	/^	~KNNResultSet()$/;"	f	class:cvflann::KNNResultSet	access:public	signature:()
cvflann::KULLBACK_LEIBLER	/usr/include/opencv2/flann/general.h	/^	KULLBACK_LEIBLER        = 8$/;"	e	enum:cvflann::flann_distance_t
cvflann::LINEAR	/usr/include/opencv2/flann/general.h	/^	LINEAR = 0,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::LOG_ERROR	/usr/include/opencv2/flann/general.h	/^	LOG_ERROR = 2,$/;"	e	enum:cvflann::flann_log_level_t
cvflann::LOG_FATAL	/usr/include/opencv2/flann/general.h	/^	LOG_FATAL = 1,$/;"	e	enum:cvflann::flann_log_level_t
cvflann::LOG_INFO	/usr/include/opencv2/flann/general.h	/^	LOG_INFO = 4$/;"	e	enum:cvflann::flann_log_level_t
cvflann::LOG_NONE	/usr/include/opencv2/flann/general.h	/^	LOG_NONE = 0,$/;"	e	enum:cvflann::flann_log_level_t
cvflann::LOG_WARN	/usr/include/opencv2/flann/general.h	/^	LOG_WARN = 3,$/;"	e	enum:cvflann::flann_log_level_t
cvflann::LinearIndex	/usr/include/opencv2/flann/linear_index.h	/^class LinearIndex : public NNIndex<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::LinearIndex::LinearIndex	/usr/include/opencv2/flann/linear_index.h	/^	LinearIndex(const Matrix<ELEM_TYPE>& inputData, const LinearIndexParams& params = LinearIndexParams() ) :$/;"	f	class:cvflann::LinearIndex	access:public	signature:(const Matrix<ELEM_TYPE>& inputData, const LinearIndexParams& params = LinearIndexParams() )
cvflann::LinearIndex::buildIndex	/usr/include/opencv2/flann/linear_index.h	/^	void buildIndex()$/;"	f	class:cvflann::LinearIndex	access:public	signature:()
cvflann::LinearIndex::dataset	/usr/include/opencv2/flann/linear_index.h	/^	const Matrix<ELEM_TYPE> dataset;$/;"	m	class:cvflann::LinearIndex	access:private
cvflann::LinearIndex::findNeighbors	/usr/include/opencv2/flann/linear_index.h	/^	void findNeighbors(ResultSet<ELEM_TYPE>& resultSet, const ELEM_TYPE*, const SearchParams&)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(ResultSet<ELEM_TYPE>& resultSet, const ELEM_TYPE*, const SearchParams&)
cvflann::LinearIndex::getParameters	/usr/include/opencv2/flann/linear_index.h	/^	const IndexParams* getParameters() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
cvflann::LinearIndex::getType	/usr/include/opencv2/flann/linear_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
cvflann::LinearIndex::index_params	/usr/include/opencv2/flann/linear_index.h	/^	const LinearIndexParams& index_params;$/;"	m	class:cvflann::LinearIndex	access:private
cvflann::LinearIndex::loadIndex	/usr/include/opencv2/flann/linear_index.h	/^    void loadIndex(FILE*)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(FILE*)
cvflann::LinearIndex::saveIndex	/usr/include/opencv2/flann/linear_index.h	/^    void saveIndex(FILE*)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(FILE*)
cvflann::LinearIndex::size	/usr/include/opencv2/flann/linear_index.h	/^	size_t size() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
cvflann::LinearIndex::usedMemory	/usr/include/opencv2/flann/linear_index.h	/^	int usedMemory() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
cvflann::LinearIndex::veclen	/usr/include/opencv2/flann/linear_index.h	/^	size_t veclen() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
cvflann::LinearIndexParams	/usr/include/opencv2/flann/linear_index.h	/^struct CV_EXPORTS LinearIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::LinearIndexParams::LinearIndexParams	/usr/include/opencv2/flann/linear_index.h	/^	LinearIndexParams() : IndexParams(LINEAR) {};$/;"	f	struct:cvflann::LinearIndexParams	access:public	signature:()
cvflann::LinearIndexParams::getIndexType	/usr/include/opencv2/flann/linear_index.h	/^	flann_algorithm_t getIndexType() const { return algorithm; }$/;"	f	struct:cvflann::LinearIndexParams	access:public	signature:() const
cvflann::LinearIndexParams::print	/usr/include/opencv2/flann/linear_index.h	/^	void print() const$/;"	f	struct:cvflann::LinearIndexParams	access:public	signature:() const
cvflann::Logger	/usr/include/opencv2/flann/logger.h	/^class CV_EXPORTS Logger$/;"	c	namespace:cvflann
cvflann::Logger::Logger	/usr/include/opencv2/flann/logger.h	/^    Logger() : stream(stdout), logLevel(LOG_WARN) {};$/;"	f	class:cvflann::Logger	access:public	signature:()
cvflann::Logger::error	/usr/include/opencv2/flann/logger.h	/^    int error(const char* fmt, ...);$/;"	p	class:cvflann::Logger	access:public	signature:(const char* fmt, ...)
cvflann::Logger::fatal	/usr/include/opencv2/flann/logger.h	/^    int fatal(const char* fmt, ...);$/;"	p	class:cvflann::Logger	access:public	signature:(const char* fmt, ...)
cvflann::Logger::info	/usr/include/opencv2/flann/logger.h	/^    int info(const char* fmt, ...);$/;"	p	class:cvflann::Logger	access:public	signature:(const char* fmt, ...)
cvflann::Logger::log	/usr/include/opencv2/flann/logger.h	/^    int log(int level, const char* fmt, ...);$/;"	p	class:cvflann::Logger	access:public	signature:(int level, const char* fmt, ...)
cvflann::Logger::log	/usr/include/opencv2/flann/logger.h	/^    int log(int level, const char* fmt, va_list arglist);$/;"	p	class:cvflann::Logger	access:public	signature:(int level, const char* fmt, va_list arglist)
cvflann::Logger::logLevel	/usr/include/opencv2/flann/logger.h	/^    int logLevel;$/;"	m	class:cvflann::Logger	access:private
cvflann::Logger::setDestination	/usr/include/opencv2/flann/logger.h	/^    void setDestination(const char* name)$/;"	f	class:cvflann::Logger	access:public	signature:(const char* name)
cvflann::Logger::setLevel	/usr/include/opencv2/flann/logger.h	/^    void setLevel(int level) { logLevel = level; }$/;"	f	class:cvflann::Logger	access:public	signature:(int level)
cvflann::Logger::stream	/usr/include/opencv2/flann/logger.h	/^    FILE* stream;$/;"	m	class:cvflann::Logger	access:private
cvflann::Logger::warn	/usr/include/opencv2/flann/logger.h	/^    int warn(const char* fmt, ...);$/;"	p	class:cvflann::Logger	access:public	signature:(const char* fmt, ...)
cvflann::Logger::~Logger	/usr/include/opencv2/flann/logger.h	/^    ~Logger()$/;"	f	class:cvflann::Logger	access:public	signature:()
cvflann::MANHATTAN	/usr/include/opencv2/flann/general.h	/^	MANHATTAN = 2,$/;"	e	enum:cvflann::flann_distance_t
cvflann::MAX_DIST	/usr/include/opencv2/flann/general.h	/^	MAX_DIST   = 4,$/;"	e	enum:cvflann::flann_distance_t
cvflann::MINKOWSKI	/usr/include/opencv2/flann/general.h	/^	MINKOWSKI = 3,$/;"	e	enum:cvflann::flann_distance_t
cvflann::Matrix	/usr/include/opencv2/flann/matrix.h	/^class Matrix {$/;"	c	namespace:cvflann
cvflann::Matrix::Matrix	/usr/include/opencv2/flann/matrix.h	/^    Matrix() : rows(0), cols(0), data(NULL)$/;"	f	class:cvflann::Matrix	access:public	signature:()
cvflann::Matrix::Matrix	/usr/include/opencv2/flann/matrix.h	/^    Matrix(T* data_, long rows_, long cols_) :$/;"	f	class:cvflann::Matrix	access:public	signature:(T* data_, long rows_, long cols_)
cvflann::Matrix::cols	/usr/include/opencv2/flann/matrix.h	/^    size_t cols;$/;"	m	class:cvflann::Matrix	access:public
cvflann::Matrix::data	/usr/include/opencv2/flann/matrix.h	/^    T* data;$/;"	m	class:cvflann::Matrix	access:public
cvflann::Matrix::operator []	/usr/include/opencv2/flann/matrix.h	/^    T* operator[](size_t index) const$/;"	f	class:cvflann::Matrix	access:public	signature:(size_t index) const
cvflann::Matrix::operator []	/usr/include/opencv2/flann/matrix.h	/^    T* operator[](size_t index)$/;"	f	class:cvflann::Matrix	access:public	signature:(size_t index)
cvflann::Matrix::release	/usr/include/opencv2/flann/matrix.h	/^    void release()$/;"	f	class:cvflann::Matrix	access:public	signature:()
cvflann::Matrix::rows	/usr/include/opencv2/flann/matrix.h	/^    size_t rows;$/;"	m	class:cvflann::Matrix	access:public
cvflann::Matrix::~Matrix	/usr/include/opencv2/flann/matrix.h	/^	~Matrix()$/;"	f	class:cvflann::Matrix	access:public	signature:()
cvflann::NNIndex	/usr/include/opencv2/flann/nn_index.h	/^class NNIndex$/;"	c	namespace:cvflann
cvflann::NNIndex::buildIndex	/usr/include/opencv2/flann/nn_index.h	/^	virtual void buildIndex() = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:()
cvflann::NNIndex::findNeighbors	/usr/include/opencv2/flann/nn_index.h	/^	virtual void findNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)
cvflann::NNIndex::getParameters	/usr/include/opencv2/flann/nn_index.h	/^	virtual const IndexParams* getParameters() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
cvflann::NNIndex::getType	/usr/include/opencv2/flann/nn_index.h	/^	virtual flann_algorithm_t getType() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
cvflann::NNIndex::loadIndex	/usr/include/opencv2/flann/nn_index.h	/^	virtual void loadIndex(FILE* stream) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(FILE* stream)
cvflann::NNIndex::saveIndex	/usr/include/opencv2/flann/nn_index.h	/^	virtual void saveIndex(FILE* stream) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(FILE* stream)
cvflann::NNIndex::size	/usr/include/opencv2/flann/nn_index.h	/^	virtual size_t size() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
cvflann::NNIndex::usedMemory	/usr/include/opencv2/flann/nn_index.h	/^	virtual int usedMemory() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
cvflann::NNIndex::veclen	/usr/include/opencv2/flann/nn_index.h	/^	virtual size_t veclen() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
cvflann::NNIndex::~NNIndex	/usr/include/opencv2/flann/nn_index.h	/^	virtual ~NNIndex() {};$/;"	f	class:cvflann::NNIndex	access:public	signature:()
cvflann::ObjectFactory	/usr/include/opencv2/flann/object_factory.h	/^class ObjectFactory$/;"	c	namespace:cvflann
cvflann::ObjectFactory::CreateObjectFunc	/usr/include/opencv2/flann/object_factory.h	/^	typedef BaseClass* (*CreateObjectFunc)();$/;"	t	class:cvflann::ObjectFactory	access:private
cvflann::ObjectFactory::Iterator	/usr/include/opencv2/flann/object_factory.h	/^   typedef typename std::map<UniqueIdType, CreateObjectFunc>::iterator Iterator;$/;"	t	class:cvflann::ObjectFactory	access:public
cvflann::ObjectFactory::create	/usr/include/opencv2/flann/object_factory.h	/^   BaseClass* create(UniqueIdType id)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id)
cvflann::ObjectFactory::object_registry	/usr/include/opencv2/flann/object_factory.h	/^	std::map<UniqueIdType, CreateObjectFunc> object_registry;$/;"	m	class:cvflann::ObjectFactory	access:private
cvflann::ObjectFactory::register_	/usr/include/opencv2/flann/object_factory.h	/^   bool register_(UniqueIdType id)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id)
cvflann::ObjectFactory::unregister	/usr/include/opencv2/flann/object_factory.h	/^   bool unregister(UniqueIdType id)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id)
cvflann::ParamsFactory	/usr/include/opencv2/flann/general.h	/^typedef ObjectFactory<IndexParams, flann_algorithm_t> ParamsFactory;$/;"	t	namespace:cvflann
cvflann::ParamsFactory_instance	/usr/include/opencv2/flann/general.h	/^CV_EXPORTS ParamsFactory& ParamsFactory_instance();$/;"	p	namespace:cvflann	signature:()
cvflann::PooledAllocator	/usr/include/opencv2/flann/allocator.h	/^class CV_EXPORTS PooledAllocator$/;"	c	namespace:cvflann
cvflann::PooledAllocator::PooledAllocator	/usr/include/opencv2/flann/allocator.h	/^	PooledAllocator(int blocksize = BLOCKSIZE)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(int blocksize = BLOCKSIZE)
cvflann::PooledAllocator::allocate	/usr/include/opencv2/flann/allocator.h	/^	T* allocate(size_t count = 1)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(size_t count = 1)
cvflann::PooledAllocator::allocateBytes	/usr/include/opencv2/flann/allocator.h	/^	void* allocateBytes(int size)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(int size)
cvflann::PooledAllocator::base	/usr/include/opencv2/flann/allocator.h	/^	void*	base;     \/* Pointer to base of current block of storage. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
cvflann::PooledAllocator::blocksize	/usr/include/opencv2/flann/allocator.h	/^	int 	blocksize;$/;"	m	class:cvflann::PooledAllocator	access:private
cvflann::PooledAllocator::loc	/usr/include/opencv2/flann/allocator.h	/^	void*	loc;      \/* Current location in block to next allocate memory. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
cvflann::PooledAllocator::remaining	/usr/include/opencv2/flann/allocator.h	/^	int 	remaining;  \/* Number of bytes left in current block of storage. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
cvflann::PooledAllocator::usedMemory	/usr/include/opencv2/flann/allocator.h	/^	int 	usedMemory;$/;"	m	class:cvflann::PooledAllocator	access:public
cvflann::PooledAllocator::wastedMemory	/usr/include/opencv2/flann/allocator.h	/^	int 	wastedMemory;$/;"	m	class:cvflann::PooledAllocator	access:public
cvflann::PooledAllocator::~PooledAllocator	/usr/include/opencv2/flann/allocator.h	/^ 	~PooledAllocator()$/;"	f	class:cvflann::PooledAllocator	access:public	signature:()
cvflann::RadiusResultSet	/usr/include/opencv2/flann/result_set.h	/^class RadiusResultSet : public ResultSet<ELEM_TYPE>$/;"	c	namespace:cvflann	inherits:ResultSet
cvflann::RadiusResultSet::Item	/usr/include/opencv2/flann/result_set.h	/^	struct Item {$/;"	s	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::Item::dist	/usr/include/opencv2/flann/result_set.h	/^		float dist;$/;"	m	struct:cvflann::RadiusResultSet::Item	access:public
cvflann::RadiusResultSet::Item::index	/usr/include/opencv2/flann/result_set.h	/^		int index;$/;"	m	struct:cvflann::RadiusResultSet::Item	access:public
cvflann::RadiusResultSet::Item::operator <	/usr/include/opencv2/flann/result_set.h	/^		bool operator<(Item rhs) {$/;"	f	struct:cvflann::RadiusResultSet::Item	access:public	signature:(Item rhs)
cvflann::RadiusResultSet::RadiusResultSet	/usr/include/opencv2/flann/result_set.h	/^	RadiusResultSet(float radius_) :$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:(float radius_)
cvflann::RadiusResultSet::addPoint	/usr/include/opencv2/flann/result_set.h	/^	bool addPoint(const ELEM_TYPE* point, int index)$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:(const ELEM_TYPE* point, int index)
cvflann::RadiusResultSet::count	/usr/include/opencv2/flann/result_set.h	/^	size_t count;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::dists	/usr/include/opencv2/flann/result_set.h	/^	float* dists;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::full	/usr/include/opencv2/flann/result_set.h	/^	bool full() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
cvflann::RadiusResultSet::getDistances	/usr/include/opencv2/flann/result_set.h	/^    float* getDistances()$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:()
cvflann::RadiusResultSet::getNeighbors	/usr/include/opencv2/flann/result_set.h	/^	int* getNeighbors()$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:()
cvflann::RadiusResultSet::indices	/usr/include/opencv2/flann/result_set.h	/^	int* indices;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::init	/usr/include/opencv2/flann/result_set.h	/^	void init(const ELEM_TYPE* target_, int veclen_)$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:(const ELEM_TYPE* target_, int veclen_)
cvflann::RadiusResultSet::items	/usr/include/opencv2/flann/result_set.h	/^	vector<Item> items;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::radius	/usr/include/opencv2/flann/result_set.h	/^	float radius;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::resize_vecs	/usr/include/opencv2/flann/result_set.h	/^	void resize_vecs()$/;"	f	class:cvflann::RadiusResultSet	access:private	signature:()
cvflann::RadiusResultSet::size	/usr/include/opencv2/flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
cvflann::RadiusResultSet::sorted	/usr/include/opencv2/flann/result_set.h	/^	bool sorted;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::target	/usr/include/opencv2/flann/result_set.h	/^	const ELEM_TYPE* target;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::target_end	/usr/include/opencv2/flann/result_set.h	/^	const ELEM_TYPE* target_end;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::veclen	/usr/include/opencv2/flann/result_set.h	/^    int veclen;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::worstDist	/usr/include/opencv2/flann/result_set.h	/^	float worstDist() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
cvflann::RadiusResultSet::~RadiusResultSet	/usr/include/opencv2/flann/result_set.h	/^	~RadiusResultSet()$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:()
cvflann::ResultSet	/usr/include/opencv2/flann/result_set.h	/^class ResultSet$/;"	c	namespace:cvflann
cvflann::ResultSet::addPoint	/usr/include/opencv2/flann/result_set.h	/^	virtual bool addPoint(const ELEM_TYPE* point, int index) = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:(const ELEM_TYPE* point, int index)
cvflann::ResultSet::full	/usr/include/opencv2/flann/result_set.h	/^	virtual bool full() const = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:() const
cvflann::ResultSet::getDistances	/usr/include/opencv2/flann/result_set.h	/^	virtual float* getDistances() = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:()
cvflann::ResultSet::getNeighbors	/usr/include/opencv2/flann/result_set.h	/^	virtual int* getNeighbors() = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:()
cvflann::ResultSet::init	/usr/include/opencv2/flann/result_set.h	/^	virtual void init(const ELEM_TYPE* target_, int veclen_) = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:(const ELEM_TYPE* target_, int veclen_)
cvflann::ResultSet::size	/usr/include/opencv2/flann/result_set.h	/^	virtual size_t size() const = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:() const
cvflann::ResultSet::worstDist	/usr/include/opencv2/flann/result_set.h	/^	virtual float worstDist() const = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:() const
cvflann::ResultSet::~ResultSet	/usr/include/opencv2/flann/result_set.h	/^	virtual ~ResultSet() {};$/;"	f	class:cvflann::ResultSet	access:public	signature:()
cvflann::SAVED	/usr/include/opencv2/flann/general.h	/^	SAVED = 254,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::SavedIndexParams	/usr/include/opencv2/flann/flann_base.hpp	/^struct CV_EXPORTS SavedIndexParams : public IndexParams {$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::SavedIndexParams::SavedIndexParams	/usr/include/opencv2/flann/flann_base.hpp	/^	SavedIndexParams(std::string filename_) : IndexParams(SAVED), filename(filename_) {}$/;"	f	struct:cvflann::SavedIndexParams	access:public	signature:(std::string filename_)
cvflann::SavedIndexParams::filename	/usr/include/opencv2/flann/flann_base.hpp	/^	std::string filename;		\/\/ filename of the stored index$/;"	m	struct:cvflann::SavedIndexParams	access:public
cvflann::SavedIndexParams::getIndexType	/usr/include/opencv2/flann/flann_base.hpp	/^	flann_algorithm_t getIndexType() const { return algorithm; }$/;"	f	struct:cvflann::SavedIndexParams	access:public	signature:() const
cvflann::SavedIndexParams::print	/usr/include/opencv2/flann/flann_base.hpp	/^	void print() const$/;"	f	struct:cvflann::SavedIndexParams	access:public	signature:() const
cvflann::SearchParams	/usr/include/opencv2/flann/general.h	/^struct CV_EXPORTS SearchParams {$/;"	s	namespace:cvflann
cvflann::SearchParams::SearchParams	/usr/include/opencv2/flann/general.h	/^	SearchParams(int checks_ = 32) :$/;"	f	struct:cvflann::SearchParams	access:public	signature:(int checks_ = 32)
cvflann::SearchParams::checks	/usr/include/opencv2/flann/general.h	/^	int checks;$/;"	m	struct:cvflann::SearchParams	access:public
cvflann::StartStopTimer	/usr/include/opencv2/flann/timer.h	/^class CV_EXPORTS StartStopTimer$/;"	c	namespace:cvflann
cvflann::StartStopTimer::StartStopTimer	/usr/include/opencv2/flann/timer.h	/^    StartStopTimer()$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
cvflann::StartStopTimer::reset	/usr/include/opencv2/flann/timer.h	/^    void reset() {$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
cvflann::StartStopTimer::start	/usr/include/opencv2/flann/timer.h	/^    void start() {$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
cvflann::StartStopTimer::startTime	/usr/include/opencv2/flann/timer.h	/^    clock_t startTime;$/;"	m	class:cvflann::StartStopTimer	access:private
cvflann::StartStopTimer::stop	/usr/include/opencv2/flann/timer.h	/^    void stop() {$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
cvflann::StartStopTimer::value	/usr/include/opencv2/flann/timer.h	/^    double value;$/;"	m	class:cvflann::StartStopTimer	access:public
cvflann::UINT16	/usr/include/opencv2/flann/general.h	/^	UINT16 = 5,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::UINT32	/usr/include/opencv2/flann/general.h	/^	UINT32 = 6,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::UINT64	/usr/include/opencv2/flann/general.h	/^	UINT64 = 7,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::UINT8	/usr/include/opencv2/flann/general.h	/^	UINT8 = 4,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::UniqueRandom	/usr/include/opencv2/flann/random.h	/^class CV_EXPORTS UniqueRandom$/;"	c	namespace:cvflann
cvflann::UniqueRandom::UniqueRandom	/usr/include/opencv2/flann/random.h	/^	UniqueRandom(int n) : vals(NULL) {$/;"	f	class:cvflann::UniqueRandom	access:public	signature:(int n)
cvflann::UniqueRandom::counter	/usr/include/opencv2/flann/random.h	/^	int counter;$/;"	m	class:cvflann::UniqueRandom	access:private
cvflann::UniqueRandom::init	/usr/include/opencv2/flann/random.h	/^	void init(int n)$/;"	f	class:cvflann::UniqueRandom	access:public	signature:(int n)
cvflann::UniqueRandom::next	/usr/include/opencv2/flann/random.h	/^	int next() {$/;"	f	class:cvflann::UniqueRandom	access:public	signature:()
cvflann::UniqueRandom::size	/usr/include/opencv2/flann/random.h	/^    int size;$/;"	m	class:cvflann::UniqueRandom	access:private
cvflann::UniqueRandom::vals	/usr/include/opencv2/flann/random.h	/^	int* vals;$/;"	m	class:cvflann::UniqueRandom	access:private
cvflann::UniqueRandom::~UniqueRandom	/usr/include/opencv2/flann/random.h	/^	~UniqueRandom()$/;"	f	class:cvflann::UniqueRandom	access:public	signature:()
cvflann::UntypedMatrix	/usr/include/opencv2/flann/matrix.h	/^class UntypedMatrix$/;"	c	namespace:cvflann
cvflann::UntypedMatrix::UntypedMatrix	/usr/include/opencv2/flann/matrix.h	/^    UntypedMatrix(void* data_, long rows_, long cols_) :$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:(void* data_, long rows_, long cols_)
cvflann::UntypedMatrix::as	/usr/include/opencv2/flann/matrix.h	/^    Matrix<T> as()$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:()
cvflann::UntypedMatrix::cols	/usr/include/opencv2/flann/matrix.h	/^    size_t cols;$/;"	m	class:cvflann::UntypedMatrix	access:public
cvflann::UntypedMatrix::data	/usr/include/opencv2/flann/matrix.h	/^    void* data;$/;"	m	class:cvflann::UntypedMatrix	access:public
cvflann::UntypedMatrix::rows	/usr/include/opencv2/flann/matrix.h	/^    size_t rows;$/;"	m	class:cvflann::UntypedMatrix	access:public
cvflann::UntypedMatrix::type	/usr/include/opencv2/flann/matrix.h	/^    flann_datatype_t type;$/;"	m	class:cvflann::UntypedMatrix	access:public
cvflann::UntypedMatrix::~UntypedMatrix	/usr/include/opencv2/flann/matrix.h	/^    ~UntypedMatrix()$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:()
cvflann::WORDSIZE	/usr/include/opencv2/flann/allocator.h	/^const size_t     WORDSIZE=16;$/;"	m	namespace:cvflann
cvflann::ZeroIterator	/usr/include/opencv2/flann/dist.h	/^struct ZeroIterator {$/;"	s	namespace:cvflann
cvflann::ZeroIterator::operator *	/usr/include/opencv2/flann/dist.h	/^	T operator*() {$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:()
cvflann::ZeroIterator::operator ++	/usr/include/opencv2/flann/dist.h	/^	ZeroIterator<T>& operator ++(int) {$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
cvflann::ZeroIterator::operator +=	/usr/include/opencv2/flann/dist.h	/^	ZeroIterator<T>& operator+=(int) {$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
cvflann::ZeroIterator::operator []	/usr/include/opencv2/flann/dist.h	/^	T operator[](int) {$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^PredType get_hdf5_type()$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<char>() { return PredType::NATIVE_CHAR; }$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<double>() { return PredType::NATIVE_DOUBLE; }$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<float>() { return PredType::NATIVE_FLOAT; }$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<int>() { return PredType::NATIVE_INT; }$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<long double>() { return PredType::NATIVE_LDOUBLE; }$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<long>() { return PredType::NATIVE_LONG; }$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<short int>() { return PredType::NATIVE_SHORT; }$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<unsigned char>() { return PredType::NATIVE_UCHAR; }$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<unsigned int>() { return PredType::NATIVE_UINT; }$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<unsigned long>() { return PredType::NATIVE_ULONG; }$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::__anon184::get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<unsigned short int>() { return PredType::NATIVE_USHORT; }$/;"	f	namespace:cvflann::__anon184	signature:()
cvflann::addValue	/usr/include/opencv2/flann/simplex_downhill.h	/^void addValue(int pos, float val, float* vals, T* point, T* points, int n)$/;"	f	namespace:cvflann	signature:(int pos, float val, float* vals, T* point, T* points, int n)
cvflann::allocate	/usr/include/opencv2/flann/allocator.h	/^T* allocate(size_t count = 1)$/;"	f	namespace:cvflann	signature:(size_t count = 1)
cvflann::chi_square_dist	/usr/include/opencv2/flann/dist.h	/^double chi_square_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
cvflann::computeDistanceRaport	/usr/include/opencv2/flann/index_testing.h	/^float computeDistanceRaport(const Matrix<ELEM_TYPE>& inputData, ELEM_TYPE* target, int* neighbors, int* groundTruth, int veclen, int n)$/;"	f	namespace:cvflann	signature:(const Matrix<ELEM_TYPE>& inputData, ELEM_TYPE* target, int* neighbors, int* groundTruth, int veclen, int n)
cvflann::compute_ground_truth	/usr/include/opencv2/flann/ground_truth.h	/^void compute_ground_truth(const Matrix<T>& dataset, const Matrix<T>& testset, Matrix<int>& matches, int skip=0)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& dataset, const Matrix<T>& testset, Matrix<int>& matches, int skip=0)
cvflann::countCorrectMatches	/usr/include/opencv2/flann/index_testing.h	/^CV_EXPORTS int countCorrectMatches(int* neighbors, int* groundTruth, int n);$/;"	p	namespace:cvflann	signature:(int* neighbors, int* groundTruth, int n)
cvflann::createObject	/usr/include/opencv2/flann/object_factory.h	/^BaseClass* createObject()$/;"	f	namespace:cvflann	signature:()
cvflann::create_index_by_type	/usr/include/opencv2/flann/all_indices.h	/^NNIndex<T>* create_index_by_type(const Matrix<T>& dataset, const IndexParams& params)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& dataset, const IndexParams& params)
cvflann::custom_dist	/usr/include/opencv2/flann/dist.h	/^double custom_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
cvflann::euclidean_dist	/usr/include/opencv2/flann/dist.h	/^CV_EXPORTS double euclidean_dist(const unsigned char* first1, const unsigned char* last1, unsigned char* first2, double acc);$/;"	p	namespace:cvflann	signature:(const unsigned char* first1, const unsigned char* last1, unsigned char* first2, double acc)
cvflann::euclidean_dist	/usr/include/opencv2/flann/dist.h	/^double euclidean_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
cvflann::find_nearest	/usr/include/opencv2/flann/ground_truth.h	/^void find_nearest(const Matrix<T>& dataset, T* query, int* matches, int nn, int skip = 0)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& dataset, T* query, int* matches, int nn, int skip = 0)
cvflann::flann_algorithm_t	/usr/include/opencv2/flann/general.h	/^enum flann_algorithm_t {$/;"	g	namespace:cvflann
cvflann::flann_centers_init_t	/usr/include/opencv2/flann/general.h	/^enum flann_centers_init_t {$/;"	g	namespace:cvflann
cvflann::flann_datatype_t	/usr/include/opencv2/flann/general.h	/^enum flann_datatype_t {$/;"	g	namespace:cvflann
cvflann::flann_distance_t	/usr/include/opencv2/flann/general.h	/^enum flann_distance_t {$/;"	g	namespace:cvflann
cvflann::flann_distance_type	/usr/include/opencv2/flann/dist.h	/^CV_EXPORTS flann_distance_t flann_distance_type();$/;"	p	namespace:cvflann	signature:()
cvflann::flann_log_level_t	/usr/include/opencv2/flann/general.h	/^enum flann_log_level_t {$/;"	g	namespace:cvflann
cvflann::flann_minkowski_order	/usr/include/opencv2/flann/dist.h	/^CV_EXPORTS int flann_minkowski_order();$/;"	p	namespace:cvflann	signature:()
cvflann::hellinger_dist	/usr/include/opencv2/flann/dist.h	/^double hellinger_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
cvflann::hierarchicalClustering	/usr/include/opencv2/flann/flann_base.hpp	/^int hierarchicalClustering(const Matrix<ELEM_TYPE>& features, Matrix<DIST_TYPE>& centers, const KMeansIndexParams& params)$/;"	f	namespace:cvflann	signature:(const Matrix<ELEM_TYPE>& features, Matrix<DIST_TYPE>& centers, const KMeansIndexParams& params)
cvflann::hist_intersection_dist_sq	/usr/include/opencv2/flann/dist.h	/^double hist_intersection_dist_sq(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
cvflann::hist_intersection_kernel	/usr/include/opencv2/flann/dist.h	/^double hist_intersection_kernel(Iterator1 first1, Iterator1 last1, Iterator2 first2)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2)
cvflann::kl_divergence	/usr/include/opencv2/flann/dist.h	/^double kl_divergence(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
cvflann::load_from_file	/usr/include/opencv2/flann/hdf5.h	/^void load_from_file(cvflann::Matrix<T>& flann_dataset, const std::string& filename, const std::string& name)$/;"	f	namespace:cvflann	signature:(cvflann::Matrix<T>& flann_dataset, const std::string& filename, const std::string& name)
cvflann::load_header	/usr/include/opencv2/flann/saving.h	/^CV_EXPORTS IndexHeader load_header(FILE* stream);$/;"	p	namespace:cvflann	signature:(FILE* stream)
cvflann::load_saved_index	/usr/include/opencv2/flann/flann_base.hpp	/^NNIndex<T>* load_saved_index(const Matrix<T>& dataset, const string& filename)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& dataset, const string& filename)
cvflann::load_value	/usr/include/opencv2/flann/saving.h	/^void load_value(FILE* stream, T& value, int count = 1)$/;"	f	namespace:cvflann	signature:(FILE* stream, T& value, int count = 1)
cvflann::log_verbosity	/usr/include/opencv2/flann/flann_base.hpp	/^CV_EXPORTS void log_verbosity(int level);$/;"	p	namespace:cvflann	signature:(int level)
cvflann::logger	/usr/include/opencv2/flann/logger.h	/^CV_EXPORTS Logger& logger();$/;"	p	namespace:cvflann	signature:()
cvflann::manhattan_dist	/usr/include/opencv2/flann/dist.h	/^double manhattan_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
cvflann::max_dist	/usr/include/opencv2/flann/dist.h	/^double max_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
cvflann::minkowski_dist	/usr/include/opencv2/flann/dist.h	/^double minkowski_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
cvflann::optimizeSimplexDownhill	/usr/include/opencv2/flann/simplex_downhill.h	/^float optimizeSimplexDownhill(T* points, int n, F func, float* vals = NULL )$/;"	f	namespace:cvflann	signature:(T* points, int n, F func, float* vals = NULL )
cvflann::rand_double	/usr/include/opencv2/flann/random.h	/^CV_EXPORTS double rand_double(double high = 1.0, double low=0);$/;"	p	namespace:cvflann	signature:(double high = 1.0, double low=0)
cvflann::rand_int	/usr/include/opencv2/flann/random.h	/^CV_EXPORTS int rand_int(int high = RAND_MAX, int low = 0);$/;"	p	namespace:cvflann	signature:(int high = RAND_MAX, int low = 0)
cvflann::random_sample	/usr/include/opencv2/flann/sampling.h	/^Matrix<T> random_sample(Matrix<T>& srcMatrix, long size, bool remove = false)$/;"	f	namespace:cvflann	signature:(Matrix<T>& srcMatrix, long size, bool remove = false)
cvflann::random_sample	/usr/include/opencv2/flann/sampling.h	/^Matrix<T> random_sample(const Matrix<T>& srcMatrix, size_t size)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& srcMatrix, size_t size)
cvflann::save_header	/usr/include/opencv2/flann/saving.h	/^void save_header(FILE* stream, const NNIndex<ELEM_TYPE>& index)$/;"	f	namespace:cvflann	signature:(FILE* stream, const NNIndex<ELEM_TYPE>& index)
cvflann::save_to_file	/usr/include/opencv2/flann/hdf5.h	/^void save_to_file(const cvflann::Matrix<T>& flann_dataset, const std::string& filename, const std::string& name)$/;"	f	namespace:cvflann	signature:(const cvflann::Matrix<T>& flann_dataset, const std::string& filename, const std::string& name)
cvflann::save_value	/usr/include/opencv2/flann/saving.h	/^void save_value(FILE* stream, const T& value, int count = 1)$/;"	f	namespace:cvflann	signature:(FILE* stream, const T& value, int count = 1)
cvflann::search_with_ground_truth	/usr/include/opencv2/flann/index_testing.h	/^float search_with_ground_truth(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches, int nn, int checks, float& time, float& dist, int skipMatches)$/;"	f	namespace:cvflann	signature:(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches, int nn, int checks, float& time, float& dist, int skipMatches)
cvflann::seed_random	/usr/include/opencv2/flann/random.h	/^CV_EXPORTS void seed_random(unsigned int seed);$/;"	p	namespace:cvflann	signature:(unsigned int seed)
cvflann::set_distance_type	/usr/include/opencv2/flann/flann_base.hpp	/^CV_EXPORTS void set_distance_type(flann_distance_t distance_type, int order);$/;"	p	namespace:cvflann	signature:(flann_distance_t distance_type, int order)
cvflann::test_index_checks	/usr/include/opencv2/flann/index_testing.h	/^float test_index_checks(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches,$/;"	f	namespace:cvflann	signature:(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches, int checks, float& precision, int nn = 1, int skipMatches = 0)
cvflann::test_index_precision	/usr/include/opencv2/flann/index_testing.h	/^float test_index_precision(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches,$/;"	f	namespace:cvflann	signature:(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches, float precision, int& checks, int nn = 1, int skipMatches = 0)
cvflann::test_index_precisions	/usr/include/opencv2/flann/index_testing.h	/^float test_index_precisions(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches,$/;"	f	namespace:cvflann	signature:(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches, float* precisions, int precisions_length, int nn = 1, int skipMatches = 0, float maxTime = 0)
cvflann::zero	/usr/include/opencv2/flann/dist.h	/^CV_EXPORTS ZeroIterator<float>& zero();$/;"	p	namespace:cvflann	signature:()
cvmAdd	/usr/include/opencv2/legacy/compat.hpp	197;"	d
cvmAlloc	/usr/include/opencv2/legacy/compat.hpp	111;"	d
cvmAllocArray	/usr/include/opencv2/legacy/compat.hpp	113;"	d
cvmCopy	/usr/include/opencv2/legacy/compat.hpp	199;"	d
cvmCrossProduct	/usr/include/opencv2/legacy/compat.hpp	205;"	d
cvmDet	/usr/include/opencv2/legacy/compat.hpp	209;"	d
cvmDotProduct	/usr/include/opencv2/legacy/compat.hpp	204;"	d
cvmEigenVV	/usr/include/opencv2/legacy/compat.hpp	208;"	d
cvmFree	/usr/include/opencv2/legacy/compat.hpp	112;"	d
cvmFreeArray	/usr/include/opencv2/legacy/compat.hpp	114;"	d
cvmGet	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  double  cvmGet( const CvMat* mat, int row, int col )$/;"	f	signature:( const CvMat* mat, int row, int col )
cvmInvert	/usr/include/opencv2/legacy/compat.hpp	202;"	d
cvmMahalanobis	/usr/include/opencv2/legacy/compat.hpp	203;"	d
cvmMul	/usr/include/opencv2/legacy/compat.hpp	200;"	d
cvmMulTransposed	/usr/include/opencv2/legacy/compat.hpp	207;"	d
cvmPerspectiveProject	/usr/include/opencv2/legacy/compat.hpp	/^CV_EXPORTS void cvmPerspectiveProject( const CvMat* mat, const CvArr* src, CvArr* dst );$/;"	p	signature:( const CvMat* mat, const CvArr* src, CvArr* dst )
cvmScale	/usr/include/opencv2/legacy/compat.hpp	210;"	d
cvmSet	/usr/include/opencv2/core/types_c.h	/^CV_INLINE  void  cvmSet( CvMat* mat, int row, int col, double value )$/;"	f	signature:( CvMat* mat, int row, int col, double value )
cvmSetIdentity	/usr/include/opencv2/legacy/compat.hpp	196;"	d
cvmSetZero	/usr/include/opencv2/legacy/compat.hpp	195;"	d
cvmSub	/usr/include/opencv2/legacy/compat.hpp	198;"	d
cvmTrace	/usr/include/opencv2/legacy/compat.hpp	206;"	d
cvmTranspose	/usr/include/opencv2/legacy/compat.hpp	201;"	d
cvtColor	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cvtColor(const GpuMat& src, GpuMat& dst, int code, int dcn = 0);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int code, int dcn = 0)
cvtColor	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void cvtColor(const GpuMat& src, GpuMat& dst, int code, int dcn, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int code, int dcn, const Stream& stream)
cvtColor	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void cvtColor( const Mat& src, CV_OUT Mat& dst, int code, int dstCn=0 );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int code, int dstCn=0 )
cvvAddSearchPath	/usr/include/opencv2/highgui/highgui_c.h	388;"	d
cvvConvertImage	/usr/include/opencv2/highgui/highgui_c.h	391;"	d
cvvCreateTrackbar	/usr/include/opencv2/highgui/highgui_c.h	385;"	d
cvvDestroyWindow	/usr/include/opencv2/highgui/highgui_c.h	384;"	d
cvvInitSystem	/usr/include/opencv2/highgui/highgui_c.h	380;"	d
cvvLoadImage	/usr/include/opencv2/highgui/highgui_c.h	386;"	d
cvvNamedWindow	/usr/include/opencv2/highgui/highgui_c.h	381;"	d
cvvResizeWindow	/usr/include/opencv2/highgui/highgui_c.h	383;"	d
cvvSaveImage	/usr/include/opencv2/highgui/highgui_c.h	387;"	d
cvvShowImage	/usr/include/opencv2/highgui/highgui_c.h	382;"	d
cvvWaitKey	/usr/include/opencv2/highgui/highgui_c.h	389;"	d
cvvWaitKeyEx	/usr/include/opencv2/highgui/highgui_c.h	390;"	d
cyrillic	/usr/include/opencv2/core/core_c.h	/^    const int*  cyrillic;$/;"	m	struct:CvFont	access:public
d	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
d	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
d2	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
data	/usr/include/opencv2/contrib/contrib.hpp	/^        void* data;$/;"	m	class:cv::LevMarqSparse	access:protected
data	/usr/include/opencv2/core/core.hpp	/^    uchar* data;$/;"	m	class:cv::Mat	access:public
data	/usr/include/opencv2/core/operations.hpp	/^        _Tp* data;$/;"	m	struct:cv::Vector::Hdr	access:public
data	/usr/include/opencv2/core/types_c.h	/^    schar* data;              \/* Pointer to the first element of the block. *\/$/;"	m	struct:CvSeqBlock	access:public
data	/usr/include/opencv2/core/types_c.h	/^    } data;$/;"	m	struct:CvFileNode	typeref:union:CvFileNode::__anon100	access:public
data	/usr/include/opencv2/core/types_c.h	/^    } data;$/;"	m	struct:CvMat	typeref:union:CvMat::__anon94	access:public
data	/usr/include/opencv2/core/types_c.h	/^    } data;$/;"	m	struct:CvMatND	typeref:union:CvMatND::__anon97	access:public
data	/usr/include/opencv2/flann/matrix.h	/^    T* data;$/;"	m	class:cvflann::Matrix	access:public
data	/usr/include/opencv2/flann/matrix.h	/^    void* data;$/;"	m	class:cvflann::UntypedMatrix	access:public
data	/usr/include/opencv2/gpu/devmem2d.hpp	/^            T* data;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
data	/usr/include/opencv2/gpu/devmem2d.hpp	/^            T* data;$/;"	m	struct:cv::gpu::PtrStep_	access:public
data	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* data;$/;"	m	class:cv::gpu::CudaMem	access:public
data	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* data;$/;"	m	class:cv::gpu::GpuMat	access:public
data	/usr/include/opencv2/legacy/legacy.hpp	/^    const uchar* data() const { return image ? (const uchar*)image->imageData : 0; }$/;"	f	class:CvImage	access:public	signature:() const
data	/usr/include/opencv2/legacy/legacy.hpp	/^    const uchar* data() const { return matrix ? matrix->data.ptr : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
data	/usr/include/opencv2/legacy/legacy.hpp	/^    uchar* data() { return image ? (uchar*)image->imageData : 0; }$/;"	f	class:CvImage	access:public	signature:()
data	/usr/include/opencv2/legacy/legacy.hpp	/^    uchar* data() { return matrix ? matrix->data.ptr : 0; }$/;"	f	class:CvMatrix	access:public	signature:()
data	/usr/include/opencv2/legacy/legacy.hpp	/^    void* data;$/;"	m	union:__anon170	access:public
data	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvBoost	access:protected
data	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvDTree	access:protected
data	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvGBTrees	access:protected
data	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvRTrees	access:protected
data	/usr/include/opencv2/ml/ml.hpp	/^    float* data;$/;"	m	struct:CvSVMKernelRow	access:public
data	/usr/include/opencv2/ml/ml.hpp	/^    } data;$/;"	m	struct:CvVectors	typeref:union:CvVectors::__anon76	access:public
dataOrder	/usr/include/opencv2/core/types_c.h	/^    int  dataOrder;         \/* 0 - interleaved color channels, 1 - separate color channels.$/;"	m	struct:_IplImage	access:public
data_cost	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat data_cost;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
data_cost_selected	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat data_cost_selected;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
data_root	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode* data_root;$/;"	m	struct:CvDTreeTrainData	access:public
data_type	/usr/include/opencv2/flann/saving.h	/^	flann_datatype_t data_type;$/;"	m	struct:cvflann::IndexHeader	access:public
data_weight	/usr/include/opencv2/gpu/gpu.hpp	/^            float data_weight;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
data_weight	/usr/include/opencv2/gpu/gpu.hpp	/^            float data_weight;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
dataend	/usr/include/opencv2/core/core.hpp	/^    uchar* dataend;$/;"	m	class:cv::Mat	access:public
dataend	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* dataend;$/;"	m	class:cv::gpu::CudaMem	access:public
dataend	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* dataend;$/;"	m	class:cv::gpu::GpuMat	access:public
datalimit	/usr/include/opencv2/core/core.hpp	/^    uchar* datalimit;$/;"	m	class:cv::Mat	access:public
datas	/usr/include/opencv2/gpu/gpu.hpp	/^            std::vector<GpuMat> datas;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
dataset	/usr/include/opencv2/flann/autotuned_index.h	/^    const Matrix<ELEM_TYPE> dataset;$/;"	m	class:cvflann::AutotunedIndex	access:private
dataset	/usr/include/opencv2/flann/composite_index.h	/^    const Matrix<ELEM_TYPE> dataset;$/;"	m	class:cvflann::CompositeIndex	access:private
dataset	/usr/include/opencv2/flann/kdtree_index.h	/^	const Matrix<ELEM_TYPE> dataset;$/;"	m	class:cvflann::KDTreeIndex	access:private
dataset	/usr/include/opencv2/flann/kmeans_index.h	/^    const Matrix<ELEM_TYPE> dataset;$/;"	m	class:cvflann::KMeansIndex	access:private
dataset	/usr/include/opencv2/flann/linear_index.h	/^	const Matrix<ELEM_TYPE> dataset;$/;"	m	class:cvflann::LinearIndex	access:private
datastart	/usr/include/opencv2/core/core.hpp	/^    uchar* datastart;$/;"	m	class:cv::Mat	access:public
datastart	/usr/include/opencv2/core/operations.hpp	/^        _Tp* datastart;$/;"	m	struct:cv::Vector::Hdr	access:public
datastart	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* datastart;$/;"	m	class:cv::gpu::CudaMem	access:public
datastart	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* datastart;$/;"	m	class:cv::gpu::GpuMat	access:public
db	/usr/include/opencv2/core/types_c.h	/^        double* db;$/;"	m	union:CvMat::__anon94	access:public
db	/usr/include/opencv2/core/types_c.h	/^        double* db;$/;"	m	union:CvMatND::__anon97	access:public
db	/usr/include/opencv2/ml/ml.hpp	/^        double** db;$/;"	m	union:CvVectors::__anon76	access:public
dct	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void dct(const Mat& src, CV_OUT Mat& dst, int flags=0);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags=0)
ddot	/usr/include/opencv2/core/core.hpp	/^    double ddot(const Matx<_Tp, m, n>& v) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& v) const
ddot	/usr/include/opencv2/core/core.hpp	/^    double ddot(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
ddot	/usr/include/opencv2/core/core.hpp	/^    double ddot(const Point_& pt) const;$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt) const
ddot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline double Matx<_Tp, m, n>::ddot(const Matx<_Tp, m, n>& M) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& M) const
ddot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline double Point3_<_Tp>::ddot(const Point3_& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_& pt) const
ddot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline double Point_<_Tp>::ddot(const Point_& pt) const$/;"	f	class:cv::Point_	signature:(const Point_& pt) const
deallocate	/usr/include/opencv2/core/core.hpp	/^    virtual void deallocate(int* refcount, uchar* datastart, uchar* data) = 0;$/;"	p	class:cv::MatAllocator	access:public	signature:(int* refcount, uchar* datastart, uchar* data)
deallocate	/usr/include/opencv2/core/core.hpp	/^    void deallocate();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
deallocate	/usr/include/opencv2/core/core.hpp	/^    void deallocate();$/;"	p	class:cv::Mat	access:public	signature:()
deallocate	/usr/include/opencv2/core/core.hpp	/^    void deallocate(pointer p, size_type) {fastFree(p); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p, size_type)
deallocate	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> static inline void deallocate(_Tp* ptr, size_t)$/;"	f	namespace:cv	signature:(_Tp* ptr, size_t)
deallocate	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::deallocate()$/;"	f	class:cv::AutoBuffer	signature:()
decision_func	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMDecisionFunc* decision_func;$/;"	m	class:CvSVM	access:protected
decomposeProjectionMatrix	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void decomposeProjectionMatrix( const Mat& projMatrix, Mat& cameraMatrix,$/;"	p	namespace:cv	signature:( const Mat& projMatrix, Mat& cameraMatrix, Mat& rotMatrix, Mat& transVect )
decomposeProjectionMatrix	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void decomposeProjectionMatrix( const Mat& projMatrix, CV_OUT Mat& cameraMatrix,$/;"	p	namespace:cv	signature:( const Mat& projMatrix, CV_OUT Mat& cameraMatrix, CV_OUT Mat& rotMatrix, CV_OUT Mat& transVect, CV_OUT Mat& rotMatrixX, CV_OUT Mat& rotMatrixY, CV_OUT Mat& rotMatrixZ, CV_OUT Vec3d& eulerAngles )
defaultParams	/usr/include/opencv2/contrib/contrib.hpp	/^        void defaultParams();$/;"	p	class:cv::SpinImageModel	access:protected	signature:()
default_func_addr	/usr/include/opencv2/core/types_c.h	/^    void* default_func_addr;$/;"	m	struct:CvPluginFuncInfo	access:public
default_model_name	/usr/include/opencv2/ml/ml.hpp	/^    const char* default_model_name;$/;"	m	class:CvStatModel	access:protected
degree	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      degree; \/\/ for poly$/;"	m	struct:CvSVMParams	access:public
delete_obj	/usr/include/opencv2/calib3d/calib3d.hpp	/^template<> CV_EXPORTS void Ptr<CvStereoBMState>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/core/core.hpp	/^    void delete_obj();$/;"	p	class:cv::Ptr	access:public	signature:()
delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvFileStorage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMat>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMatND>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMemStorage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvSparseMat>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<> CV_EXPORTS void Ptr<IplImage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::delete_obj()$/;"	f	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/highgui/highgui.hpp	/^template<> void CV_EXPORTS Ptr<CvCapture>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/highgui/highgui.hpp	/^template<> void CV_EXPORTS Ptr<CvVideoWriter>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/imgproc/imgproc.hpp	/^template<> CV_EXPORTS void Ptr<CvHistogram>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/imgproc/imgproc.hpp	/^template<> CV_EXPORTS void Ptr<IplConvKernel>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/ml/ml.hpp	/^template<> CV_EXPORTS void Ptr<CvDTreeSplit>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	/usr/include/opencv2/objdetect/objdetect.hpp	/^template<> CV_EXPORTS void Ptr<CvHaarClassifierCascade>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delimiter	/usr/include/opencv2/ml/ml.hpp	/^    char delimiter;$/;"	m	class:CvMLData	access:protected
delta	/usr/include/opencv2/features2d/features2d.hpp	/^    int delta;$/;"	m	struct:CvMSERParams	access:public
delta	/usr/include/opencv2/ml/ml.hpp	/^    float delta;$/;"	m	class:CvGBTrees	access:protected
delta	/usr/include/opencv2/video/background_segm.hpp	/^    float  delta;		\/* Affects color and color co-occurrence quantization, typically set to 2.					*\/$/;"	m	struct:CvFGDStatModelParams	access:public
deltaP	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* deltaP; \/\/computed increase of parameters (result of normal system solution )$/;"	m	class:cv::LevMarqSparse	access:protected
deltas	/usr/include/opencv2/imgproc/types_c.h	/^    schar     deltas[8][2];$/;"	m	struct:CvChainPtReader	access:public
density	/usr/include/opencv2/contrib/contrib.hpp	/^        double density;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
depth	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon121
depth	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon120
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon125
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon126
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon127
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon128
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon129
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon130
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon131
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon134
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon135
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon137
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon140
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon136
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon138
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon139
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon132
depth	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 1, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
depth	/usr/include/opencv2/core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Mat	access:public	signature:() const
depth	/usr/include/opencv2/core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
depth	/usr/include/opencv2/core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Seq	access:public	signature:() const
depth	/usr/include/opencv2/core/core.hpp	/^    int depth() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
depth	/usr/include/opencv2/core/core.hpp	/^    int depth() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
depth	/usr/include/opencv2/core/mat.hpp	/^inline int Mat::depth() const { return CV_MAT_DEPTH(flags); }$/;"	f	class:cv::Mat	signature:() const
depth	/usr/include/opencv2/core/mat.hpp	/^inline int SparseMat::depth() const$/;"	f	class:cv::SparseMat	signature:() const
depth	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::depth() const$/;"	f	class:cv::Mat_	signature:() const
depth	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::depth() const$/;"	f	class:cv::SparseMat_	signature:() const
depth	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::depth() const$/;"	f	class:cv::Seq	signature:() const
depth	/usr/include/opencv2/core/types_c.h	/^    int  depth;             \/* Pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16S,$/;"	m	struct:_IplImage	access:public
depth	/usr/include/opencv2/features2d/features2d.hpp	/^  int depth() { return depth_; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
depth	/usr/include/opencv2/gpu/gpu.hpp	/^            int depth() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
depth	/usr/include/opencv2/gpu/gpu.hpp	/^            int depth() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
depth	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int CudaMem::depth() const { return CV_MAT_DEPTH(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
depth	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int GpuMat::depth() const { return CV_MAT_DEPTH(flags); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
depth	/usr/include/opencv2/imgproc/types_c.h	/^    float depth; \/* distance between the farthest point and the convex hull *\/$/;"	m	struct:CvConvexityDefect	access:public
depth	/usr/include/opencv2/legacy/legacy.hpp	/^    int depth() const { return image ? image->depth : 0; }$/;"	f	class:CvImage	access:public	signature:() const
depth	/usr/include/opencv2/legacy/legacy.hpp	/^    int depth() const { return matrix ? CV_MAT_DEPTH(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
depth	/usr/include/opencv2/ml/ml.hpp	/^    int depth;$/;"	m	struct:CvDTreeNode	access:public
depthHigh	/usr/include/opencv2/contrib/contrib.hpp	/^        unsigned int depthLow, depthHigh;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
depthLow	/usr/include/opencv2/contrib/contrib.hpp	/^        unsigned int depthLow, depthHigh;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
depth_	/usr/include/opencv2/features2d/features2d.hpp	/^  int depth_;$/;"	m	class:cv::RandomizedTree	access:private
depth_point	/usr/include/opencv2/imgproc/types_c.h	/^    CvPoint* depth_point; \/* the farthest from the convex hull point within the defect *\/$/;"	m	struct:CvConvexityDefect	access:public
derivAperture	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP int derivAperture;$/;"	m	struct:cv::HOGDescriptor	access:public
desc	/usr/include/opencv2/imgproc/imgproc_c.h	/^CVAPI(struct CvFeatureTree*) cvCreateKDTree(CvMat* desc);$/;"	v
descripotorsCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int descripotorsCount() const;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
descriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> descriptorExtractor;$/;"	m	class:cv::OpponentColorDescriptorExtractor	access:protected
descriptorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    DescriptorParams descriptorParams;$/;"	m	class:cv::SIFT	access:protected
descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP int descriptorSize() const;$/;"	p	class:cv::SURF	access:public	signature:() const
descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int descriptorSize() const { return DescriptorParams::DESCRIPTOR_SIZE; }$/;"	f	class:cv::SIFT	access:public	signature:() const
descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int descriptorSize() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const = 0;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:() const
descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const { return classifier_.classes(); }$/;"	f	class:cv::CalonderDescriptorExtractor	access:public	signature:() const
descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:() const
descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:() const
descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:() const
descriptorSize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:() const
descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    int descriptorType() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const = 0;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:() const
descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const { return DataType<T>::type; }$/;"	f	class:cv::CalonderDescriptorExtractor	access:public	signature:() const
descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:() const
descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:() const
descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:() const
descriptorType	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:() const
descriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<Mat> descriptors;$/;"	m	class:cv::BOWTrainer	access:protected
destroy	/usr/include/opencv2/core/core.hpp	/^    void destroy(pointer p) { p->~_Tp(); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p)
destroyWindow	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W void destroyWindow( const string& winname );$/;"	p	namespace:cv	signature:( const string& winname )
detach	/usr/include/opencv2/legacy/legacy.hpp	/^    void detach()$/;"	f	class:CvImage	access:public	signature:()
detect	/usr/include/opencv2/features2d/features2d.hpp	/^    void detect( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detect	/usr/include/opencv2/features2d/features2d.hpp	/^    void detect( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const vector<Mat>& masks=vector<Mat>() ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const vector<Mat>& masks=vector<Mat>() ) const
detect	/usr/include/opencv2/gpu/gpu.hpp	/^            void detect(const GpuMat& img, vector<Point>& found_locations, double hit_threshold=0, $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, vector<Point>& found_locations, double hit_threshold=0, Size win_stride=Size(), Size padding=Size())
detect	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void detect(const Mat& img, CV_OUT vector<Point>& foundLocations,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Point>& foundLocations, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), const vector<Point>& searchLocations=vector<Point>()) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const = 0;$/;"	p	class:cv::FeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::DenseFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FastFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::GridAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::MserFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::PyramidAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SiftFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::StarFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SurfFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FastAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::StarAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SurfAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectMultiScale	/usr/include/opencv2/gpu/gpu.hpp	/^            void detectMultiScale(const GpuMat& img, vector<Rect>& found_locations, $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, vector<Rect>& found_locations, double hit_threshold=0, Size win_stride=Size(), Size padding=Size(), double scale0=1.05, int group_threshold=2)
detectMultiScale	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void detectMultiScale(const Mat& img, CV_OUT vector<Rect>& foundLocations,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Rect>& foundLocations, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), double scale=1.05, int groupThreshold=2) const
detectMultiScale	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP void detectMultiScale( const Mat& image,$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const Mat& image, CV_OUT vector<Rect>& objects, double scaleFactor=1.1, int minNeighbors=3, int flags=0, Size minSize=Size(), Size maxSize=Size())
detector	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<FeatureDetector> detector;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
detector	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<FeatureDetector> detector;$/;"	m	class:cv::PyramidAdaptedFeatureDetector	access:protected
detector	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat detector;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
detector	/usr/include/opencv2/objdetect/objdetect.hpp	/^CVAPI(void) cvReleaseLatentSvmDetector(CvLatentSvmDetector** detector);$/;"	v
detectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    DetectorParams detectorParams;$/;"	m	class:cv::SIFT	access:protected
determinant	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double determinant(const Mat& mtx);$/;"	p	namespace:cv	signature:(const Mat& mtx)
determinant	/usr/include/opencv2/core/operations.hpp	/^double determinant(const Matx<_Tp, m, m>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, m>& a)
dextractor	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> dextractor;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
dft	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void dft(const Mat& src, CV_OUT Mat& dst, int flags=0, int nonzeroRows=0);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags=0, int nonzeroRows=0)
diag	/usr/include/opencv2/core/core.hpp	/^    Mat diag(int d=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int d=0) const
diag	/usr/include/opencv2/core/core.hpp	/^    Mat_ diag(int d=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int d=0) const
diag	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, MIN(m,n), 1> diag() const;$/;"	p	class:cv::Matx	access:public	signature:() const
diag	/usr/include/opencv2/core/core.hpp	/^    static Mat diag(const Mat& d);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& d)
diag	/usr/include/opencv2/core/core.hpp	/^    static Matx diag(const diag_type& d);$/;"	p	class:cv::Matx	access:public	signature:(const diag_type& d)
diag	/usr/include/opencv2/core/mat.hpp	/^    MatExpr diag(int d=0) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int d=0) const
diag	/usr/include/opencv2/core/mat.hpp	/^    virtual void diag(const MatExpr& expr, int d, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, int d, MatExpr& res) const
diag	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::diag(const Mat& d)$/;"	f	class:cv::Mat	signature:(const Mat& d)
diag	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::diag(int d) const$/;"	f	class:cv::Mat_	signature:(int d) const
diag	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, MIN(m,n), 1> Matx<_Tp, m, n>::diag() const$/;"	f	class:cv::Matx	signature:() const
diag	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::diag(const Matx<_Tp,MIN(m,n),1>& d)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp,MIN(m,n),1>& d)
diag_type	/usr/include/opencv2/core/core.hpp	/^    typedef Matx<_Tp, MIN(m, n), 1> diag_type;$/;"	t	class:cv::Matx	access:public
difference_type	/usr/include/opencv2/core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::Allocator	access:public
difference_type	/usr/include/opencv2/core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::MatConstIterator	access:public
difference_type	/usr/include/opencv2/core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::MatConstIterator_	access:public
dilate	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void dilate( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1);$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1)
dilate	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void dilate( const Mat& src, CV_OUT Mat& dst, const Mat& kernel,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
dim	/usr/include/opencv2/core/types_c.h	/^    dim[CV_MAX_DIM];$/;"	m	struct:CvMatND	typeref:struct:CvMatND::__anon98	access:public
dims	/usr/include/opencv2/core/core.hpp	/^        int dims;$/;"	m	struct:cv::SparseMat::Hdr	access:public
dims	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP int dims() const;$/;"	p	class:cv::KDTree	access:public	signature:() const
dims	/usr/include/opencv2/core/core.hpp	/^    int dims() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
dims	/usr/include/opencv2/core/core.hpp	/^    int dims;$/;"	m	class:cv::Mat	access:public
dims	/usr/include/opencv2/core/core_c.h	/^    int dims; \/* number of dimensions to iterate *\/$/;"	m	struct:CvNArrayIterator	access:public
dims	/usr/include/opencv2/core/mat.hpp	/^inline int SparseMat::dims() const$/;"	f	class:cv::SparseMat	signature:() const
dims	/usr/include/opencv2/core/types_c.h	/^    int dims;$/;"	m	struct:CvMatND	access:public
dims	/usr/include/opencv2/core/types_c.h	/^    int dims;$/;"	m	struct:CvSparseMat	access:public
dims	/usr/include/opencv2/ml/ml.hpp	/^    int dims, count;$/;"	m	struct:CvVectors	access:public
dir	/usr/include/opencv2/features2d/features2d.hpp	/^    float dir;$/;"	m	struct:CvSURFPoint	access:public
direction	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* direction;$/;"	m	struct:CvDTreeTrainData	access:public
disc_single_jump	/usr/include/opencv2/gpu/gpu.hpp	/^            float disc_single_jump;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
disc_single_jump	/usr/include/opencv2/gpu/gpu.hpp	/^            float disc_single_jump;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
discardFloatPosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void discardFloatPosteriors() { freePosteriors(1); }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
discardFloatPosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void discardFloatPosteriors();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
disp	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* disp;$/;"	m	struct:CvStereoBMState	access:public
disp12MaxDiff	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int disp12MaxDiff;$/;"	m	class:cv::StereoSGBM	access:public
disp12MaxDiff	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int disp12MaxDiff;$/;"	m	struct:CvStereoBMState	access:public
dispLeft	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* dispLeft;$/;"	m	struct:CvStereoGCState	access:public
dispRight	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* dispRight;$/;"	m	struct:CvStereoGCState	access:public
disp_selected_pyr	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat disp_selected_pyr[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
displayOverlay	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void displayOverlay(const string& winname, const string& text, int delayms);$/;"	p	namespace:cv	signature:(const string& winname, const string& text, int delayms)
displayStatusBar	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void displayStatusBar(const string& winname, const string& text, int delayms);$/;"	p	namespace:cv	signature:(const string& winname, const string& text, int delayms)
dist	/usr/include/opencv2/flann/result_set.h	/^		float dist;$/;"	m	struct:cvflann::RadiusResultSet::Item	access:public
distance	/usr/include/opencv2/features2d/features2d.hpp	/^    Distance distance;$/;"	m	class:cv::BruteForceMatcher	access:protected
distance	/usr/include/opencv2/features2d/features2d.hpp	/^    float distance;$/;"	m	struct:cv::DMatch	access:public
distanceTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^    void distanceTransform( const Mat& src, CV_OUT Mat& dst, Mat& labels,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, Mat& labels, int distanceType, int maskSize )
distanceTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void distanceTransform( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int distanceType, int maskSize )
distortion	/usr/include/opencv2/legacy/legacy.hpp	/^    float   distortion[4]; \/* distortion coefficients - two coefficients for radial distortion$/;"	m	struct:CvCamera	access:public
distortion	/usr/include/opencv2/legacy/legacy.hpp	/^    float distortion[4];$/;"	m	struct:__anon176	access:public
dists	/usr/include/opencv2/flann/result_set.h	/^	float* dists;$/;"	m	class:cvflann::KNNResultSet	access:private
dists	/usr/include/opencv2/flann/result_set.h	/^	float* dists;$/;"	m	class:cvflann::RadiusResultSet	access:private
disttype	/usr/include/opencv2/legacy/compat.hpp	/^    int       disttype; \/* distribution type *\/$/;"	m	struct:CvRandState	access:public
divfeat	/usr/include/opencv2/flann/kdtree_index.h	/^		int divfeat;$/;"	m	struct:cvflann::KDTreeIndex::TreeSt	access:public
divide	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void divide(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, double scale=1);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, double scale=1)
divide	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void divide(double scale, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(double scale, const Mat& src2, CV_OUT Mat& dst)
divide	/usr/include/opencv2/core/mat.hpp	/^    virtual void divide(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const
divide	/usr/include/opencv2/core/mat.hpp	/^    virtual void divide(double s, const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(double s, const MatExpr& expr, MatExpr& res) const
divide	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void divide(const GpuMat& a, const GpuMat& b, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c)
divide	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void divide(const GpuMat& a, const Scalar& sc, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c)
divideTree	/usr/include/opencv2/flann/kdtree_index.h	/^	Tree divideTree(int first, int last)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(int first, int last)
divval	/usr/include/opencv2/flann/kdtree_index.h	/^		DIST_TYPE divval;$/;"	m	struct:cvflann::KDTreeIndex::TreeSt	access:public
dmatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<DescriptorMatcher> dmatcher;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
do_responses_copy	/usr/include/opencv2/ml/ml.hpp	/^    virtual void do_responses_copy();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
do_subsample	/usr/include/opencv2/ml/ml.hpp	/^    virtual void do_subsample();$/;"	p	class:CvGBTrees	access:protected	signature:()
do_train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool do_train( const CvMat* _subsample_idx );$/;"	p	class:CvDTree	access:protected	signature:( const CvMat* _subsample_idx )
do_train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool do_train( int svm_type, int sample_count, int var_count, const float** samples,$/;"	p	class:CvSVM	access:protected	signature:( int svm_type, int sample_count, int var_count, const float** samples, const CvMat* responses, CvMemStorage* _storage, double* alpha )
dot	/usr/include/opencv2/core/core.hpp	/^    _Tp dot(const Matx<_Tp, m, n>& v) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& v) const
dot	/usr/include/opencv2/core/core.hpp	/^    _Tp dot(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
dot	/usr/include/opencv2/core/core.hpp	/^    _Tp dot(const Point_& pt) const;$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt) const
dot	/usr/include/opencv2/core/core.hpp	/^    double dot(const Mat& m) const;$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m) const
dot	/usr/include/opencv2/core/mat.hpp	/^    double dot(const Mat& m) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m) const
dot	/usr/include/opencv2/core/operations.hpp	/^dot(const Vector<_Tp>& v1, const Vector<_Tp>& v2)$/;"	f	namespace:cv	signature:(const Vector<_Tp>& v1, const Vector<_Tp>& v2)
dot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int m, int n> inline _Tp Matx<_Tp, m, n>::dot(const Matx<_Tp, m, n>& M) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& M) const
dot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp Point3_<_Tp>::dot(const Point3_& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_& pt) const
dot	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp Point_<_Tp>::dot(const Point_& pt) const$/;"	f	class:cv::Point_	signature:(const Point_& pt) const
download	/usr/include/opencv2/gpu/gpu.hpp	/^            void download(CudaMem& m, Stream& stream) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(CudaMem& m, Stream& stream) const
download	/usr/include/opencv2/gpu/gpu.hpp	/^            void download(cv::Mat& m) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(cv::Mat& m) const
drawChessboardCorners	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void drawChessboardCorners( Mat& image, Size patternSize,$/;"	p	namespace:cv	signature:( Mat& image, Size patternSize, const vector<Point2f>& corners, bool patternWasFound )
drawChessboardCorners	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void drawChessboardCorners( Mat& image, Size patternSize,$/;"	p	namespace:cv	signature:( Mat& image, Size patternSize, const Mat& corners, bool patternWasFound )
drawColorDisp	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void drawColorDisp(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp)
drawColorDisp	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void drawColorDisp(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp, const Stream& stream)
drawContours	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void drawContours( Mat& image, const vector<vector<Point> >& contours,$/;"	p	namespace:cv	signature:( Mat& image, const vector<vector<Point> >& contours, int contourIdx, const Scalar& color, int thickness=1, int lineType=8, const vector<Vec4i>& hierarchy=vector<Vec4i>(), int maxLevel=INT_MAX, Point offset=Point() )
drawKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void drawKeypoints( const Mat& image, const vector<KeyPoint>& keypoints, Mat& outImg,$/;"	p	namespace:cv	signature:( const Mat& image, const vector<KeyPoint>& keypoints, Mat& outImg, const Scalar& color=Scalar::all(-1), int flags=DrawMatchesFlags::DEFAULT )
drawMatches	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void drawMatches( const Mat& img1, const vector<KeyPoint>& keypoints1,$/;"	p	namespace:cv	signature:( const Mat& img1, const vector<KeyPoint>& keypoints1, const Mat& img2, const vector<KeyPoint>& keypoints2, const vector<DMatch>& matches1to2, Mat& outImg, const Scalar& matchColor=Scalar::all(-1), const Scalar& singlePointColor=Scalar::all(-1), const vector<char>& matchesMask=vector<char>(), int flags=DrawMatchesFlags::DEFAULT )
drawMatches	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void drawMatches( const Mat& img1, const vector<KeyPoint>& keypoints1,$/;"	p	namespace:cv	signature:( const Mat& img1, const vector<KeyPoint>& keypoints1, const Mat& img2, const vector<KeyPoint>& keypoints2, const vector<vector<DMatch> >& matches1to2, Mat& outImg, const Scalar& matchColor=Scalar::all(-1), const Scalar& singlePointColor=Scalar::all(-1), const vector<vector<char> >& matchesMask=vector<vector<char> >(), int flags=DrawMatchesFlags::DEFAULT )
dst	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, m, n>* dst;$/;"	m	class:cv::MatxCommaInitializer	access:public
dst	/usr/include/opencv2/core/core_c.h	/^    CvGraphVtx* dst;       \/* current graph edge destination vertex *\/$/;"	m	struct:CvGraphScanner	access:public
dstType	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
dstY	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
dx	/usr/include/opencv2/core/core_c.h	/^    float       dx; 			\/* horizontal interval between letters *\/$/;"	m	struct:CvFont	access:public
dx1	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int dx1, dx2;$/;"	m	class:cv::FilterEngine	access:public
dx2	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int dx1, dx2;$/;"	m	class:cv::FilterEngine	access:public
ea	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** ea; \/\/ sum_i  AijT * e_ij , used as right part of normal equation$/;"	m	class:cv::LevMarqSparse	access:protected
eb	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** eb; \/\/ sum_j  BijT * e_ij , used as right part of normal equation$/;"	m	class:cv::LevMarqSparse	access:protected
edge	/usr/include/opencv2/core/core_c.h	/^    CvGraphEdge* edge;     \/* current edge *\/$/;"	m	struct:CvGraphScanner	access:public
edgeBlurSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int edgeBlurSize;$/;"	m	struct:CvMSERParams	access:public
edgeBuf	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* edgeBuf;$/;"	m	struct:CvStereoGCState	access:public
edgeThreshold	/usr/include/opencv2/features2d/features2d.hpp	/^        double threshold, edgeThreshold;$/;"	m	struct:cv::SIFT::DetectorParams	access:public
edge_threshold	/usr/include/opencv2/gpu/gpu.hpp	/^            float edge_threshold;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
edge_weights	/usr/include/opencv2/legacy/legacy.hpp	/^    float* edge_weights;$/;"	m	struct:CvCliqueFinder	access:public
egvals	/usr/include/opencv2/legacy/legacy.hpp	/^    float egvals[2];$/;"	m	struct:CvContourOrientation	access:public
egvects	/usr/include/opencv2/legacy/legacy.hpp	/^    float egvects[4];$/;"	m	struct:CvContourOrientation	access:public
ehmm	/usr/include/opencv2/legacy/legacy.hpp	/^        struct CvEHMM* ehmm; \/* pointer to an embedded model or NULL, if it is a leaf *\/$/;"	m	union:CvEHMM::__anon171	typeref:struct:CvEHMM::__anon171::CvEHMM	access:public
eigen	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS bool eigen(const Mat& src, CV_OUT Mat& eigenvalues, CV_OUT Mat& eigenvectors,$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& eigenvalues, CV_OUT Mat& eigenvectors, int lowindex=-1, int highindex=-1)
eigen	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS bool eigen(const Mat& src, CV_OUT Mat& eigenvalues, int lowindex=-1,$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& eigenvalues, int lowindex=-1, int highindex=-1)
eigen2cv	/usr/include/opencv2/core/eigen.hpp	/^void eigen2cv( const Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& src, Mat& dst )$/;"	f	namespace:cv	signature:( const Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& src, Mat& dst )
eigenvalues	/usr/include/opencv2/core/core.hpp	/^    Mat eigenvalues; \/\/!< eigenvalues of the covariation matrix$/;"	m	class:cv::PCA	access:public
eigenvectors	/usr/include/opencv2/core/core.hpp	/^    Mat eigenvectors; \/\/!< eigenvectors of the covariation matrix$/;"	m	class:cv::PCA	access:public
elemSize	/usr/include/opencv2/core/core.hpp	/^    int step, elemSize;$/;"	m	class:cv::LineIterator	access:public
elemSize	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Mat	access:public	signature:() const
elemSize	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
elemSize	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Seq	access:public	signature:() const
elemSize	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
elemSize	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize;$/;"	m	class:cv::MatConstIterator	access:public
elemSize	/usr/include/opencv2/core/mat.hpp	/^inline size_t Mat::elemSize() const { return dims > 0 ? step.p[dims-1] : 0; }$/;"	f	class:cv::Mat	signature:() const
elemSize	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::elemSize() const$/;"	f	class:cv::SparseMat	signature:() const
elemSize	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::elemSize() const$/;"	f	class:cv::Mat_	signature:() const
elemSize	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::elemSize() const$/;"	f	class:cv::Seq	signature:() const
elemSize	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ size_t elemSize() const { return elem_size; }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:() const
elemSize	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ size_t elemSize() const { return elem_size; }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:() const
elemSize	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t elemSize() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
elemSize	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t elemSize() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
elemSize	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t CudaMem::elemSize() const { return CV_ELEM_SIZE(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
elemSize	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t GpuMat::elemSize() const { return CV_ELEM_SIZE(flags); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
elemSize1	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::Mat	access:public	signature:() const
elemSize1	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
elemSize1	/usr/include/opencv2/core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
elemSize1	/usr/include/opencv2/core/mat.hpp	/^inline size_t Mat::elemSize1() const { return CV_ELEM_SIZE1(flags); }$/;"	f	class:cv::Mat	signature:() const
elemSize1	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::elemSize1() const$/;"	f	class:cv::SparseMat	signature:() const
elemSize1	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::elemSize1() const$/;"	f	class:cv::Mat_	signature:() const
elemSize1	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t elemSize1() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
elemSize1	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t elemSize1() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
elemSize1	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t CudaMem::elemSize1() const { return CV_ELEM_SIZE1(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
elemSize1	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t GpuMat::elemSize1() const { return CV_ELEM_SIZE1(flags); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
elem_size	/usr/include/opencv2/gpu/devmem2d.hpp	/^            enum { elem_size = sizeof(elem_type) };$/;"	e	enum:cv::gpu::DevMem2D_::__anon168
elem_size	/usr/include/opencv2/gpu/devmem2d.hpp	/^            enum { elem_size = sizeof(elem_type) };$/;"	e	enum:cv::gpu::PtrStep_::__anon169
elem_type	/usr/include/opencv2/gpu/devmem2d.hpp	/^            typedef T elem_type;$/;"	t	struct:cv::gpu::DevMem2D_	access:public
elem_type	/usr/include/opencv2/gpu/devmem2d.hpp	/^            typedef T elem_type;$/;"	t	struct:cv::gpu::PtrStep_	access:public
element	/usr/include/opencv2/imgproc/imgproc_c.h	/^CVAPI(void)  cvReleaseStructuringElement( IplConvKernel** element );$/;"	v
elementWise	/usr/include/opencv2/core/mat.hpp	/^    virtual bool elementWise(const MatExpr& expr) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr) const
ellipse	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void ellipse(Mat& img, Point center, Size axes,$/;"	p	namespace:cv	signature:(Mat& img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
ellipse	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void ellipse(Mat& img, const RotatedRect& box, const Scalar& color,$/;"	p	namespace:cv	signature:(Mat& img, const RotatedRect& box, const Scalar& color, int thickness=1, int lineType=8)
ellipse2Poly	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void ellipse2Poly( Point center, Size axes, int angle,$/;"	p	namespace:cv	signature:( Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, CV_OUT vector<Point>& pts )
ellipseAngle	/usr/include/opencv2/contrib/contrib.hpp	/^        double ellipseAngle;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
ellipseHeight	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
ellipseWidth	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
elname	/usr/include/opencv2/core/core.hpp	/^    string elname; \/\/!< the currently written element$/;"	m	class:cv::FileStorage	access:public
empty	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool empty() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
empty	/usr/include/opencv2/core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Mat	access:public	signature:() const
empty	/usr/include/opencv2/core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Ptr	access:public	signature:() const
empty	/usr/include/opencv2/core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Range	access:public	signature:() const
empty	/usr/include/opencv2/core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Seq	access:public	signature:() const
empty	/usr/include/opencv2/core/mat.hpp	/^inline bool Mat::empty() const { return data == 0 || total() == 0; }$/;"	f	class:cv::Mat	signature:() const
empty	/usr/include/opencv2/core/operations.hpp	/^    bool empty() const { return hdr.size == 0; }$/;"	f	class:cv::Vector	access:public	signature:() const
empty	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::empty() const { return node == 0; }$/;"	f	class:cv::FileNode	signature:() const
empty	/usr/include/opencv2/core/operations.hpp	/^inline bool Range::empty() const { return start == end; }$/;"	f	class:cv::Range	signature:() const
empty	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool Ptr<_Tp>::empty() const { return obj == 0; }$/;"	f	class:cv::Ptr	signature:() const
empty	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool Seq<_Tp>::empty() const$/;"	f	class:cv::Seq	signature:() const
empty	/usr/include/opencv2/features2d/features2d.hpp	/^	bool empty() const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
empty	/usr/include/opencv2/flann/heap.h	/^	bool empty()$/;"	f	class:cvflann::Heap	access:public	signature:()
empty	/usr/include/opencv2/gpu/gpu.hpp	/^            bool empty() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
empty	/usr/include/opencv2/gpu/gpu.hpp	/^            bool empty() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
empty	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline bool CudaMem::empty() const { return data == 0; }$/;"	f	class:cv::gpu::CudaMem	signature:() const
empty	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline bool GpuMat::empty() const { return data == 0; }$/;"	f	class:cv::gpu::GpuMat	signature:() const
empty	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP bool empty() const;$/;"	p	class:cv::CascadeClassifier	access:public	signature:() const
end	/usr/include/opencv2/contrib/contrib.hpp	/^            int begin, end;$/;"	m	struct:cv::Octree::Node	access:public
end	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator end() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
end	/usr/include/opencv2/core/core.hpp	/^    SeqIterator<_Tp> end() const;$/;"	p	class:cv::Seq	access:public	signature:() const
end	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator end() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
end	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_<_Tp> end() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
end	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator end();$/;"	p	class:cv::SparseMat	access:public	signature:()
end	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_<_Tp> end();$/;"	p	class:cv::SparseMat_	access:public	signature:()
end	/usr/include/opencv2/core/core.hpp	/^    const_iterator end() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
end	/usr/include/opencv2/core/core.hpp	/^    int start, end;$/;"	m	class:cv::Range	access:public
end	/usr/include/opencv2/core/core.hpp	/^    iterator end();$/;"	p	class:cv::Mat_	access:public	signature:()
end	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> MatConstIterator_<_Tp> end() const;$/;"	p	class:cv::Mat	access:public	signature:() const
end	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> MatIterator_<_Tp> end();$/;"	p	class:cv::Mat	access:public	signature:()
end	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> SparseMatConstIterator_<_Tp> end() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
end	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> SparseMatIterator_<_Tp> end();$/;"	p	class:cv::SparseMat	access:public	signature:()
end	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator SparseMat::end() const$/;"	f	class:cv::SparseMat	signature:() const
end	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator SparseMat::end()$/;"	f	class:cv::SparseMat	signature:()
end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat::end() const$/;"	f	class:cv::Mat	signature:() const
end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::end() const$/;"	f	class:cv::Mat_	signature:() const
end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat::end()$/;"	f	class:cv::Mat	signature:()
end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::end()$/;"	f	class:cv::Mat_	signature:()
end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::end() const$/;"	f	class:cv::SparseMat	signature:() const
end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::end() const$/;"	f	class:cv::SparseMat_	signature:() const
end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::end()$/;"	f	class:cv::SparseMat	signature:()
end	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::end()$/;"	f	class:cv::SparseMat_	signature:()
end	/usr/include/opencv2/core/operations.hpp	/^    _Tp* end() { return hdr.data + hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:()
end	/usr/include/opencv2/core/operations.hpp	/^    const _Tp* end() const { return hdr.data + hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:() const
end	/usr/include/opencv2/core/operations.hpp	/^inline FileNodeIterator FileNode::end() const$/;"	f	class:cv::FileNode	signature:() const
end	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::end() const$/;"	f	class:cv::Seq	signature:() const
end	/usr/include/opencv2/imgproc/types_c.h	/^    CvPoint* end; \/* point of the contour where the defect ends *\/$/;"	m	struct:CvConvexityDefect	access:public
end1	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int end1,end2;$/;"	m	struct:CvTracksTimePos	access:public
end2	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int end1,end2;$/;"	m	struct:CvTracksTimePos	access:public
endY	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
end_index	/usr/include/opencv2/core/types_c.h	/^    int  start_index, end_index;$/;"	m	struct:CvSlice	access:public
enqueueConvert	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueConvert(const GpuMat& src, GpuMat& dst, int type, double a = 1, double b = 0);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, GpuMat& dst, int type, double a = 1, double b = 0)
enqueueCopy	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueCopy(const GpuMat& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, GpuMat& dst)
enqueueDownload	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueDownload(const GpuMat& src, CudaMem& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, CudaMem& dst)
enqueueDownload	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueDownload(const GpuMat& src, Mat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, Mat& dst)
enqueueMemSet	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueMemSet(const GpuMat& src, Scalar val);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, Scalar val)
enqueueMemSet	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueMemSet(const GpuMat& src, Scalar val, const GpuMat& mask);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, Scalar val, const GpuMat& mask)
enqueueUpload	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueUpload(const CudaMem& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const CudaMem& src, GpuMat& dst)
enqueueUpload	/usr/include/opencv2/gpu/gpu.hpp	/^            void enqueueUpload(const Mat& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Mat& src, GpuMat& dst)
ensemble	/usr/include/opencv2/ml/ml.hpp	/^    CvBoost* ensemble;$/;"	m	class:CvBoostTree	access:protected
epipole	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint3D32f epipole[2];$/;"	m	struct:CvStereoCamera	access:public
eps	/usr/include/opencv2/ml/ml.hpp	/^    double eps;$/;"	m	class:CvSVMSolver	access:public
epsilon	/usr/include/opencv2/core/core.hpp	/^    double epsilon; \/\/ the desired accuracy$/;"	m	class:cv::TermCriteria	access:public
epsilon	/usr/include/opencv2/core/types_c.h	/^    double epsilon;$/;"	m	struct:CvTermCriteria	access:public
equalizeHist	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void equalizeHist( const Mat& src, CV_OUT Mat& dst );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst )
erase	/usr/include/opencv2/core/core.hpp	/^    void erase(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0)
erase	/usr/include/opencv2/core/core.hpp	/^    void erase(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
erase	/usr/include/opencv2/core/core.hpp	/^    void erase(int i0, int i1, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0)
erode	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void erode( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1);$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1)
erode	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void erode( const Mat& src, CV_OUT Mat& dst, const Mat& kernel,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
err	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> err;$/;"	m	class:CvLevMarq	access:public
err	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* err; \/\/error X-hX$/;"	m	class:cv::LevMarqSparse	access:protected
err	/usr/include/opencv2/core/core.hpp	/^	string err; \/\/\/< error description$/;"	m	class:cv::Exception	access:public
err	/usr/include/opencv2/core/core.hpp	/^    int err, count;$/;"	m	class:cv::LineIterator	access:public
err	/usr/include/opencv2/core/types_c.h	/^    int  err;$/;"	m	struct:CvLineIterator	access:public
errNorm	/usr/include/opencv2/calib3d/calib3d.hpp	/^    double prevErrNorm, errNorm;$/;"	m	class:CvLevMarq	access:public
errNorm	/usr/include/opencv2/contrib/contrib.hpp	/^        double prevErrNorm, errNorm;$/;"	m	class:cv::LevMarqSparse	access:protected
error	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void error( const Exception& exc );$/;"	p	namespace:cv	signature:( const Exception& exc )
error	/usr/include/opencv2/flann/logger.h	/^    int error(const char* fmt, ...);$/;"	p	class:cvflann::Logger	access:public	signature:(const char* fmt, ...)
error	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void error(const char *error_string, const char *file, const int line, const char *func);$/;"	p	namespace:cv::gpu	signature:(const char *error_string, const char *file, const int line, const char *func)
errorCovPost	/usr/include/opencv2/video/tracking.hpp	/^    Mat errorCovPost;       \/\/!< posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)$/;"	m	class:cv::KalmanFilter	access:public
errorCovPre	/usr/include/opencv2/video/tracking.hpp	/^    Mat errorCovPre;        \/\/!< priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)*\/$/;"	m	class:cv::KalmanFilter	access:public
error_cov_post	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* error_cov_post;      \/* posteriori error estimate covariance matrix (P(k)):$/;"	m	struct:CvKalman	access:public
error_cov_pre	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* error_cov_pre;       \/* priori error estimate covariance matrix (P'(k)):$/;"	m	struct:CvKalman	access:public
escape_iters_	/usr/include/opencv2/features2d/features2d.hpp	/^	int escape_iters_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
estimateAffine3D	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS int estimateAffine3D(const Mat& from, const Mat& to, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:(const Mat& from, const Mat& to, CV_OUT Mat& dst, CV_OUT vector<uchar>& outliers, double param1 = 3.0, double param2 = 0.99)
estimateBuildParams	/usr/include/opencv2/flann/autotuned_index.h	/^    IndexParams* estimateBuildParams()$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:()
estimateQuantPercForPosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void estimateQuantPercForPosteriors(float perc[2]);$/;"	p	class:cv::RandomizedTree	access:private	signature:(float perc[2])
estimateRecommendedParams	/usr/include/opencv2/gpu/gpu.hpp	/^            static void estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int width, int height, int& ndisp, int& iters, int& levels)
estimateRecommendedParams	/usr/include/opencv2/gpu/gpu.hpp	/^            static void estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane);$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane)
estimateResolution	/usr/include/opencv2/contrib/contrib.hpp	/^        float estimateResolution(float tryRatio = 0.1f);$/;"	p	class:cv::Mesh3D	access:public	signature:(float tryRatio = 0.1f)
estimateRigidTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat estimateRigidTransform( const Mat& A, const Mat& B,$/;"	p	namespace:cv	signature:( const Mat& A, const Mat& B, bool fullAffine )
estimateSearchParams	/usr/include/opencv2/flann/autotuned_index.h	/^    float estimateSearchParams(SearchParams& searchParams)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(SearchParams& searchParams)
etalonParamCount	/usr/include/opencv2/legacy/legacy.hpp	/^    int     etalonParamCount;$/;"	m	class:CvCalibFilter	access:protected
etalonParams	/usr/include/opencv2/legacy/legacy.hpp	/^    double* etalonParams;$/;"	m	class:CvCalibFilter	access:protected
etalonPointCount	/usr/include/opencv2/legacy/legacy.hpp	/^    int     etalonPointCount;$/;"	m	class:CvCalibFilter	access:protected
etalonPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f* etalonPoints;$/;"	m	class:CvCalibFilter	access:protected
etalonType	/usr/include/opencv2/legacy/legacy.hpp	/^    CvCalibEtalonType  etalonType;$/;"	m	class:CvCalibFilter	access:protected
euclidean_dist	/usr/include/opencv2/flann/dist.h	/^CV_EXPORTS double euclidean_dist(const unsigned char* first1, const unsigned char* last1, unsigned char* first2, double acc);$/;"	p	namespace:cvflann	signature:(const unsigned char* first1, const unsigned char* last1, unsigned char* first2, double acc)
euclidean_dist	/usr/include/opencv2/flann/dist.h	/^double euclidean_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
evaluateFeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void evaluateFeatureDetector( const Mat& img1, const Mat& img2, const Mat& H1to2,$/;"	p	namespace:cv	signature:( const Mat& img1, const Mat& img2, const Mat& H1to2, vector<KeyPoint>* keypoints1, vector<KeyPoint>* keypoints2, float& repeatability, int& correspCount, const Ptr<FeatureDetector>& fdetector=Ptr<FeatureDetector>() )
evaluateGenericDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void evaluateGenericDescriptorMatcher( const Mat& img1, const Mat& img2, const Mat& H1to2,$/;"	p	namespace:cv	signature:( const Mat& img1, const Mat& img2, const Mat& H1to2, vector<KeyPoint>& keypoints1, vector<KeyPoint>& keypoints2, vector<vector<DMatch> >* matches1to2, vector<vector<uchar> >* correctMatches1to2Mask, vector<Point2f>& recallPrecisionCurve, const Ptr<GenericDescriptorMatcher>& dmatch=Ptr<GenericDescriptorMatcher>() )
evaluate_kdtree	/usr/include/opencv2/flann/autotuned_index.h	/^     void evaluate_kdtree(CostData& cost, const KDTreeIndexParams& kdtree_params)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(CostData& cost, const KDTreeIndexParams& kdtree_params)
evaluate_kmeans	/usr/include/opencv2/flann/autotuned_index.h	/^    void evaluate_kmeans(CostData& cost, const KMeansIndexParams& kmeans_params)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(CostData& cost, const KMeansIndexParams& kmeans_params)
evenLevels	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void evenLevels(GpuMat& levels, int nLevels, int lowerLevel, int upperLevel);$/;"	p	namespace:cv::gpu	signature:(GpuMat& levels, int nLevels, int lowerLevel, int upperLevel)
exp	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void exp(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
exp	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void exp(const GpuMat& a, GpuMat& b);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b)
exploreNodeBranches	/usr/include/opencv2/flann/kmeans_index.h	/^	int exploreNodeBranches(KMeansNode node, const ELEM_TYPE* q, float* domain_distances, Heap<BranchSt>* heap)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, const ELEM_TYPE* q, float* domain_distances, Heap<BranchSt>* heap)
extended	/usr/include/opencv2/features2d/features2d.hpp	/^    int extended;$/;"	m	struct:CvSURFParams	access:public
extractImageCOI	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void extractImageCOI(const CvArr* arr, CV_OUT Mat& coiimg, int coi=-1);$/;"	p	namespace:cv	signature:(const CvArr* arr, CV_OUT Mat& coiimg, int coi=-1)
extractInfo	/usr/include/opencv2/contrib/contrib.hpp	/^        void extractInfo(IplImage *maskImage, IplImage *depthMap, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap, bool initDepth)
extractor	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> extractor;$/;"	m	class:cv::VectorDescriptorMatcher	access:protected
eye	/usr/include/opencv2/core/core.hpp	/^    static MatExpr eye(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
eye	/usr/include/opencv2/core/core.hpp	/^    static MatExpr eye(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
eye	/usr/include/opencv2/core/core.hpp	/^    static MatExpr eye(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
eye	/usr/include/opencv2/core/core.hpp	/^    static MatExpr eye(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
eye	/usr/include/opencv2/core/core.hpp	/^    static Matx eye();$/;"	p	class:cv::Matx	access:public	signature:()
eye	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
eye	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
eye	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::eye()$/;"	f	class:cv::Matx	signature:()
f	/usr/include/opencv2/core/types_c.h	/^        double f; \/* scalar floating-point number *\/$/;"	m	union:CvFileNode::__anon100	access:public
f	/usr/include/opencv2/core/types_c.h	/^    double f;$/;"	m	union:Cv64suf	access:public
f	/usr/include/opencv2/core/types_c.h	/^    float f;$/;"	m	union:Cv32suf	access:public
fHistogram	/usr/include/opencv2/contrib/contrib.hpp	/^        CvHistogram *fHistogram;$/;"	m	class:CvAdaptiveSkinDetector::Histogram	access:public
fHistogramMergeFactor	/usr/include/opencv2/contrib/contrib.hpp	/^    double fHistogramMergeFactor, fHuePercentCovered;$/;"	m	class:CvAdaptiveSkinDetector	access:private
fHuePercentCovered	/usr/include/opencv2/contrib/contrib.hpp	/^    double fHistogramMergeFactor, fHuePercentCovered;$/;"	m	class:CvAdaptiveSkinDetector	access:private
f_param1	/usr/include/opencv2/ml/ml.hpp	/^    double f_param1, f_param2;$/;"	m	class:CvANN_MLP	access:protected
f_param2	/usr/include/opencv2/ml/ml.hpp	/^    double f_param1, f_param2;$/;"	m	class:CvANN_MLP	access:protected
fastAtan2	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W float fastAtan2(float y, float x);$/;"	p	namespace:cv	signature:(float y, float x)
fastFree	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void fastFree(void* ptr);$/;"	p	namespace:cv	signature:(void* ptr)
fastMalloc	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void* fastMalloc(size_t bufSize);$/;"	p	namespace:cv	signature:(size_t bufSize)
fatal	/usr/include/opencv2/flann/logger.h	/^    int fatal(const char* fmt, ...);$/;"	p	class:cvflann::Logger	access:public	signature:(const char* fmt, ...)
featureIdx	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int featureIdx;$/;"	m	struct:cv::CascadeClassifier::DTreeNode	access:public
featureScaleLevels	/usr/include/opencv2/features2d/features2d.hpp	/^        int featureScaleLevels;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
featureScaleMul	/usr/include/opencv2/features2d/features2d.hpp	/^        float featureScaleMul;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
featureType	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int featureType;$/;"	m	class:cv::CascadeClassifier	access:public
features	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<Feature> features;$/;"	m	class:cv::FernClassifier	access:protected
fernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    FernClassifier fernClassifier;$/;"	m	class:cv::PlanarObjectDetector	access:protected
feval	/usr/include/opencv2/objdetect/objdetect.hpp	/^    Ptr<FeatureEvaluator> feval;$/;"	m	class:cv::CascadeClassifier	access:public
file	/usr/include/opencv2/core/core.hpp	/^	string file; \/\/\/< source file name where the error has occured$/;"	m	class:cv::Exception	access:public
filename	/usr/include/opencv2/features2d/features2d.hpp	/^        string filename;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
filename	/usr/include/opencv2/flann/flann_base.hpp	/^	std::string filename;		\/\/ filename of the stored index$/;"	m	struct:cvflann::SavedIndexParams	access:public
fill	/usr/include/opencv2/core/core.hpp	/^    void fill( Mat& mat, int distType, const Scalar& a, const Scalar& b );$/;"	p	class:cv::RNG	access:public	signature:( Mat& mat, int distType, const Scalar& a, const Scalar& b )
fillConvexPoly	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void fillConvexPoly(Mat& img, const Point* pts, int npts,$/;"	p	namespace:cv	signature:(Mat& img, const Point* pts, int npts, const Scalar& color, int lineType=8, int shift=0)
fillPoly	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void fillPoly(Mat& img, const Point** pts,$/;"	p	namespace:cv	signature:(Mat& img, const Point** pts, const int* npts, int ncontours, const Scalar& color, int lineType=8, int shift=0, Point offset=Point() )
filter2D	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void filter2D(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernel, Point anchor=Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernel, Point anchor=Point(-1,-1))
filter2D	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Ptr<BaseFilter> filter2D;$/;"	m	class:cv::FilterEngine	access:public
filter2D	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void filter2D( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, const Mat& kernel, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT )
filterSpeckles	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void filterSpeckles( Mat& img, double newVal, int maxSpeckleSize, double maxDiff, Mat& buf );$/;"	p	namespace:cv	signature:( Mat& img, double newVal, int maxSpeckleSize, double maxDiff, Mat& buf )
filterSpeckles	/usr/include/opencv2/gpu/gpu.hpp	/^    CV_EXPORTS void filterSpeckles( Mat& img, uchar newVal, int maxSpeckleSize, uchar diffThreshold, Mat& buf);$/;"	p	namespace:cv	signature:( Mat& img, uchar newVal, int maxSpeckleSize, uchar diffThreshold, Mat& buf)
filters	/usr/include/opencv2/objdetect/objdetect.hpp	/^	CvLSVMFilterObject** filters;$/;"	m	struct:CvLatentSvmDetector	access:public
finalize	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void finalize(RNG& rng);$/;"	p	class:cv::FernClassifier	access:protected	signature:(RNG& rng)
finalize	/usr/include/opencv2/features2d/features2d.hpp	/^  void finalize(size_t reduced_num_dim, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:private	signature:(size_t reduced_num_dim, int num_quant_bits)
find	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* find(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0) const
find	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
find	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0) const
find	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0) const
find	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval) const
find	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval) const
find	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval) const
find	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval) const
find4QuadCornerSubpix	/usr/include/opencv2/contrib/contrib.hpp	/^    CV_EXPORTS bool find4QuadCornerSubpix(const Mat& img, std::vector<Point2f>& corners, Size region_size);$/;"	p	namespace:cv	signature:(const Mat& img, std::vector<Point2f>& corners, Size region_size)
findChessboardCorners	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W bool findChessboardCorners( const Mat& image, Size patternSize,$/;"	p	namespace:cv	signature:( const Mat& image, Size patternSize, CV_OUT vector<Point2f>& corners, int flags=CALIB_CB_ADAPTIVE_THRESH+ CALIB_CB_NORMALIZE_IMAGE )
findContours	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void findContours( Mat& image, CV_OUT vector<vector<Point> >& contours,$/;"	p	namespace:cv	signature:( Mat& image, CV_OUT vector<vector<Point> >& contours, int mode, int method, Point offset=Point())
findContours	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void findContours( Mat& image, CV_OUT vector<vector<Point> >& contours,$/;"	p	namespace:cv	signature:( Mat& image, CV_OUT vector<vector<Point> >& contours, vector<Vec4i>& hierarchy, int mode, int method, Point offset=Point())
findCoverageIndex	/usr/include/opencv2/contrib/contrib.hpp	/^        int findCoverageIndex(double surfaceToCover, int defaultValue = 0);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:protected	signature:(double surfaceToCover, int defaultValue = 0)
findCurveThresholds	/usr/include/opencv2/contrib/contrib.hpp	/^        void findCurveThresholds(int &x1, int &x2, double percent = 0.05);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:(int &x1, int &x2, double percent = 0.05)
findExactNN	/usr/include/opencv2/flann/kmeans_index.h	/^	void findExactNN(KMeansNode node, ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec)
findFundamentalMat	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS Mat findFundamentalMat( const Mat& points1, const Mat& points2,$/;"	p	namespace:cv	signature:( const Mat& points1, const Mat& points2, CV_OUT vector<uchar>& mask, int method=FM_RANSAC, double param1=3., double param2=0.99 )
findFundamentalMat	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat findFundamentalMat( const Mat& points1, const Mat& points2,$/;"	p	namespace:cv	signature:( const Mat& points1, const Mat& points2, int method=FM_RANSAC, double param1=3., double param2=0.99 )
findHomography	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_AS(findHomographyAndOutliers) Mat findHomography( const Mat& srcPoints,$/;"	p	namespace:cv	signature:( const Mat& srcPoints, const Mat& dstPoints, vector<uchar>& mask, int method=0, double ransacReprojThreshold=3 )
findHomography	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat findHomography( const Mat& srcPoints,$/;"	p	namespace:cv	signature:( const Mat& srcPoints, const Mat& dstPoints, int method=0, double ransacReprojThreshold=3 )
findNN	/usr/include/opencv2/flann/kmeans_index.h	/^	void findNN(KMeansNode node, ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, int& checks, int maxChecks,$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, int& checks, int maxChecks, Heap<BranchSt>* heap)
findNearest	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP int findNearest(const vector<float>& vec, int K, int Emax,$/;"	p	class:cv::KDTree	access:public	signature:(const vector<float>& vec, int K, int Emax, CV_OUT vector<int>* neighborsIdx, CV_OUT Mat* neighbors=0, CV_OUT vector<float>* dist=0, CV_OUT vector<int>* labels=0) const
findNearest	/usr/include/opencv2/core/core.hpp	/^    int findNearest(const float* vec, int K, int Emax,$/;"	p	class:cv::KDTree	access:public	signature:(const float* vec, int K, int Emax, vector<int>* neighborsIdx, Mat* neighbors=0, vector<float>* dist=0, vector<int>* labels=0) const
findNearest	/usr/include/opencv2/core/core.hpp	/^    int findNearest(const float* vec,$/;"	p	class:cv::KDTree	access:public	signature:(const float* vec, int K, int Emax, int* neighborsIdx, Mat* neighbors=0, float* dist=0, int* labels=0) const
findNeighbors	/usr/include/opencv2/flann/autotuned_index.h	/^	virtual void findNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)
findNeighbors	/usr/include/opencv2/flann/composite_index.h	/^	void findNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)
findNeighbors	/usr/include/opencv2/flann/kdtree_index.h	/^    void findNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)
findNeighbors	/usr/include/opencv2/flann/kmeans_index.h	/^    void findNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)
findNeighbors	/usr/include/opencv2/flann/linear_index.h	/^	void findNeighbors(ResultSet<ELEM_TYPE>& resultSet, const ELEM_TYPE*, const SearchParams&)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(ResultSet<ELEM_TYPE>& resultSet, const ELEM_TYPE*, const SearchParams&)
findNeighbors	/usr/include/opencv2/flann/nn_index.h	/^	virtual void findNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, const SearchParams& searchParams)
findOptimumSearchWindow	/usr/include/opencv2/contrib/contrib.hpp	/^    void findOptimumSearchWindow(SearchWindow &searchWindow, IplImage *maskImage, IplImage *depthMap, int maxIteration, int resizeMethod, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker	access:private	signature:(SearchWindow &searchWindow, IplImage *maskImage, IplImage *depthMap, int maxIteration, int resizeMethod, bool initDepth)
findOrthoRange	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP void findOrthoRange(const vector<float>& minBounds, const vector<float>& maxBounds,$/;"	p	class:cv::KDTree	access:public	signature:(const vector<float>& minBounds, const vector<float>& maxBounds, CV_OUT vector<int>* neighborsIdx, CV_OUT Mat* neighbors=0, CV_OUT vector<int>* labels=0) const
findOrthoRange	/usr/include/opencv2/core/core.hpp	/^    void findOrthoRange(const float* minBounds, const float* maxBounds,$/;"	p	class:cv::KDTree	access:public	signature:(const float* minBounds, const float* maxBounds, vector<int>* neighborsIdx, Mat* neighbors=0, vector<int>* labels=0) const
find_best_split	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_best_split( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
find_best_split	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_best_split( CvDTreeNode* n );$/;"	p	class:CvForestTree	access:protected	signature:( CvDTreeNode* n )
find_gradient	/usr/include/opencv2/ml/ml.hpp	/^    virtual void find_gradient( const int k = 0);$/;"	p	class:CvGBTrees	access:protected	signature:( const int k = 0)
find_nearest	/usr/include/opencv2/flann/ground_truth.h	/^void find_nearest(const Matrix<T>& dataset, T* query, int* matches, int nn, int skip = 0)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& dataset, T* query, int* matches, int nn, int skip = 0)
find_nearest	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float find_nearest( const cv::Mat& samples, int k, CV_OUT cv::Mat& results,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& samples, int k, CV_OUT cv::Mat& results, CV_OUT cv::Mat& neighborResponses, CV_OUT cv::Mat& dists) const
find_nearest	/usr/include/opencv2/ml/ml.hpp	/^    virtual float find_nearest( const CvMat* samples, int k, CV_OUT CvMat* results=0,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* samples, int k, CV_OUT CvMat* results=0, const float** neighbors=0, CV_OUT CvMat* neighborResponses=0, CV_OUT CvMat* dist=0 ) const
find_nearest	/usr/include/opencv2/ml/ml.hpp	/^    virtual float find_nearest( const cv::Mat& samples, int k, cv::Mat* results=0,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& samples, int k, cv::Mat* results=0, const float** neighbors=0, cv::Mat* neighborResponses=0, cv::Mat* dist=0 ) const
find_neighbors_direct	/usr/include/opencv2/ml/ml.hpp	/^    virtual void find_neighbors_direct( const CvMat* _samples, int k, int start, int end,$/;"	p	class:CvKNearest	access:protected	signature:( const CvMat* _samples, int k, int start, int end, float* neighbor_responses, const float** neighbors, float* dist ) const
find_optimal_value	/usr/include/opencv2/ml/ml.hpp	/^    virtual float find_optimal_value( const CvMat* _Idx );$/;"	p	class:CvGBTrees	access:protected	signature:( const CvMat* _Idx )
find_split_cat_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_cat_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_cat_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_cat_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_cat_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_cat_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_reg	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_surrogate_split_cat	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_cat( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
find_surrogate_split_cat	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_cat( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
find_surrogate_split_ord	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_ord( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
find_surrogate_split_ord	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_ord( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
fineFunction	/usr/include/opencv2/objdetect/objdetect.hpp	/^    float fineFunction[4];$/;"	m	struct:__anon60	access:public
first	/usr/include/opencv2/core/core_c.h	/^    static CvModuleInfo* first;$/;"	m	struct:CvModule	access:public
first	/usr/include/opencv2/core/core_c.h	/^    static CvTypeInfo* first;$/;"	m	struct:CvType	access:public
first	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int first;$/;"	m	struct:cv::CascadeClassifier::Stage	access:public
firstOctave	/usr/include/opencv2/features2d/features2d.hpp	/^        int nOctaves, nOctaveLayers, firstOctave;$/;"	m	struct:cv::SIFT::CommonParams	access:public
fitEllipse	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W RotatedRect fitEllipse( const Mat& points );$/;"	p	namespace:cv	signature:( const Mat& points )
fitLine	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void fitLine( const Mat& points, CV_OUT Vec4f& line, int distType,$/;"	p	namespace:cv	signature:( const Mat& points, CV_OUT Vec4f& line, int distType, double param, double reps, double aeps )
fitLine	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void fitLine( const Mat& points, CV_OUT Vec6f& line, int distType,$/;"	p	namespace:cv	signature:( const Mat& points, CV_OUT Vec6f& line, int distType, double param, double reps, double aeps )
fixp	/usr/include/opencv2/legacy/legacy.hpp	/^    int* fixp; \/\/node with minimal disconnections$/;"	m	struct:CvCliqueFinder	access:public
fjac	/usr/include/opencv2/contrib/contrib.hpp	/^        void (*fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data);$/;"	m	class:cv::LevMarqSparse	access:protected
fl	/usr/include/opencv2/core/types_c.h	/^        float* fl;$/;"	m	union:CvMat::__anon94	access:public
fl	/usr/include/opencv2/core/types_c.h	/^        float* fl;$/;"	m	union:CvMatND::__anon97	access:public
fl	/usr/include/opencv2/ml/ml.hpp	/^        float** fl;$/;"	m	union:CvVectors::__anon76	access:public
flConfidence	/usr/include/opencv2/legacy/legacy.hpp	/^    float* flConfidence;    \/* Confidence for each Sample            *\/$/;"	m	struct:CvConDensation	access:public
flCumulative	/usr/include/opencv2/legacy/legacy.hpp	/^    float* flCumulative;    \/* Cumulative confidence                 *\/$/;"	m	struct:CvConDensation	access:public
flNewSamples	/usr/include/opencv2/legacy/legacy.hpp	/^    float** flNewSamples;   \/* temporary array of the Sample Vectors *\/$/;"	m	struct:CvConDensation	access:public
flSamples	/usr/include/opencv2/legacy/legacy.hpp	/^    float** flSamples;      \/* arr of the Sample Vectors             *\/$/;"	m	struct:CvConDensation	access:public
flags	/usr/include/opencv2/core/core.hpp	/^    int flags;$/;"	m	class:cv::Mat	access:public
flags	/usr/include/opencv2/core/core.hpp	/^    int flags;$/;"	m	class:cv::SparseMat	access:public
flags	/usr/include/opencv2/core/mat.hpp	/^    int flags;$/;"	m	class:cv::MatExpr	access:public
flags	/usr/include/opencv2/core/types_c.h	/^    int flags;$/;"	m	struct:CvTypeInfo	access:public
flags	/usr/include/opencv2/features2d/features2d.hpp	/^    int flags;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
flags	/usr/include/opencv2/gpu/gpu.hpp	/^            int flags;$/;"	m	class:cv::gpu::CudaMem	access:public
flags	/usr/include/opencv2/gpu/gpu.hpp	/^            int flags;$/;"	m	class:cv::gpu::GpuMat	access:public
flags	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int  flags;$/;"	m	struct:CvHaarClassifierCascade	access:public
flann	/usr/include/opencv2/flann/flann.hpp	/^namespace flann$/;"	n	namespace:cv
flannIndex	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<flann::Index> flannIndex;$/;"	m	class:cv::FlannBasedMatcher	access:protected
flann_algorithm_t	/usr/include/opencv2/flann/general.h	/^enum flann_algorithm_t {$/;"	g	namespace:cvflann
flann_centers_init_t	/usr/include/opencv2/flann/general.h	/^enum flann_centers_init_t {$/;"	g	namespace:cvflann
flann_datatype_t	/usr/include/opencv2/flann/general.h	/^enum flann_datatype_t {$/;"	g	namespace:cvflann
flann_dist	/usr/include/opencv2/flann/dist.h	47;"	d
flann_distance_t	/usr/include/opencv2/flann/general.h	/^enum flann_distance_t {$/;"	g	namespace:cvflann
flann_distance_type	/usr/include/opencv2/flann/dist.h	/^CV_EXPORTS flann_distance_t flann_distance_type();$/;"	p	namespace:cvflann	signature:()
flann_log_level_t	/usr/include/opencv2/flann/general.h	/^enum flann_log_level_t {$/;"	g	namespace:cvflann
flann_minkowski_order	/usr/include/opencv2/flann/dist.h	/^CV_EXPORTS int flann_minkowski_order();$/;"	p	namespace:cvflann	signature:()
flip	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void flip(const Mat& src, CV_OUT Mat& dst, int flipCode);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flipCode)
flip	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void flip(const GpuMat& a, GpuMat& b, int flipCode);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b, int flipCode)
floodFill	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(floodFillMask) int floodFill( Mat& image, Mat& mask,$/;"	p	namespace:cv	signature:( Mat& image, Mat& mask, Point seedPoint, Scalar newVal, CV_OUT Rect* rect=0, Scalar loDiff=Scalar(), Scalar upDiff=Scalar(), int flags=4 )
floodFill	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W int floodFill( Mat& image,$/;"	p	namespace:cv	signature:( Mat& image, Point seedPoint, Scalar newVal, CV_OUT Rect* rect=0, Scalar loDiff=Scalar(), Scalar upDiff=Scalar(), int flags=4 )
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon132
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon133
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon134
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon135
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon136
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon137
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon138
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon139
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon140
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon123
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon124
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon125
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon126
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon127
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon128
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon129
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon130
fmt	/usr/include/opencv2/core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon131
fmt	/usr/include/opencv2/core/core.hpp	/^        fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon122
fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon109
fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon112
fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	e	enum:cv::DataDepth::__anon118
fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	e	enum:cv::DataDepth::__anon117
fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon115
fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon111
fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	e	enum:cv::DataDepth::__anon114
fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon110
fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon116
fmt	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	e	enum:cv::DataDepth::__anon113
fmt	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	e	enum:cv::DataDepth::__anon119
fmt	/usr/include/opencv2/core/operations.hpp	/^    const Formatter* fmt;$/;"	m	struct:cv::Formatted	access:public
fn_2d	/usr/include/opencv2/core/internal.hpp	/^    void*   fn_2d[CV_DEPTH_MAX*4];$/;"	m	struct:CvBigFuncTable	access:public
fn_2d	/usr/include/opencv2/core/internal.hpp	/^    void*   fn_2d[CV_DEPTH_MAX];$/;"	m	struct:CvFuncTable	access:public
focal_length	/usr/include/opencv2/legacy/legacy.hpp	/^    float focal_length[2];$/;"	m	struct:__anon176	access:public
fontQt	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS CvFont fontQt(const string& nameFont, int pointSize CV_DEFAULT(-1), Scalar color CV_DEFAULT(Scalar::all(0)), int weight CV_DEFAULT(CV_FONT_NORMAL),  int style CV_DEFAULT(CV_STYLE_NORMAL), int spacing CV_DEFAULT(0));$/;"	p	namespace:cv	signature:(const string& nameFont, int pointSize CV_DEFAULT(-1), Scalar color CV_DEFAULT(Scalar::all(0)), int weight CV_DEFAULT(CV_FONT_NORMAL), int style CV_DEFAULT(CV_STYLE_NORMAL), int spacing CV_DEFAULT(0))
font_face	/usr/include/opencv2/core/core_c.h	/^    int         font_face; 		\/\/Qt: bool italic         \/* =CV_FONT_* *\/$/;"	m	struct:CvFont	access:public
forest	/usr/include/opencv2/ml/ml.hpp	/^    CvRTrees* forest;$/;"	m	class:CvForestTree	access:protected
format	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS string format( const char* fmt, ... );$/;"	p	namespace:cv	signature:( const char* fmt, ... )
format	/usr/include/opencv2/core/operations.hpp	/^static inline Formatted format(const Mat& mtx, const char* fmt,$/;"	f	namespace:cv	signature:(const Mat& mtx, const char* fmt, const vector<int>& params=vector<int>())
format	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Formatted format(const vector<Point3_<_Tp> >& vec,$/;"	f	namespace:cv	signature:(const vector<Point3_<_Tp> >& vec, const char* fmt, const vector<int>& params=vector<int>())
format	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Formatted format(const vector<Point_<_Tp> >& vec,$/;"	f	namespace:cv	signature:(const vector<Point_<_Tp> >& vec, const char* fmt, const vector<int>& params=vector<int>())
formatMessage	/usr/include/opencv2/core/core.hpp	/^    void formatMessage()$/;"	f	class:cv::Exception	access:public	signature:()
frameSize	/usr/include/opencv2/video/background_segm.hpp	/^    Size frameSize;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
frameType	/usr/include/opencv2/video/background_segm.hpp	/^    int frameType;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
framesAccepted	/usr/include/opencv2/legacy/legacy.hpp	/^    int     framesAccepted;$/;"	m	class:CvCalibFilter	access:protected
framesTotal	/usr/include/opencv2/legacy/legacy.hpp	/^    int     framesTotal;$/;"	m	class:CvCalibFilter	access:protected
freeList	/usr/include/opencv2/core/core.hpp	/^        size_t freeList;$/;"	m	struct:cv::SparseMat::Hdr	access:public
freeList	/usr/include/opencv2/video/background_segm.hpp	/^    CvBGCodeBookElem* freeList;$/;"	m	struct:CvBGCodeBookModel	access:public
freePosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void freePosteriors(int which);    \/\/ which: 1=posteriors_, 2=posteriors2_, 3=both$/;"	p	class:cv::RandomizedTree	access:private	signature:(int which)
free_centers	/usr/include/opencv2/flann/kmeans_index.h	/^    void free_centers(KMeansNode node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node)
free_coef	/usr/include/opencv2/gpu/gpu.hpp	/^            float free_coef;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
free_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual void free_node( CvDTreeNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* node )
free_node_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void free_node_data( CvDTreeNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* node )
free_prune_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void free_prune_data(bool cut_tree);$/;"	p	class:CvDTree	access:protected	signature:(bool cut_tree)
free_space	/usr/include/opencv2/core/types_c.h	/^    int free_space;               \/* Remaining free space in current block.   *\/$/;"	m	struct:CvMemStorage	access:public
free_space	/usr/include/opencv2/core/types_c.h	/^    int free_space;$/;"	m	struct:CvMemStoragePos	access:public
free_train_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void free_train_data();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
free_train_test_idx	/usr/include/opencv2/ml/ml.hpp	/^    void free_train_test_idx();$/;"	p	class:CvMLData	access:protected	signature:()
free_tree	/usr/include/opencv2/ml/ml.hpp	/^    virtual void free_tree();$/;"	p	class:CvDTree	access:protected	signature:()
fromUtf16	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS string fromUtf16(const WString& str);$/;"	p	namespace:cv	signature:(const WString& str)
front	/usr/include/opencv2/core/core.hpp	/^    _Tp& front();$/;"	p	class:cv::Seq	access:public	signature:()
front	/usr/include/opencv2/core/core.hpp	/^    const _Tp& front() const;$/;"	p	class:cv::Seq	access:public	signature:() const
front	/usr/include/opencv2/core/operations.hpp	/^    _Tp& front() { CV_DbgAssert(!empty()); return hdr.data[0]; }$/;"	f	class:cv::Vector	access:public	signature:()
front	/usr/include/opencv2/core/operations.hpp	/^    const _Tp& front() const { CV_DbgAssert(!empty()); return hdr.data[0]; }$/;"	f	class:cv::Vector	access:public	signature:() const
front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::front()$/;"	f	class:cv::Seq	signature:()
front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::front() const$/;"	f	class:cv::Seq	signature:() const
fs	/usr/include/opencv2/core/core.hpp	/^    Ptr<CvFileStorage> fs; \/\/!< the underlying C FileStorage structure$/;"	m	class:cv::FileStorage	access:public
fs	/usr/include/opencv2/core/core.hpp	/^    const CvFileStorage* fs;$/;"	m	class:cv::FileNode	access:public
fs	/usr/include/opencv2/core/core.hpp	/^    const CvFileStorage* fs;$/;"	m	class:cv::FileNodeIterator	access:public
fs	/usr/include/opencv2/core/core_c.h	/^CVAPI(void) cvEndWriteStruct( CvFileStorage* fs );$/;"	v
fs	/usr/include/opencv2/core/core_c.h	/^CVAPI(void) cvReleaseFileStorage( CvFileStorage** fs );$/;"	v
fs	/usr/include/opencv2/core/core_c.h	/^CVAPI(void) cvStartNextStream( CvFileStorage* fs );$/;"	v
fs	/usr/include/opencv2/core/operations.hpp	/^    FileStorage* fs;$/;"	m	class:cv::VecWriterProxy	access:public
fs	/usr/include/opencv2/core/operations.hpp	/^    FileStorage* fs;$/;"	m	class:cv::WriteStructContext	access:public
full	/usr/include/opencv2/flann/result_set.h	/^	bool full() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
full	/usr/include/opencv2/flann/result_set.h	/^	bool full() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
full	/usr/include/opencv2/flann/result_set.h	/^	virtual bool full() const = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:() const
fullDP	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW bool fullDP;$/;"	m	class:cv::StereoSGBM	access:public
func	/usr/include/opencv2/contrib/contrib.hpp	/^        void (*func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data );$/;"	m	class:cv::LevMarqSparse	access:protected
func	/usr/include/opencv2/core/core.hpp	/^	string func; \/\/\/< function name. Available only when the compiler supports __func__ macro$/;"	m	class:cv::Exception	access:public
func_addr	/usr/include/opencv2/core/types_c.h	/^    void** func_addr;$/;"	m	struct:CvPluginFuncInfo	access:public
func_names	/usr/include/opencv2/core/types_c.h	/^    const char* func_names;$/;"	m	struct:CvPluginFuncInfo	access:public
func_tab	/usr/include/opencv2/core/types_c.h	/^    CvPluginFuncInfo* func_tab;$/;"	m	struct:CvModuleInfo	access:public
fundMatr	/usr/include/opencv2/legacy/legacy.hpp	/^    float fundMatr[9]; \/* fundamental matrix *\/$/;"	m	struct:CvStereoCamera	access:public
fuzzyController	/usr/include/opencv2/contrib/contrib.hpp	/^        CvFuzzyController fuzzyController;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
fuzzyInput1	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyInput1, *fuzzyInput2;$/;"	m	class:CvFuzzyRule	access:private
fuzzyInput2	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyInput1, *fuzzyInput2;$/;"	m	class:CvFuzzyRule	access:private
fuzzyOutput	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyOutput;$/;"	m	class:CvFuzzyRule	access:private
fuzzyResizer	/usr/include/opencv2/contrib/contrib.hpp	/^        FuzzyResizer *fuzzyResizer;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
g_point	/usr/include/opencv2/video/background_segm.hpp	/^    CvGaussBGPoint*            g_point;    $/;"	m	struct:CvGaussBGModel	access:public
g_values	/usr/include/opencv2/video/background_segm.hpp	/^    CvGaussBGValues* g_values;$/;"	m	struct:CvGaussBGPoint	access:public
gain	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* gain;                \/* Kalman gain matrix (K(k)):$/;"	m	struct:CvKalman	access:public
gain	/usr/include/opencv2/video/tracking.hpp	/^    Mat gain;               \/\/!< Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)$/;"	m	class:cv::KalmanFilter	access:public
gamma	/usr/include/opencv2/contrib/contrib.hpp	/^        float gamma;$/;"	m	class:cv::SpinImageModel	access:public
gamma	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      gamma;  \/\/ for poly\/rbf\/sigmoid$/;"	m	struct:CvSVMParams	access:public
gammaCorrection	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP bool gammaCorrection;$/;"	m	struct:cv::HOGDescriptor	access:public
gamma_correction	/usr/include/opencv2/gpu/gpu.hpp	/^            bool gamma_correction;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
gaussian	/usr/include/opencv2/core/core.hpp	/^	double gaussian(double sigma);$/;"	p	class:cv::RNG	access:public	signature:(double sigma)
gcd	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp gcd(_Tp a, _Tp b)$/;"	f	namespace:cv	signature:(_Tp a, _Tp b)
gemm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void gemm(const Mat& src1, const Mat& src2, double alpha,$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, double alpha, const Mat& src3, double gamma, CV_OUT Mat& dst, int flags=0)
generateRandomTransform	/usr/include/opencv2/features2d/features2d.hpp	/^    void generateRandomTransform(Point2f srcCenter, Point2f dstCenter,$/;"	p	class:cv::PatchGenerator	access:public	signature:(Point2f srcCenter, Point2f dstCenter, CV_OUT Mat& transform, RNG& rng, bool inverse=false) const
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon125
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon126
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon127
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon128
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon129
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon130
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon131
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon134
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon135
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon137
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon140
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon136
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon138
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon139
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon132
generic_type	/usr/include/opencv2/core/core.hpp	/^    enum { generic_type = 1, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
geometricConsistency	/usr/include/opencv2/contrib/contrib.hpp	/^        static float geometricConsistency(const Point3f& pointScene1, const Point3f& normalScene1,$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& pointScene1, const Point3f& normalScene1, const Point3f& pointModel1, const Point3f& normalModel1, const Point3f& pointScene2, const Point3f& normalScene2, const Point3f& pointModel2, const Point3f& normalModel2)
get	/usr/include/opencv2/core/operations.hpp	/^    static const Formatter* get(const char* fmt="");$/;"	p	class:cv::Formatter	access:public	signature:(const char* fmt=)
get	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual double get(int propId);$/;"	p	class:cv::VideoCapture	access:public	signature:(int propId)
getAffineTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Mat getAffineTransform( const Point2f src[], const Point2f dst[] );$/;"	p	namespace:cv	signature:( const Point2f src[], const Point2f dst[] )
getBlockHistogramSize	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t getBlockHistogramSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
getBoxFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getBoxFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1, -1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1, -1))
getCPUTickCount	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS int64 getCPUTickCount();$/;"	p	namespace:cv	signature:()
getCenterOrdering	/usr/include/opencv2/flann/kmeans_index.h	/^	void getCenterOrdering(KMeansNode node, const ELEM_TYPE* q, int* sort_indices)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode node, const ELEM_TYPE* q, int* sort_indices)
getCentre	/usr/include/opencv2/contrib/contrib.hpp	/^    double getCentre();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
getClassCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int getClassCount() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    const FernClassifier& getClassifier() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
getClusterCenters	/usr/include/opencv2/flann/kmeans_index.h	/^    int getClusterCenters(Matrix<DIST_TYPE>& centers)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(Matrix<DIST_TYPE>& centers)
getColumnSumFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getColumnSumFilter( int sumType, int dstType,$/;"	p	namespace:cv	signature:( int sumType, int dstType, int ksize, int anchor=-1, double scale=1)
getColumnSumFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseColumnFilter_GPU> getColumnSumFilter_GPU(int sumType, int dstType, int ksize, int anchor = -1);$/;"	p	namespace:cv::gpu	signature:(int sumType, int dstType, int ksize, int anchor = -1)
getCommonParams	/usr/include/opencv2/features2d/features2d.hpp	/^    CommonParams getCommonParams () const { return commParams; }$/;"	f	class:cv::SIFT	access:public	signature:() const
getCompressionMethod	/usr/include/opencv2/features2d/features2d.hpp	/^    int getCompressionMethod() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getComputeCapability	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void getComputeCapability(int device, int& major, int& minor);$/;"	p	namespace:cv::gpu	signature:(int device, int& major, int& minor)
getConvertElem	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS ConvertData getConvertElem(int fromType, int toType);$/;"	p	namespace:cv	signature:(int fromType, int toType)
getConvertScaleElem	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS ConvertScaleData getConvertScaleElem(int fromType, int toType);$/;"	p	namespace:cv	signature:(int fromType, int toType)
getCounter	/usr/include/opencv2/contrib/contrib.hpp	/^        int64 getCounter() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
getCovs	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP void getCovs(CV_OUT std::vector<cv::Mat>& covs)      const;$/;"	p	class:CvEM	access:public	signature:(CV_OUT std::vector<cv::Mat>& covs) const
getCudaEnabledDeviceCount	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS int getCudaEnabledDeviceCount();$/;"	p	namespace:cv::gpu	signature:()
getData	/usr/include/opencv2/features2d/features2d.hpp	/^inline uchar* getData(IplImage* image)$/;"	f	namespace:cv	signature:(IplImage* image)
getDefaultNewCameraMatrix	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getDefaultNewCameraMatrix( const Mat& cameraMatrix, Size imgsize=Size(),$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix, Size imgsize=Size(), bool centerPrincipalPoint=false )
getDefaultObjectName	/usr/include/opencv2/core/core.hpp	/^    static string getDefaultObjectName(const string& filename);$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename)
getDefaultPeopleDetector	/usr/include/opencv2/gpu/gpu.hpp	/^            static vector<float> getDefaultPeopleDetector();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
getDefaultPeopleDetector	/usr/include/opencv2/objdetect/objdetect.hpp	/^    static vector<float> getDefaultPeopleDetector();$/;"	p	struct:cv::HOGDescriptor	access:public	signature:()
getDerivKernels	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void getDerivKernels( CV_OUT Mat& kx, CV_OUT Mat& ky,$/;"	p	namespace:cv	signature:( CV_OUT Mat& kx, CV_OUT Mat& ky, int dx, int dy, int ksize, bool normalize=false, int ktype=CV_32F )
getDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^        const Mat getDescriptor( int globalDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int globalDescIdx ) const
getDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^        const Mat getDescriptor( int imgIdx, int localDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int imgIdx, int localDescIdx ) const
getDescriptorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    DescriptorParams getDescriptorParams () const { return descriptorParams; }$/;"	f	class:cv::SIFT	access:public	signature:() const
getDescriptorSize	/usr/include/opencv2/contrib/contrib.hpp	/^        size_t getDescriptorSize() const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:() const
getDescriptorSize	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t getDescriptorSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
getDescriptorSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP size_t getDescriptorSize() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
getDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^        const Mat& getDescriptors() const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:() const
getDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    const vector<Mat>& getDescriptors() const;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
getDescriptors	/usr/include/opencv2/gpu/gpu.hpp	/^            void getDescriptors(const GpuMat& img, Size win_stride, GpuMat& descriptors, $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, Size win_stride, GpuMat& descriptors, int descr_format=DESCR_FORMAT_COL_BY_COL)
getDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    const LDetector& getDetector() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
getDetectorParams	/usr/include/opencv2/features2d/features2d.hpp	/^    DetectorParams getDetectorParams () const { return detectorParams; }$/;"	f	class:cv::SIFT	access:public	signature:() const
getDevice	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS int getDevice();$/;"	p	namespace:cv::gpu	signature:()
getDeviceName	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS string getDeviceName(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
getDistanceToBorder	/usr/include/opencv2/flann/kmeans_index.h	/^	float getDistanceToBorder(float* p, float* c, float* q)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(float* p, float* c, float* q)
getDistances	/usr/include/opencv2/flann/result_set.h	/^	virtual float* getDistances() = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:()
getDistances	/usr/include/opencv2/flann/result_set.h	/^    float* getDistances()$/;"	f	class:cvflann::KNNResultSet	access:public	signature:()
getDistances	/usr/include/opencv2/flann/result_set.h	/^    float* getDistances()$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:()
getElemSize	/usr/include/opencv2/core/core.hpp	/^static inline size_t getElemSize(int type) { return CV_ELEM_SIZE(type); }$/;"	f	namespace:cv	signature:(int type)
getExactNeighbors	/usr/include/opencv2/flann/kdtree_index.h	/^	void getExactNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec)
getFeatureType	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual int getFeatureType() const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:() const
getFirstTopLevelNode	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode getFirstTopLevelNode() const;$/;"	p	class:cv::FileStorage	access:public	signature:() const
getFirstTopLevelNode	/usr/include/opencv2/core/operations.hpp	/^inline FileNode FileStorage::getFirstTopLevelNode() const$/;"	f	class:cv::FileStorage	signature:() const
getFloatSignature	/usr/include/opencv2/features2d/features2d.hpp	/^  void getFloatSignature(IplImage *patch, float *sig) const { getSignature(patch, sig); }$/;"	f	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig) const
getGaussianKernel	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getGaussianKernel( int ksize, double sigma, int ktype=CV_64F );$/;"	p	namespace:cv	signature:( int ksize, double sigma, int ktype=CV_64F )
getGpuMemInfo	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void getGpuMemInfo(size_t& free, size_t& total);$/;"	p	namespace:cv::gpu	signature:(size_t& free, size_t& total)
getGridSize	/usr/include/opencv2/contrib/contrib.hpp	/^        Size getGridSize( Size imgsize, Size winStride ) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:( Size imgsize, Size winStride ) const
getImage	/usr/include/opencv2/features2d/features2d.hpp	/^        const Mat& getImage( int imgIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx ) const
getImages	/usr/include/opencv2/features2d/features2d.hpp	/^        const vector<Mat>& getImages() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
getIndex	/usr/include/opencv2/features2d/features2d.hpp	/^  int getIndex(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(uchar* patch_data) const
getIndex	/usr/include/opencv2/flann/flann_base.hpp	/^	NNIndex<T>* getIndex() { return nnIndex; }$/;"	f	class:cvflann::Index	access:public	signature:()
getIndexParameters	/usr/include/opencv2/flann/flann.hpp	/^	const IndexParams* getIndexParameters() { return nnIndex->getParameters(); }$/;"	f	class:cv::flann::Index_	access:public	signature:()
getIndexParameters	/usr/include/opencv2/flann/flann_base.hpp	/^	const IndexParams* getIndexParameters() { return nnIndex->getParameters(); }$/;"	f	class:cvflann::Index	access:public	signature:()
getIndexType	/usr/include/opencv2/flann/autotuned_index.h	/^	flann_algorithm_t getIndexType() const { return algorithm; }$/;"	f	struct:cvflann::AutotunedIndexParams	access:public	signature:() const
getIndexType	/usr/include/opencv2/flann/composite_index.h	/^	flann_algorithm_t getIndexType() const { return algorithm; }$/;"	f	struct:cvflann::CompositeIndexParams	access:public	signature:() const
getIndexType	/usr/include/opencv2/flann/flann_base.hpp	/^	flann_algorithm_t getIndexType() const { return algorithm; }$/;"	f	struct:cvflann::SavedIndexParams	access:public	signature:() const
getIndexType	/usr/include/opencv2/flann/general.h	/^	virtual flann_algorithm_t getIndexType() const = 0;$/;"	p	struct:cvflann::IndexParams	access:public	signature:() const
getIndexType	/usr/include/opencv2/flann/kdtree_index.h	/^	flann_algorithm_t getIndexType() const { return algorithm; }$/;"	f	struct:cvflann::KDTreeIndexParams	access:public	signature:() const
getIndexType	/usr/include/opencv2/flann/kmeans_index.h	/^	flann_algorithm_t getIndexType() const { return KMEANS; }$/;"	f	struct:cvflann::KMeansIndexParams	access:public	signature:() const
getIndexType	/usr/include/opencv2/flann/linear_index.h	/^	flann_algorithm_t getIndexType() const { return algorithm; }$/;"	f	struct:cvflann::LinearIndexParams	access:public	signature:() const
getKernelType	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS int getKernelType(const Mat& kernel, Point anchor);$/;"	p	namespace:cv	signature:(const Mat& kernel, Point anchor)
getKeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^        const KeyPoint& getKeyPoint( int globalPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int globalPointIdx ) const
getKeyPoint	/usr/include/opencv2/features2d/features2d.hpp	/^        const KeyPoint& getKeyPoint( int imgIdx, int localPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx, int localPointIdx ) const
getKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^        const vector<KeyPoint>& getKeypoints( int imgIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx ) const
getKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^        const vector<vector<KeyPoint> >& getKeypoints() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
getLeaf	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int getLeaf(int fidx, const Mat& patch) const;$/;"	p	class:cv::FernClassifier	access:protected	signature:(int fidx, const Mat& patch) const
getLikelihood	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP inline double getLikelihood() const { return log_likelihood;     };$/;"	f	class:CvEM	access:public	signature:() const
getLinearColumnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getLinearColumnFilter(int bufType, int dstType,$/;"	p	namespace:cv	signature:(int bufType, int dstType, const Mat& kernel, int anchor, int symmetryType, double delta=0, int bits=0)
getLinearColumnFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseColumnFilter_GPU> getLinearColumnFilter_GPU(int bufType, int dstType, const Mat& columnKernel, $/;"	p	namespace:cv::gpu	signature:(int bufType, int dstType, const Mat& columnKernel, int anchor = -1)
getLinearFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseFilter> getLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, const Mat& kernel, Point anchor=Point(-1,-1), double delta=0, int bits=0)
getLinearFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getLinearFilter_GPU(int srcType, int dstType, const Mat& kernel, const Size& ksize, $/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& kernel, const Size& ksize, Point anchor = Point(-1, -1))
getLinearRowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getLinearRowFilter(int srcType, int bufType,$/;"	p	namespace:cv	signature:(int srcType, int bufType, const Mat& kernel, int anchor, int symmetryType)
getLinearRowFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseRowFilter_GPU> getLinearRowFilter_GPU(int srcType, int bufType, const Mat& rowKernel, $/;"	p	namespace:cv::gpu	signature:(int srcType, int bufType, const Mat& rowKernel, int anchor = -1)
getLocalIdx	/usr/include/opencv2/features2d/features2d.hpp	/^        void getLocalIdx( int globalDescIdx, int& imgIdx, int& localDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int globalDescIdx, int& imgIdx, int& localDescIdx ) const
getLocalIdx	/usr/include/opencv2/features2d/features2d.hpp	/^        void getLocalIdx( int globalPointIdx, int& imgIdx, int& localPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int globalPointIdx, int& imgIdx, int& localPointIdx ) const
getMaxFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMaxFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1))
getMeans	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP cv::Mat  getMeans()     const;$/;"	p	class:CvEM	access:public	signature:() const
getMesh	/usr/include/opencv2/contrib/contrib.hpp	/^        Mesh3D& getMesh() { return mesh; }$/;"	f	class:cv::SpinImageModel	access:public	signature:()
getMesh	/usr/include/opencv2/contrib/contrib.hpp	/^        const Mesh3D& getMesh() const { return mesh; }$/;"	f	class:cv::SpinImageModel	access:public	signature:() const
getMinFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMinFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1))
getMinVarianceClusters	/usr/include/opencv2/flann/kmeans_index.h	/^	int getMinVarianceClusters(KMeansNode root, KMeansNode* clusters, int clusters_length, float& varianceValue)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNode root, KMeansNode* clusters, int clusters_length, float& varianceValue)
getModelPoints	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<KeyPoint> getModelPoints() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
getModelROI	/usr/include/opencv2/features2d/features2d.hpp	/^    Rect getModelROI() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
getMorphologyColumnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getMorphologyColumnFilter(int op, int type, int ksize, int anchor=-1);$/;"	p	namespace:cv	signature:(int op, int type, int ksize, int anchor=-1)
getMorphologyFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseFilter> getMorphologyFilter(int op, int type, const Mat& kernel,$/;"	p	namespace:cv	signature:(int op, int type, const Mat& kernel, Point anchor=Point(-1,-1))
getMorphologyFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMorphologyFilter_GPU(int op, int type, const Mat& kernel, const Size& ksize, $/;"	p	namespace:cv::gpu	signature:(int op, int type, const Mat& kernel, const Size& ksize, Point anchor=Point(-1,-1))
getMorphologyRowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getMorphologyRowFilter(int op, int type, int ksize, int anchor=-1);$/;"	p	namespace:cv	signature:(int op, int type, int ksize, int anchor=-1)
getMostStable2D	/usr/include/opencv2/features2d/features2d.hpp	/^    void getMostStable2D(const Mat& image, CV_OUT vector<KeyPoint>& keypoints,$/;"	p	class:cv::LDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int maxCount, const PatchGenerator& patchGenerator) const
getNClusters	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP int  getNClusters() const;$/;"	p	class:CvEM	access:public	signature:() const
getNeighbors	/usr/include/opencv2/flann/kdtree_index.h	/^	void getNeighbors(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, int maxCheck)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, int maxCheck)
getNeighbors	/usr/include/opencv2/flann/result_set.h	/^	int* getNeighbors()$/;"	f	class:cvflann::KNNResultSet	access:public	signature:()
getNeighbors	/usr/include/opencv2/flann/result_set.h	/^	int* getNeighbors()$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:()
getNeighbors	/usr/include/opencv2/flann/result_set.h	/^	virtual int* getNeighbors() = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:()
getNodes	/usr/include/opencv2/contrib/contrib.hpp	/^        const vector<Node>& getNodes() const { return nodes; }$/;"	f	class:cv::Octree	access:public	signature:() const
getNumThreads	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS int getNumThreads();$/;"	p	namespace:cv	signature:()
getNumberOfSMs	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS int getNumberOfSMs(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
getOptimalDFTSize	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W int getOptimalDFTSize(int vecsize);$/;"	p	namespace:cv	signature:(int vecsize)
getOptimalNewCameraMatrix	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat getOptimalNewCameraMatrix( const Mat& cameraMatrix, const Mat& distCoeffs,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix, const Mat& distCoeffs, Size imageSize, double alpha, Size newImgSize=Size(), CV_OUT Rect* validPixROI=0)
getOutputCurve	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve *getOutputCurve();$/;"	p	class:CvFuzzyRule	access:public	signature:()
getParameters	/usr/include/opencv2/flann/autotuned_index.h	/^	const IndexParams* getParameters() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
getParameters	/usr/include/opencv2/flann/composite_index.h	/^	const IndexParams* getParameters() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
getParameters	/usr/include/opencv2/flann/kdtree_index.h	/^	const IndexParams* getParameters() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
getParameters	/usr/include/opencv2/flann/kmeans_index.h	/^	const IndexParams* getParameters() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
getParameters	/usr/include/opencv2/flann/linear_index.h	/^	const IndexParams* getParameters() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
getParameters	/usr/include/opencv2/flann/nn_index.h	/^	virtual const IndexParams* getParameters() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
getPatchSize	/usr/include/opencv2/features2d/features2d.hpp	/^    Size getPatchSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getPeopleDetector_48x96	/usr/include/opencv2/gpu/gpu.hpp	/^            static vector<float> getPeopleDetector_48x96();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
getPeopleDetector_64x128	/usr/include/opencv2/gpu/gpu.hpp	/^            static vector<float> getPeopleDetector_64x128();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
getPerspectiveTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Mat getPerspectiveTransform( const Point2f src[], const Point2f dst[] );$/;"	p	namespace:cv	signature:( const Point2f src[], const Point2f dst[] )
getPoint	/usr/include/opencv2/core/core.hpp	/^    const float* getPoint(int ptidx, int* label=0) const;$/;"	p	class:cv::KDTree	access:public	signature:(int ptidx, int* label=0) const
getPoints	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP void getPoints(const vector<int>& idxs, Mat& pts, CV_OUT vector<int>* labels=0) const;$/;"	p	class:cv::KDTree	access:public	signature:(const vector<int>& idxs, Mat& pts, CV_OUT vector<int>* labels=0) const
getPoints	/usr/include/opencv2/core/core.hpp	/^    void getPoints(const int* idx, size_t nidx, Mat& pts, vector<int>* labels=0) const;$/;"	p	class:cv::KDTree	access:public	signature:(const int* idx, size_t nidx, Mat& pts, vector<int>* labels=0) const
getPointsWithinSphere	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void getPointsWithinSphere( const Point3f& center, float radius,$/;"	p	class:cv::Octree	access:public	signature:( const Point3f& center, float radius, vector<Point3f>& points ) const
getPosterior	/usr/include/opencv2/features2d/features2d.hpp	/^  const float* getPosterior(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data) const
getPosterior	/usr/include/opencv2/features2d/features2d.hpp	/^  float* getPosterior(uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data)
getPosterior2	/usr/include/opencv2/features2d/features2d.hpp	/^  const uchar* getPosterior2(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data) const
getPosterior2	/usr/include/opencv2/features2d/features2d.hpp	/^  uchar* getPosterior2(uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data)
getPosteriorByIndex	/usr/include/opencv2/features2d/features2d.hpp	/^  inline const float* getPosteriorByIndex(int index) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index) const
getPosteriorByIndex	/usr/include/opencv2/features2d/features2d.hpp	/^  inline float* getPosteriorByIndex(int index);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index)
getPosteriorByIndex	/usr/include/opencv2/features2d/features2d.hpp	/^inline const float* RandomizedTree::getPosteriorByIndex(int index) const$/;"	f	class:cv::RandomizedTree	signature:(int index) const
getPosteriorByIndex	/usr/include/opencv2/features2d/features2d.hpp	/^inline float* RandomizedTree::getPosteriorByIndex(int index)$/;"	f	class:cv::RandomizedTree	signature:(int index)
getPosteriorByIndex2	/usr/include/opencv2/features2d/features2d.hpp	/^  inline const uchar* getPosteriorByIndex2(int index) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index) const
getPosteriorByIndex2	/usr/include/opencv2/features2d/features2d.hpp	/^  inline uchar* getPosteriorByIndex2(int index);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index)
getPosteriorByIndex2	/usr/include/opencv2/features2d/features2d.hpp	/^inline const uchar* RandomizedTree::getPosteriorByIndex2(int index) const$/;"	f	class:cv::RandomizedTree	signature:(int index) const
getPosteriorByIndex2	/usr/include/opencv2/features2d/features2d.hpp	/^inline uchar* RandomizedTree::getPosteriorByIndex2(int index)$/;"	f	class:cv::RandomizedTree	signature:(int index)
getProbs	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP cv::Mat  getProbs()     const;$/;"	p	class:CvEM	access:public	signature:() const
getRecall	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS float getRecall( const vector<Point2f>& recallPrecisionCurve, float l_precision );$/;"	p	namespace:cv	signature:( const vector<Point2f>& recallPrecisionCurve, float l_precision )
getRectSubPix	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void getRectSubPix( const Mat& image, Size patchSize,$/;"	p	namespace:cv	signature:( const Mat& image, Size patchSize, Point2f center, CV_OUT Mat& patch, int patchType=-1 )
getResizeAttribsEdgeDensityFuzzy	/usr/include/opencv2/contrib/contrib.hpp	/^        void getResizeAttribsEdgeDensityFuzzy(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
getResizeAttribsEdgeDensityLinear	/usr/include/opencv2/contrib/contrib.hpp	/^        void getResizeAttribsEdgeDensityLinear(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
getResizeAttribsInnerDensity	/usr/include/opencv2/contrib/contrib.hpp	/^        void getResizeAttribsInnerDensity(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
getRotationMatrix2D	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getRotationMatrix2D( Point2f center, double angle, double scale );$/;"	p	namespace:cv	signature:( Point2f center, double angle, double scale )
getRowSumFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getRowSumFilter(int srcType, int sumType,$/;"	p	namespace:cv	signature:(int srcType, int sumType, int ksize, int anchor=-1)
getRowSumFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseRowFilter_GPU> getRowSumFilter_GPU(int srcType, int sumType, int ksize, int anchor = -1);$/;"	p	namespace:cv::gpu	signature:(int srcType, int sumType, int ksize, int anchor = -1)
getSeqElem	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS schar*  getSeqElem( const CvSeq* seq, int index );$/;"	p	namespace:cv	signature:( const CvSeq* seq, int index )
getSignature	/usr/include/opencv2/features2d/features2d.hpp	/^  void getSignature(IplImage *patch, float *sig) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig) const
getSignature	/usr/include/opencv2/features2d/features2d.hpp	/^  void getSignature(IplImage *patch, uchar *sig) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, uchar *sig) const
getSignatureSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int getSignatureSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getSparseSignature	/usr/include/opencv2/features2d/features2d.hpp	/^  void getSparseSignature(IplImage *patch, float *sig, float thresh) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig, float thresh) const
getSpinCount	/usr/include/opencv2/contrib/contrib.hpp	/^        size_t getSpinCount() const { return spinImages.rows; }$/;"	f	class:cv::SpinImageModel	access:public	signature:() const
getSpinImage	/usr/include/opencv2/contrib/contrib.hpp	/^        Mat getSpinImage(size_t index) const { return spinImages.row((int)index); }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
getSpinNormal	/usr/include/opencv2/contrib/contrib.hpp	/^        const Point3f& getSpinNormal(size_t index) const { return mesh.normals[subset[index]]; }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
getSpinVertex	/usr/include/opencv2/contrib/contrib.hpp	/^        const Point3f& getSpinVertex(size_t index) const { return mesh.vtx[subset[index]]; }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
getStream	/usr/include/opencv2/gpu/stream_accessor.hpp	/^            CV_EXPORTS static cudaStream_t getStream(const Stream& stream);$/;"	p	struct:cv::gpu::StreamAccessor	access:public	signature:(const Stream& stream)
getStructCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int getStructCount() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getStructSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int getStructSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getStructuringElement	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getStructuringElement(int shape, Size ksize, Point anchor=Point(-1,-1));$/;"	p	namespace:cv	signature:(int shape, Size ksize, Point anchor=Point(-1,-1))
getTextSize	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W Size getTextSize(const string& text, int fontFace,$/;"	p	namespace:cv	signature:(const string& text, int fontFace, double fontScale, int thickness, CV_OUT int* baseLine)
getThreadNum	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS int getThreadNum();$/;"	p	namespace:cv	signature:()
getTickCount	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS int64 getTickCount();$/;"	p	namespace:cv	signature:()
getTickFrequency	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double getTickFrequency();$/;"	p	namespace:cv	signature:()
getTimeMicro	/usr/include/opencv2/contrib/contrib.hpp	/^        double getTimeMicro() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
getTimeMilli	/usr/include/opencv2/contrib/contrib.hpp	/^        double getTimeMilli() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
getTimeSec	/usr/include/opencv2/contrib/contrib.hpp	/^        double getTimeSec()   const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
getTimeTicks	/usr/include/opencv2/contrib/contrib.hpp	/^        int64 getTimeTicks() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
getTrackbarPos	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W int getTrackbarPos( const string& trackbarname, const string& winname );$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname )
getTrainDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    const vector<Mat>& getTrainDescriptors() const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
getTrainImages	/usr/include/opencv2/features2d/features2d.hpp	/^    const vector<Mat>& getTrainImages() const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:() const
getTrainKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^    const vector<vector<KeyPoint> >& getTrainKeypoints() const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:() const
getType	/usr/include/opencv2/flann/autotuned_index.h	/^    virtual flann_algorithm_t getType() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
getType	/usr/include/opencv2/flann/composite_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
getType	/usr/include/opencv2/flann/kdtree_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
getType	/usr/include/opencv2/flann/kmeans_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
getType	/usr/include/opencv2/flann/linear_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
getType	/usr/include/opencv2/flann/nn_index.h	/^	virtual flann_algorithm_t getType() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
getValidDisparityROI	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Rect getValidDisparityROI( Rect roi1, Rect roi2,$/;"	p	namespace:cv	signature:( Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int SADWindowSize )
getValue	/usr/include/opencv2/contrib/contrib.hpp	/^    double getValue();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
getVarImportance	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual cv::Mat getVarImportance();$/;"	p	class:CvDTree	access:public	signature:()
getVarImportance	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual cv::Mat getVarImportance();$/;"	p	class:CvRTrees	access:public	signature:()
getVocabulary	/usr/include/opencv2/features2d/features2d.hpp	/^    const Mat& getVocabulary() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
getWeights	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP cv::Mat  getWeights()   const;$/;"	p	class:CvEM	access:public	signature:() const
getWinSigma	/usr/include/opencv2/gpu/gpu.hpp	/^            double getWinSigma() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
getWinSigma	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP double getWinSigma() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
getWindowProperty	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W double getWindowProperty(const string& winname, int prop_id);\/\/YV$/;"	p	namespace:cv	signature:(const string& winname, int prop_id)
get_active_var_mask	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* get_active_var_mask();$/;"	p	class:CvRTrees	access:public	signature:()
get_active_vars	/usr/include/opencv2/ml/ml.hpp	/^    virtual const CvMat* get_active_vars(bool absolute_idx=true);$/;"	p	class:CvBoost	access:public	signature:(bool absolute_idx=true)
get_back_project	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual IplImage* get_back_project()$/;"	f	class:CvCamShiftTracker	access:public	signature:()
get_cat_var_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_cat_var_data( CvDTreeNode* n, int vi, int* cat_values_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, int* cat_values_buf )
get_cat_var_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_cat_var_data( CvDTreeNode* n, int vi, int* cat_values_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, int* cat_values_buf )
get_center	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f get_center() const \/\/ center of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_child_buf_idx	/usr/include/opencv2/ml/ml.hpp	/^    virtual int get_child_buf_idx( CvDTreeNode* n );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n )
get_class_labels	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_class_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
get_covs	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat** get_covs()      const;$/;"	p	class:CvEM	access:public	signature:() const
get_cv_labels	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_cv_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
get_cv_labels	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_cv_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
get_data	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeTrainData* get_data();$/;"	p	class:CvDTree	access:public	signature:()
get_data	/usr/include/opencv2/ml/ml.hpp	/^    const CvDTreeTrainData* get_data() const;$/;"	p	class:CvBoost	access:public	signature:() const
get_default_grid	/usr/include/opencv2/ml/ml.hpp	/^    static CvParamGrid get_default_grid( int param_id );$/;"	p	class:CvSVM	access:public	signature:( int param_id )
get_delimiter	/usr/include/opencv2/ml/ml.hpp	/^    char get_delimiter() { return delimiter; };$/;"	f	class:CvMLData	access:public	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^PredType get_hdf5_type()$/;"	f	namespace:cvflann::__anon184	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<char>() { return PredType::NATIVE_CHAR; }$/;"	f	namespace:cvflann::__anon184	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<double>() { return PredType::NATIVE_DOUBLE; }$/;"	f	namespace:cvflann::__anon184	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<float>() { return PredType::NATIVE_FLOAT; }$/;"	f	namespace:cvflann::__anon184	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<int>() { return PredType::NATIVE_INT; }$/;"	f	namespace:cvflann::__anon184	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<long double>() { return PredType::NATIVE_LDOUBLE; }$/;"	f	namespace:cvflann::__anon184	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<long>() { return PredType::NATIVE_LONG; }$/;"	f	namespace:cvflann::__anon184	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<short int>() { return PredType::NATIVE_SHORT; }$/;"	f	namespace:cvflann::__anon184	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<unsigned char>() { return PredType::NATIVE_UCHAR; }$/;"	f	namespace:cvflann::__anon184	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<unsigned int>() { return PredType::NATIVE_UINT; }$/;"	f	namespace:cvflann::__anon184	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<unsigned long>() { return PredType::NATIVE_ULONG; }$/;"	f	namespace:cvflann::__anon184	signature:()
get_hdf5_type	/usr/include/opencv2/flann/hdf5.h	/^template<> PredType get_hdf5_type<unsigned short int>() { return PredType::NATIVE_USHORT; }$/;"	f	namespace:cvflann::__anon184	signature:()
get_hist_dims	/usr/include/opencv2/legacy/legacy.hpp	/^    int     get_hist_dims( int* dims = 0 ) const \/\/ returns number of histogram dimensions and sets$/;"	f	class:CvCamShiftTracker	access:public	signature:( int* dims = 0 ) const
get_layer_count	/usr/include/opencv2/ml/ml.hpp	/^    int get_layer_count() { return layer_sizes ? layer_sizes->cols : 0; }$/;"	f	class:CvANN_MLP	access:public	signature:()
get_layer_sizes	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_layer_sizes() { return layer_sizes; }$/;"	f	class:CvANN_MLP	access:public	signature:()
get_length	/usr/include/opencv2/legacy/legacy.hpp	/^    float   get_length() const \/\/ the larger linear size of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_log_likelihood	/usr/include/opencv2/ml/ml.hpp	/^    inline double         get_log_likelihood     () const { return log_likelihood;     };$/;"	f	class:CvEM	access:public	signature:() const
get_max_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    int     get_max_ch_val( int channel ) const \/\/ get the maximum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel ) const
get_max_k	/usr/include/opencv2/ml/ml.hpp	/^    int get_max_k() const;$/;"	p	class:CvKNearest	access:public	signature:() const
get_means	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat*  get_means()     const;$/;"	p	class:CvEM	access:public	signature:() const
get_min_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    int     get_min_ch_val( int channel ) const \/\/ get the minimum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel ) const
get_minor	/usr/include/opencv2/core/core.hpp	/^    template<int m1, int n1> Matx<_Tp, m1, n1> get_minor(int i, int j) const;$/;"	p	class:cv::Matx	access:public	signature:(int i, int j) const
get_minor	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m1, n1> Matx<_Tp, m, n>::get_minor(int i, int j) const$/;"	f	class:cv::Matx	signature:(int i, int j) const
get_miss_ch	/usr/include/opencv2/ml/ml.hpp	/^    char get_miss_ch() { return miss_ch; };$/;"	f	class:CvMLData	access:public	signature:()
get_missing	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_missing(){ return missing; };$/;"	f	class:CvMLData	access:public	signature:()
get_nclusters	/usr/include/opencv2/ml/ml.hpp	/^    int           get_nclusters() const;$/;"	p	class:CvEM	access:public	signature:() const
get_num_classes	/usr/include/opencv2/ml/ml.hpp	/^    int get_num_classes() const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:() const
get_num_valid	/usr/include/opencv2/ml/ml.hpp	/^    int get_num_valid(int vi) { return num_valid ? num_valid[vi] : sample_count; }$/;"	f	struct:CvDTreeNode	access:public	signature:(int vi)
get_ord_responses	/usr/include/opencv2/ml/ml.hpp	/^    virtual const float* get_ord_responses( CvDTreeNode* n, float* values_buf, int* sample_indices_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, float* values_buf, int* sample_indices_buf )
get_ord_var_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void get_ord_var_data( CvDTreeNode* n, int vi, float* ord_values_buf, int* missing_buf,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, float* ord_values_buf, int* missing_buf, const float** ord_values, const int** missing, int* sample_buf = 0 )
get_ord_var_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void get_ord_var_data( CvDTreeNode* n, int vi, float* ord_values_buf, int* sorted_indices_buf,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, float* ord_values_buf, int* sorted_indices_buf, const float** ord_values, const int** sorted_indices, int* sample_indices_buf )
get_orientation	/usr/include/opencv2/legacy/legacy.hpp	/^    float   get_orientation() const \/\/ orientation of the object in degrees$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_params	/usr/include/opencv2/ml/ml.hpp	/^    const CvBoostParams& get_params() const;$/;"	p	class:CvBoost	access:public	signature:() const
get_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvSVMParams get_params() const { return params; };$/;"	f	class:CvSVM	access:public	signature:() const
get_probs	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat*  get_probs()     const;$/;"	p	class:CvEM	access:public	signature:() const
get_proximity	/usr/include/opencv2/ml/ml.hpp	/^    virtual float get_proximity( const CvMat* sample1, const CvMat* sample2,$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample1, const CvMat* sample2, const CvMat* missing1 = 0, const CvMat* missing2 = 0 ) const
get_pruned_tree_idx	/usr/include/opencv2/ml/ml.hpp	/^    int get_pruned_tree_idx() const;$/;"	p	class:CvDTree	access:public	signature:() const
get_response_idx	/usr/include/opencv2/ml/ml.hpp	/^    int get_response_idx() { return response_idx; }$/;"	f	class:CvMLData	access:public	signature:()
get_responses	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_responses();$/;"	p	class:CvMLData	access:public	signature:()
get_rng	/usr/include/opencv2/ml/ml.hpp	/^    CvRNG* get_rng();$/;"	p	class:CvRTrees	access:public	signature:()
get_root	/usr/include/opencv2/ml/ml.hpp	/^    const CvDTreeNode* get_root() const;$/;"	p	class:CvDTree	access:public	signature:() const
get_row	/usr/include/opencv2/ml/ml.hpp	/^    virtual float* get_row( int i, float* dst );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* dst )
get_row_base	/usr/include/opencv2/ml/ml.hpp	/^    virtual float* get_row_base( int i, bool* _existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, bool* _existed )
get_row_func	/usr/include/opencv2/ml/ml.hpp	/^    GetRow get_row_func;$/;"	m	class:CvSVMSolver	access:public
get_row_one_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual float* get_row_one_class( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
get_row_svc	/usr/include/opencv2/ml/ml.hpp	/^    virtual float* get_row_svc( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
get_row_svr	/usr/include/opencv2/ml/ml.hpp	/^    virtual float* get_row_svr( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
get_sample_count	/usr/include/opencv2/ml/ml.hpp	/^    int get_sample_count() const;$/;"	p	class:CvKNearest	access:public	signature:() const
get_sample_indices	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_sample_indices( CvDTreeNode* n, int* indices_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* indices_buf )
get_sample_indices	/usr/include/opencv2/ml/ml.hpp	/^    virtual const int* get_sample_indices( CvDTreeNode* n, int* indices_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int* indices_buf )
get_subtree_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* get_subtree_weights();$/;"	p	class:CvBoost	access:public	signature:()
get_support_vector	/usr/include/opencv2/ml/ml.hpp	/^    virtual const float* get_support_vector(int i) const;$/;"	p	class:CvSVM	access:public	signature:(int i) const
get_support_vector_count	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual int get_support_vector_count() const;$/;"	p	class:CvSVM	access:public	signature:() const
get_test_sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_test_sample_idx() { return test_sample_idx; };$/;"	f	class:CvMLData	access:public	signature:()
get_threshold	/usr/include/opencv2/legacy/legacy.hpp	/^    int     get_threshold() const \/\/ thresholding value that applied to back project$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_train_error	/usr/include/opencv2/ml/ml.hpp	/^    virtual float get_train_error();    $/;"	p	class:CvRTrees	access:public	signature:()
get_train_sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_train_sample_idx() { return train_sample_idx; };$/;"	f	class:CvMLData	access:public	signature:()
get_tree	/usr/include/opencv2/ml/ml.hpp	/^    CvForestTree* get_tree(int i) const;$/;"	p	class:CvRTrees	access:public	signature:(int i) const
get_tree_count	/usr/include/opencv2/ml/ml.hpp	/^    int get_tree_count() const;$/;"	p	class:CvRTrees	access:public	signature:() const
get_values	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_values(){ return values; };$/;"	f	class:CvMLData	access:public	signature:()
get_var_count	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP int get_var_count() const { return var_idx ? var_idx->cols : var_all; }$/;"	f	class:CvSVM	access:public	signature:() const
get_var_count	/usr/include/opencv2/ml/ml.hpp	/^    int get_var_count() const;$/;"	p	class:CvKNearest	access:public	signature:() const
get_var_count	/usr/include/opencv2/ml/ml.hpp	/^    virtual int get_var_count() const {return data ? data->var_count : 0;}$/;"	f	class:CvForestTree	access:public	signature:() const
get_var_idx	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_var_idx();$/;"	p	class:CvMLData	access:public	signature:()
get_var_importance	/usr/include/opencv2/ml/ml.hpp	/^    virtual const CvMat* get_var_importance();$/;"	p	class:CvDTree	access:public	signature:()
get_var_importance	/usr/include/opencv2/ml/ml.hpp	/^    virtual const CvMat* get_var_importance();$/;"	p	class:CvRTrees	access:public	signature:()
get_var_type	/usr/include/opencv2/ml/ml.hpp	/^    int get_var_type( int var_idx ) { return var_types->data.ptr[var_idx]; };$/;"	f	class:CvMLData	access:public	signature:( int var_idx )
get_var_type	/usr/include/opencv2/ml/ml.hpp	/^    int get_var_type(int vi) const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:(int vi) const
get_var_types	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* get_var_types();$/;"	p	class:CvMLData	access:public	signature:()
get_vectors	/usr/include/opencv2/ml/ml.hpp	/^    virtual void get_vectors( const CvMat* _subsample_idx, float* values, uchar* missing,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* _subsample_idx, float* values, uchar* missing, float* responses, bool get_class_idx=false )
get_vectors	/usr/include/opencv2/ml/ml.hpp	/^    virtual void get_vectors( const CvMat* _subsample_idx,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* _subsample_idx, float* values, uchar* missing, float* responses, bool get_class_idx=false )
get_weak_predictors	/usr/include/opencv2/ml/ml.hpp	/^    CvSeq* get_weak_predictors();$/;"	p	class:CvBoost	access:public	signature:()
get_weak_response	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* get_weak_response();$/;"	p	class:CvBoost	access:public	signature:()
get_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* get_weights();$/;"	p	class:CvBoost	access:public	signature:()
get_weights	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat*  get_weights()   const;$/;"	p	class:CvEM	access:public	signature:() const
get_weights	/usr/include/opencv2/ml/ml.hpp	/^    double* get_weights(int layer)$/;"	f	class:CvANN_MLP	access:public	signature:(int layer)
get_width	/usr/include/opencv2/legacy/legacy.hpp	/^    float   get_width() const \/\/ the smaller linear size of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_window	/usr/include/opencv2/legacy/legacy.hpp	/^    CvRect get_window() const \/\/ bounding rectangle for the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_work_var_count	/usr/include/opencv2/ml/ml.hpp	/^    int get_work_var_count() const {return work_var_count;}$/;"	f	struct:CvDTreeTrainData	access:public	signature:() const
good	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual bool good() const = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:() const
good	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual bool good() const;$/;"	p	class:cv::FastAdjuster	access:public	signature:() const
good	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual bool good() const;$/;"	p	class:cv::StarAdjuster	access:public	signature:() const
good	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual bool good() const;$/;"	p	class:cv::SurfAdjuster	access:public	signature:() const
goodFeaturesToTrack	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void goodFeaturesToTrack( const Mat& image, CV_OUT vector<Point2f>& corners,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT vector<Point2f>& corners, int maxCorners, double qualityLevel, double minDistance, const Mat& mask=Mat(), int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
gpu	/usr/include/opencv2/gpu/devmem2d.hpp	/^    namespace gpu$/;"	n	namespace:cv
gpu	/usr/include/opencv2/gpu/gpu.hpp	/^    namespace gpu$/;"	n	namespace:cv
gpu	/usr/include/opencv2/gpu/matrix_operations.hpp	/^namespace gpu$/;"	n	namespace:cv
gpu	/usr/include/opencv2/gpu/stream_accessor.hpp	/^    namespace gpu$/;"	n	namespace:cv
grab	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool grab();$/;"	p	class:cv::VideoCapture	access:public	signature:()
grabCut	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void grabCut( const Mat& img, Mat& mask, Rect rect, $/;"	p	namespace:cv	signature:( const Mat& img, Mat& mask, Rect rect, Mat& bgdModel, Mat& fgdModel, int iterCount, int mode = GC_EVAL )
grad	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat grad, qangle;            $/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
graph	/usr/include/opencv2/core/core_c.h	/^    CvGraph* graph;        \/* the graph *\/$/;"	m	struct:CvGraphScanner	access:public
graph	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvClearGraph( CvGraph* graph );$/;"	v
graph	/usr/include/opencv2/legacy/legacy.hpp	/^    CvGraph* graph;$/;"	m	struct:CvCliqueFinder	access:public
graphcut	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void graphcut(GpuMat& terminals, GpuMat& leftTransp, GpuMat& rightTransp, GpuMat& top, GpuMat& bottom, GpuMat& labels, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(GpuMat& terminals, GpuMat& leftTransp, GpuMat& rightTransp, GpuMat& top, GpuMat& bottom, GpuMat& labels, GpuMat& buf)
grayImg	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat*  grayImg;$/;"	m	class:CvCalibFilter	access:protected
greek	/usr/include/opencv2/core/core_c.h	/^    const int*  greek;$/;"	m	struct:CvFont	access:public
gridCols	/usr/include/opencv2/features2d/features2d.hpp	/^    int gridCols;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
gridRows	/usr/include/opencv2/features2d/features2d.hpp	/^    int gridRows;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
groupRectangles	/usr/include/opencv2/objdetect/objdetect.hpp	/^CV_EXPORTS_W void groupRectangles(vector<Rect>& rectList, CV_OUT vector<int>& weights, int groupThreshold, double eps=0.2);$/;"	p	namespace:cv	signature:(vector<Rect>& rectList, CV_OUT vector<int>& weights, int groupThreshold, double eps=0.2)
groupRectangles	/usr/include/opencv2/objdetect/objdetect.hpp	/^CV_EXPORTS_W void groupRectangles(vector<Rect>& rectList, int groupThreshold, double eps=0.2);$/;"	p	namespace:cv	signature:(vector<Rect>& rectList, int groupThreshold, double eps=0.2)
groupingCreteria	/usr/include/opencv2/contrib/contrib.hpp	/^        static float groupingCreteria(const Point3f& pointScene1, const Point3f& normalScene1,$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& pointScene1, const Point3f& normalScene1, const Point3f& pointModel1, const Point3f& normalModel1, const Point3f& pointScene2, const Point3f& normalScene2, const Point3f& pointModel2, const Point3f& normalModel2, float gamma)
grow_forest	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool grow_forest( const CvTermCriteria term_crit );$/;"	p	class:CvERTrees	access:protected	signature:( const CvTermCriteria term_crit )
grow_forest	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool grow_forest( const CvTermCriteria term_crit );$/;"	p	class:CvRTrees	access:protected	signature:( const CvTermCriteria term_crit )
gt_matches	/usr/include/opencv2/flann/autotuned_index.h	/^    Matrix<int> gt_matches;$/;"	m	class:cvflann::AutotunedIndex	access:private
h	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float   w,h; \/* blob sizes      *\/$/;"	m	struct:CvBlob	access:public
h1	/usr/include/opencv2/imgproc/imgproc.hpp	/^  int h1, h2;$/;"	m	struct:lsh_hash	access:public
h2	/usr/include/opencv2/imgproc/imgproc.hpp	/^  int h1, h2;$/;"	m	struct:lsh_hash	access:public
hX	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* hX; \/\/current measurement extimation given new parameter vector$/;"	m	class:cv::LevMarqSparse	access:protected
haar_feature	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvHaarFeature* haar_feature;$/;"	m	struct:CvHaarClassifier	access:public
hasAtomicsSupport	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS bool hasAtomicsSupport(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
hasNativeDoubleSupport	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS bool hasNativeDoubleSupport(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
hash	/usr/include/opencv2/core/core.hpp	/^    size_t hash(const int* idx) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx) const
hash	/usr/include/opencv2/core/core.hpp	/^    size_t hash(int i0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0) const
hash	/usr/include/opencv2/core/core.hpp	/^    size_t hash(int i0, int i1) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1) const
hash	/usr/include/opencv2/core/core.hpp	/^    size_t hash(int i0, int i1, int i2) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2) const
hash	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::hash(const int* idx) const$/;"	f	class:cv::SparseMat	signature:(const int* idx) const
hash	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::hash(int i0) const$/;"	f	class:cv::SparseMat	signature:(int i0) const
hash	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::hash(int i0, int i1) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1) const
hash	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::hash(int i0, int i1, int i2) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2) const
hash_insert	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual void hash_insert(lsh_hash h, int l, int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int i)
hash_lookup	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual int hash_lookup(lsh_hash h, int l, int* ret_i, int ret_i_max) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int* ret_i, int ret_i_max)
hash_remove	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual void hash_remove(lsh_hash h, int l, int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int i)
hashidx	/usr/include/opencv2/core/core.hpp	/^    size_t hashidx;$/;"	m	class:cv::SparseMatConstIterator	access:public
hashsize	/usr/include/opencv2/core/types_c.h	/^    int hashsize;$/;"	m	struct:CvSparseMat	access:public
hashtab	/usr/include/opencv2/core/core.hpp	/^        vector<size_t> hashtab;$/;"	m	struct:cv::SparseMat::Hdr	access:public
hashtable	/usr/include/opencv2/core/types_c.h	/^    void** hashtable;$/;"	m	struct:CvSparseMat	access:public
hashval	/usr/include/opencv2/core/core.hpp	/^        size_t hashval;$/;"	m	struct:cv::SparseMat::Node	access:public
hashval	/usr/include/opencv2/core/types_c.h	/^    unsigned hashval;$/;"	m	struct:CvSparseNode	access:public
hashval	/usr/include/opencv2/core/types_c.h	/^    unsigned hashval;$/;"	m	struct:CvStringHashNode	access:public
have_active_cat_vars	/usr/include/opencv2/ml/ml.hpp	/^    bool have_active_cat_vars;$/;"	m	class:CvBoost	access:protected
have_labels	/usr/include/opencv2/ml/ml.hpp	/^    bool have_labels, have_priors;$/;"	m	struct:CvDTreeTrainData	access:public
have_priors	/usr/include/opencv2/ml/ml.hpp	/^    bool have_labels, have_priors;$/;"	m	struct:CvDTreeTrainData	access:public
have_subsample	/usr/include/opencv2/ml/ml.hpp	/^    bool have_subsample;$/;"	m	class:CvBoost	access:protected
hconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void hconcat(const Mat& src1, const Mat& src2, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, Mat& dst)
hconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void hconcat(const Mat* src, size_t nsrc, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrc, Mat& dst)
hconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void hconcat(const vector<Mat>& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const vector<Mat>& src, CV_OUT Mat& dst)
hdr	/usr/include/opencv2/core/core.hpp	/^    Hdr* hdr;$/;"	m	class:cv::SparseMat	access:public
hdr	/usr/include/opencv2/core/core_c.h	/^    CvMatND* hdr[CV_MAX_ARR]; \/* pointers to the headers of the$/;"	m	struct:CvNArrayIterator	access:public
hdr	/usr/include/opencv2/core/operations.hpp	/^    Hdr hdr;$/;"	m	class:cv::Vector	access:protected
hdr_refcount	/usr/include/opencv2/core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvMat	access:public
hdr_refcount	/usr/include/opencv2/core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvMatND	access:public
hdr_refcount	/usr/include/opencv2/core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvSparseMat	access:public
header_	/usr/include/opencv2/core/wimage.hpp	/^    IplImage header_;$/;"	m	class:cv::WImageView	access:protected
header_	/usr/include/opencv2/core/wimage.hpp	/^    IplImage header_;$/;"	m	class:cv::WImageViewC	access:protected
header_size	/usr/include/opencv2/core/types_c.h	/^    int header_size;$/;"	m	struct:CvTypeInfo	access:public
heap	/usr/include/opencv2/core/types_c.h	/^    struct CvSet* heap;$/;"	m	struct:CvSparseMat	typeref:struct:CvSparseMat::CvSet	access:public
heap	/usr/include/opencv2/flann/heap.h	/^	T* heap;$/;"	m	class:cvflann::Heap	access:private
heapify	/usr/include/opencv2/flann/heap.h	/^	void heapify(int parent)$/;"	f	class:cvflann::Heap	access:public	signature:(int parent)
height	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
height	/usr/include/opencv2/core/core.hpp	/^    _Tp width, height; \/\/ the width and the height$/;"	m	class:cv::Size_	access:public
height	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
height	/usr/include/opencv2/core/types_c.h	/^        int height;$/;"	m	union:CvMat::__anon95	access:public
height	/usr/include/opencv2/core/types_c.h	/^    float height;$/;"	m	struct:CvSize2D32f	access:public
height	/usr/include/opencv2/core/types_c.h	/^    int  height;            \/* Image height in pixels.                          *\/$/;"	m	struct:_IplImage	access:public
height	/usr/include/opencv2/core/types_c.h	/^    int  height;$/;"	m	struct:_IplROI	access:public
height	/usr/include/opencv2/core/types_c.h	/^    int height;$/;"	m	struct:CvRect	access:public
height	/usr/include/opencv2/core/types_c.h	/^    int height;$/;"	m	struct:__anon99	access:public
height	/usr/include/opencv2/legacy/compat.hpp	/^    int     height;                 \/* height of the image  ( in pixels )               *\/$/;"	m	struct:_CvPixelPosition8u	access:public
height	/usr/include/opencv2/legacy/compat.hpp	/^    int     height;$/;"	m	struct:_CvPixelPosition32f	access:public
height	/usr/include/opencv2/legacy/compat.hpp	/^    int     height;$/;"	m	struct:_CvPixelPosition8s	access:public
height	/usr/include/opencv2/legacy/legacy.hpp	/^    int height() const { return image ? image->height : 0; }$/;"	f	class:CvImage	access:public	signature:() const
hellinger_dist	/usr/include/opencv2/flann/dist.h	/^double hellinger_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
hessian	/usr/include/opencv2/features2d/features2d.hpp	/^    float hessian;$/;"	m	struct:CvSURFPoint	access:public
hessianThreshold	/usr/include/opencv2/features2d/features2d.hpp	/^    double hessianThreshold;$/;"	m	struct:CvSURFParams	access:public
hid_cascade	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvHidHaarClassifierCascade* hid_cascade;$/;"	m	struct:CvHaarClassifierCascade	access:public
hierarchicalClustering	/usr/include/opencv2/flann/flann.hpp	/^int hierarchicalClustering(const Mat& features, Mat& centers, const KMeansIndexParams& params)$/;"	f	namespace:cv::flann	signature:(const Mat& features, Mat& centers, const KMeansIndexParams& params)
hierarchicalClustering	/usr/include/opencv2/flann/flann_base.hpp	/^int hierarchicalClustering(const Matrix<ELEM_TYPE>& features, Matrix<DIST_TYPE>& centers, const KMeansIndexParams& params)$/;"	f	namespace:cvflann	signature:(const Matrix<ELEM_TYPE>& features, Matrix<DIST_TYPE>& centers, const KMeansIndexParams& params)
hist	/usr/include/opencv2/imgproc/imgproc_c.h	/^CVAPI(void)  cvClearHist( CvHistogram* hist );$/;"	v
hist	/usr/include/opencv2/imgproc/imgproc_c.h	/^CVAPI(void)  cvReleaseHist( CvHistogram** hist );$/;"	v
histEven	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat hist[4], int histSize[4], int lowerLevel[4], int upperLevel[4]);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], int histSize[4], int lowerLevel[4], int upperLevel[4])
histEven	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat& hist, int histSize, int lowerLevel, int upperLevel);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, int histSize, int lowerLevel, int upperLevel)
histRange	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4]);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4])
histRange	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat& hist, const GpuMat& levels);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, const GpuMat& levels)
hist_intersection_dist_sq	/usr/include/opencv2/flann/dist.h	/^double hist_intersection_dist_sq(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
hist_intersection_kernel	/usr/include/opencv2/flann/dist.h	/^double hist_intersection_kernel(Iterator1 first1, Iterator1 last1, Iterator2 first2)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2)
histogramHueMotion	/usr/include/opencv2/contrib/contrib.hpp	/^    Histogram histogramHueMotion, skinHueHistogram;$/;"	m	class:CvAdaptiveSkinDetector	access:private
histogramNormType	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP int histogramNormType;$/;"	m	struct:cv::HOGDescriptor	access:public
history	/usr/include/opencv2/video/background_segm.hpp	/^    int history;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
hmm	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(void)  cvRelease2DHMM( CvEHMM** hmm );$/;"	v
horizontalEdgeBottom	/usr/include/opencv2/contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
horizontalEdgeTop	/usr/include/opencv2/contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
hscale	/usr/include/opencv2/core/core_c.h	/^    float       hscale, vscale;$/;"	m	struct:CvFont	access:public
hu1	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu2	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu3	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu4	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu5	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu6	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu7	/usr/include/opencv2/imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
i	/usr/include/opencv2/core/types_c.h	/^        int i;    \/* scalar integer number *\/$/;"	m	union:CvFileNode::__anon100	access:public
i	/usr/include/opencv2/core/types_c.h	/^        int* i;$/;"	m	union:CvMat::__anon94	access:public
i	/usr/include/opencv2/core/types_c.h	/^        int* i;$/;"	m	union:CvMatND::__anon97	access:public
i	/usr/include/opencv2/core/types_c.h	/^    int i;$/;"	m	union:Cv32suf	access:public
i	/usr/include/opencv2/core/types_c.h	/^    int64 i;$/;"	m	union:Cv64suf	access:public
i	/usr/include/opencv2/ml/ml.hpp	/^    int* i;$/;"	m	struct:CvPair16u32s	access:public
iInput	/usr/include/opencv2/contrib/contrib.hpp	/^        CvFuzzyFunction iInput, iOutput;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
iOutput	/usr/include/opencv2/contrib/contrib.hpp	/^        CvFuzzyFunction iInput, iOutput;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
icvSqDist2D32f	/usr/include/opencv2/legacy/legacy.hpp	/^CV_INLINE double icvSqDist2D32f( CvPoint2D32f pt1, CvPoint2D32f pt2 )$/;"	f	signature:( CvPoint2D32f pt1, CvPoint2D32f pt2 )
id	/usr/include/opencv2/legacy/legacy.hpp	/^    int id;$/;"	m	struct:__anon173	access:public
id	/usr/include/opencv2/legacy/legacy.hpp	/^    int id;$/;"	m	struct:__anon174	access:public
idct	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void idct(const Mat& src, CV_OUT Mat& dst, int flags=0);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags=0)
idft	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void idft(const Mat& src, CV_OUT Mat& dst, int flags=0, int nonzeroRows=0);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags=0, int nonzeroRows=0)
idx	/usr/include/opencv2/core/core.hpp	/^        int idx;$/;"	m	struct:cv::KDTree::Node	access:public
idx	/usr/include/opencv2/core/core.hpp	/^        int idx[CV_MAX_DIM];$/;"	m	struct:cv::SparseMat::Node	access:public
idx	/usr/include/opencv2/core/core.hpp	/^    int idx;$/;"	m	class:cv::MatxCommaInitializer	access:public
idx	/usr/include/opencv2/core/core.hpp	/^    int iterdepth, idx;$/;"	m	class:cv::NAryMatIterator	access:protected
idxoffset	/usr/include/opencv2/core/types_c.h	/^    int idxoffset;$/;"	m	struct:CvSparseMat	access:public
im	/usr/include/opencv2/core/core.hpp	/^    _Tp re, im; \/\/< the real and the imaginary parts$/;"	m	class:cv::Complex	access:public
image	/usr/include/opencv2/core/core_c.h	/^CVAPI(CvRect) cvGetImageROI( const IplImage* image );$/;"	v
image	/usr/include/opencv2/core/core_c.h	/^CVAPI(IplImage*) cvCloneImage( const IplImage* image );$/;"	v
image	/usr/include/opencv2/core/core_c.h	/^CVAPI(int)  cvGetImageCOI( const IplImage* image );$/;"	v
image	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvReleaseImage( IplImage** image );$/;"	v
image	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvReleaseImageHeader( IplImage** image );$/;"	v
image	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvResetImageROI( IplImage* image );$/;"	v
image	/usr/include/opencv2/features2d/features2d.hpp	/^  IplImage* image;$/;"	m	struct:cv::BaseKeypoint	access:public
image	/usr/include/opencv2/legacy/legacy.hpp	/^    IplImage* image;$/;"	m	class:CvImage	access:protected
imageCount	/usr/include/opencv2/features2d/features2d.hpp	/^        size_t imageCount() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
imageData	/usr/include/opencv2/core/types_c.h	/^    char *imageData;        \/* Pointer to aligned image data.         *\/$/;"	m	struct:_IplImage	access:public
imageDataOrigin	/usr/include/opencv2/core/types_c.h	/^    char *imageDataOrigin;  \/* Pointer to very origin of image data$/;"	m	struct:_IplImage	access:public
imageId	/usr/include/opencv2/core/types_c.h	/^    void  *imageId;                 \/* "           " *\/$/;"	m	struct:_IplImage	access:public
imageSize	/usr/include/opencv2/core/types_c.h	/^    int  imageSize;         \/* Image data size in bytes$/;"	m	struct:_IplImage	access:public
imageWidth	/usr/include/opencv2/contrib/contrib.hpp	/^        int imageWidth;$/;"	m	class:cv::SpinImageModel	access:public
image_	/usr/include/opencv2/core/wimage.hpp	/^    IplImage* image_;$/;"	m	class:cv::WImage	access:protected
images	/usr/include/opencv2/features2d/features2d.hpp	/^        vector<Mat> images;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
imax	/usr/include/opencv2/legacy/legacy.hpp	/^    int imax, imin;$/;"	m	struct:CvContourOrientation	access:public
imdecode	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W Mat imdecode( const Mat& buf, int flags );$/;"	p	namespace:cv	signature:( const Mat& buf, int flags )
imencode	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W bool imencode( const string& ext, const Mat& img,$/;"	p	namespace:cv	signature:( const string& ext, const Mat& img, CV_OUT vector<uchar>& buf, const vector<int>& params=vector<int>())
img	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(void)  cvDeleteMoire( IplImage*  img );$/;"	v
imgFilteredFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgGrayFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgHSVFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgHueFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgIdx	/usr/include/opencv2/features2d/features2d.hpp	/^    int imgIdx;   \/\/ train image index$/;"	m	struct:cv::DMatch	access:public
imgLastGrayFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgMotionFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgSaturationFrame	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgShrinked	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgSize	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSize  imgSize;$/;"	m	class:CvCalibFilter	access:protected
imgSize	/usr/include/opencv2/legacy/legacy.hpp	/^    float   imgSize[2]; \/* size of the camera view, used during calibration *\/$/;"	m	struct:CvCamera	access:public
imgTemp	/usr/include/opencv2/contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imin	/usr/include/opencv2/legacy/legacy.hpp	/^    int imax, imin;$/;"	m	struct:CvContourOrientation	access:public
impl	/usr/include/opencv2/gpu/gpu.hpp	/^            Impl *impl;$/;"	m	class:cv::gpu::Stream	access:private
impl	/usr/include/opencv2/legacy/blobtrack.hpp	/^    class CvObjectDetectorImpl* impl;$/;"	m	class:CvObjectDetector	typeref:class:CvObjectDetector::CvObjectDetectorImpl	access:protected
imread	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W Mat imread( const string& filename, int flags=1 );$/;"	p	namespace:cv	signature:( const string& filename, int flags=1 )
imshow	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W void imshow( const string& winname, const Mat& mat );$/;"	p	namespace:cv	signature:( const string& winname, const Mat& mat )
imwrite	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W bool imwrite( const string& filename, const Mat& img,$/;"	p	namespace:cv	signature:( const string& filename, const Mat& img, const vector<int>& params=vector<int>())
inRange	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void inRange(const Mat& src, const Mat& lowerb,$/;"	p	namespace:cv	signature:(const Mat& src, const Mat& lowerb, const Mat& upperb, CV_OUT Mat& dst)
inRange	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void inRange(const Mat& src, const Scalar& lowerb,$/;"	p	namespace:cv	signature:(const Mat& src, const Scalar& lowerb, const Scalar& upperb, CV_OUT Mat& dst)
index	/usr/include/opencv2/core/core.hpp	/^    int index;$/;"	m	class:cv::SeqIterator	access:public
index	/usr/include/opencv2/core/core.hpp	/^    size_t index(const _Tp& elem) const;$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem) const
index	/usr/include/opencv2/core/core_c.h	/^    int      index;        \/* the lower bound of certainly visited vertices *\/$/;"	m	struct:CvGraphScanner	access:public
index	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::index(const _Tp& elem) const$/;"	f	class:cv::Seq	signature:(const _Tp& elem) const
index	/usr/include/opencv2/flann/result_set.h	/^		int index;$/;"	m	struct:cvflann::RadiusResultSet::Item	access:public
index1	/usr/include/opencv2/legacy/legacy.hpp	/^    int index1;$/;"	m	struct:CvLCMEdge	access:public
index2	/usr/include/opencv2/legacy/legacy.hpp	/^    int index2;$/;"	m	struct:CvLCMEdge	access:public
indexParams	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<flann::IndexParams> indexParams;$/;"	m	class:cv::FlannBasedMatcher	access:protected
index_params	/usr/include/opencv2/flann/autotuned_index.h	/^    const AutotunedIndexParams& index_params;$/;"	m	class:cvflann::AutotunedIndex	access:private
index_params	/usr/include/opencv2/flann/composite_index.h	/^    const IndexParams& index_params;$/;"	m	class:cvflann::CompositeIndex	access:private
index_params	/usr/include/opencv2/flann/kdtree_index.h	/^    const IndexParams& index_params;$/;"	m	class:cvflann::KDTreeIndex	access:private
index_params	/usr/include/opencv2/flann/kmeans_index.h	/^    const IndexParams& index_params;$/;"	m	class:cvflann::KMeansIndex	access:private
index_params	/usr/include/opencv2/flann/linear_index.h	/^	const LinearIndexParams& index_params;$/;"	m	class:cvflann::LinearIndex	access:private
index_type	/usr/include/opencv2/flann/saving.h	/^	flann_algorithm_t index_type;$/;"	m	struct:cvflann::IndexHeader	access:public
indices	/usr/include/opencv2/flann/kmeans_index.h	/^		int* indices;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
indices	/usr/include/opencv2/flann/kmeans_index.h	/^	int* indices;$/;"	m	class:cvflann::KMeansIndex	access:private
indices	/usr/include/opencv2/flann/result_set.h	/^	int* indices;$/;"	m	class:cvflann::KNNResultSet	access:private
indices	/usr/include/opencv2/flann/result_set.h	/^	int* indices;$/;"	m	class:cvflann::RadiusResultSet	access:private
info	/usr/include/opencv2/core/core_c.h	/^    CvModuleInfo* info;$/;"	m	struct:CvModule	access:public
info	/usr/include/opencv2/core/core_c.h	/^    CvTypeInfo* info;$/;"	m	struct:CvType	access:public
info	/usr/include/opencv2/core/core_c.h	/^CVAPI(void) cvRegisterType( const CvTypeInfo* info );$/;"	v
info	/usr/include/opencv2/core/types_c.h	/^    struct CvTypeInfo* info; \/* type information$/;"	m	struct:CvFileNode	typeref:struct:CvFileNode::CvTypeInfo	access:public
info	/usr/include/opencv2/flann/logger.h	/^    int info(const char* fmt, ...);$/;"	p	class:cvflann::Logger	access:public	signature:(const char* fmt, ...)
init	/usr/include/opencv2/calib3d/calib3d.hpp	/^    void init( int nparams, int nerrs, CvTermCriteria criteria=$/;"	p	class:CvLevMarq	access:public	signature:( int nparams, int nerrs, CvTermCriteria criteria= cvTermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,30,DBL_EPSILON), bool completeSymmFlag=false )
init	/usr/include/opencv2/calib3d/calib3d.hpp	/^    void init(int preset, int ndisparities=0, int SADWindowSize=21);$/;"	p	class:cv::StereoBM	access:public	signature:(int preset, int ndisparities=0, int SADWindowSize=21)
init	/usr/include/opencv2/core/core.hpp	/^    void init(const Mat** arrays, Mat* planes, int narrays=-1);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(const Mat** arrays, Mat* planes, int narrays=-1)
init	/usr/include/opencv2/features2d/features2d.hpp	/^  void init(int classes, int depth, RNG &rng);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int classes, int depth, RNG &rng)
init	/usr/include/opencv2/flann/random.h	/^	void init(int n)$/;"	f	class:cvflann::UniqueRandom	access:public	signature:(int n)
init	/usr/include/opencv2/flann/result_set.h	/^	virtual void init(const ELEM_TYPE* target_, int veclen_) = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:(const ELEM_TYPE* target_, int veclen_)
init	/usr/include/opencv2/flann/result_set.h	/^	void init(const ELEM_TYPE* target_, int veclen_)$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(const ELEM_TYPE* target_, int veclen_)
init	/usr/include/opencv2/flann/result_set.h	/^	void init(const ELEM_TYPE* target_, int veclen_)$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:(const ELEM_TYPE* target_, int veclen_)
init	/usr/include/opencv2/imgproc/imgproc.hpp	/^    void init(const Ptr<BaseFilter>& _filter2D,$/;"	p	class:cv::FilterEngine	access:public	signature:(const Ptr<BaseFilter>& _filter2D, const Ptr<BaseRowFilter>& _rowFilter, const Ptr<BaseColumnFilter>& _columnFilter, int srcType, int dstType, int bufType, int _rowBorderType=BORDER_REPLICATE, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
init	/usr/include/opencv2/video/tracking.hpp	/^    void init(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F);$/;"	p	class:cv::KalmanFilter	access:public	signature:(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F)
initCameraMatrix2D	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat initCameraMatrix2D( const vector<vector<Point3f> >& objectPoints,$/;"	p	namespace:cv	signature:( const vector<vector<Point3f> >& objectPoints, const vector<vector<Point2f> >& imagePoints, Size imageSize, double aspectRatio=1. )
initData	/usr/include/opencv2/contrib/contrib.hpp	/^    void initData(IplImage *src, int widthDivider, int heightDivider);$/;"	p	class:CvAdaptiveSkinDetector	access:protected	signature:(IplImage *src, int widthDivider, int heightDivider)
initDepthValues	/usr/include/opencv2/contrib/contrib.hpp	/^        void initDepthValues(IplImage *maskImage, IplImage *depthMap);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap)
initFeatureScale	/usr/include/opencv2/features2d/features2d.hpp	/^        float initFeatureScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
initImgBound	/usr/include/opencv2/features2d/features2d.hpp	/^        int initImgBound;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
initUndistortRectifyMap	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void initUndistortRectifyMap( const Mat& cameraMatrix, const Mat& distCoeffs,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix, const Mat& distCoeffs, const Mat& R, const Mat& newCameraMatrix, Size size, int m1type, CV_OUT Mat& map1, CV_OUT Mat& map2 )
initWideAngleProjMap	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W float initWideAngleProjMap( const Mat& cameraMatrix, const Mat& distCoeffs,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix, const Mat& distCoeffs, Size imageSize, int destImageWidth, int m1type, CV_OUT Mat& map1, CV_OUT Mat& map2, int projType=PROJ_SPHERICAL_EQRECT, double alpha=0)
initXyStep	/usr/include/opencv2/features2d/features2d.hpp	/^        int initXyStep;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
init_auto	/usr/include/opencv2/ml/ml.hpp	/^    virtual void init_auto( const CvVectors& samples );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& samples )
init_em	/usr/include/opencv2/ml/ml.hpp	/^    virtual void init_em( const CvVectors& train_data );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data )
init_weights	/usr/include/opencv2/ml/ml.hpp	/^    virtual void init_weights();$/;"	p	class:CvANN_MLP	access:protected	signature:()
initialize	/usr/include/opencv2/features2d/features2d.hpp	/^    void initialize( const Params& params, const Ptr<OneWayDescriptorBase>& base=Ptr<OneWayDescriptorBase>() );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const Params& params, const Ptr<OneWayDescriptorBase>& base=Ptr<OneWayDescriptorBase>() )
initialize	/usr/include/opencv2/video/background_segm.hpp	/^    virtual void initialize(Size frameSize, int frameType);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(Size frameSize, int frameType)
inpaint	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void inpaint( const Mat& src, const Mat& inpaintMask,$/;"	p	namespace:cv	signature:( const Mat& src, const Mat& inpaintMask, CV_OUT Mat& dst, double inpaintRange, int flags )
insert	/usr/include/opencv2/core/core.hpp	/^    void insert(int idx, const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(int idx, const _Tp& elem)
insert	/usr/include/opencv2/core/core.hpp	/^    void insert(int idx, const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(int idx, const _Tp* elems, size_t count)
insert	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp& elem)$/;"	f	class:cv::Seq	signature:(int idx, const _Tp& elem)
insert	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp* elems, size_t count)$/;"	f	class:cv::Seq	signature:(int idx, const _Tp* elems, size_t count)
insert	/usr/include/opencv2/flann/heap.h	/^	void insert(T value)$/;"	f	class:cvflann::Heap	access:public	signature:(T value)
insertImageCOI	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void insertImageCOI(const Mat& coiimg, CvArr* arr, int coi=-1);$/;"	p	namespace:cv	signature:(const Mat& coiimg, CvArr* arr, int coi=-1)
inside	/usr/include/opencv2/core/core.hpp	/^    bool inside(const Rect_<_Tp>& r) const;$/;"	p	class:cv::Point_	access:public	signature:(const Rect_<_Tp>& r) const
inside	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool Point_<_Tp>::inside( const Rect_<_Tp>& r ) const$/;"	f	class:cv::Point_	signature:( const Rect_<_Tp>& r ) const
int64	/usr/include/opencv2/core/types_c.h	/^typedef __int64 int64;$/;"	t
int64	/usr/include/opencv2/core/types_c.h	/^typedef int64_t int64;$/;"	t
integral	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void integral(GpuMat& src, GpuMat& sum, GpuMat& sqsum);$/;"	p	namespace:cv::gpu	signature:(GpuMat& src, GpuMat& sum, GpuMat& sqsum)
integral	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(integral2) void integral( const Mat& src, CV_OUT Mat& sum, CV_OUT Mat& sqsum, int sdepth=-1 );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& sum, CV_OUT Mat& sqsum, int sdepth=-1 )
integral	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_AS(integral3) void integral( const Mat& src, CV_OUT Mat& sum, CV_OUT Mat& sqsum, CV_OUT Mat& tilted, int sdepth=-1 );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& sum, CV_OUT Mat& sqsum, CV_OUT Mat& tilted, int sdepth=-1 )
integral	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void integral( const Mat& src, CV_OUT Mat& sum, int sdepth=-1 );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& sum, int sdepth=-1 )
interactionRadius	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int interactionRadius;$/;"	m	struct:CvStereoGCState	access:public
inv	/usr/include/opencv2/core/core.hpp	/^    MatExpr inv(int method=DECOMP_LU) const;$/;"	p	class:cv::Mat	access:public	signature:(int method=DECOMP_LU) const
inv	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, n, m> inv(int method=DECOMP_LU) const;$/;"	p	class:cv::Matx	access:public	signature:(int method=DECOMP_LU) const
inv	/usr/include/opencv2/core/mat.hpp	/^    MatExpr inv(int method = DECOMP_LU) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int method = DECOMP_LU) const
inv	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, n, m> Matx<_Tp, m, n>::inv(int method) const$/;"	f	class:cv::Matx	signature:(int method) const
inv_V_star	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat** inv_V_star; \/\/inverse of V*$/;"	m	class:cv::LevMarqSparse	access:protected
inv_eigen_values	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* inv_eigen_values;$/;"	m	class:CvEM	access:protected
inv_eigen_values	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** inv_eigen_values;$/;"	m	class:CvNormalBayesClassifier	access:protected
inv_sqrt_m00	/usr/include/opencv2/imgproc/types_c.h	/^    double  inv_sqrt_m00; \/* m00 != 0 ? 1\/sqrt(m00) : 0 *\/$/;"	m	struct:CvMoments	access:public
inv_var	/usr/include/opencv2/legacy/legacy.hpp	/^    float* inv_var;     \/* square root of inversed variances corresp. to each mixture*\/$/;"	m	struct:CvEHMMState	access:public
inversed	/usr/include/opencv2/ml/ml.hpp	/^    int inversed;$/;"	m	struct:CvDTreeSplit	access:public
invert	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double invert(const Mat& src, CV_OUT Mat& dst, int flags=DECOMP_LU);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags=DECOMP_LU)
invert	/usr/include/opencv2/core/mat.hpp	/^    virtual void invert(const MatExpr& expr, int method, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, int method, MatExpr& res) const
invertAffineTransform	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void invertAffineTransform( const Mat& M, CV_OUT Mat& iM );$/;"	p	namespace:cv	signature:( const Mat& M, CV_OUT Mat& iM )
iplHeight	/usr/include/opencv2/legacy/legacy.hpp	/^CV_INLINE int iplHeight( const IplImage* img )$/;"	f	signature:( const IplImage* img )
iplWidth	/usr/include/opencv2/legacy/legacy.hpp	/^CV_INLINE int iplWidth( const IplImage* img )$/;"	f	signature:( const IplImage* img )
ippiSize	/usr/include/opencv2/core/internal.hpp	/^CV_INLINE IppiSize ippiSize(int width, int height)$/;"	f	signature:(int width, int height)
isCalibrated	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    isCalibrated;$/;"	m	class:CvCalibFilter	access:protected
isContinuous	/usr/include/opencv2/core/core.hpp	/^    bool isContinuous() const;$/;"	p	class:cv::Mat	access:public	signature:() const
isContinuous	/usr/include/opencv2/core/mat.hpp	/^inline bool Mat::isContinuous() const { return (flags & CONTINUOUS_FLAG) != 0; }$/;"	f	class:cv::Mat	signature:() const
isContinuous	/usr/include/opencv2/gpu/gpu.hpp	/^            bool isContinuous() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
isContinuous	/usr/include/opencv2/gpu/gpu.hpp	/^            bool isContinuous() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
isContinuous	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline bool CudaMem::isContinuous() const { return (flags & Mat::CONTINUOUS_FLAG) != 0; }$/;"	f	class:cv::gpu::CudaMem	signature:() const
isContinuous	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline bool GpuMat::isContinuous() const { return (flags & Mat::CONTINUOUS_FLAG) != 0; }$/;"	f	class:cv::gpu::GpuMat	signature:() const
isContourConvex	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W bool isContourConvex( const Mat& contour );$/;"	p	namespace:cv	signature:( const Mat& contour )
isInstance	/usr/include/opencv2/core/operations.hpp	/^    static int isInstance(const void* ptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(const void* ptr)
isInt	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isInt() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isInt	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isInt() const { return type() == INT; }$/;"	f	class:cv::FileNode	signature:() const
isLeaf	/usr/include/opencv2/contrib/contrib.hpp	/^            bool isLeaf;$/;"	m	struct:cv::Octree::Node	access:public
isMap	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isMap() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isMap	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isMap() const { return type() == MAP; }$/;"	f	class:cv::FileNode	signature:() const
isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported() = 0;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported() const = 0;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported() const { return true; }$/;"	f	class:cv::BruteForceMatcher	access:public	signature:() const
isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported() const;$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:() const
isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
isMaskSupported	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
isMaskedOut	/usr/include/opencv2/features2d/features2d.hpp	/^    static bool isMaskedOut( const vector<Mat>& masks, int queryIdx );$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const vector<Mat>& masks, int queryIdx )
isNamed	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isNamed() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isNamed	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isNamed() const { return !node ? false : (node->tag & NAMED) != 0; }$/;"	f	class:cv::FileNode	signature:() const
isNone	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isNone() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isNone	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isNone() const { return type() == NONE; }$/;"	f	class:cv::FileNode	signature:() const
isNormalize	/usr/include/opencv2/features2d/features2d.hpp	/^        bool isNormalize;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
isOpened	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::FileStorage	access:public	signature:() const
isOpened	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::VideoCapture	access:public	signature:() const
isOpened	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::VideoWriter	access:public	signature:() const
isPossibleMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    static bool isPossibleMatch( const Mat& mask, int queryIdx, int trainIdx );$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& mask, int queryIdx, int trainIdx )
isReal	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isReal() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isReal	/usr/include/opencv2/core/core.hpp	/^    bool isReal() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
isReal	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isReal() const { return type() == REAL; }$/;"	f	class:cv::FileNode	signature:() const
isReal	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool Scalar_<_Tp>::isReal() const$/;"	f	class:cv::Scalar_	signature:() const
isSeparable	/usr/include/opencv2/imgproc/imgproc.hpp	/^    bool isSeparable() const { return (const BaseFilter*)filter2D == 0; }$/;"	f	class:cv::FilterEngine	access:public	signature:() const
isSeq	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isSeq() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isSeq	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isSeq() const { return type() == SEQ; }$/;"	f	class:cv::FileNode	signature:() const
isString	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP bool isString() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isString	/usr/include/opencv2/core/operations.hpp	/^inline bool FileNode::isString() const { return type() == STR; }$/;"	f	class:cv::FileNode	signature:() const
isSubmatrix	/usr/include/opencv2/core/core.hpp	/^    bool isSubmatrix() const;$/;"	p	class:cv::Mat	access:public	signature:() const
isSubmatrix	/usr/include/opencv2/core/mat.hpp	/^inline bool Mat::isSubmatrix() const { return (flags & SUBMATRIX_FLAG) != 0; }$/;"	f	class:cv::Mat	signature:() const
is_buf_16u	/usr/include/opencv2/ml/ml.hpp	/^    int is_buf_16u;$/;"	m	struct:CvDTreeTrainData	access:public
is_classifier	/usr/include/opencv2/ml/ml.hpp	/^    bool is_classifier;$/;"	m	struct:CvDTreeTrainData	access:public
is_instance	/usr/include/opencv2/core/types_c.h	/^    CvIsInstanceFunc is_instance;$/;"	m	struct:CvTypeInfo	access:public
is_obj_without_holes	/usr/include/opencv2/video/background_segm.hpp	/^    int    is_obj_without_holes;\/* If TRUE we ignore holes within foreground blobs. Defaults to TRUE.						*\/$/;"	m	struct:CvFGDStatModelParams	access:public
is_regression	/usr/include/opencv2/ml/ml.hpp	/^    bool is_regression() const;$/;"	p	class:CvKNearest	access:public	signature:() const
is_stump_based	/usr/include/opencv2/objdetect/objdetect.hpp	/^    bool is_stump_based;$/;"	m	class:cv::CascadeClassifier	access:public
is_trained_dyn_model	/usr/include/opencv2/video/background_segm.hpp	/^    uchar                 is_trained_dyn_model;$/;"	m	struct:CvBGPixelStat	access:public
is_trained_st_model	/usr/include/opencv2/video/background_segm.hpp	/^    uchar                 is_trained_st_model;$/;"	m	struct:CvBGPixelStat	access:public
is_valid	/usr/include/opencv2/legacy/legacy.hpp	/^    bool is_valid() { return image != 0; }$/;"	f	class:CvImage	access:public	signature:()
is_valid	/usr/include/opencv2/legacy/legacy.hpp	/^    bool is_valid() { return matrix != 0; }$/;"	f	class:CvMatrix	access:public	signature:()
it	/usr/include/opencv2/core/core.hpp	/^    MatIterator_<_Tp> it;$/;"	m	class:cv::MatCommaInitializer_	access:protected
it	/usr/include/opencv2/core/operations.hpp	/^    FileNodeIterator* it;$/;"	m	class:cv::VecReaderProxy	access:public
items	/usr/include/opencv2/flann/result_set.h	/^	vector<Item> items;$/;"	m	class:cvflann::RadiusResultSet	access:private
iterations	/usr/include/opencv2/flann/composite_index.h	/^	int iterations;            \/\/ max iterations to perform in one kmeans clustering (kmeans tree)$/;"	m	struct:cvflann::CompositeIndexParams	access:public
iterations	/usr/include/opencv2/flann/kmeans_index.h	/^	int iterations;            \/\/ max iterations to perform in one kmeans clustering (kmeans tree)$/;"	m	struct:cvflann::KMeansIndexParams	access:public
iterator	/usr/include/opencv2/core/core.hpp	/^    typedef MatIterator_<_Tp> iterator;$/;"	t	class:cv::Mat_	access:public
iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SeqIterator<_Tp> iterator;$/;"	t	class:cv::Seq	access:public
iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SparseMatIterator iterator;$/;"	t	class:cv::SparseMat	access:public
iterator	/usr/include/opencv2/core/core.hpp	/^    typedef SparseMatIterator_<_Tp> iterator;$/;"	t	class:cv::SparseMat_	access:public
iterator	/usr/include/opencv2/core/operations.hpp	/^    typedef _Tp* iterator;$/;"	t	class:cv::Vector	access:public
iterator_category	/usr/include/opencv2/core/core.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	class:cv::SparseMatConstIterator_	access:public
iterator_category	/usr/include/opencv2/core/core.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	class:cv::SparseMatIterator_	access:public
iterator_category	/usr/include/opencv2/core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatConstIterator	access:public
iterator_category	/usr/include/opencv2/core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatConstIterator_	access:public
iterator_category	/usr/include/opencv2/core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatIterator_	access:public
iterdepth	/usr/include/opencv2/core/core.hpp	/^    int iterdepth, idx;$/;"	m	class:cv::NAryMatIterator	access:protected
iters	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int iters;$/;"	m	class:CvLevMarq	access:public
iters	/usr/include/opencv2/contrib/contrib.hpp	/^        int iters;$/;"	m	class:cv::LevMarqSparse	access:protected
iters	/usr/include/opencv2/gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
iters	/usr/include/opencv2/gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
iters	/usr/include/opencv2/gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
k	/usr/include/opencv2/features2d/features2d.hpp	/^        double k;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
k	/usr/include/opencv2/legacy/legacy.hpp	/^    int k; \/\/stack size$/;"	m	struct:CvCliqueFinder	access:public
kChannels	/usr/include/opencv2/core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageBufferC::__anon102
kChannels	/usr/include/opencv2/core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageC::__anon101
kChannels	/usr/include/opencv2/core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageViewC::__anon103
kalman	/usr/include/opencv2/video/tracking.hpp	/^CVAPI(void)  cvReleaseKalman( CvKalman** kalman);$/;"	v
kdtree	/usr/include/opencv2/flann/composite_index.h	/^	KDTreeIndex<ELEM_TYPE, DIST_TYPE>* kdtree;$/;"	m	class:cvflann::CompositeIndex	access:private
keep_floats_	/usr/include/opencv2/features2d/features2d.hpp	/^  bool keep_floats_;$/;"	m	class:cv::RTreeClassifier	access:private
kernel	/usr/include/opencv2/contrib/contrib.hpp	/^    SearchWindow kernel;$/;"	m	class:CvFuzzyMeanShiftTracker	access:public
kernel	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernel* kernel;$/;"	m	class:CvSVM	access:protected
kernel	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernel* kernel;$/;"	m	class:CvSVMSolver	access:public
kernel_type	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int         kernel_type;$/;"	m	struct:CvSVMParams	access:public
keypointCount	/usr/include/opencv2/features2d/features2d.hpp	/^        size_t keypointCount() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
keypoints	/usr/include/opencv2/features2d/features2d.hpp	/^        vector<vector<KeyPoint> > keypoints;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
kl_divergence	/usr/include/opencv2/flann/dist.h	/^double kl_divergence(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
kmeans	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double kmeans( const Mat& data, int K, CV_OUT Mat& bestLabels,$/;"	p	namespace:cv	signature:( const Mat& data, int K, CV_OUT Mat& bestLabels, TermCriteria criteria, int attempts, int flags, CV_OUT Mat* centers=0 )
kmeans	/usr/include/opencv2/flann/composite_index.h	/^	KMeansIndex<ELEM_TYPE, DIST_TYPE>* kmeans;$/;"	m	class:cvflann::CompositeIndex	access:private
kmeans	/usr/include/opencv2/ml/ml.hpp	/^    virtual void kmeans( const CvVectors& train_data, int nclusters,$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data, int nclusters, CvMat* labels, CvTermCriteria criteria, const CvMat* means )
knnMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void knnMatch( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<vector<DMatch> >& matches, int k, const Mat& mask=Mat(), bool compactResult=false ) const
knnMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void knnMatch( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
knnMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void knnMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<vector<DMatch> >& matches, int k, const Mat& mask=Mat(), bool compactResult=false ) const
knnMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void knnMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::BruteForceMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::OneWayDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::VectorDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^void BruteForceMatcher<Distance>::knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	f	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^void BruteForceMatcher<L2<float> >::knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnSearch	/usr/include/opencv2/flann/flann.hpp	/^	void knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const SearchParams& params)
knnSearch	/usr/include/opencv2/flann/flann.hpp	/^	void knnSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const vector<T>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& params)
knnSearch	/usr/include/opencv2/flann/flann.hpp	/^void Index_<T>::knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const SearchParams& searchParams)
knnSearch	/usr/include/opencv2/flann/flann.hpp	/^void Index_<T>::knnSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const vector<T>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& searchParams)
knnSearch	/usr/include/opencv2/flann/flann_base.hpp	/^	void knnSearch(const Matrix<T>& queries, Matrix<int>& indices, Matrix<float>& dists, int knn, const SearchParams& params);$/;"	p	class:cvflann::Index	access:public	signature:(const Matrix<T>& queries, Matrix<int>& indices, Matrix<float>& dists, int knn, const SearchParams& params)
knnSearch	/usr/include/opencv2/flann/flann_base.hpp	/^void Index<T>::knnSearch(const Matrix<T>& queries, Matrix<int>& indices, Matrix<float>& dists, int knn, const SearchParams& searchParams)$/;"	f	class:cvflann::Index	signature:(const Matrix<T>& queries, Matrix<int>& indices, Matrix<float>& dists, int knn, const SearchParams& searchParams)
ksize	/usr/include/opencv2/gpu/gpu.hpp	/^            Size ksize;$/;"	m	class:cv::gpu::BaseFilter_GPU	access:public
ksize	/usr/include/opencv2/gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseColumnFilter_GPU	access:public
ksize	/usr/include/opencv2/gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseRowFilter_GPU	access:public
ksize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Size ksize;$/;"	m	class:cv::BaseFilter	access:public
ksize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Size ksize;$/;"	m	class:cv::FilterEngine	access:public
ksize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseColumnFilter	access:public
ksize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseRowFilter	access:public
l	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
l	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
l	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int l;$/;"	m	struct:__anon59	access:public
l2	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
labels	/usr/include/opencv2/core/core.hpp	/^    CV_PROP vector<int> labels; \/\/!< the parallel array of labels.$/;"	m	class:cv::KDTree	access:public
labels	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat labels;        $/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
labels_host	/usr/include/opencv2/gpu/gpu.hpp	/^            Mat labels_host;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
lambda	/usr/include/opencv2/calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
lambda	/usr/include/opencv2/contrib/contrib.hpp	/^        double lambda;$/;"	m	class:cv::LevMarqSparse	access:protected
lambda	/usr/include/opencv2/contrib/contrib.hpp	/^        float lambda;$/;"	m	class:cv::SpinImageModel	access:public
lambda1	/usr/include/opencv2/calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
lambda1	/usr/include/opencv2/features2d/features2d.hpp	/^    float lambda1;$/;"	m	class:cv::CvAffinePose	access:public
lambda2	/usr/include/opencv2/calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
lambda2	/usr/include/opencv2/features2d/features2d.hpp	/^    float lambda2;$/;"	m	class:cv::CvAffinePose	access:public
lambdaLg10	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int lambdaLg10;$/;"	m	class:CvLevMarq	access:public
lambdaMax	/usr/include/opencv2/features2d/features2d.hpp	/^    double lambdaMin, lambdaMax;$/;"	m	class:cv::PatchGenerator	access:public
lambdaMin	/usr/include/opencv2/features2d/features2d.hpp	/^    double lambdaMin, lambdaMax;$/;"	m	class:cv::PatchGenerator	access:public
laplacian	/usr/include/opencv2/features2d/features2d.hpp	/^    int laplacian;$/;"	m	struct:CvSURFPoint	access:public
largeSize	/usr/include/opencv2/contrib/contrib.hpp	/^        int largeSize;$/;"	m	class:cv::SelfSimDescriptor	access:public
last	/usr/include/opencv2/core/core_c.h	/^    static CvModuleInfo* last;$/;"	m	struct:CvModule	access:public
last	/usr/include/opencv2/core/core_c.h	/^    static CvTypeInfo* last;$/;"	m	struct:CvType	access:public
latestCounts	/usr/include/opencv2/legacy/legacy.hpp	/^    int     latestCounts[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
latestPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f* latestPoints[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
layer_sizes	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* layer_sizes;$/;"	m	class:CvANN_MLP	access:protected
ldetector	/usr/include/opencv2/features2d/features2d.hpp	/^    LDetector ldetector;$/;"	m	class:cv::PlanarObjectDetector	access:protected
ldh	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
ldw	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
ldx	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
ldy	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
leBuf	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
leaf_counts_	/usr/include/opencv2/features2d/features2d.hpp	/^  std::vector<int> leaf_counts_;$/;"	m	class:cv::RandomizedTree	access:private
learnMax	/usr/include/opencv2/video/background_segm.hpp	/^    uchar learnMax[3];$/;"	m	struct:CvBGCodeBookElem	access:public
learnMin	/usr/include/opencv2/video/background_segm.hpp	/^    uchar learnMin[3];$/;"	m	struct:CvBGCodeBookElem	access:public
leaves	/usr/include/opencv2/objdetect/objdetect.hpp	/^    vector<float> leaves;$/;"	m	class:cv::CascadeClassifier	access:public
leavesPerStruct	/usr/include/opencv2/features2d/features2d.hpp	/^    int leavesPerStruct;$/;"	m	class:cv::FernClassifier	access:protected
leaves_get	/usr/include/opencv2/ml/ml.hpp	/^    void leaves_get( CvDTreeNode** leaves, int& count, CvDTreeNode* node );$/;"	p	class:CvGBTrees	access:protected	signature:( CvDTreeNode** leaves, int& count, CvDTreeNode* node )
left	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* left;$/;"	m	struct:CvStereoGCState	access:public
left	/usr/include/opencv2/core/core.hpp	/^        int left, right;$/;"	m	struct:cv::KDTree::Node	access:public
left	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode* left;$/;"	m	struct:CvDTreeNode	access:public
left	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int left;$/;"	m	struct:cv::CascadeClassifier::DTreeNode	access:public
left	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int* left;$/;"	m	struct:CvHaarClassifier	access:public
len	/usr/include/opencv2/core/types_c.h	/^    int len;$/;"	m	struct:CvString	access:public
len1	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int len1,len2;$/;"	m	struct:CvTracksTimePos	access:public
len2	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int len1,len2;$/;"	m	struct:CvTracksTimePos	access:public
length	/usr/include/opencv2/flann/heap.h	/^    int length;$/;"	m	class:cvflann::Heap	access:private
level	/usr/include/opencv2/core/core_c.h	/^    int level;$/;"	m	struct:CvTreeNodeIterator	access:public
level	/usr/include/opencv2/flann/kmeans_index.h	/^		int level;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
level	/usr/include/opencv2/legacy/legacy.hpp	/^    int level; \/* 0 - lowest(i.e its states are real states), ..... *\/$/;"	m	struct:CvEHMM	access:public
levels	/usr/include/opencv2/features2d/features2d.hpp	/^    int levels;$/;"	m	class:cv::PyramidAdaptedFeatureDetector	access:protected
levels	/usr/include/opencv2/gpu/gpu.hpp	/^            int levels;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
levels	/usr/include/opencv2/gpu/gpu.hpp	/^            int levels;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
line	/usr/include/opencv2/core/core.hpp	/^	int line; \/\/\/< line number in the source file where the error has occured $/;"	m	class:cv::Exception	access:public
line	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void line(Mat& img, Point pt1, Point pt2, const Scalar& color,$/;"	p	namespace:cv	signature:(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
lineCoeffs	/usr/include/opencv2/legacy/legacy.hpp	/^    CvStereoLineCoeff* lineCoeffs;$/;"	m	struct:CvStereoCamera	access:public
lineThresholdBinarized	/usr/include/opencv2/features2d/features2d.hpp	/^    int lineThresholdBinarized;$/;"	m	struct:CvStarDetectorParams	access:public
lineThresholdProjected	/usr/include/opencv2/features2d/features2d.hpp	/^    int lineThresholdProjected;$/;"	m	struct:CvStarDetectorParams	access:public
line_type	/usr/include/opencv2/core/core_c.h	/^    int         line_type;		\/\/Qt: PointSize$/;"	m	struct:CvFont	access:public
load	/usr/include/opencv2/legacy/legacy.hpp	/^    bool load( const char* filename, const char* imgname=0, int color=-1 );$/;"	p	class:CvImage	access:public	signature:( const char* filename, const char* imgname=0, int color=-1 )
load	/usr/include/opencv2/legacy/legacy.hpp	/^    bool load( const char* filename, const char* matname=0, int color=-1 );$/;"	p	class:CvMatrix	access:public	signature:( const char* filename, const char* matname=0, int color=-1 )
load	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void load( const char* filename, const char* name=0 );$/;"	p	class:CvStatModel	access:public	signature:( const char* filename, const char* name=0 )
load	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP bool load(const string& filename);$/;"	p	class:cv::CascadeClassifier	access:public	signature:(const string& filename)
load	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual bool load(const String& filename, const String& objname=String());$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const String& filename, const String& objname=String())
loadIndex	/usr/include/opencv2/flann/autotuned_index.h	/^    virtual void loadIndex(FILE* stream)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(FILE* stream)
loadIndex	/usr/include/opencv2/flann/composite_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(FILE* stream)
loadIndex	/usr/include/opencv2/flann/kdtree_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(FILE* stream)
loadIndex	/usr/include/opencv2/flann/kmeans_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(FILE* stream)
loadIndex	/usr/include/opencv2/flann/linear_index.h	/^    void loadIndex(FILE*)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(FILE*)
loadIndex	/usr/include/opencv2/flann/nn_index.h	/^	virtual void loadIndex(FILE* stream) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(FILE* stream)
loadWindowParameters	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void loadWindowParameters(const string& windowName);$/;"	p	namespace:cv	signature:(const string& windowName)
load_from_file	/usr/include/opencv2/flann/hdf5.h	/^void load_from_file(cvflann::Matrix<T>& flann_dataset, const std::string& filename, const std::string& name)$/;"	f	namespace:cvflann	signature:(cvflann::Matrix<T>& flann_dataset, const std::string& filename, const std::string& name)
load_header	/usr/include/opencv2/flann/saving.h	/^CV_EXPORTS IndexHeader load_header(FILE* stream);$/;"	p	namespace:cvflann	signature:(FILE* stream)
load_saved_index	/usr/include/opencv2/flann/flann_base.hpp	/^NNIndex<T>* load_saved_index(const Matrix<T>& dataset, const string& filename)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& dataset, const string& filename)
load_tree	/usr/include/opencv2/flann/kdtree_index.h	/^    void load_tree(FILE* stream, Tree& tree)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(FILE* stream, Tree& tree)
load_tree	/usr/include/opencv2/flann/kmeans_index.h	/^    void load_tree(FILE* stream, KMeansNode& node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(FILE* stream, KMeansNode& node)
load_value	/usr/include/opencv2/flann/saving.h	/^void load_value(FILE* stream, T& value, int count = 1)$/;"	f	namespace:cvflann	signature:(FILE* stream, T& value, int count = 1)
loaded_from	/usr/include/opencv2/core/types_c.h	/^    int loaded_from;$/;"	m	struct:CvPluginFuncInfo	access:public
loc	/usr/include/opencv2/flann/allocator.h	/^	void*	loc;      \/* Current location in block to next allocate memory. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
locateROI	/usr/include/opencv2/core/core.hpp	/^    void locateROI( Size& wholeSize, Point& ofs ) const;$/;"	p	class:cv::Mat	access:public	signature:( Size& wholeSize, Point& ofs ) const
locateROI	/usr/include/opencv2/gpu/gpu.hpp	/^            void locateROI( Size& wholeSize, Point& ofs ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( Size& wholeSize, Point& ofs ) const
locateROI	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline void GpuMat::locateROI( Size& wholeSize, Point& ofs ) const$/;"	f	class:cv::gpu::GpuMat	signature:( Size& wholeSize, Point& ofs ) const
log	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void log(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
log	/usr/include/opencv2/flann/logger.h	/^    int log(int level, const char* fmt, ...);$/;"	p	class:cvflann::Logger	access:public	signature:(int level, const char* fmt, ...)
log	/usr/include/opencv2/flann/logger.h	/^    int log(int level, const char* fmt, va_list arglist);$/;"	p	class:cvflann::Logger	access:public	signature:(int level, const char* fmt, va_list arglist)
log	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void log(const GpuMat& a, GpuMat& b);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b)
logLevel	/usr/include/opencv2/flann/logger.h	/^    int logLevel;$/;"	m	class:cvflann::Logger	access:private
log_likelihood	/usr/include/opencv2/ml/ml.hpp	/^    double log_likelihood;$/;"	m	class:CvEM	access:protected
log_var_val	/usr/include/opencv2/legacy/legacy.hpp	/^    float* log_var_val; \/* sum of 0.5 (LN2PI + ln(variance[i]) ) for i=1,n *\/$/;"	m	struct:CvEHMMState	access:public
log_verbosity	/usr/include/opencv2/flann/flann_base.hpp	/^CV_EXPORTS void log_verbosity(int level);$/;"	p	namespace:cvflann	signature:(int level)
log_weight_div_det	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* log_weight_div_det;$/;"	m	class:CvEM	access:protected
logger	/usr/include/opencv2/flann/logger.h	/^CV_EXPORTS Logger& logger();$/;"	p	namespace:cvflann	signature:()
loss_function_type	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int loss_function_type;$/;"	m	struct:CvGBTreesParams	access:public
lpos	/usr/include/opencv2/core/core.hpp	/^    ptrdiff_t lpos() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
lru_list	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernelRow lru_list;$/;"	m	class:CvSVMSolver	access:public
lsh_hash	/usr/include/opencv2/imgproc/imgproc.hpp	/^struct lsh_hash {$/;"	s
lsh_hash::h1	/usr/include/opencv2/imgproc/imgproc.hpp	/^  int h1, h2;$/;"	m	struct:lsh_hash	access:public
lsh_hash::h2	/usr/include/opencv2/imgproc/imgproc.hpp	/^  int h1, h2;$/;"	m	struct:lsh_hash	access:public
m	/usr/include/opencv2/core/core.hpp	/^    const Mat* m;$/;"	m	class:cv::MatConstIterator	access:public
m	/usr/include/opencv2/core/core.hpp	/^    const SparseMat* m;$/;"	m	class:cv::SparseMatConstIterator	access:public
m	/usr/include/opencv2/legacy/legacy.hpp	/^    float m[3][3];$/;"	m	struct:CvMatrix3	access:public
m00	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m00	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m00	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m01	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m01	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m01	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m02	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m02	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m02	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m03	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m03	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m10	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m10	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m10	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m11	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m11	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m11	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m12	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m12	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m20	/usr/include/opencv2/contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m20	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m20	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m21	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m21	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m30	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m30	/usr/include/opencv2/imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m_Wnd	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int         m_Wnd;$/;"	m	class:CvVSModule	access:protected
m_affine_poses	/usr/include/opencv2/features2d/features2d.hpp	/^    CvAffinePose* m_affine_poses; \/\/ an array of poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_back_project	/usr/include/opencv2/legacy/legacy.hpp	/^    IplImage*  m_back_project;$/;"	m	class:CvCamShiftTracker	access:protected
m_box	/usr/include/opencv2/legacy/legacy.hpp	/^    CvBox2D    m_box;$/;"	m	class:CvCamShiftTracker	access:protected
m_center	/usr/include/opencv2/features2d/features2d.hpp	/^    CvPoint m_center; \/\/ the coordinates of the feature (the center of the input image ROI)$/;"	m	class:cv::OneWayDescriptor	access:protected
m_color_planes	/usr/include/opencv2/legacy/legacy.hpp	/^    IplImage*  m_color_planes[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
m_comp	/usr/include/opencv2/legacy/legacy.hpp	/^    CvConnectedComp m_comp;$/;"	m	class:CvCamShiftTracker	access:protected
m_descriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptor* m_descriptors; \/\/ array of train feature descriptors$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_feature_name	/usr/include/opencv2/features2d/features2d.hpp	/^    string m_feature_name; \/\/ the name of the feature associated with the descriptor$/;"	m	class:cv::OneWayDescriptor	access:protected
m_hist	/usr/include/opencv2/legacy/legacy.hpp	/^    CvHistogram* m_hist;$/;"	m	class:CvCamShiftTracker	access:protected
m_hist_ranges	/usr/include/opencv2/legacy/legacy.hpp	/^    float*     m_hist_ranges[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
m_hist_ranges_data	/usr/include/opencv2/legacy/legacy.hpp	/^    float      m_hist_ranges_data[CV_MAX_DIM][2];$/;"	m	class:CvCamShiftTracker	access:protected
m_image	/usr/include/opencv2/legacy/blobtrack.hpp	/^    IplImage* m_image;$/;"	m	class:CvImageDrawer	access:protected
m_input_patch	/usr/include/opencv2/features2d/features2d.hpp	/^    IplImage* m_input_patch;$/;"	m	class:cv::OneWayDescriptor	access:protected
m_mask	/usr/include/opencv2/legacy/legacy.hpp	/^    IplImage*  m_mask;$/;"	m	class:CvCamShiftTracker	access:protected
m_max_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    int        m_max_ch_val[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
m_min_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    int        m_min_ch_val[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
m_object_feature_count	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_object_feature_count; \/\/ the number of the positive features$/;"	m	class:cv::OneWayDescriptorObject	access:protected
m_pElemFormat	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char            m_pElemFormat[1024];$/;"	m	class:CvBlobSeq	access:protected
m_pMem	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvMemStorage*   m_pMem;$/;"	m	class:CvBlobSeq	access:protected
m_pMem	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvMemStorage*   m_pMem;$/;"	m	class:CvBlobTrackSeq	access:protected
m_pModuleName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*       m_pModuleName;$/;"	m	class:CvVSModule	access:private
m_pModuleTypeName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*       m_pModuleTypeName;$/;"	m	class:CvVSModule	access:private
m_pNickName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*       m_pNickName;$/;"	m	class:CvVSModule	access:private
m_pParamList	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvDefParam*   m_pParamList;$/;"	m	class:CvVSModule	access:private
m_pSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvSeq*          m_pSeq;$/;"	m	class:CvBlobSeq	access:protected
m_pSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvSeq*          m_pSeq;$/;"	m	class:CvBlobTrackSeq	access:protected
m_part_id	/usr/include/opencv2/features2d/features2d.hpp	/^    int* m_part_id; \/\/ contains part id for each of object descriptors$/;"	m	class:cv::OneWayDescriptorObject	access:protected
m_patch_size	/usr/include/opencv2/features2d/features2d.hpp	/^    CvSize m_patch_size; \/\/ patch size$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_patch_size	/usr/include/opencv2/features2d/features2d.hpp	/^    CvSize m_patch_size; \/\/ size of each image$/;"	m	class:cv::OneWayDescriptor	access:protected
m_pca_avg	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat* m_pca_avg; \/\/ PCA average Vector for small patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_coeffs	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat** m_pca_coeffs; \/\/ an array of length m_pose_count containing pca decomposition of the patch in different poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_pca_descriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    OneWayDescriptor* m_pca_descriptors; \/\/ an array of PCA descriptors$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_descriptors_matrix	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat* m_pca_descriptors_matrix;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_descriptors_tree	/usr/include/opencv2/features2d/features2d.hpp	/^    cv::flann::Index* m_pca_descriptors_tree;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_dim_high	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pca_dim_high; \/\/ the number of descriptor pca components to use for generating affine poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_pca_dim_high	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pca_dim_high;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_dim_low	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pca_dim_low; \/\/ the number of pca components to use for comparison$/;"	m	class:cv::OneWayDescriptor	access:protected
m_pca_dim_low	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pca_dim_low;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_eigenvectors	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat* m_pca_eigenvectors; \/\/ PCA eigenvectors for small patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_hr_avg	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat* m_pca_hr_avg; \/\/ PCA average Vector for large patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_hr_eigenvectors	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat* m_pca_hr_eigenvectors; \/\/ PCA eigenvectors for large patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pose_count	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pose_count; \/\/ the number of poses for each descriptor$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pose_count	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pose_count; \/\/ the number of poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_poses	/usr/include/opencv2/features2d/features2d.hpp	/^    CvAffinePose* m_poses; \/\/ array of poses$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pyr_levels	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_pyr_levels;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_samples	/usr/include/opencv2/features2d/features2d.hpp	/^    IplImage** m_samples; \/\/ an array of length m_pose_count containing the patch in different poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_shape	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvDrawShape m_shape[16];$/;"	m	class:CvImageDrawer	access:protected
m_temp	/usr/include/opencv2/legacy/legacy.hpp	/^    IplImage*  m_temp;$/;"	m	class:CvCamShiftTracker	access:protected
m_threshold	/usr/include/opencv2/legacy/legacy.hpp	/^    int        m_threshold;$/;"	m	class:CvCamShiftTracker	access:protected
m_train_feature_count	/usr/include/opencv2/features2d/features2d.hpp	/^    int m_train_feature_count; \/\/ the number of the training features$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_train_features	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<cv::KeyPoint> m_train_features; \/\/ train features$/;"	m	class:cv::OneWayDescriptorObject	access:protected
m_train_patch	/usr/include/opencv2/features2d/features2d.hpp	/^    IplImage* m_train_patch;$/;"	m	class:cv::OneWayDescriptor	access:protected
m_transforms	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat** m_transforms; \/\/ an array of affine transforms corresponding to poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_transforms	/usr/include/opencv2/features2d/features2d.hpp	/^    CvMat** m_transforms; \/\/ array of affine transformations corresponding to poses$/;"	m	class:cv::OneWayDescriptorBase	access:protected
magnification	/usr/include/opencv2/features2d/features2d.hpp	/^        double magnification;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
magnitude	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void magnitude(const Mat& x, const Mat& y, CV_OUT Mat& magnitude);$/;"	p	namespace:cv	signature:(const Mat& x, const Mat& y, CV_OUT Mat& magnitude)
magnitude	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitude(const GpuMat& x, GpuMat& magnitude);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, GpuMat& magnitude)
magnitude	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitude(const GpuMat& x, const GpuMat& y, GpuMat& magnitude);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude)
magnitude	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitude(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, const Stream& stream)
magnitudeSqr	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitudeSqr(const GpuMat& x, GpuMat& magnitude);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, GpuMat& magnitude)
magnitudeSqr	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitudeSqr(const GpuMat& x, const GpuMat& y, GpuMat& magnitude);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude)
magnitudeSqr	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void magnitudeSqr(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, const Stream& stream)
makePosteriors2	/usr/include/opencv2/features2d/features2d.hpp	/^  void makePosteriors2(int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_quant_bits)
make_branch	/usr/include/opencv2/flann/result_set.h	/^    static BranchStruct<T> make_branch(const T& aNode, float dist)$/;"	f	struct:cvflann::BranchStruct	access:public	signature:(const T& aNode, float dist)
manhattan_dist	/usr/include/opencv2/flann/dist.h	/^double manhattan_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
map	/usr/include/opencv2/core/types_c.h	/^        CvFileNodeHash* map; \/* map (collection of named file nodes) *\/$/;"	m	union:CvFileNode::__anon100	access:public
mask	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> mask;$/;"	m	class:CvLevMarq	access:public
mask	/usr/include/opencv2/core/core_c.h	/^    int      mask;         \/* event mask *\/$/;"	m	struct:CvGraphScanner	access:public
maskROI	/usr/include/opencv2/core/types_c.h	/^    struct _IplImage *maskROI;      \/* Must be NULL. *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplImage	access:public
mat	/usr/include/opencv2/core/core_c.h	/^CVAPI(CvMat*) cvCloneMat( const CvMat* mat );$/;"	v
mat	/usr/include/opencv2/core/core_c.h	/^CVAPI(CvMatND*) cvCloneMatND( const CvMatND* mat );$/;"	v
mat	/usr/include/opencv2/core/core_c.h	/^CVAPI(CvScalar) cvTrace( const CvArr* mat );$/;"	v
mat	/usr/include/opencv2/core/core_c.h	/^CVAPI(CvSparseMat*) cvCloneSparseMat( const CvSparseMat* mat );$/;"	v
mat	/usr/include/opencv2/core/core_c.h	/^CVAPI(double) cvDet( const CvArr* mat );$/;"	v
mat	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvReleaseMat( CvMat** mat );$/;"	v
mat	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvReleaseSparseMat( CvSparseMat** mat );$/;"	v
mat	/usr/include/opencv2/core/types_c.h	/^    CvMatND mat;                    \/* Embedded matrix header for array histograms. *\/$/;"	m	struct:CvHistogram	access:public
mat	/usr/include/opencv2/core/types_c.h	/^    CvSparseMat* mat;$/;"	m	struct:CvSparseMatIterator	access:public
mat	/usr/include/opencv2/legacy/legacy.hpp	/^    float mat[4][4];              \/* maps camera coordinates to world coordinates *\/$/;"	m	struct:__anon175	access:public
matMulDeriv	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void matMulDeriv( const Mat& A, const Mat& B, CV_OUT Mat& dABdA, CV_OUT Mat& dABdB );$/;"	p	namespace:cv	signature:( const Mat& A, const Mat& B, CV_OUT Mat& dABdA, CV_OUT Mat& dABdB )
mat_type	/usr/include/opencv2/core/core.hpp	/^    typedef Matx<_Tp, m, n> mat_type;$/;"	t	class:cv::Matx	access:public
match	/usr/include/opencv2/contrib/contrib.hpp	/^        void match(const SpinImageModel& scene, vector< vector<Vec2i> >& result);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const SpinImageModel& scene, vector< vector<Vec2i> >& result)
match	/usr/include/opencv2/features2d/features2d.hpp	/^    void match( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<DMatch>& matches, const Mat& mask=Mat() ) const
match	/usr/include/opencv2/features2d/features2d.hpp	/^    void match( const Mat& queryDescriptors, vector<DMatch>& matches,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<DMatch>& matches, const vector<Mat>& masks=vector<Mat>() )
match	/usr/include/opencv2/features2d/features2d.hpp	/^    void match( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<DMatch>& matches, const Mat& mask=Mat() ) const
match	/usr/include/opencv2/features2d/features2d.hpp	/^    void match( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<DMatch>& matches, const vector<Mat>& masks=vector<Mat>() )
matchShapes	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double matchShapes( const Mat& contour1,$/;"	p	namespace:cv	signature:( const Mat& contour1, const Mat& contour2, int method, double parameter )
matchSpinToModel	/usr/include/opencv2/contrib/contrib.hpp	/^        void matchSpinToModel(const Mat& spin, vector<int>& indeces,$/;"	p	class:cv::SpinImageModel	access:protected	signature:(const Mat& spin, vector<int>& indeces, vector<float>& corrCoeffs, bool useExtremeOutliers = true) const
matchTemplate	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void matchTemplate( const Mat& image, const Mat& templ, CV_OUT Mat& result, int method );$/;"	p	namespace:cv	signature:( const Mat& image, const Mat& templ, CV_OUT Mat& result, int method )
match_sum	/usr/include/opencv2/video/background_segm.hpp	/^    int         match_sum;$/;"	m	struct:CvGaussBGValues	access:public
matcher	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<DescriptorMatcher> matcher;$/;"	m	class:cv::VectorDescriptorMatcher	access:protected
matmul	/usr/include/opencv2/core/mat.hpp	/^    virtual void matmul(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
matrix	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat* matrix;$/;"	m	class:CvMatrix	access:protected
matrix	/usr/include/opencv2/legacy/legacy.hpp	/^    float   matrix[9]; \/* intinsic camera parameters:  [ fx 0 cx; 0 fy cy; 0 0 1 ] *\/$/;"	m	struct:CvCamera	access:public
max	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void max(const Mat& src1, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst)
max	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void max(const Mat& src1, double src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, double src2, CV_OUT Mat& dst)
max	/usr/include/opencv2/core/core.hpp	72;"	d
max	/usr/include/opencv2/core/internal.hpp	131;"	d
max	/usr/include/opencv2/core/internal.hpp	69;"	d
max	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr max(const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
max	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr max(const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
max	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr max(double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
max	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
max	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
max	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(double s, const Mat_<_Tp>& a)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a)
max	/usr/include/opencv2/core/operations.hpp	93;"	d
max	/usr/include/opencv2/highgui/highgui_c.h	49;"	d
max	/usr/include/opencv2/legacy/legacy.hpp	/^    float max, min; \/\/ minimum and maximum projections$/;"	m	struct:CvContourOrientation	access:public
maxArea	/usr/include/opencv2/features2d/features2d.hpp	/^    int maxArea;$/;"	m	struct:CvMSERParams	access:public
maxCorners	/usr/include/opencv2/features2d/features2d.hpp	/^        int maxCorners;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
maxCount	/usr/include/opencv2/core/core.hpp	/^    int maxCount; \/\/ the maximum number of iterations\/elements$/;"	m	class:cv::TermCriteria	access:public
maxDepth	/usr/include/opencv2/core/core.hpp	/^    CV_PROP int maxDepth; \/\/!< maximum depth of the search tree. Do not modify it$/;"	m	class:cv::KDTree	access:public
maxEvolution	/usr/include/opencv2/features2d/features2d.hpp	/^    int maxEvolution;$/;"	m	struct:CvMSERParams	access:public
maxHeight	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
maxIters	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int maxIters;$/;"	m	struct:CvStereoGCState	access:public
maxLevels	/usr/include/opencv2/contrib/contrib.hpp	/^            int maxLevels;$/;"	m	struct:cv::Octree::Node	access:public
maxPoints	/usr/include/opencv2/legacy/legacy.hpp	/^    int     maxPoints;$/;"	m	class:CvCalibFilter	access:protected
maxScale	/usr/include/opencv2/features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
maxSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int maxSize;$/;"	m	struct:CvStarDetectorParams	access:public
maxTotalKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^    int maxTotalKeypoints;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
maxVariation	/usr/include/opencv2/features2d/features2d.hpp	/^    float maxVariation;$/;"	m	struct:CvMSERParams	access:public
maxWidth	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
maxWidth	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int maxWidth;$/;"	m	class:cv::FilterEngine	access:public
max_buf_sz	/usr/include/opencv2/ml/ml.hpp	/^    int max_count, max_buf_sz;$/;"	m	class:CvANN_MLP	access:protected
max_c_count	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
max_categories	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int   max_categories;$/;"	m	struct:CvDTreeParams	access:public
max_count	/usr/include/opencv2/ml/ml.hpp	/^    int max_count, max_buf_sz;$/;"	m	class:CvANN_MLP	access:protected
max_data_term	/usr/include/opencv2/gpu/gpu.hpp	/^            float max_data_term;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
max_data_term	/usr/include/opencv2/gpu/gpu.hpp	/^            float max_data_term;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
max_depth	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int   max_depth;$/;"	m	struct:CvDTreeParams	access:public
max_disc_term	/usr/include/opencv2/gpu/gpu.hpp	/^            float max_disc_term;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
max_disc_term	/usr/include/opencv2/gpu/gpu.hpp	/^            float max_disc_term;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
max_disc_threshold	/usr/include/opencv2/gpu/gpu.hpp	/^            float max_disc_threshold;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
max_dist	/usr/include/opencv2/flann/dist.h	/^double max_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
max_features_	/usr/include/opencv2/features2d/features2d.hpp	/^	int min_features_, max_features_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
max_iter	/usr/include/opencv2/core/types_c.h	/^    int    max_iter;$/;"	m	struct:CvTermCriteria	access:public
max_iter	/usr/include/opencv2/flann/kmeans_index.h	/^	int max_iter;$/;"	m	class:cvflann::KMeansIndex	access:private
max_iter	/usr/include/opencv2/ml/ml.hpp	/^    int max_iter;$/;"	m	class:CvSVMSolver	access:public
max_k	/usr/include/opencv2/ml/ml.hpp	/^    int max_k, var_count;$/;"	m	class:CvKNearest	access:protected
max_level	/usr/include/opencv2/core/core_c.h	/^    int max_level;$/;"	m	struct:CvTreeNodeIterator	access:public
max_size	/usr/include/opencv2/core/core.hpp	/^    size_type max_size() const$/;"	f	class:cv::Allocator	access:public	signature:() const
max_val	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double max_val;$/;"	m	struct:CvParamGrid	access:public
max_val	/usr/include/opencv2/ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
max_val1	/usr/include/opencv2/ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
maxlr	/usr/include/opencv2/ml/ml.hpp	/^    double maxlr;$/;"	m	struct:CvDTreeNode	access:public
mean	/usr/include/opencv2/core/core.hpp	/^    Mat mean; \/\/!< mean value subtracted before the projection and added after the back projection$/;"	m	class:cv::PCA	access:public
mean	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS Scalar mean(const Mat& src);$/;"	p	namespace:cv	signature:(const Mat& src)
mean	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W Scalar mean(const Mat& src, const Mat& mask CV_WRAP_DEFAULT(Mat()));$/;"	p	namespace:cv	signature:(const Mat& src, const Mat& mask CV_WRAP_DEFAULT(Mat()))
mean	/usr/include/opencv2/flann/kdtree_index.h	/^    DIST_TYPE* mean;$/;"	m	class:cvflann::KDTreeIndex	access:private
mean	/usr/include/opencv2/video/background_segm.hpp	/^    double      mean[CV_BGFG_MOG_NCOLORS];$/;"	m	struct:CvGaussBGValues	access:public
meanShift	/usr/include/opencv2/contrib/contrib.hpp	/^        bool meanShift(IplImage *maskImage, IplImage *depthMap, int maxIteration, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap, int maxIteration, bool initDepth)
meanShift	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W int meanShift( const Mat& probImage, CV_IN_OUT Rect& window,$/;"	p	namespace:cv	signature:( const Mat& probImage, CV_IN_OUT Rect& window, TermCriteria criteria )
meanShiftFiltering	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftFiltering(const GpuMat& src, GpuMat& dst, int sp, int sr, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int sp, int sr, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
meanShiftProc	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftProc(const GpuMat& src, GpuMat& dstr, GpuMat& dstsp, int sp, int sr, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dstr, GpuMat& dstsp, int sp, int sr, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
meanShiftSegmentation	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftSegmentation(const GpuMat& src, Mat& dst, int sp, int sr, int minsize,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, Mat& dst, int sp, int sr, int minsize, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
meanStdDev	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void meanStdDev(const Mat& src, CV_OUT Scalar& mean, CV_OUT Scalar& stddev, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Scalar& mean, CV_OUT Scalar& stddev, const Mat& mask=Mat())
meanStdDev	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void meanStdDev(const GpuMat& mtx, Scalar& mean, Scalar& stddev);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& mtx, Scalar& mean, Scalar& stddev)
mean_radius	/usr/include/opencv2/flann/kmeans_index.h	/^		DIST_TYPE mean_radius;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
means	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* means;$/;"	m	class:CvEM	access:protected
means	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* means;$/;"	m	struct:CvEMParams	access:public
meanshift_profile	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     meanshift_profile;$/;"	m	struct:CvBlobTrackerParamMS	access:public
measurementMatrix	/usr/include/opencv2/video/tracking.hpp	/^    Mat measurementMatrix;  \/\/!< measurement matrix (H)$/;"	m	class:cv::KalmanFilter	access:public
measurementNoiseCov	/usr/include/opencv2/video/tracking.hpp	/^    Mat measurementNoiseCov;\/\/!< measurement noise covariance matrix (R)$/;"	m	class:cv::KalmanFilter	access:public
measurement_matrix	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* measurement_matrix;  \/* measurement matrix (H) *\/$/;"	m	struct:CvKalman	access:public
measurement_noise_cov	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* measurement_noise_cov; \/* measurement noise covariance matrix (R) *\/$/;"	m	struct:CvKalman	access:public
medianBlur	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void medianBlur( const Mat& src, CV_OUT Mat& dst, int ksize );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ksize )
memoryCost	/usr/include/opencv2/flann/autotuned_index.h	/^        float memoryCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
memoryCounter	/usr/include/opencv2/flann/kmeans_index.h	/^	int memoryCounter;$/;"	m	class:cvflann::KMeansIndex	access:private
memory_weight	/usr/include/opencv2/flann/autotuned_index.h	/^	float memory_weight;       \/\/ index memory weighting factor$/;"	m	struct:cvflann::AutotunedIndexParams	access:public
merge	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void merge(const Mat* mv, size_t count, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat* mv, size_t count, CV_OUT Mat& dst)
merge	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void merge(const vector<Mat>& mv, Mat& dst);$/;"	p	namespace:cv	signature:(const vector<Mat>& mv, Mat& dst)
merge	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void merge(const GpuMat* src, size_t n, GpuMat& dst);$/;"	p	namespace:cv::gpu	signature:(const GpuMat* src, size_t n, GpuMat& dst)
merge	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void merge(const GpuMat* src, size_t n, GpuMat& dst, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat* src, size_t n, GpuMat& dst, const Stream& stream)
merge	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void merge(const vector<GpuMat>& src, GpuMat& dst);$/;"	p	namespace:cv::gpu	signature:(const vector<GpuMat>& src, GpuMat& dst)
merge	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void merge(const vector<GpuMat>& src, GpuMat& dst, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const vector<GpuMat>& src, GpuMat& dst, const Stream& stream)
mergeWith	/usr/include/opencv2/contrib/contrib.hpp	/^        void mergeWith(Histogram *source, double weight);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:(Histogram *source, double weight)
mergedDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^        Mat mergedDescriptors;$/;"	m	class:cv::DescriptorMatcher::DescriptorCollection	access:protected
mergedDescriptors	/usr/include/opencv2/features2d/features2d.hpp	/^    DescriptorCollection mergedDescriptors;$/;"	m	class:cv::FlannBasedMatcher	access:protected
mesh	/usr/include/opencv2/contrib/contrib.hpp	/^        Mesh3D mesh;$/;"	m	class:cv::SpinImageModel	access:protected
min	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void min(const Mat& src1, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst)
min	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void min(const Mat& src1, double src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, double src2, CV_OUT Mat& dst)
min	/usr/include/opencv2/core/core.hpp	71;"	d
min	/usr/include/opencv2/core/internal.hpp	130;"	d
min	/usr/include/opencv2/core/internal.hpp	68;"	d
min	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr min(const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
min	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr min(const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
min	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr min(double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
min	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
min	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
min	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(double s, const Mat_<_Tp>& a)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a)
min	/usr/include/opencv2/core/operations.hpp	92;"	d
min	/usr/include/opencv2/highgui/highgui_c.h	48;"	d
min	/usr/include/opencv2/legacy/legacy.hpp	/^    float max, min; \/\/ minimum and maximum projections$/;"	m	struct:CvContourOrientation	access:public
minArea	/usr/include/opencv2/features2d/features2d.hpp	/^    int minArea;$/;"	m	struct:CvMSERParams	access:public
minArea	/usr/include/opencv2/video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
minArea	/usr/include/opencv2/video/background_segm.hpp	/^    float  minArea;		\/* Discard foreground blobs whose bounding box is smaller than this threshold.					*\/$/;"	m	struct:CvFGDStatModelParams	access:public
minAreaRect	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W RotatedRect minAreaRect( const Mat& points );$/;"	p	namespace:cv	signature:( const Mat& points )
minDisparity	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int minDisparity;$/;"	m	class:cv::StereoSGBM	access:public
minDisparity	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int minDisparity;  \/\/ minimum disparity (can be negative)$/;"	m	struct:CvStereoBMState	access:public
minDisparity	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int minDisparity;$/;"	m	struct:CvStereoGCState	access:public
minDistance	/usr/include/opencv2/features2d/features2d.hpp	/^        double minDistance;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
minDiversity	/usr/include/opencv2/features2d/features2d.hpp	/^    float minDiversity;$/;"	m	struct:CvMSERParams	access:public
minEnclosingCircle	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void minEnclosingCircle( const Mat& points,$/;"	p	namespace:cv	signature:( const Mat& points, Point2f& center, float& radius )
minMargin	/usr/include/opencv2/features2d/features2d.hpp	/^    double minMargin;$/;"	m	struct:CvMSERParams	access:public
minMax	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void minMax(const GpuMat& src, double* minVal, double* maxVal, const GpuMat& mask, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal, const GpuMat& mask, GpuMat& buf)
minMax	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void minMax(const GpuMat& src, double* minVal, double* maxVal=0, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal=0, const GpuMat& mask=GpuMat())
minMaxIdx	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void minMaxIdx(const Mat& src, double* minVal, double* maxVal,$/;"	p	namespace:cv	signature:(const Mat& src, double* minVal, double* maxVal, int* minIdx=0, int* maxIdx=0, const Mat& mask=Mat())
minMaxLoc	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void minMaxLoc(const SparseMat& a, double* minVal,$/;"	p	namespace:cv	signature:(const SparseMat& a, double* minVal, double* maxVal, int* minIdx=0, int* maxIdx=0)
minMaxLoc	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void minMaxLoc(const Mat& src, CV_OUT double* minVal,$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT double* minVal, CV_OUT double* maxVal=0, CV_OUT Point* minLoc=0, CV_OUT Point* maxLoc=0, const Mat& mask=Mat())
minMaxLoc	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void minMaxLoc(const GpuMat& src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, const GpuMat& mask, GpuMat& valbuf, GpuMat& locbuf)
minMaxLoc	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void minMaxLoc(const GpuMat& src, double* minVal, double* maxVal=0, Point* minLoc=0, Point* maxLoc=0, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal=0, Point* minLoc=0, Point* maxLoc=0, const GpuMat& mask=GpuMat())
minNeighbors	/usr/include/opencv2/contrib/contrib.hpp	/^        int minNeighbors;$/;"	m	class:cv::SpinImageModel	access:public
minPoints	/usr/include/opencv2/contrib/contrib.hpp	/^        int minPoints;$/;"	m	class:cv::Octree	access:private
minSSD	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
minScale	/usr/include/opencv2/features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
min_disp_th	/usr/include/opencv2/gpu/gpu.hpp	/^            int min_disp_th;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
min_features_	/usr/include/opencv2/features2d/features2d.hpp	/^	int min_features_, max_features_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
min_sample_count	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int   min_sample_count;$/;"	m	struct:CvDTreeParams	access:public
min_val	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double min_val;$/;"	m	struct:CvParamGrid	access:public
min_val	/usr/include/opencv2/ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
min_val1	/usr/include/opencv2/ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
mindistsq	/usr/include/opencv2/flann/result_set.h	/^	float mindistsq;     \/* Minimum distance to query for all nodes below. *\/$/;"	m	struct:cvflann::BranchStruct	access:public
minkowski_dist	/usr/include/opencv2/flann/dist.h	/^double minkowski_dist(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)$/;"	f	namespace:cvflann	signature:(Iterator1 first1, Iterator1 last1, Iterator2 first2, double acc = 0)
minusDelta	/usr/include/opencv2/core/core.hpp	/^    int minusDelta, plusDelta;$/;"	m	class:cv::LineIterator	access:public
minusStep	/usr/include/opencv2/core/core.hpp	/^    int minusStep, plusStep;$/;"	m	class:cv::LineIterator	access:public
minus_delta	/usr/include/opencv2/core/types_c.h	/^    int  minus_delta;$/;"	m	struct:CvLineIterator	access:public
minus_step	/usr/include/opencv2/core/types_c.h	/^    int  minus_step;$/;"	m	struct:CvLineIterator	access:public
miss_ch	/usr/include/opencv2/ml/ml.hpp	/^    char miss_ch;$/;"	m	class:CvMLData	access:protected
missing	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* missing;$/;"	m	class:CvGBTrees	access:protected
missing	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* missing;$/;"	m	class:CvMLData	access:protected
missing_mask	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* missing_mask;$/;"	m	struct:CvERTreeTrainData	access:public
mix	/usr/include/opencv2/legacy/legacy.hpp	/^    int* mix;  \/* number of mixture to which observation belong *\/$/;"	m	struct:CvImgObsInfo	access:public
mix	/usr/include/opencv2/ml/ml.hpp	/^    bool mix;    $/;"	m	struct:CvTrainTestSplit	access:public
mix	/usr/include/opencv2/ml/ml.hpp	/^    bool mix;$/;"	m	class:CvMLData	access:protected
mixChannels	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts,$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)
mixChannels	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void mixChannels(const vector<Mat>& src, vector<Mat>& dst,$/;"	p	namespace:cv	signature:(const vector<Mat>& src, vector<Mat>& dst, const int* fromTo, int npairs)
mix_train_and_test_idx	/usr/include/opencv2/ml/ml.hpp	/^    void mix_train_and_test_idx();$/;"	p	class:CvMLData	access:public	signature:()
modMax	/usr/include/opencv2/video/background_segm.hpp	/^    uchar modMax[3];$/;"	m	struct:CvBGCodeBookModel	access:public
modMin	/usr/include/opencv2/video/background_segm.hpp	/^    uchar modMin[3];$/;"	m	struct:CvBGCodeBookModel	access:public
model	/usr/include/opencv2/video/background_segm.hpp	/^CVAPI(void) cvReleaseBGCodeBookModel( CvBGCodeBookModel** model );$/;"	v
modelPoints	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<KeyPoint> modelPoints;$/;"	m	class:cv::PlanarObjectDetector	access:protected
modelROI	/usr/include/opencv2/features2d/features2d.hpp	/^    Rect modelROI;$/;"	m	class:cv::PlanarObjectDetector	access:protected
module_info	/usr/include/opencv2/core/core_c.h	/^CVAPI(int)  cvRegisterModule( const CvModuleInfo* module_info );$/;"	v
moments	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W Moments moments( const Mat& array, bool binaryImage=false );$/;"	p	namespace:cv	signature:( const Mat& array, bool binaryImage=false )
morphologyDefaultBorderValue	/usr/include/opencv2/imgproc/imgproc.hpp	/^static inline Scalar morphologyDefaultBorderValue() { return Scalar::all(DBL_MAX); }$/;"	f	namespace:cv	signature:()
morphologyEx	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void morphologyEx( const GpuMat& src, GpuMat& dst, int op, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1);$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, int op, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1)
morphologyEx	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void morphologyEx( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int op, const Mat& kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
mser	/usr/include/opencv2/features2d/features2d.hpp	/^    MSER mser;$/;"	m	class:cv::MserFeatureDetector	access:protected
msg	/usr/include/opencv2/core/core.hpp	/^	string msg; \/\/\/< the formatted error message$/;"	m	class:cv::Exception	access:public
msg_type	/usr/include/opencv2/gpu/gpu.hpp	/^            int msg_type;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
msg_type	/usr/include/opencv2/gpu/gpu.hpp	/^            int msg_type;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
mtx	/usr/include/opencv2/core/operations.hpp	/^    Mat mtx;$/;"	m	struct:cv::Formatted	access:public
mu	/usr/include/opencv2/legacy/legacy.hpp	/^    float* mu;          \/*mean vectors corresponding to each mixture*\/$/;"	m	struct:CvEHMMState	access:public
mu02	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu02	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu03	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu03	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu11	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu11	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu12	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu12	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu20	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu20	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu21	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu21	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu30	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu30	/usr/include/opencv2/imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mul	/usr/include/opencv2/core/core.hpp	/^    MatExpr mul(const Mat& m, double scale=1) const;$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, double scale=1) const
mul	/usr/include/opencv2/core/core.hpp	/^    MatExpr mul(const MatExpr& m, double scale=1) const;$/;"	p	class:cv::Mat	access:public	signature:(const MatExpr& m, double scale=1) const
mul	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, m, n> mul(const Matx<_Tp, m, n>& a) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a) const
mul	/usr/include/opencv2/core/core.hpp	/^    Scalar_<_Tp> mul(const Scalar_<_Tp>& t, double scale=1 ) const;$/;"	p	class:cv::Scalar_	access:public	signature:(const Scalar_<_Tp>& t, double scale=1 ) const
mul	/usr/include/opencv2/core/core.hpp	/^    Vec mul(const Vec<_Tp, cn>& v) const;$/;"	p	class:cv::Vec	access:public	signature:(const Vec<_Tp, cn>& v) const
mul	/usr/include/opencv2/core/mat.hpp	/^    MatExpr mul(const Mat& m, double scale=1) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m, double scale=1) const
mul	/usr/include/opencv2/core/mat.hpp	/^    MatExpr mul(const MatExpr& e, double scale=1) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const MatExpr& e, double scale=1) const
mul	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> Matx<_Tp, m, n>::mul(const Matx<_Tp, m, n>& a) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a) const
mul	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::mul(const Vec<_Tp, cn>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& v) const
mul	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::mul(const Scalar_<_Tp>& t, double scale ) const$/;"	f	class:cv::Scalar_	signature:(const Scalar_<_Tp>& t, double scale ) const
mulSpectrums	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void mulSpectrums(const Mat& a, const Mat& b, CV_OUT Mat& c,$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b, CV_OUT Mat& c, int flags, bool conjB=false)
mulTransposed	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void mulTransposed( const Mat& src, CV_OUT Mat& dst, bool aTa,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, bool aTa, const Mat& delta=Mat(), double scale=1, int rtype=-1 )
multiply	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void multiply(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, double scale=1);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, double scale=1)
multiply	/usr/include/opencv2/core/mat.hpp	/^    virtual void multiply(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const
multiply	/usr/include/opencv2/core/mat.hpp	/^    virtual void multiply(const MatExpr& expr1, double s, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, double s, MatExpr& res) const
multiply	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void multiply(const GpuMat& a, const GpuMat& b, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c)
multiply	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void multiply(const GpuMat& a, const Scalar& sc, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c)
nChannels	/usr/include/opencv2/core/types_c.h	/^    int  nChannels;         \/* Most of OpenCV functions support 1,2,3 or 4 channels *\/$/;"	m	struct:_IplImage	access:public
nCols	/usr/include/opencv2/core/types_c.h	/^    int  nCols;$/;"	m	struct:_IplConvKernel	access:public
nCols	/usr/include/opencv2/core/types_c.h	/^    int  nCols;$/;"	m	struct:_IplConvKernelFP	access:public
nFrameCount	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nMorphingMethod	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nOctaveLayers	/usr/include/opencv2/features2d/features2d.hpp	/^        int nOctaves, nOctaveLayers, firstOctave;$/;"	m	struct:cv::SIFT::CommonParams	access:public
nOctaveLayers	/usr/include/opencv2/features2d/features2d.hpp	/^    int nOctaveLayers;$/;"	m	struct:CvSURFParams	access:public
nOctaves	/usr/include/opencv2/features2d/features2d.hpp	/^        int nOctaves, nOctaveLayers, firstOctave;$/;"	m	struct:cv::SIFT::CommonParams	access:public
nOctaves	/usr/include/opencv2/features2d/features2d.hpp	/^    int nOctaves;$/;"	m	class:cv::LDetector	access:public
nOctaves	/usr/include/opencv2/features2d/features2d.hpp	/^    int nOctaves;$/;"	m	struct:CvSURFParams	access:public
nRows	/usr/include/opencv2/core/types_c.h	/^    int  nRows;$/;"	m	struct:_IplConvKernel	access:public
nRows	/usr/include/opencv2/core/types_c.h	/^    int  nRows;$/;"	m	struct:_IplConvKernelFP	access:public
nSamplingDivider	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nShiftR	/usr/include/opencv2/core/types_c.h	/^    int  nShiftR;$/;"	m	struct:_IplConvKernel	access:public
nSize	/usr/include/opencv2/core/types_c.h	/^    int  nSize;             \/* sizeof(IplImage) *\/$/;"	m	struct:_IplImage	access:public
nSkinHueLowerBound	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nSkinHueUpperBound	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nStartCounter	/usr/include/opencv2/contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nViews	/usr/include/opencv2/features2d/features2d.hpp	/^    int nViews;$/;"	m	class:cv::LDetector	access:public
n_gauss	/usr/include/opencv2/video/background_segm.hpp	/^    int     n_gauss;$/;"	m	struct:CvGaussBGStatModelParams	access:public
nactive_vars	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int nactive_vars;$/;"	m	struct:CvRTParams	access:public
name	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP string name() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
name	/usr/include/opencv2/core/types_c.h	/^    const char* name;$/;"	m	struct:CvModuleInfo	access:public
nameFont	/usr/include/opencv2/core/core_c.h	/^	const char* nameFont;		\/\/Qt:nameFont$/;"	m	struct:CvFont	access:public
namedWindow	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W void namedWindow( const string& winname, int flags CV_DEFAULT(WINDOW_AUTOSIZE) );$/;"	p	namespace:cv	signature:( const string& winname, int flags CV_DEFAULT(WINDOW_AUTOSIZE) )
narrays	/usr/include/opencv2/core/core.hpp	/^    int narrays;$/;"	m	class:cv::NAryMatIterator	access:public
nbins	/usr/include/opencv2/gpu/gpu.hpp	/^            int nbins;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
nbins	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP int nbins;$/;"	m	struct:cv::HOGDescriptor	access:public
ncategories	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int ncategories;$/;"	m	class:cv::CascadeClassifier	access:public
nclasses	/usr/include/opencv2/features2d/features2d.hpp	/^        int nclasses;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
nclasses	/usr/include/opencv2/features2d/features2d.hpp	/^    int nclasses;$/;"	m	class:cv::FernClassifier	access:protected
nclasses	/usr/include/opencv2/ml/ml.hpp	/^    int nclasses;$/;"	m	class:CvRTrees	access:protected
nclusters	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int nclusters;$/;"	m	struct:CvEMParams	access:public
ndisp	/usr/include/opencv2/gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
ndisp	/usr/include/opencv2/gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
ndisp	/usr/include/opencv2/gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
ndisp	/usr/include/opencv2/gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
ne	/usr/include/opencv2/legacy/legacy.hpp	/^    int* ne;$/;"	m	struct:CvCliqueFinder	access:public
needSwapCameras	/usr/include/opencv2/legacy/legacy.hpp	/^    int needSwapCameras;\/* flag set to 1 if need to swap cameras for good reconstruction *\/$/;"	m	struct:CvStereoCamera	access:public
neighbors	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int neighbors;$/;"	m	struct:CvAvgComp	access:public
newCurve	/usr/include/opencv2/contrib/contrib.hpp	/^    CvFuzzyCurve *newCurve();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
newNode	/usr/include/opencv2/core/core.hpp	/^    uchar* newNode(const int* idx, size_t hashval);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t hashval)
new_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeNode* new_node( CvDTreeNode* parent, int count,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* parent, int count, int storage_idx, int offset )
new_split_cat	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* new_split_cat( int vi, float quality );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( int vi, float quality )
new_split_ord	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* new_split_ord( int vi, float cmp_val,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( int vi, float cmp_val, int split_point, int inversed, float quality )
next	/usr/include/opencv2/core/core.hpp	/^        size_t next;$/;"	m	struct:cv::SparseMat::Node	access:public
next	/usr/include/opencv2/core/core.hpp	/^    unsigned next();$/;"	p	class:cv::RNG	access:public	signature:()
next	/usr/include/opencv2/core/operations.hpp	/^inline unsigned RNG::next()$/;"	f	class:cv::RNG	signature:()
next	/usr/include/opencv2/core/types_c.h	/^    struct CvAttrList* next;   \/* Pointer to next chunk of the attributes list.                    *\/$/;"	m	struct:CvAttrList	typeref:struct:CvAttrList::CvAttrList	access:public
next	/usr/include/opencv2/core/types_c.h	/^    struct CvMemBlock*  next;$/;"	m	struct:CvMemBlock	typeref:struct:CvMemBlock::CvMemBlock	access:public
next	/usr/include/opencv2/core/types_c.h	/^    struct CvModuleInfo* next;$/;"	m	struct:CvModuleInfo	typeref:struct:CvModuleInfo::CvModuleInfo	access:public
next	/usr/include/opencv2/core/types_c.h	/^    struct CvSeqBlock*  next; \/* Next sequence block.                       *\/$/;"	m	struct:CvSeqBlock	typeref:struct:CvSeqBlock::CvSeqBlock	access:public
next	/usr/include/opencv2/core/types_c.h	/^    struct CvSparseNode* next;$/;"	m	struct:CvSparseNode	typeref:struct:CvSparseNode::CvSparseNode	access:public
next	/usr/include/opencv2/core/types_c.h	/^    struct CvStringHashNode* next;$/;"	m	struct:CvStringHashNode	typeref:struct:CvStringHashNode::CvStringHashNode	access:public
next	/usr/include/opencv2/core/types_c.h	/^    struct CvTypeInfo* next;$/;"	m	struct:CvTypeInfo	typeref:struct:CvTypeInfo::CvTypeInfo	access:public
next	/usr/include/opencv2/flann/random.h	/^	int next() {$/;"	f	class:cvflann::UniqueRandom	access:public	signature:()
next	/usr/include/opencv2/legacy/blobtrack.hpp	/^    struct CvDefParam*    next;$/;"	m	struct:CvDefParam	typeref:struct:CvDefParam::CvDefParam	access:public
next	/usr/include/opencv2/legacy/legacy.hpp	/^    struct CvVoronoiSite2D *next[2];$/;"	m	struct:CvVoronoiSite2D	typeref:struct:CvVoronoiSite2D::CvVoronoiSite2D	access:public
next	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeSplit* next;$/;"	m	struct:CvDTreeSplit	access:public
next	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernelRow* next;$/;"	m	struct:CvSVMKernelRow	access:public
next	/usr/include/opencv2/ml/ml.hpp	/^    CvVectors* next;$/;"	m	struct:CvVectors	access:public
next	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int next;$/;"	m	struct:CvHaarStageClassifier	access:public
next	/usr/include/opencv2/video/background_segm.hpp	/^    struct CvBGCodeBookElem* next;$/;"	m	struct:CvBGCodeBookElem	typeref:struct:CvBGCodeBookElem::CvBGCodeBookElem	access:public
nframes	/usr/include/opencv2/video/background_segm.hpp	/^    int nframes;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
nlevels	/usr/include/opencv2/gpu/gpu.hpp	/^            int nlevels;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
nlevels	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP int nlevels;$/;"	m	struct:cv::HOGDescriptor	access:public
nmixtures	/usr/include/opencv2/video/background_segm.hpp	/^    int nmixtures;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
nnIndex	/usr/include/opencv2/flann/flann.hpp	/^	::cvflann::Index<T>* nnIndex;$/;"	m	class:cv::flann::Index_	access:private
nnIndex	/usr/include/opencv2/flann/flann_base.hpp	/^	NNIndex<T>* nnIndex;$/;"	m	class:cvflann::Index	access:private
noOfSigBits	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int     noOfSigBits;$/;"	m	struct:CvBlobTrackerParamMS	access:public
nod	/usr/include/opencv2/legacy/legacy.hpp	/^    int* nod;$/;"	m	struct:CvCliqueFinder	access:public
node	/usr/include/opencv2/core/core.hpp	/^    Node* node(size_t nidx);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t nidx)
node	/usr/include/opencv2/core/core.hpp	/^    SparseMat::Node* node() const;$/;"	p	class:cv::SparseMatIterator	access:public	signature:() const
node	/usr/include/opencv2/core/core.hpp	/^    const CvFileNode* node;$/;"	m	class:cv::FileNode	access:public
node	/usr/include/opencv2/core/core.hpp	/^    const Node* node(size_t nidx) const;$/;"	p	class:cv::SparseMat	access:public	signature:(size_t nidx) const
node	/usr/include/opencv2/core/core.hpp	/^    const SparseMat::Node* node() const;$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:() const
node	/usr/include/opencv2/core/core_c.h	/^    const void* node;$/;"	m	struct:CvTreeNodeIterator	access:public
node	/usr/include/opencv2/core/core_c.h	/^CVAPI(const char*) cvGetFileNodeName( const CvFileNode* node );$/;"	v
node	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::Node* SparseMat::node(size_t nidx)$/;"	f	class:cv::SparseMat	signature:(size_t nidx)
node	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::Node* SparseMatIterator::node() const$/;"	f	class:cv::SparseMatIterator	signature:() const
node	/usr/include/opencv2/core/mat.hpp	/^inline const SparseMat::Node* SparseMat::node(size_t nidx) const$/;"	f	class:cv::SparseMat	signature:(size_t nidx) const
node	/usr/include/opencv2/core/mat.hpp	/^inline const SparseMat::Node* SparseMatConstIterator::node() const$/;"	f	class:cv::SparseMatConstIterator	signature:() const
node	/usr/include/opencv2/core/types_c.h	/^    CvSparseNode* node;$/;"	m	struct:CvSparseMatIterator	access:public
node	/usr/include/opencv2/flann/result_set.h	/^	T node;           \/* Tree node at which search resumes *\/$/;"	m	struct:cvflann::BranchStruct	access:public
nodeCount	/usr/include/opencv2/core/core.hpp	/^        size_t nodeCount;$/;"	m	struct:cv::SparseMat::Hdr	access:public
nodeCount	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int nodeCount;$/;"	m	struct:cv::CascadeClassifier::DTree	access:public
nodeSize	/usr/include/opencv2/core/core.hpp	/^        size_t nodeSize;$/;"	m	struct:cv::SparseMat::Hdr	access:public
node_heap	/usr/include/opencv2/ml/ml.hpp	/^    CvSet* node_heap;$/;"	m	struct:CvDTreeTrainData	access:public
node_risk	/usr/include/opencv2/ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
nodes	/usr/include/opencv2/contrib/contrib.hpp	/^        vector<Node> nodes;$/;"	m	class:cv::Octree	access:private
nodes	/usr/include/opencv2/core/core.hpp	/^    vector<Node> nodes; \/\/!< all the tree nodes$/;"	m	class:cv::KDTree	access:public
nodes	/usr/include/opencv2/objdetect/objdetect.hpp	/^    vector<DTreeNode> nodes;$/;"	m	class:cv::CascadeClassifier	access:public
nodes_	/usr/include/opencv2/features2d/features2d.hpp	/^  std::vector<RTreeNode> nodes_;$/;"	m	class:cv::RandomizedTree	access:private
noiseRange	/usr/include/opencv2/features2d/features2d.hpp	/^    double noiseRange;$/;"	m	class:cv::PatchGenerator	access:public
noiseSigma	/usr/include/opencv2/video/background_segm.hpp	/^    double noiseSigma;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
nonmaxSuppression	/usr/include/opencv2/features2d/features2d.hpp	/^    bool nonmaxSuppression;$/;"	m	class:cv::FastFeatureDetector	access:protected
nonmax_	/usr/include/opencv2/features2d/features2d.hpp	/^	bool nonmax_;$/;"	m	class:cv::FastAdjuster	access:protected
norm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS double norm( const SparseMat& src, int normType );$/;"	p	namespace:cv	signature:( const SparseMat& src, int normType )
norm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS double norm(const Mat& src1, const Mat& src2, int normType=NORM_L2);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, int normType=NORM_L2)
norm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS double norm(const Mat& src1, int normType=NORM_L2);$/;"	p	namespace:cv	signature:(const Mat& src1, int normType=NORM_L2)
norm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double norm(const Mat& src1, const Mat& src2,$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, int normType, const Mat& mask CV_WRAP_DEFAULT(Mat()))
norm	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double norm(const Mat& src1, int normType, const Mat& mask CV_WRAP_DEFAULT(Mat()));$/;"	p	namespace:cv	signature:(const Mat& src1, int normType, const Mat& mask CV_WRAP_DEFAULT(Mat()))
norm	/usr/include/opencv2/core/operations.hpp	/^double norm(const Matx<_Tp, m, n>& M)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& M)
norm	/usr/include/opencv2/core/operations.hpp	/^double norm(const Matx<_Tp, m, n>& M, int normType)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& M, int normType)
norm	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline double norm(const Point3_<_Tp>& pt)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& pt)
norm	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline double norm(const Point_<_Tp>& pt)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& pt)
norm	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS double norm(const GpuMat& src1, const GpuMat& src2, int normType=NORM_L2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, int normType=NORM_L2)
norm	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS double norm(const GpuMat& src1, int normType=NORM_L2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, int normType=NORM_L2)
normType	/usr/include/opencv2/core/core.hpp	/^    CV_PROP_RW int normType; \/\/!< type of the distance (cv::NORM_L1 or cv::NORM_L2) used for search. Initially set to cv::NORM_L2, but you can modify it$/;"	m	class:cv::KDTree	access:public
normalRadius	/usr/include/opencv2/contrib/contrib.hpp	/^        float normalRadius;$/;"	m	class:cv::SpinImageModel	access:public
normalize	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void normalize( const SparseMat& src, SparseMat& dst, double alpha, int normType );$/;"	p	namespace:cv	signature:( const SparseMat& src, SparseMat& dst, double alpha, int normType )
normalize	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void normalize( const Mat& src, CV_OUT Mat& dst, double alpha=1, double beta=0,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, double alpha=1, double beta=0, int norm_type=NORM_L2, int rtype=-1, const Mat& mask=Mat())
normals	/usr/include/opencv2/contrib/contrib.hpp	/^        vector<Point3f> normals;$/;"	m	class:cv::Mesh3D	access:public
nplanes	/usr/include/opencv2/core/core.hpp	/^    int nplanes;$/;"	m	class:cv::NAryMatIterator	access:public
nppError	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void nppError( int err, const char *file, const int line, const char *func);        $/;"	p	namespace:cv::gpu	signature:( int err, const char *file, const int line, const char *func)
nr_plane	/usr/include/opencv2/gpu/gpu.hpp	/^            int nr_plane;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
nsamples	/usr/include/opencv2/ml/ml.hpp	/^    int nsamples;$/;"	m	class:CvRTrees	access:protected
nstructs	/usr/include/opencv2/features2d/features2d.hpp	/^        int nstructs;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
nstructs	/usr/include/opencv2/features2d/features2d.hpp	/^    int nstructs;$/;"	m	class:cv::FernClassifier	access:protected
ntrees	/usr/include/opencv2/ml/ml.hpp	/^    int ntrees;$/;"	m	class:CvRTrees	access:protected
ntrees	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int ntrees;$/;"	m	struct:cv::CascadeClassifier::Stage	access:public
nu	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      nu; \/\/ for CV_SVM_NU_SVC, CV_SVM_ONE_CLASS, and CV_SVM_NU_SVR$/;"	m	struct:CvSVMParams	access:public
nu02	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu03	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu11	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu12	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu20	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu21	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu30	/usr/include/opencv2/imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
numIters	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
numPartsWithin	/usr/include/opencv2/gpu/gpu.hpp	/^            static Size numPartsWithin(Size size, Size part_size, Size stride);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(Size size, Size part_size, Size stride)
numPartsWithin	/usr/include/opencv2/gpu/gpu.hpp	/^            static int numPartsWithin(int size, int part_size, int stride);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(int size, int part_size, int stride)
numShifts	/usr/include/opencv2/contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
numTrees	/usr/include/opencv2/flann/kdtree_index.h	/^	int numTrees;$/;"	m	class:cvflann::KDTreeIndex	access:private
num_cam_param	/usr/include/opencv2/contrib/contrib.hpp	/^        int num_cam_param;$/;"	m	class:cv::LevMarqSparse	access:protected
num_cams	/usr/include/opencv2/contrib/contrib.hpp	/^        int num_cams;$/;"	m	class:cv::LevMarqSparse	access:protected
num_components	/usr/include/opencv2/objdetect/objdetect.hpp	/^	int num_components;$/;"	m	struct:CvLatentSvmDetector	access:public
num_err_param	/usr/include/opencv2/contrib/contrib.hpp	/^        int num_err_param;$/;"	m	class:cv::LevMarqSparse	access:protected
num_filters	/usr/include/opencv2/objdetect/objdetect.hpp	/^	int num_filters;$/;"	m	struct:CvLatentSvmDetector	access:public
num_leaves_	/usr/include/opencv2/features2d/features2d.hpp	/^  int num_leaves_;$/;"	m	class:cv::RandomizedTree	access:private
num_mix	/usr/include/opencv2/legacy/legacy.hpp	/^    int num_mix;        \/*number of mixtures in this state*\/$/;"	m	struct:CvEHMMState	access:public
num_part_filters	/usr/include/opencv2/objdetect/objdetect.hpp	/^	int* num_part_filters;$/;"	m	struct:CvLatentSvmDetector	access:public
num_point_param	/usr/include/opencv2/contrib/contrib.hpp	/^        int num_point_param;$/;"	m	class:cv::LevMarqSparse	access:protected
num_points	/usr/include/opencv2/contrib/contrib.hpp	/^        int num_points;$/;"	m	class:cv::LevMarqSparse	access:protected
num_quant_bits_	/usr/include/opencv2/features2d/features2d.hpp	/^  int num_quant_bits_;$/;"	m	class:cv::RTreeClassifier	access:private
num_states	/usr/include/opencv2/legacy/legacy.hpp	/^    int num_states; \/* number of HMM states *\/$/;"	m	struct:CvEHMM	access:public
num_valid	/usr/include/opencv2/ml/ml.hpp	/^    int* num_valid;$/;"	m	struct:CvDTreeNode	access:public
numberOfAngles	/usr/include/opencv2/contrib/contrib.hpp	/^        int numberOfAngles;$/;"	m	class:cv::SelfSimDescriptor	access:public
numberOfDisparities	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int numberOfDisparities;$/;"	m	class:cv::StereoSGBM	access:public
numberOfDisparities	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int numberOfDisparities; \/\/ maximum disparity - minimum disparity (> 0)$/;"	m	struct:CvStereoBMState	access:public
numberOfDisparities	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int numberOfDisparities;$/;"	m	struct:CvStereoGCState	access:public
numberOfDistanceBuckets	/usr/include/opencv2/contrib/contrib.hpp	/^        int numberOfDistanceBuckets;$/;"	m	class:cv::SelfSimDescriptor	access:public
nv_heap	/usr/include/opencv2/ml/ml.hpp	/^    CvSet* nv_heap;$/;"	m	struct:CvDTreeTrainData	access:public
nviews	/usr/include/opencv2/features2d/features2d.hpp	/^        int nviews;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
nzcount	/usr/include/opencv2/core/core.hpp	/^    size_t nzcount() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
nzcount	/usr/include/opencv2/core/mat.hpp	/^inline size_t SparseMat::nzcount() const$/;"	f	class:cv::SparseMat	signature:() const
obj	/usr/include/opencv2/core/core.hpp	/^    _Tp* obj; \/\/< the object pointer.$/;"	m	class:cv::Ptr	access:protected
obj	/usr/include/opencv2/ml/ml.hpp	/^    double obj;$/;"	m	struct:CvSVMSolutionInfo	access:public
object_registry	/usr/include/opencv2/flann/object_factory.h	/^	std::map<UniqueIdType, CreateObjectFunc> object_registry;$/;"	m	class:cvflann::ObjectFactory	access:private
obs	/usr/include/opencv2/legacy/legacy.hpp	/^    float* obs;\/\/consequtive observations$/;"	m	struct:CvImgObsInfo	access:public
obsProb	/usr/include/opencv2/legacy/legacy.hpp	/^    float** obsProb; \/* if level == 0 - array of brob matrices corresponding to hmm$/;"	m	struct:CvEHMM	access:public
obs_info	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(void)  cvReleaseObsInfo( CvImgObsInfo** obs_info );$/;"	v
obs_size	/usr/include/opencv2/legacy/legacy.hpp	/^    int obs_size;$/;"	m	struct:CvImgObsInfo	access:public
obs_x	/usr/include/opencv2/legacy/legacy.hpp	/^    int obs_x;$/;"	m	struct:CvImgObsInfo	access:public
obs_y	/usr/include/opencv2/legacy/legacy.hpp	/^    int obs_y;$/;"	m	struct:CvImgObsInfo	access:public
occlusionCost	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int occlusionCost;$/;"	m	struct:CvStereoGCState	access:public
octave	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW int octave; \/\/!< octave (pyramid layer) from which the keypoint has been extracted$/;"	m	class:cv::KeyPoint	access:public
octree	/usr/include/opencv2/contrib/contrib.hpp	/^        Octree octree;$/;"	m	class:cv::Mesh3D	access:public
offset	/usr/include/opencv2/ml/ml.hpp	/^    int offset;$/;"	m	struct:CvDTreeNode	access:public
offset1	/usr/include/opencv2/features2d/features2d.hpp	/^  short offset1, offset2;$/;"	m	struct:cv::RTreeNode	access:public
offset2	/usr/include/opencv2/features2d/features2d.hpp	/^  short offset1, offset2;$/;"	m	struct:cv::RTreeNode	access:public
oldCascade	/usr/include/opencv2/objdetect/objdetect.hpp	/^    Ptr<CvHaarClassifierCascade> oldCascade;$/;"	m	class:cv::CascadeClassifier	access:public
old_state	/usr/include/opencv2/features2d/features2d.hpp	/^        const uint64 old_state;$/;"	m	struct:cv::DefaultRngAuto	access:public
on_postprocess	/usr/include/opencv2/highgui/highgui_c.h	/^CVAPI(void) cvSetPostprocessFuncWin32( CvWin32WindowCallback on_postprocess );$/;"	v
on_preprocess	/usr/include/opencv2/highgui/highgui_c.h	/^CVAPI(void) cvSetPreprocessFuncWin32( CvWin32WindowCallback on_preprocess );$/;"	v
ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(int ndims, const int* sz, int type);$/;"	p	class:cv::Mat	access:public	signature:(int ndims, const int* sz, int type)
ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
ones	/usr/include/opencv2/core/core.hpp	/^    static MatExpr ones(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
ones	/usr/include/opencv2/core/core.hpp	/^    static Matx ones();$/;"	p	class:cv::Matx	access:public	signature:()
ones	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
ones	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
ones	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::ones()$/;"	f	class:cv::Matx	signature:()
oob_error	/usr/include/opencv2/ml/ml.hpp	/^    double oob_error;$/;"	m	class:CvRTrees	access:protected
op	/usr/include/opencv2/core/mat.hpp	/^    const MatOp* op;$/;"	m	class:cv::MatExpr	access:public
open	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP virtual bool open(const string& filename, int flags);$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename, int flags)
open	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool open(const string& filename);$/;"	p	class:cv::VideoCapture	access:public	signature:(const string& filename)
open	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool open(const string& filename, int fourcc, double fps,$/;"	p	class:cv::VideoWriter	access:public	signature:(const string& filename, int fourcc, double fps, Size frameSize, bool isColor=true)
open	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool open(int device);$/;"	p	class:cv::VideoCapture	access:public	signature:(int device)
operator !	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator !(const Range& r)$/;"	f	namespace:cv	signature:(const Range& r)
operator !=	/usr/include/opencv2/core/core.hpp	/^        bool operator != (const MSize& sz) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(const MSize& sz) const
operator !=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator != (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator !=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator != (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator !=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator != (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator !=	/usr/include/opencv2/core/mat.hpp	/^inline bool Mat::MSize::operator != (const MSize& sz) const$/;"	f	class:cv::Mat::MSize	signature:(const MSize& sz) const
operator !=	/usr/include/opencv2/core/mat.hpp	/^operator != (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator !=	/usr/include/opencv2/core/mat.hpp	/^operator != (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
operator !=	/usr/include/opencv2/core/mat.hpp	/^operator != (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
operator !=	/usr/include/opencv2/core/mat.hpp	/^static inline bool operator != (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)$/;"	f	namespace:cv	signature:(const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
operator !=	/usr/include/opencv2/core/operations.hpp	/^bool operator != (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator !=	/usr/include/opencv2/core/operations.hpp	/^bool operator != (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
operator !=	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator != (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
operator !=	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator != (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool operator != (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator != ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )$/;"	f	namespace:cv	signature:( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
operator !=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
operator &	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator &	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator &	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
operator &	/usr/include/opencv2/core/operations.hpp	/^static inline Range operator & (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
operator &	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator & (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
operator &	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS GpuMat operator & (const GpuMat& src1, const GpuMat& src2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2)
operator &=	/usr/include/opencv2/core/mat.hpp	/^operator &= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator &=	/usr/include/opencv2/core/mat.hpp	/^operator &= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
operator &=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator &= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator &=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator &= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator &=	/usr/include/opencv2/core/operations.hpp	/^static inline Range& operator &= (Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(Range& r1, const Range& r2)
operator &=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator &= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Rect_<_Tp>& b )
operator ()	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP_AS(compute) virtual void operator()(const Mat& left, const Mat& right, Mat& disp);$/;"	p	class:cv::StereoSGBM	access:public	signature:(const Mat& left, const Mat& right, Mat& disp)
operator ()	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_WRAP_AS(compute) void operator()( const Mat& left, const Mat& right, Mat& disparity, int disptype=CV_16S );$/;"	p	class:cv::StereoBM	access:public	signature:( const Mat& left, const Mat& right, Mat& disparity, int disptype=CV_16S )
operator ()	/usr/include/opencv2/core/core.hpp	/^	unsigned operator ()();$/;"	p	class:cv::RNG	access:public	signature:()
operator ()	/usr/include/opencv2/core/core.hpp	/^	unsigned operator()(unsigned N);$/;"	p	class:cv::RNG	access:public	signature:(unsigned N)
operator ()	/usr/include/opencv2/core/core.hpp	/^        Size operator()() const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:() const
operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat operator()( Range rowRange, Range colRange ) const;$/;"	p	class:cv::Mat	access:public	signature:( Range rowRange, Range colRange ) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat operator()( const Range* ranges ) const;$/;"	p	class:cv::Mat	access:public	signature:( const Range* ranges ) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat operator()( const Rect& roi ) const;$/;"	p	class:cv::Mat	access:public	signature:( const Rect& roi ) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat_ operator()( const Range& rowRange, const Range& colRange ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Range& rowRange, const Range& colRange ) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat_ operator()( const Range* ranges ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Range* ranges ) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    Mat_ operator()( const Rect& roi ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Rect& roi ) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    PCA& operator()(const Mat& data, const Mat& mean, int flags, int maxComponents=0);$/;"	p	class:cv::PCA	access:public	signature:(const Mat& data, const Mat& mean, int flags, int maxComponents=0)
operator ()	/usr/include/opencv2/core/core.hpp	/^    SVD& operator ()( const Mat& src, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( const Mat& src, int flags=0 )
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp operator()(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(const int* idx, size_t* hashval=0) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp operator()(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp operator()(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, size_t* hashval=0) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp operator()(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, size_t* hashval=0) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(Point pt);$/;"	p	class:cv::Mat_	access:public	signature:(Point pt)
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(const int* idx);$/;"	p	class:cv::Mat_	access:public	signature:(const int* idx)
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int i);$/;"	p	class:cv::Matx	access:public	signature:(int i)
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int i);$/;"	p	class:cv::Vec	access:public	signature:(int i)
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int i, int j);$/;"	p	class:cv::Matx	access:public	signature:(int i, int j)
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int idx0);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0)
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int idx0, int idx1);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1)
operator ()	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator ()(int idx0, int idx1, int idx2);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1, int idx2)
operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(Point pt) const;$/;"	p	class:cv::Mat_	access:public	signature:(Point pt) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(const int* idx) const;$/;"	p	class:cv::Mat_	access:public	signature:(const int* idx) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int i) const;$/;"	p	class:cv::Vec	access:public	signature:(int i) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int i, int j) const;$/;"	p	class:cv::Matx	access:public	signature:(int i, int j) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int idx0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int idx0, int idx1) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator ()(int idx0, int idx1, int idx2) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1, int idx2) const
operator ()	/usr/include/opencv2/core/core.hpp	/^    template<int n> _Tp& operator ()(const Vec<int, n>& idx);$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<int, n>& idx)
operator ()	/usr/include/opencv2/core/core.hpp	/^    template<int n> const _Tp& operator ()(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<int, n>& idx) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^    MatExpr operator()( const Range& rowRange, const Range& colRange ) const;$/;"	p	class:cv::MatExpr	access:public	signature:( const Range& rowRange, const Range& colRange ) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^    MatExpr operator()( const Rect& roi ) const;$/;"	p	class:cv::MatExpr	access:public	signature:( const Rect& roi ) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator()(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(const int* idx, size_t* hashval) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, int i2, size_t* hashval) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, size_t* hashval) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, size_t* hashval) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::operator()( Range rowRange, Range colRange ) const$/;"	f	class:cv::Mat	signature:( Range rowRange, Range colRange ) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::operator()( const Rect& roi ) const$/;"	f	class:cv::Mat	signature:( const Rect& roi ) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::operator()(const Range* ranges) const$/;"	f	class:cv::Mat	signature:(const Range* ranges) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^inline Size Mat::MSize::operator()() const$/;"	f	class:cv::Mat::MSize	signature:() const
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range& rowRange, const Range& colRange ) const$/;"	f	class:cv::Mat_	signature:( const Range& rowRange, const Range& colRange ) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range* ranges ) const$/;"	f	class:cv::Mat_	signature:( const Range* ranges ) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Rect& roi ) const$/;"	f	class:cv::Mat_	signature:( const Rect& roi ) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(Point pt)$/;"	f	class:cv::Mat_	signature:(Point pt)
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(const int* idx)$/;"	f	class:cv::Mat_	signature:(const int* idx)
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0)$/;"	f	class:cv::Mat_	signature:(int i0)
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1)$/;"	f	class:cv::Mat_	signature:(int i0, int i1)
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2)$/;"	f	class:cv::Mat_	signature:(int i0, int i1, int i2)
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(Point pt) const$/;"	f	class:cv::Mat_	signature:(Point pt) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(const int* idx) const$/;"	f	class:cv::Mat_	signature:(const int* idx) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0) const$/;"	f	class:cv::Mat_	signature:(int i0) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1) const$/;"	f	class:cv::Mat_	signature:(int i0, int i1) const
operator ()	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2) const$/;"	f	class:cv::Mat_	signature:(int i0, int i1, int i2) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    Vector operator() (const Range& r) const { return Vector(*this, r); }$/;"	f	class:cv::Vector	access:public	signature:(const Range& r) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, 2, 2>& a, Matx<_Tp, 2, 2>& b, int) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, 2, 2>& a, Matx<_Tp, 2, 2>& b, int) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, 2, 2>& a, const Matx<_Tp, 2, 1>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, 2, 2>& a, const Matx<_Tp, 2, 1>& b, Matx<_Tp, 2, 1>& x, int method) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, 3, 3>& a, Matx<_Tp, 3, 3>& b, int) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, 3, 3>& a, Matx<_Tp, 3, 3>& b, int) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, 3, 3>& a, const Matx<_Tp, 3, 1>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, 3, 3>& a, const Matx<_Tp, 3, 1>& b, Matx<_Tp, 3, 1>& x, int method) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, m, m>& a, Matx<_Tp, m, m>& b, int method) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, m, m>& a, Matx<_Tp, m, m>& b, int method) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const Matx<_Tp, m, m>& a, const Matx<_Tp, m, n>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, m, m>& a, const Matx<_Tp, m, n>& b, Matx<_Tp, m, n>& x, int method) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const _Tp& a, const _Tp& b) const { return a < b; }$/;"	f	class:cv::LessThan	access:public	signature:(const _Tp& a, const _Tp& b) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(const _Tp& a, const _Tp& b) const { return a >= b; }$/;"	f	class:cv::GreaterEq	access:public	signature:(const _Tp& a, const _Tp& b) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(int a, int b) const { return arr[a] < arr[b]; }$/;"	f	class:cv::LessThanIdx	access:public	signature:(int a, int b) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    bool operator()(int a, int b) const { return arr[a] >= arr[b]; }$/;"	f	class:cv::GreaterEqIdx	access:public	signature:(int a, int b) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    double operator ()(const Matx<_Tp, 1, 1>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 1, 1>& a) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    double operator ()(const Matx<_Tp, 2, 2>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 2, 2>& a) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    double operator ()(const Matx<_Tp, 3, 3>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 3, 3>& a) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    double operator ()(const Matx<_Tp, m, m>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, m, m>& a) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    void operator()(const vector<_Tp>& vec) const$/;"	f	class:cv::VecWriterProxy	access:public	signature:(const vector<_Tp>& vec) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^    void operator()(vector<_Tp>& vec, size_t count) const$/;"	f	class:cv::VecReaderProxy	access:public	signature:(vector<_Tp>& vec, size_t count) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^_Tp& Matx<_Tp, m, n>::operator ()(int i)$/;"	f	class:cv::Matx	signature:(int i)
operator ()	/usr/include/opencv2/core/operations.hpp	/^_Tp& Matx<_Tp, m, n>::operator ()(int i, int j)$/;"	f	class:cv::Matx	signature:(int i, int j)
operator ()	/usr/include/opencv2/core/operations.hpp	/^const _Tp& Matx<_Tp, m, n>::operator ()(int i) const$/;"	f	class:cv::Matx	signature:(int i) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^const _Tp& Matx<_Tp, m, n>::operator ()(int i, int j) const$/;"	f	class:cv::Matx	signature:(int i, int j) const
operator ()	/usr/include/opencv2/core/operations.hpp	/^inline unsigned RNG::operator ()() {return next();}$/;"	f	class:cv::RNG	signature:()
operator ()	/usr/include/opencv2/core/operations.hpp	/^inline unsigned RNG::operator ()(unsigned N) {return (unsigned)uniform(0,N);}$/;"	f	class:cv::RNG	signature:(unsigned N)
operator ()	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator ()(int i)$/;"	f	class:cv::Vec	signature:(int i)
operator ()	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator ()(int i) const$/;"	f	class:cv::Vec	signature:(int i) const
operator ()	/usr/include/opencv2/core/wimage.hpp	/^    inline T* operator() (int c, int r)  {$/;"	f	class:cv::WImage	access:public	signature:(int c, int r)
operator ()	/usr/include/opencv2/core/wimage.hpp	/^    inline const T* operator() (int c, int r) const  {$/;"	f	class:cv::WImage	access:public	signature:(int c, int r) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^        template<typename _Tp> bool operator ()(const Mat_<_Tp>& patch) const$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:(const Mat_<_Tp>& patch) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()( const Mat& image,$/;"	p	class:cv::MSER	access:public	signature:( const Mat& image, CV_OUT vector<vector<Point> >& msers, const Mat& mask ) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& image,$/;"	p	class:cv::StarDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SURF	access:public	signature:(const Mat& img, const Mat& mask, CV_OUT vector<KeyPoint>& keypoints) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SURF	access:public	signature:(const Mat& img, const Mat& mask, CV_OUT vector<KeyPoint>& keypoints, CV_OUT vector<float>& descriptors, bool useProvidedKeypoints=false) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    ResultType operator()( const T* a, const T* b, int size ) const$/;"	f	struct:cv::L1	access:public	signature:( const T* a, const T* b, int size ) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    ResultType operator()( const T* a, const T* b, int size ) const$/;"	f	struct:cv::L2	access:public	signature:( const T* a, const T* b, int size ) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    ResultType operator()( const unsigned char* a, const unsigned char* b, int size ) const;$/;"	p	struct:cv::HammingLUT	access:public	signature:( const unsigned char* a, const unsigned char* b, int size ) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    ResultType operator()(const unsigned char* a, const unsigned char* b, int size) const;$/;"	p	struct:cv::Hamming	access:public	signature:(const unsigned char* a, const unsigned char* b, int size) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    bool operator()(const Mat& image, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners) const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const Mat& image, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    bool operator()(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners, CV_OUT vector<int>* pairs=0) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int operator()(const Mat& img, Point2f kpt, vector<float>& signature) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& img, Point2f kpt, vector<float>& signature) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual int operator()(const Mat& patch, vector<float>& signature) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& patch, vector<float>& signature) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const Mat& image, Point2f pt, Mat& patch, Size patchSize, RNG& rng) const;$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, Point2f pt, Mat& patch, Size patchSize, RNG& rng) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const Mat& image, const Mat& transform, Mat& patch,$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, const Mat& transform, Mat& patch, Size patchSize, RNG& rng) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const Mat& image,$/;"	p	class:cv::LDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int maxCount=0, bool scaleCoords=true) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SIFT	access:public	signature:(const Mat& img, const Mat& mask, vector<KeyPoint>& keypoints) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SIFT	access:public	signature:(const Mat& img, const Mat& mask, vector<KeyPoint>& keypoints, Mat& descriptors, bool useProvidedKeypoints=false) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^    void operator()(const vector<Mat>& pyr,$/;"	p	class:cv::LDetector	access:public	signature:(const vector<Mat>& pyr, CV_OUT vector<KeyPoint>& keypoints, int maxCount=0, bool scaleCoords=true) const
operator ()	/usr/include/opencv2/features2d/features2d.hpp	/^  inline bool operator() (uchar* patch_data) const$/;"	f	struct:cv::RTreeNode	access:public	signature:(uchar* patch_data) const
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat operator()( Range rowRange, Range colRange ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( Range rowRange, Range colRange ) const
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat operator()( const Rect& roi ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( const Rect& roi ) const
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst) = 0;$/;"	p	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst) = 0;$/;"	p	class:cv::gpu::BaseFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst) = 0;$/;"	p	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator() ( const GpuMat& left, const GpuMat& right, GpuMat& disparity);$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:( const GpuMat& left, const GpuMat& right, GpuMat& disparity)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator() ( const GpuMat& left, const GpuMat& right, GpuMat& disparity, const Stream & stream);$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:( const GpuMat& left, const GpuMat& right, GpuMat& disparity, const Stream & stream)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& data, GpuMat& disparity);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& data, GpuMat& disparity)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& data, GpuMat& disparity, Stream& stream);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& data, GpuMat& disparity, Stream& stream)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& disparity, const GpuMat& image, GpuMat& dst);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(const GpuMat& disparity, const GpuMat& image, GpuMat& dst)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& disparity, const GpuMat& image, GpuMat& dst, Stream& stream);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(const GpuMat& disparity, const GpuMat& image, GpuMat& dst, Stream& stream)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity);$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream)
operator ()	/usr/include/opencv2/gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream);$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream)
operator ()	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::operator()( Range rowRange, Range colRange ) const { return GpuMat(*this, rowRange, colRange); }$/;"	f	class:cv::gpu::GpuMat	signature:( Range rowRange, Range colRange ) const
operator ()	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::operator()( const Rect& roi ) const { return GpuMat(*this, roi); }$/;"	f	class:cv::gpu::GpuMat	signature:( const Rect& roi ) const
operator ()	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void operator()(const uchar* src, uchar* dst,$/;"	p	class:cv::BaseRowFilter	access:public	signature:(const uchar* src, uchar* dst, int width, int cn)
operator ()	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void operator()(const uchar** src, uchar* dst, int dststep,$/;"	p	class:cv::BaseColumnFilter	access:public	signature:(const uchar** src, uchar* dst, int dststep, int dstcount, int width)
operator ()	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void operator()(const uchar** src, uchar* dst, int dststep,$/;"	p	class:cv::BaseFilter	access:public	signature:(const uchar** src, uchar* dst, int dststep, int dstcount, int width, int cn)
operator ()	/usr/include/opencv2/video/background_segm.hpp	/^    CV_WRAP_AS(apply) virtual void operator()(const Mat& image, CV_OUT Mat& fgmask,$/;"	p	class:cv::BackgroundSubtractor	access:public	signature:(const Mat& image, CV_OUT Mat& fgmask, double learningRate=0)
operator ()	/usr/include/opencv2/video/background_segm.hpp	/^    virtual void operator()(const Mat& image, Mat& fgmask, double learningRate=0);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(const Mat& image, Mat& fgmask, double learningRate=0)
operator *	/usr/include/opencv2/core/core.hpp	/^    CvFileNode* operator *();$/;"	p	class:cv::FileNode	access:public	signature:()
operator *	/usr/include/opencv2/core/core.hpp	/^    CvFileStorage* operator *() { return fs; }$/;"	f	class:cv::FileStorage	access:public	signature:()
operator *	/usr/include/opencv2/core/core.hpp	/^    FileNode operator *() const;$/;"	p	class:cv::FileNodeIterator	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    Mat_<_Tp> operator *() const;$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, m, n> operator *() const;$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    Vec<_Tp, m> operator *() const;$/;"	p	class:cv::VecCommaInitializer	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    _Tp operator *() const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator *() const;$/;"	p	class:cv::MatIterator_	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator *() const;$/;"	p	class:cv::SparseMatIterator_	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator *();$/;"	p	class:cv::SeqIterator	access:public	signature:()
operator *	/usr/include/opencv2/core/core.hpp	/^    const CvFileNode* operator* () const;$/;"	p	class:cv::FileNode	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    const CvFileStorage* operator *() const { return fs; }$/;"	f	class:cv::FileStorage	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator *() const;$/;"	p	class:cv::SeqIterator	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator *() const;$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    uchar* operator *() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
operator *	/usr/include/opencv2/core/core.hpp	/^    uchar* operator *();$/;"	p	class:cv::LineIterator	access:public	signature:()
operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e, double s);$/;"	p	namespace:cv	signature:(const MatExpr& e, double s)
operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator *	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator * (double s, const MatExpr& e);$/;"	p	namespace:cv	signature:(double s, const MatExpr& e)
operator *	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator *() const$/;"	f	class:cv::SparseMatConstIterator_	signature:() const
operator *	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::operator *() const$/;"	f	class:cv::SparseMatIterator_	signature:() const
operator *	/usr/include/opencv2/core/mat.hpp	/^inline uchar* MatConstIterator::operator *() const { return ptr; }$/;"	f	class:cv::MatConstIterator	signature:() const
operator *	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> MatCommaInitializer_<_Tp>::operator *() const$/;"	f	class:cv::MatCommaInitializer_	signature:() const
operator *	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }$/;"	f	class:cv::MatConstIterator_	signature:() const
operator *	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }$/;"	f	class:cv::MatIterator_	signature:() const
operator *	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator * (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
operator *	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator * (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
operator *	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator * (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, 4, 1> operator * (const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> MatxCommaInitializer<_Tp, m, n>::operator *() const$/;"	f	class:cv::MatxCommaInitializer	signature:() const
operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, double alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, double alpha)
operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, float alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, float alpha)
operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, int alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, int alpha)
operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (double alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(double alpha, const Matx<_Tp, m, n>& a)
operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (float alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(float alpha, const Matx<_Tp, m, n>& a)
operator *	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator * (int alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(int alpha, const Matx<_Tp, m, n>& a)
operator *	/usr/include/opencv2/core/operations.hpp	/^Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^Point_<_Tp> operator * (const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^Scalar operator * (const Matx<_Tp, 4, 4>& a, const Scalar& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 4, 4>& a, const Scalar& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^Vec<_Tp, cn> VecCommaInitializer<_Tp, cn>::operator *() const$/;"	f	class:cv::VecCommaInitializer	signature:() const
operator *	/usr/include/opencv2/core/operations.hpp	/^inline CvFileNode* FileNode::operator *() { return (CvFileNode*)node; }$/;"	f	class:cv::FileNode	signature:()
operator *	/usr/include/opencv2/core/operations.hpp	/^inline FileNode FileNodeIterator::operator *() const$/;"	f	class:cv::FileNodeIterator	signature:() const
operator *	/usr/include/opencv2/core/operations.hpp	/^inline const CvFileNode* FileNode::operator* () const { return node; }$/;"	f	class:cv::FileNode	signature:() const
operator *	/usr/include/opencv2/core/operations.hpp	/^inline uchar* LineIterator::operator *() { return ptr; }$/;"	f	class:cv::LineIterator	signature:()
operator *	/usr/include/opencv2/core/operations.hpp	/^operator * (_Tp alpha, const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(_Tp alpha, const Vec<_Tp, cn>& a)
operator *	/usr/include/opencv2/core/operations.hpp	/^operator * (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^operator * (const Vec<_Tp, 4>& a, const Vec<_Tp, 4>& b)$/;"	f	namespace:cv	signature:(const Vec<_Tp, 4>& a, const Vec<_Tp, 4>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^operator * (const Vec<_Tp, cn>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, _Tp alpha)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp& SeqIterator<_Tp>::operator *()$/;"	f	class:cv::SeqIterator	signature:()
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline const _Tp& SeqIterator<_Tp>::operator *() const$/;"	f	class:cv::SeqIterator	signature:() const
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, double b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, float b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, int b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (double a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(double a, const Point3_<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (float a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(float a, const Point3_<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (int a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(int a, const Point3_<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, double b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, float b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, int b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (double a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(double a, const Point_<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (float a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(float a, const Point_<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (int a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(int a, const Point_<_Tp>& b)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp alpha, const Scalar_<_Tp>& a)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, _Tp alpha)
operator *	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator * (const Size_<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, _Tp b)
operator *	/usr/include/opencv2/flann/dist.h	/^	T operator*() {$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:()
operator *=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
operator *=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator *=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
operator *=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator *=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
operator *=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, double s)$/;"	f	namespace:cv	signature:(const Mat& a, double s)
operator *=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator *= (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
operator *=	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, double alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, double alpha)
operator *=	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, float alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, float alpha)
operator *=	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, int alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, int alpha)
operator *=	/usr/include/opencv2/core/operations.hpp	/^Vec<_Tp, 2>& operator *= (Vec<_Tp, 2>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, 2>& a, _Tp alpha)
operator *=	/usr/include/opencv2/core/operations.hpp	/^Vec<_Tp, 3>& operator *= (Vec<_Tp, 3>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, 3>& a, _Tp alpha)
operator *=	/usr/include/opencv2/core/operations.hpp	/^Vec<_Tp, 4>& operator *= (Vec<_Tp, 4>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, 4>& a, _Tp alpha)
operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point3_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, double b)
operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point3_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, float b)
operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point3_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, int b)
operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, double b)
operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, float b)
operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Point_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, int b)
operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator *=	/usr/include/opencv2/core/operations.hpp	/^operator *= (Vec<_Tp, 4>& a, const Vec<_Tp, 4>& b)$/;"	f	namespace:cv	signature:(Vec<_Tp, 4>& a, const Vec<_Tp, 4>& b)
operator *=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator *= ( Scalar_<_Tp>& a, _Tp v )$/;"	f	namespace:cv	signature:( Scalar_<_Tp>& a, _Tp v )
operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e, const Scalar& s);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Scalar& s)
operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
operator +	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Scalar& s, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Scalar& s, const MatExpr& e)
operator +	/usr/include/opencv2/core/mat.hpp	/^operator + (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
operator +	/usr/include/opencv2/core/mat.hpp	/^operator + (const MatIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, ptrdiff_t ofs)
operator +	/usr/include/opencv2/core/mat.hpp	/^operator + (ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)
operator +	/usr/include/opencv2/core/mat.hpp	/^operator + (ptrdiff_t ofs, const MatIterator_<_Tp>& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatIterator_<_Tp>& a)
operator +	/usr/include/opencv2/core/mat.hpp	/^static inline MatConstIterator operator + (const MatConstIterator& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, ptrdiff_t ofs)
operator +	/usr/include/opencv2/core/mat.hpp	/^static inline MatConstIterator operator + (ptrdiff_t ofs, const MatConstIterator& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatConstIterator& a)
operator +	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator + (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
operator +	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator + (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
operator +	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator + (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator +	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator + (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
operator +	/usr/include/opencv2/core/operations.hpp	/^operator + (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
operator +	/usr/include/opencv2/core/operations.hpp	/^static inline Range operator + (const Range& r1, int delta)$/;"	f	namespace:cv	signature:(const Range& r1, int delta)
operator +	/usr/include/opencv2/core/operations.hpp	/^static inline Range operator + (int delta, const Range& r1)$/;"	f	namespace:cv	signature:(int delta, const Range& r1)
operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator + (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator + (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Point_<_Tp>& b)
operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Size_<_Tp>& b)
operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator + (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator +	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator + (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
operator ++	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator operator ++ (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
operator ++	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator& operator ++ ();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
operator ++	/usr/include/opencv2/core/core.hpp	/^    LineIterator operator ++(int);$/;"	p	class:cv::LineIterator	access:public	signature:(int)
operator ++	/usr/include/opencv2/core/core.hpp	/^    LineIterator& operator ++();$/;"	p	class:cv::LineIterator	access:public	signature:()
operator ++	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator operator ++(int);$/;"	p	class:cv::MatConstIterator	access:public	signature:(int)
operator ++	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator& operator ++();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
operator ++	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_ operator ++(int);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(int)
operator ++	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_& operator ++();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
operator ++	/usr/include/opencv2/core/core.hpp	/^    MatIterator_ operator ++(int);$/;"	p	class:cv::MatIterator_	access:public	signature:(int)
operator ++	/usr/include/opencv2/core/core.hpp	/^    MatIterator_& operator ++();$/;"	p	class:cv::MatIterator_	access:public	signature:()
operator ++	/usr/include/opencv2/core/core.hpp	/^    NAryMatIterator operator ++(int);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(int)
operator ++	/usr/include/opencv2/core/core.hpp	/^    NAryMatIterator& operator ++();$/;"	p	class:cv::NAryMatIterator	access:public	signature:()
operator ++	/usr/include/opencv2/core/core.hpp	/^    SeqIterator operator ++(int) const;$/;"	p	class:cv::SeqIterator	access:public	signature:(int) const
operator ++	/usr/include/opencv2/core/core.hpp	/^    SeqIterator& operator ++();$/;"	p	class:cv::SeqIterator	access:public	signature:()
operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator operator ++(int);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(int)
operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator& operator ++();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_ operator ++(int);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(int)
operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_& operator ++();$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:()
operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator operator ++(int);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(int)
operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator& operator ++();$/;"	p	class:cv::SparseMatIterator	access:public	signature:()
operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_ operator ++(int);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(int)
operator ++	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_& operator ++();$/;"	p	class:cv::SparseMatIterator_	access:public	signature:()
operator ++	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator ++()$/;"	f	class:cv::SparseMatConstIterator_	signature:()
operator ++	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::SparseMatConstIterator_	signature:(int)
operator ++	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::operator ++()$/;"	f	class:cv::SparseMatIterator_	signature:()
operator ++	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::SparseMatIterator_	signature:(int)
operator ++	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator MatConstIterator::operator ++(int)$/;"	f	class:cv::MatConstIterator	signature:(int)
operator ++	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator ++()$/;"	f	class:cv::MatConstIterator	signature:()
operator ++	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator SparseMatConstIterator::operator ++(int)$/;"	f	class:cv::SparseMatConstIterator	signature:(int)
operator ++	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator SparseMatIterator::operator ++(int)$/;"	f	class:cv::SparseMatIterator	signature:(int)
operator ++	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator& SparseMatIterator::operator ++()$/;"	f	class:cv::SparseMatIterator	signature:()
operator ++	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::MatConstIterator_	signature:(int)
operator ++	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator ++()$/;"	f	class:cv::MatConstIterator_	signature:()
operator ++	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::MatIterator_	signature:(int)
operator ++	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator ++()$/;"	f	class:cv::MatIterator_	signature:()
operator ++	/usr/include/opencv2/core/operations.hpp	/^inline LineIterator LineIterator::operator ++(int)$/;"	f	class:cv::LineIterator	signature:(int)
operator ++	/usr/include/opencv2/core/operations.hpp	/^inline LineIterator& LineIterator::operator ++()$/;"	f	class:cv::LineIterator	signature:()
operator ++	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator ++(int) const$/;"	f	class:cv::SeqIterator	signature:(int) const
operator ++	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator ++()$/;"	f	class:cv::SeqIterator	signature:()
operator ++	/usr/include/opencv2/flann/dist.h	/^	ZeroIterator<T>& operator ++(int) {$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
operator +=	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator& operator += (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
operator +=	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs)
operator +=	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t ofs)
operator +=	/usr/include/opencv2/core/core.hpp	/^    MatIterator_& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t ofs)
operator +=	/usr/include/opencv2/core/core.hpp	/^    SeqIterator& operator +=(int);$/;"	p	class:cv::SeqIterator	access:public	signature:(int)
operator +=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
operator +=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator +=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
operator +=	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t ofs)
operator +=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator +=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
operator +=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator +=	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t ofs)
operator +=	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t ofs)
operator +=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator += (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
operator +=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator += (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
operator +=	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp1, m, n>& operator += (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)$/;"	f	namespace:cv	signature:(Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
operator +=	/usr/include/opencv2/core/operations.hpp	/^Vec<T1, 2>& operator += (Vec<T1, 2>& a, const Vec<T2, 2>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 2>& a, const Vec<T2, 2>& b)
operator +=	/usr/include/opencv2/core/operations.hpp	/^Vec<T1, 3>& operator += (Vec<T1, 3>& a, const Vec<T2, 3>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 3>& a, const Vec<T2, 3>& b)
operator +=	/usr/include/opencv2/core/operations.hpp	/^Vec<T1, 4>& operator += (Vec<T1, 4>& a, const Vec<T2, 4>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 4>& a, const Vec<T2, 4>& b)
operator +=	/usr/include/opencv2/core/operations.hpp	/^operator += (Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator +=	/usr/include/opencv2/core/operations.hpp	/^operator += (Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, const Point_<_Tp>& b)
operator +=	/usr/include/opencv2/core/operations.hpp	/^operator += (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)$/;"	f	namespace:cv	signature:(Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
operator +=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator +=(int delta)$/;"	f	class:cv::SeqIterator	signature:(int delta)
operator +=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Point_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Point_<_Tp>& b )
operator +=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Size_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Size_<_Tp>& b )
operator +=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator += (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator +=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp>& operator += (Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(Size_<_Tp>& a, const Size_<_Tp>& b)
operator +=	/usr/include/opencv2/flann/dist.h	/^	ZeroIterator<T>& operator+=(int) {$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
operator ,	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> MatCommaInitializer_<_Tp>& operator , (T2 v);$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:(T2 v)
operator ,	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> MatxCommaInitializer<_Tp, m, n>& operator , (T2 val);$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:(T2 val)
operator ,	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> VecCommaInitializer<_Tp, m>& operator , (T2 val);$/;"	p	class:cv::VecCommaInitializer	access:public	signature:(T2 val)
operator ,	/usr/include/opencv2/core/mat.hpp	/^MatCommaInitializer_<_Tp>::operator , (T2 v)$/;"	f	class:cv::MatCommaInitializer_	signature:(T2 v)
operator ,	/usr/include/opencv2/core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n>& MatxCommaInitializer<_Tp, m, n>::operator , (_T2 value)$/;"	f	class:cv::MatxCommaInitializer	signature:(_T2 value)
operator ,	/usr/include/opencv2/core/operations.hpp	/^VecCommaInitializer<_Tp, cn>& VecCommaInitializer<_Tp, cn>::operator , (_T2 value)$/;"	f	class:cv::VecCommaInitializer	signature:(_T2 value)
operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e);$/;"	p	namespace:cv	signature:(const MatExpr& e)
operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e, const Scalar& s);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Scalar& s)
operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Scalar& s, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Scalar& s, const MatExpr& e)
operator -	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS ptrdiff_t operator - (const MatConstIterator& b, const MatConstIterator& a);$/;"	p	namespace:cv	signature:(const MatConstIterator& b, const MatConstIterator& a)
operator -	/usr/include/opencv2/core/mat.hpp	/^operator - (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
operator -	/usr/include/opencv2/core/mat.hpp	/^operator - (const MatIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, ptrdiff_t ofs)
operator -	/usr/include/opencv2/core/mat.hpp	/^static inline MatConstIterator operator - (const MatConstIterator& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, ptrdiff_t ofs)
operator -	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator - (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
operator -	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a)
operator -	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
operator -	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator -	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a)
operator -	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
operator -	/usr/include/opencv2/core/operations.hpp	/^operator - (const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a)
operator -	/usr/include/opencv2/core/operations.hpp	/^operator - (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
operator -	/usr/include/opencv2/core/operations.hpp	/^static inline Range operator - (const Range& r1, int delta)$/;"	f	namespace:cv	signature:(const Range& r1, int delta)
operator -	/usr/include/opencv2/core/operations.hpp	/^static inline ptrdiff_t operator - (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline ptrdiff_t operator - (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a)
operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a)
operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator - (const Rect_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Point_<_Tp>& b)
operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a)
operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator -	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator - (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
operator --	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator operator -- (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
operator --	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator& operator -- ();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
operator --	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator operator --(int);$/;"	p	class:cv::MatConstIterator	access:public	signature:(int)
operator --	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator& operator --();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
operator --	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_ operator --(int);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(int)
operator --	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_& operator --();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
operator --	/usr/include/opencv2/core/core.hpp	/^    MatIterator_ operator --(int);$/;"	p	class:cv::MatIterator_	access:public	signature:(int)
operator --	/usr/include/opencv2/core/core.hpp	/^    MatIterator_& operator --();$/;"	p	class:cv::MatIterator_	access:public	signature:()
operator --	/usr/include/opencv2/core/core.hpp	/^    SeqIterator operator --(int) const;$/;"	p	class:cv::SeqIterator	access:public	signature:(int) const
operator --	/usr/include/opencv2/core/core.hpp	/^    SeqIterator& operator --();$/;"	p	class:cv::SeqIterator	access:public	signature:()
operator --	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator operator --(int);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(int)
operator --	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator& operator --();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
operator --	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator MatConstIterator::operator --(int)$/;"	f	class:cv::MatConstIterator	signature:(int)
operator --	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator --()$/;"	f	class:cv::MatConstIterator	signature:()
operator --	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator --(int)$/;"	f	class:cv::MatConstIterator_	signature:(int)
operator --	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator --()$/;"	f	class:cv::MatConstIterator_	signature:()
operator --	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator --(int)$/;"	f	class:cv::MatIterator_	signature:(int)
operator --	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator --()$/;"	f	class:cv::MatIterator_	signature:()
operator --	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator --(int) const$/;"	f	class:cv::SeqIterator	signature:(int) const
operator --	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator --()$/;"	f	class:cv::SeqIterator	signature:()
operator -=	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator& operator -= (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
operator -=	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs)
operator -=	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t ofs)
operator -=	/usr/include/opencv2/core/core.hpp	/^    MatIterator_& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t ofs)
operator -=	/usr/include/opencv2/core/core.hpp	/^    SeqIterator& operator -=(int);$/;"	p	class:cv::SeqIterator	access:public	signature:(int)
operator -=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
operator -=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator -=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
operator -=	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t ofs)
operator -=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator -=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
operator -=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator -=	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t ofs)
operator -=	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t ofs)
operator -=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator -= (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
operator -=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator -= (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
operator -=	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp1, m, n>& operator -= (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)$/;"	f	namespace:cv	signature:(Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
operator -=	/usr/include/opencv2/core/operations.hpp	/^operator -= (Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator -=	/usr/include/opencv2/core/operations.hpp	/^operator -= (Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, const Point_<_Tp>& b)
operator -=	/usr/include/opencv2/core/operations.hpp	/^operator -= (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)$/;"	f	namespace:cv	signature:(Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
operator -=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator -=(int delta)$/;"	f	class:cv::SeqIterator	signature:(int delta)
operator -=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Point_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Point_<_Tp>& b )
operator -=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Size_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Size_<_Tp>& b )
operator -=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator -= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator -=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp>& operator -= (Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(Size_<_Tp>& a, const Size_<_Tp>& b)
operator ->	/usr/include/opencv2/core/core.hpp	/^    FileNode operator ->() const;$/;"	p	class:cv::FileNodeIterator	access:public	signature:() const
operator ->	/usr/include/opencv2/core/core.hpp	/^    _Tp* operator -> ();$/;"	p	class:cv::Ptr	access:public	signature:()
operator ->	/usr/include/opencv2/core/core.hpp	/^    const _Tp* operator -> () const;$/;"	p	class:cv::Ptr	access:public	signature:() const
operator ->	/usr/include/opencv2/core/operations.hpp	/^inline FileNode FileNodeIterator::operator ->() const$/;"	f	class:cv::FileNodeIterator	signature:() const
operator ->	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp* Ptr<_Tp>::operator -> () { return obj; }$/;"	f	class:cv::Ptr	signature:()
operator ->	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline const _Tp* Ptr<_Tp>::operator -> () const { return obj; }$/;"	f	class:cv::Ptr	signature:() const
operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e, double s);$/;"	p	namespace:cv	signature:(const MatExpr& e, double s)
operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e1, const MatExpr& e2);    $/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator /	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (double s, const MatExpr& e);$/;"	p	namespace:cv	signature:(double s, const MatExpr& e)
operator /	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator \/ (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
operator /	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator \/ (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
operator /	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator \/ (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator /	/usr/include/opencv2/core/operations.hpp	/^Scalar_<_Tp> operator \/ (_Tp a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(_Tp a, const Scalar_<_Tp>& b)
operator /	/usr/include/opencv2/core/operations.hpp	/^Scalar_<_Tp> operator \/ (const Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, _Tp alpha)
operator /	/usr/include/opencv2/core/operations.hpp	/^Scalar_<_Tp> operator \/ (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator /	/usr/include/opencv2/core/operations.hpp	/^Scalar_<double> operator \/ (const Scalar_<double>& a, double alpha)$/;"	f	namespace:cv	signature:(const Scalar_<double>& a, double alpha)
operator /	/usr/include/opencv2/core/operations.hpp	/^Scalar_<float> operator \/ (const Scalar_<float>& a, float alpha)$/;"	f	namespace:cv	signature:(const Scalar_<float>& a, float alpha)
operator /=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
operator /=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator /=	/usr/include/opencv2/core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
operator /=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator /=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
operator /=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, double s)$/;"	f	namespace:cv	signature:(const Mat& a, double s)
operator /=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp> operator \/= (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
operator /=	/usr/include/opencv2/core/operations.hpp	/^Complex<_Tp>& operator \/= (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
operator /=	/usr/include/opencv2/core/operations.hpp	/^Scalar_<_Tp>& operator \/= (Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, _Tp alpha)
operator /=	/usr/include/opencv2/core/operations.hpp	/^Scalar_<_Tp>& operator \/= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator <	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator < (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator <	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator < (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator <	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator < (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator <	/usr/include/opencv2/core/mat.hpp	/^operator < (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator <	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator < (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
operator <	/usr/include/opencv2/features2d/features2d.hpp	/^    bool operator<( const DMatch &m ) const$/;"	f	struct:cv::DMatch	access:public	signature:( const DMatch &m ) const
operator <	/usr/include/opencv2/flann/result_set.h	/^		bool operator<(Item rhs) {$/;"	f	struct:cvflann::RadiusResultSet::Item	access:public	signature:(Item rhs)
operator <	/usr/include/opencv2/flann/result_set.h	/^	bool operator<(const BranchStruct<T>& rhs)$/;"	f	struct:cvflann::BranchStruct	access:public	signature:(const BranchStruct<T>& rhs)
operator <<	/usr/include/opencv2/contrib/contrib.hpp	/^    CV_EXPORTS std::ostream& operator<<(std::ostream& out, const TickMeter& tm);$/;"	p	namespace:cv	signature:(std::ostream& out, const TickMeter& tm)
operator <<	/usr/include/opencv2/core/mat.hpp	/^operator << (const Mat_<_Tp>& m, T2 val)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& m, T2 val)
operator <<	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS FileStorage& operator << (FileStorage& fs, const string& str);$/;"	p	namespace:cv	signature:(FileStorage& fs, const string& str)
operator <<	/usr/include/opencv2/core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n> operator << (const Matx<_Tp, m, n>& mtx, _T2 val)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& mtx, _T2 val)
operator <<	/usr/include/opencv2/core/operations.hpp	/^VecCommaInitializer<_Tp, cn> operator << (const Vec<_Tp, cn>& vec, _T2 val)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& vec, _T2 val)
operator <<	/usr/include/opencv2/core/operations.hpp	/^operator << ( FileStorage& fs, const vector<_Tp>& vec )$/;"	f	namespace:cv	signature:( FileStorage& fs, const vector<_Tp>& vec )
operator <<	/usr/include/opencv2/core/operations.hpp	/^static inline FileStorage& operator << (FileStorage& fs, const char* str)$/;"	f	namespace:cv	signature:(FileStorage& fs, const char* str)
operator <<	/usr/include/opencv2/core/operations.hpp	/^static inline std::ostream& operator << (std::ostream& out, const Formatted& fmtd)$/;"	f	namespace:cv	signature:(std::ostream& out, const Formatted& fmtd)
operator <<	/usr/include/opencv2/core/operations.hpp	/^static inline std::ostream& operator << (std::ostream& out, const Mat& mtx)$/;"	f	namespace:cv	signature:(std::ostream& out, const Mat& mtx)
operator <<	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point3_<_Tp>& p)$/;"	f	namespace:cv	signature:(std::ostream& out, const Point3_<_Tp>& p)
operator <<	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point_<_Tp>& p)$/;"	f	namespace:cv	signature:(std::ostream& out, const Point_<_Tp>& p)
operator <<	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline FileStorage& operator << (FileStorage& fs, const _Tp& value)$/;"	f	namespace:cv	signature:(FileStorage& fs, const _Tp& value)
operator <<	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,$/;"	f	namespace:cv	signature:(std::ostream& out, const vector<Point3_<_Tp> >& vec)
operator <<	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,$/;"	f	namespace:cv	signature:(std::ostream& out, const vector<Point_<_Tp> >& vec)
operator <<	/usr/include/opencv2/highgui/highgui.hpp	/^    virtual VideoWriter& operator << (const Mat& image);$/;"	p	class:cv::VideoWriter	access:public	signature:(const Mat& image)
operator <=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator <=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator <=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator <=	/usr/include/opencv2/core/mat.hpp	/^operator <= (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator =	/usr/include/opencv2/contrib/contrib.hpp	/^        SelfSimDescriptor& operator = (const SelfSimDescriptor& ss);$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const SelfSimDescriptor& ss)
operator =	/usr/include/opencv2/core/core.hpp	/^        MStep& operator = (const MStep&);$/;"	p	struct:cv::Mat::MStep	access:protected	signature:(const MStep&)
operator =	/usr/include/opencv2/core/core.hpp	/^        MStep& operator = (size_t s);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(size_t s)
operator =	/usr/include/opencv2/core/core.hpp	/^    Mat& operator = (const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
operator =	/usr/include/opencv2/core/core.hpp	/^    Mat& operator = (const MatExpr& expr);$/;"	p	class:cv::Mat	access:public	signature:(const MatExpr& expr)
operator =	/usr/include/opencv2/core/core.hpp	/^    Mat& operator = (const Scalar& s);$/;"	p	class:cv::Mat	access:public	signature:(const Scalar& s)
operator =	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator& operator = (const MatConstIterator& it);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const MatConstIterator& it)
operator =	/usr/include/opencv2/core/core.hpp	/^    MatConstIterator_& operator = (const MatConstIterator_& it);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const MatConstIterator_& it)
operator =	/usr/include/opencv2/core/core.hpp	/^    MatIterator_& operator = (const MatIterator_<_Tp>& it );$/;"	p	class:cv::MatIterator_	access:public	signature:(const MatIterator_<_Tp>& it )
operator =	/usr/include/opencv2/core/core.hpp	/^    Mat_& operator = (const Mat& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat& m)
operator =	/usr/include/opencv2/core/core.hpp	/^    Mat_& operator = (const MatExpr& expr);$/;"	p	class:cv::Mat_	access:public	signature:(const MatExpr& expr)
operator =	/usr/include/opencv2/core/core.hpp	/^    Mat_& operator = (const Mat_& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m)
operator =	/usr/include/opencv2/core/core.hpp	/^    Mat_& operator = (const _Tp& s);$/;"	p	class:cv::Mat_	access:public	signature:(const _Tp& s)
operator =	/usr/include/opencv2/core/core.hpp	/^    Point3_& operator = (const Point3_& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt)
operator =	/usr/include/opencv2/core/core.hpp	/^    Point_& operator = (const Point_& pt);$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt)
operator =	/usr/include/opencv2/core/core.hpp	/^    Ptr& operator = (const Ptr& ptr);$/;"	p	class:cv::Ptr	access:public	signature:(const Ptr& ptr)
operator =	/usr/include/opencv2/core/core.hpp	/^    Rect_& operator = ( const Rect_& r );$/;"	p	class:cv::Rect_	access:public	signature:( const Rect_& r )
operator =	/usr/include/opencv2/core/core.hpp	/^    Size_& operator = (const Size_& sz);$/;"	p	class:cv::Size_	access:public	signature:(const Size_& sz)
operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMat& operator = (const Mat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const Mat& m)
operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMat& operator = (const SparseMat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const SparseMat& m)
operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator& operator = (const SparseMatConstIterator& it);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMatConstIterator& it)
operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMatConstIterator_& operator = (const SparseMatConstIterator_& it);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMatConstIterator_& it)
operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator& operator = (const SparseMatIterator& it);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(const SparseMatIterator& it)
operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMatIterator_& operator = (const SparseMatIterator_& it);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(const SparseMatIterator_& it)
operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMat_& operator = (const Mat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const Mat& m)
operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMat_& operator = (const SparseMat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat& m)
operator =	/usr/include/opencv2/core/core.hpp	/^    SparseMat_& operator = (const SparseMat_& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat_& m)
operator =	/usr/include/opencv2/core/mat.hpp	/^    MatConstIterator_<_Tp>::operator = (const MatConstIterator_& it )$/;"	f	class:cv::MatConstIterator_	signature:(const MatConstIterator_& it )
operator =	/usr/include/opencv2/core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator = (const SparseMatConstIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMatConstIterator_<_Tp>& it)
operator =	/usr/include/opencv2/core/mat.hpp	/^SparseMatIterator_<_Tp>::operator = (const SparseMatIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatIterator_	signature:(const SparseMatIterator_<_Tp>& it)
operator =	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator = (const Mat& m)$/;"	f	class:cv::SparseMat_	signature:(const Mat& m)
operator =	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator = (const SparseMat& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat& m)
operator =	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator = (const SparseMat_<_Tp>& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat_<_Tp>& m)
operator =	/usr/include/opencv2/core/mat.hpp	/^inline Mat& Mat::operator = (const Mat& m)$/;"	f	class:cv::Mat	signature:(const Mat& m)
operator =	/usr/include/opencv2/core/mat.hpp	/^inline Mat& Mat::operator = (const MatExpr& e)$/;"	f	class:cv::Mat	signature:(const MatExpr& e)
operator =	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MStep& Mat::MStep::operator = (size_t s)$/;"	f	class:cv::Mat::MStep	signature:(size_t s)
operator =	/usr/include/opencv2/core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator = (const MatConstIterator& it )$/;"	f	class:cv::MatConstIterator	signature:(const MatConstIterator& it )
operator =	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat& SparseMat::operator = (const Mat& m)$/;"	f	class:cv::SparseMat	signature:(const Mat& m)
operator =	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat& SparseMat::operator = (const SparseMat& m)$/;"	f	class:cv::SparseMat	signature:(const SparseMat& m)
operator =	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatConstIterator& SparseMatConstIterator::operator = (const SparseMatConstIterator& it)$/;"	f	class:cv::SparseMatConstIterator	signature:(const SparseMatConstIterator& it)
operator =	/usr/include/opencv2/core/mat.hpp	/^inline SparseMatIterator& SparseMatIterator::operator = (const SparseMatIterator& it)$/;"	f	class:cv::SparseMatIterator	signature:(const SparseMatIterator& it)
operator =	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> Mat_<_Tp>& Mat_<_Tp>::operator = (const MatExpr& e)$/;"	f	class:cv::Mat_	signature:(const MatExpr& e)
operator =	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator = (const MatIterator_<_Tp>& it )$/;"	f	class:cv::MatIterator_	signature:(const MatIterator_<_Tp>& it )
operator =	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat& m)$/;"	f	class:cv::Mat_	signature:(const Mat& m)
operator =	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat_& m)$/;"	f	class:cv::Mat_	signature:(const Mat_& m)
operator =	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const _Tp& s)$/;"	f	class:cv::Mat_	signature:(const _Tp& s)
operator =	/usr/include/opencv2/core/operations.hpp	/^    Vector<_Tp>& operator = (const Vector& d)$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d)
operator =	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>& Point3_<_Tp>::operator = (const Point3_& pt)$/;"	f	class:cv::Point3_	signature:(const Point3_& pt)
operator =	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>& Point_<_Tp>::operator = (const Point_& pt)$/;"	f	class:cv::Point_	signature:(const Point_& pt)
operator =	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>& Ptr<_Tp>::operator = (const Ptr<_Tp>& ptr)$/;"	f	class:cv::Ptr	signature:(const Ptr<_Tp>& ptr)
operator =	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>& Rect_<_Tp>::operator = ( const Rect_<_Tp>& r )$/;"	f	class:cv::Rect_	signature:( const Rect_<_Tp>& r )
operator =	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>& Size_<_Tp>::operator = (const Size_<_Tp>& sz)$/;"	f	class:cv::Size_	signature:(const Size_<_Tp>& sz)
operator =	/usr/include/opencv2/core/wimage.hpp	/^    WImageView& operator=(const WImage<T>& img) {$/;"	f	class:cv::WImageView	access:public	signature:(const WImage<T>& img)
operator =	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC& operator=(const WImageC<T, C>& img) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageC<T, C>& img)
operator =	/usr/include/opencv2/core/wimage.hpp	/^    WImageViewC& operator=(const WImageViewC<T, C>& img) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageViewC<T, C>& img)
operator =	/usr/include/opencv2/core/wimage.hpp	/^    void operator=(const WImage&);$/;"	p	class:cv::WImage	access:protected	signature:(const WImage&)
operator =	/usr/include/opencv2/core/wimage.hpp	/^    void operator=(const WImageBuffer&);$/;"	p	class:cv::WImageBuffer	access:private	signature:(const WImageBuffer&)
operator =	/usr/include/opencv2/core/wimage.hpp	/^    void operator=(const WImageBufferC&);$/;"	p	class:cv::WImageBufferC	access:private	signature:(const WImageBufferC&)
operator =	/usr/include/opencv2/core/wimage.hpp	/^    void operator=(const WImageC&);$/;"	p	class:cv::WImageC	access:protected	signature:(const WImageC&)
operator =	/usr/include/opencv2/features2d/features2d.hpp	/^        DefaultRngAuto& operator=(const DefaultRngAuto&);$/;"	p	struct:cv::DefaultRngAuto	access:public	signature:(const DefaultRngAuto&)
operator =	/usr/include/opencv2/gpu/gpu.hpp	/^            CudaMem& operator = (const CudaMem& m);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const CudaMem& m)
operator =	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat& operator = (const GpuMat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m)
operator =	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat& operator = (const Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Mat& m)
operator =	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat& operator = (const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Scalar& s)
operator =	/usr/include/opencv2/gpu/gpu.hpp	/^            Stream& operator=(const Stream&);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Stream&)
operator =	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem& CudaMem::operator = (const CudaMem& m)$/;"	f	class:cv::gpu::CudaMem	signature:(const CudaMem& m)
operator =	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat& GpuMat::operator = (const GpuMat& m)$/;"	f	class:cv::gpu::GpuMat	signature:(const GpuMat& m)
operator =	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat& GpuMat::operator = (const Mat& m) { upload(m); return *this; }$/;"	f	class:cv::gpu::GpuMat	signature:(const Mat& m)
operator =	/usr/include/opencv2/legacy/legacy.hpp	/^    CvImage& operator = (const CvImage& img)$/;"	f	class:CvImage	access:public	signature:(const CvImage& img)
operator =	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMatrix& operator = (const CvMatrix& _m)$/;"	f	class:CvMatrix	access:public	signature:(const CvMatrix& _m)
operator ==	/usr/include/opencv2/core/core.hpp	/^        bool operator == (const MSize& sz) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(const MSize& sz) const
operator ==	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator == (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator ==	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator == (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator ==	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator == (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator ==	/usr/include/opencv2/core/mat.hpp	/^inline bool Mat::MSize::operator == (const MSize& sz) const$/;"	f	class:cv::Mat::MSize	signature:(const MSize& sz) const
operator ==	/usr/include/opencv2/core/mat.hpp	/^operator == (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator ==	/usr/include/opencv2/core/mat.hpp	/^operator == (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
operator ==	/usr/include/opencv2/core/mat.hpp	/^operator == (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
operator ==	/usr/include/opencv2/core/mat.hpp	/^static inline bool operator == (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)$/;"	f	namespace:cv	signature:(const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
operator ==	/usr/include/opencv2/core/operations.hpp	/^bool operator == (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator ==	/usr/include/opencv2/core/operations.hpp	/^bool operator == (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
operator ==	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator == (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
operator ==	/usr/include/opencv2/core/operations.hpp	/^static inline bool operator == (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline bool operator == (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator == ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )$/;"	f	namespace:cv	signature:( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
operator ==	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
operator >	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator > (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator >	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator > (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator >	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator > (double s, const Mat& a);    $/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator >	/usr/include/opencv2/core/mat.hpp	/^operator > (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator >=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator >=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator >=	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator >=	/usr/include/opencv2/core/mat.hpp	/^operator >= (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator >>	/usr/include/opencv2/core/operations.hpp	/^FileNodeIterator& operator >> (FileNodeIterator& it, vector<_Tp>& vec)$/;"	f	namespace:cv	signature:(FileNodeIterator& it, vector<_Tp>& vec)
operator >>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline FileNodeIterator& operator >> (FileNodeIterator& it, _Tp& value)$/;"	f	namespace:cv	signature:(FileNodeIterator& it, _Tp& value)
operator >>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline void operator >> (const FileNode& n, _Tp& value)$/;"	f	namespace:cv	signature:(const FileNode& n, _Tp& value)
operator >>	/usr/include/opencv2/highgui/highgui.hpp	/^    virtual VideoCapture& operator >> (CV_OUT Mat& image);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image)
operator Complex<T2>	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> operator Complex<T2>() const;$/;"	p	class:cv::Complex	access:public	signature:() const
operator Complex<T2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename T2> inline Complex<_Tp>::operator Complex<T2>() const$/;"	f	class:cv::Complex	signature:() const
operator CvBox2D	/usr/include/opencv2/core/core.hpp	/^    operator CvBox2D() const;$/;"	p	class:cv::RotatedRect	access:public	signature:() const
operator CvBox2D	/usr/include/opencv2/core/operations.hpp	/^inline RotatedRect::operator CvBox2D() const$/;"	f	class:cv::RotatedRect	signature:() const
operator CvMat	/usr/include/opencv2/core/core.hpp	/^    operator CvMat() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator CvMat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::operator CvMat() const$/;"	f	class:cv::Mat	signature:() const
operator CvMat	/usr/include/opencv2/core/operations.hpp	/^    operator CvMat() const$/;"	f	class:cv::Vector	access:public	signature:() const
operator CvMat*	/usr/include/opencv2/legacy/legacy.hpp	/^    operator CvMat* () { return matrix; }$/;"	f	class:CvMatrix	access:public	signature:()
operator CvMatND	/usr/include/opencv2/core/core.hpp	/^    operator CvMatND() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator CvMoments	/usr/include/opencv2/imgproc/imgproc.hpp	/^    operator CvMoments() const;$/;"	p	class:cv::Moments	access:public	signature:() const
operator CvPoint	/usr/include/opencv2/core/core.hpp	/^    operator CvPoint() const;$/;"	p	class:cv::Point_	access:public	signature:() const
operator CvPoint	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator CvPoint() const$/;"	f	class:cv::Point_	signature:() const
operator CvPoint2D32f	/usr/include/opencv2/core/core.hpp	/^    operator CvPoint2D32f() const;$/;"	p	class:cv::Point_	access:public	signature:() const
operator CvPoint2D32f	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator CvPoint2D32f() const$/;"	f	class:cv::Point_	signature:() const
operator CvPoint3D32f	/usr/include/opencv2/core/core.hpp	/^    operator CvPoint3D32f() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
operator CvPoint3D32f	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::operator CvPoint3D32f() const$/;"	f	class:cv::Point3_	signature:() const
operator CvRect	/usr/include/opencv2/core/core.hpp	/^    operator CvRect() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
operator CvRect	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::operator CvRect() const$/;"	f	class:cv::Rect_	signature:() const
operator CvScalar	/usr/include/opencv2/core/core.hpp	/^    operator CvScalar() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
operator CvScalar	/usr/include/opencv2/core/core.hpp	/^    operator CvScalar() const;$/;"	p	class:cv::Vec	access:public	signature:() const
operator CvScalar	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::operator CvScalar() const$/;"	f	class:cv::Vec	signature:() const
operator CvScalar	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::operator CvScalar() const$/;"	f	class:cv::Scalar_	signature:() const
operator CvSize	/usr/include/opencv2/core/core.hpp	/^    operator CvSize() const;$/;"	p	class:cv::Size_	access:public	signature:() const
operator CvSize	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::operator CvSize() const$/;"	f	class:cv::Size_	signature:() const
operator CvSize2D32f	/usr/include/opencv2/core/core.hpp	/^    operator CvSize2D32f() const;$/;"	p	class:cv::Size_	access:public	signature:() const
operator CvSize2D32f	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::operator CvSize2D32f() const$/;"	f	class:cv::Size_	signature:() const
operator CvSlice	/usr/include/opencv2/core/core.hpp	/^    operator CvSlice() const;$/;"	p	class:cv::Range	access:public	signature:() const
operator CvSlice	/usr/include/opencv2/core/operations.hpp	/^inline Range::operator CvSlice() const$/;"	f	class:cv::Range	signature:() const
operator CvSparseMat*	/usr/include/opencv2/core/core.hpp	/^    operator CvSparseMat*() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
operator CvSparseMat*	/usr/include/opencv2/core/core.hpp	/^    operator CvSparseMat*() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
operator CvSparseMat*	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::operator CvSparseMat*() const$/;"	f	class:cv::SparseMat_	signature:() const
operator CvTermCriteria	/usr/include/opencv2/core/core.hpp	/^    operator CvTermCriteria() const;$/;"	p	class:cv::TermCriteria	access:public	signature:() const
operator CvTermCriteria	/usr/include/opencv2/core/operations.hpp	/^inline TermCriteria::operator CvTermCriteria() const$/;"	f	class:cv::TermCriteria	signature:() const
operator DevMem2D_<T>	/usr/include/opencv2/gpu/gpu.hpp	/^            template <class T> operator DevMem2D_<T>() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
operator DevMem2D_<T>	/usr/include/opencv2/gpu/matrix_operations.hpp	/^template <class T> inline GpuMat::operator DevMem2D_<T>() const { return DevMem2D_<T>(rows, cols, (T*)data, step); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
operator GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            operator GpuMat() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
operator GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::operator GpuMat() const { return createGpuMatHeader(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
operator IplImage	/usr/include/opencv2/core/core.hpp	/^    operator IplImage() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator IplImage*	/usr/include/opencv2/legacy/legacy.hpp	/^    operator IplImage* () { return image; }$/;"	f	class:CvImage	access:public	signature:()
operator Mat	/usr/include/opencv2/core/mat.hpp	/^    operator Mat() const$/;"	f	class:cv::MatExpr	access:public	signature:() const
operator Mat	/usr/include/opencv2/gpu/gpu.hpp	/^            operator Mat() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
operator Mat	/usr/include/opencv2/gpu/gpu.hpp	/^            operator Mat() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
operator Mat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^ inline GpuMat::operator Mat() const$/;"	f	class:cv::gpu::GpuMat	signature:() const
operator Mat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::operator Mat() const { return createMatHeader(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
operator Mat_<T2>	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> operator Mat_<T2>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
operator Mat_<T2>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> template<typename T2> inline Mat_<_Tp>::operator Mat_<T2>() const$/;"	f	class:cv::Mat_	signature:() const
operator Mat_<_Tp>	/usr/include/opencv2/core/core.hpp	/^    operator Mat_<_Tp>() const;$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:() const
operator Mat_<_Tp>	/usr/include/opencv2/core/mat.hpp	/^    template<typename _Tp> operator Mat_<_Tp>() const$/;"	f	class:cv::MatExpr	access:public	signature:() const
operator Mat_<_Tp>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatCommaInitializer_<_Tp>::operator Mat_<_Tp>() const$/;"	f	class:cv::MatCommaInitializer_	signature:() const
operator Matx<T2, m, n>	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> operator Matx<T2, m, n>() const;$/;"	p	class:cv::Matx	access:public	signature:() const
operator Matx<T2, m, n>	/usr/include/opencv2/core/operations.hpp	/^inline Matx<_Tp, m, n>::operator Matx<T2, m, n>() const$/;"	f	class:cv::Matx	signature:() const
operator Matx<_Tp, m, n>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int m, int n> operator Matx<_Tp, m, n>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator Matx<_Tp, m, n>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp, int m, int n> inline Mat::operator Matx<_Tp, m, n>() const$/;"	f	class:cv::Mat	signature:() const
operator Matx<typename DataType<_Tp>::channel_type, m, n>	/usr/include/opencv2/core/core.hpp	/^    template<int m, int n> operator Matx<typename DataType<_Tp>::channel_type, m, n>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
operator Matx<typename DataType<_Tp>::channel_type, m, n>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> template<int m, int n> inline Mat_<_Tp>::operator Matx<typename DataType<_Tp>::channel_type, m, n>() const$/;"	f	class:cv::Mat_	signature:() const
operator Point3_<_Tp2>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp2> operator Point3_<_Tp2>() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
operator Point3_<_Tp2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Point3_<_Tp>::operator Point3_<_Tp2>() const$/;"	f	class:cv::Point3_	signature:() const
operator Point_<_Tp2>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp2> operator Point_<_Tp2>() const;$/;"	p	class:cv::Point_	access:public	signature:() const
operator Point_<_Tp2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Point_<_Tp>::operator Point_<_Tp2>() const$/;"	f	class:cv::Point_	signature:() const
operator PtrStep_<T>	/usr/include/opencv2/gpu/gpu.hpp	/^            template <class T> operator PtrStep_<T>() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
operator PtrStep_<T>	/usr/include/opencv2/gpu/matrix_operations.hpp	/^template <class T> inline GpuMat::operator PtrStep_<T>() const { return PtrStep_<T>(static_cast< DevMem2D_<T> >(*this)); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
operator Rect_<_Tp2>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp2> operator Rect_<_Tp2>() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
operator Rect_<_Tp2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Rect_<_Tp>::operator Rect_<_Tp2>() const$/;"	f	class:cv::Rect_	signature:() const
operator Scalar_<T2>	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> operator Scalar_<T2>() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
operator Scalar_<T2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename T2> inline Scalar_<_Tp>::operator Scalar_<T2>() const$/;"	f	class:cv::Scalar_	signature:() const
operator Size_<_Tp2>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp2> operator Size_<_Tp2>() const;$/;"	p	class:cv::Size_	access:public	signature:() const
operator Size_<_Tp2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Size_<_Tp>::operator Size_<_Tp2>() const$/;"	f	class:cv::Size_	signature:() const
operator Vec<T2, cn>	/usr/include/opencv2/core/core.hpp	/^    template<typename T2> operator Vec<T2, cn>() const;$/;"	p	class:cv::Vec	access:public	signature:() const
operator Vec<T2, cn>	/usr/include/opencv2/core/operations.hpp	/^inline Vec<_Tp, cn>::operator Vec<T2, cn>() const$/;"	f	class:cv::Vec	signature:() const
operator Vec<_Tp, 2>	/usr/include/opencv2/core/core.hpp	/^    operator Vec<_Tp, 2>() const;$/;"	p	class:cv::Point_	access:public	signature:() const
operator Vec<_Tp, 2>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator Vec<_Tp, 2>() const$/;"	f	class:cv::Point_	signature:() const
operator Vec<_Tp, 3>	/usr/include/opencv2/core/core.hpp	/^    operator Vec<_Tp, 3>() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
operator Vec<_Tp, 3>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::operator Vec<_Tp, 3>() const$/;"	f	class:cv::Point3_	signature:() const
operator Vec<_Tp, n>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> operator Vec<_Tp, n>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator Vec<_Tp, n>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp, int n> inline Mat::operator Vec<_Tp, n>() const$/;"	f	class:cv::Mat	signature:() const
operator Vec<typename DataType<_Tp>::channel_type, n>	/usr/include/opencv2/core/core.hpp	/^    template<int n> operator Vec<typename DataType<_Tp>::channel_type, n>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
operator Vec<typename DataType<_Tp>::channel_type, n>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> template<int n> inline Mat_<_Tp>::operator Vec<typename DataType<_Tp>::channel_type, n>() const$/;"	f	class:cv::Mat_	signature:() const
operator []	/usr/include/opencv2/core/core.hpp	/^        int operator[](int i) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int i) const
operator []	/usr/include/opencv2/core/core.hpp	/^        int& operator[](int i);$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int i)
operator []	/usr/include/opencv2/core/core.hpp	/^        size_t operator[](int i) const;$/;"	p	struct:cv::Mat::MStep	access:public	signature:(int i) const
operator []	/usr/include/opencv2/core/core.hpp	/^        size_t& operator[](int i);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(int i)
operator []	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode operator[](const char* nodename) const;$/;"	p	class:cv::FileNode	access:public	signature:(const char* nodename) const
operator []	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode operator[](const char* nodename) const;$/;"	p	class:cv::FileStorage	access:public	signature:(const char* nodename) const
operator []	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode operator[](int i) const;$/;"	p	class:cv::FileNode	access:public	signature:(int i) const
operator []	/usr/include/opencv2/core/core.hpp	/^    FileNode operator[](const string& nodename) const;$/;"	p	class:cv::FileNode	access:public	signature:(const string& nodename) const
operator []	/usr/include/opencv2/core/core.hpp	/^    FileNode operator[](const string& nodename) const;$/;"	p	class:cv::FileStorage	access:public	signature:(const string& nodename) const
operator []	/usr/include/opencv2/core/core.hpp	/^    _Tp operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t i) const
operator []	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator [](int idx);$/;"	p	class:cv::Seq	access:public	signature:(int idx)
operator []	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t i) const
operator []	/usr/include/opencv2/core/core.hpp	/^    _Tp& operator[](int i);$/;"	p	class:cv::Vec	access:public	signature:(int i)
operator []	/usr/include/opencv2/core/core.hpp	/^    _Tp* operator [](int y);$/;"	p	class:cv::Mat_	access:public	signature:(int y)
operator []	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator [](int i) const;$/;"	p	class:cv::Vec	access:public	signature:(int i) const
operator []	/usr/include/opencv2/core/core.hpp	/^    const _Tp& operator[](int idx) const;$/;"	p	class:cv::Seq	access:public	signature:(int idx) const
operator []	/usr/include/opencv2/core/core.hpp	/^    const _Tp* operator [](int y) const;$/;"	p	class:cv::Mat_	access:public	signature:(int y) const
operator []	/usr/include/opencv2/core/core.hpp	/^    uchar* operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t i) const
operator []	/usr/include/opencv2/core/mat.hpp	/^inline int Mat::MSize::operator[](int i) const { return p[i]; }$/;"	f	class:cv::Mat::MSize	signature:(int i) const
operator []	/usr/include/opencv2/core/mat.hpp	/^inline int& Mat::MSize::operator[](int i) { return p[i]; }$/;"	f	class:cv::Mat::MSize	signature:(int i)
operator []	/usr/include/opencv2/core/mat.hpp	/^inline size_t Mat::MStep::operator[](int i) const { return p[i]; }$/;"	f	class:cv::Mat::MStep	signature:(int i) const
operator []	/usr/include/opencv2/core/mat.hpp	/^inline size_t& Mat::MStep::operator[](int i) { return p[i]; }$/;"	f	class:cv::Mat::MStep	signature:(int i)
operator []	/usr/include/opencv2/core/mat.hpp	/^inline uchar* MatConstIterator::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t i) const
operator []	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t i) const
operator []	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t i) const
operator []	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat_<_Tp>::operator [](int y)$/;"	f	class:cv::Mat_	signature:(int y)
operator []	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat_<_Tp>::operator [](int y) const$/;"	f	class:cv::Mat_	signature:(int y) const
operator []	/usr/include/opencv2/core/operations.hpp	/^    _Tp& operator [] (size_t i) { CV_DbgAssert( i < size() ); return hdr.data[i]; }$/;"	f	class:cv::Vector	access:public	signature:(size_t i)
operator []	/usr/include/opencv2/core/operations.hpp	/^    const _Tp& operator [] (size_t i) const { CV_DbgAssert( i < size() ); return hdr.data[i]; }$/;"	f	class:cv::Vector	access:public	signature:(size_t i) const
operator []	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator [](int i)$/;"	f	class:cv::Vec	signature:(int i)
operator []	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator [](int i) const$/;"	f	class:cv::Vec	signature:(int i) const
operator []	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::operator [](int idx)$/;"	f	class:cv::Seq	signature:(int idx)
operator []	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::operator [](int idx) const$/;"	f	class:cv::Seq	signature:(int idx) const
operator []	/usr/include/opencv2/flann/dist.h	/^	T operator[](int) {$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
operator []	/usr/include/opencv2/flann/matrix.h	/^    T* operator[](size_t index) const$/;"	f	class:cvflann::Matrix	access:public	signature:(size_t index) const
operator []	/usr/include/opencv2/flann/matrix.h	/^    T* operator[](size_t index)$/;"	f	class:cvflann::Matrix	access:public	signature:(size_t index)
operator ^	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator ^	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator ^	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
operator ^	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS GpuMat operator ^ (const GpuMat& src1, const GpuMat& src2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2)
operator ^=	/usr/include/opencv2/core/mat.hpp	/^operator ^= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator ^=	/usr/include/opencv2/core/mat.hpp	/^operator ^= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
operator ^=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator ^= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator ^=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator ^= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator _Tp*	/usr/include/opencv2/core/core.hpp	/^    operator _Tp* ();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
operator _Tp*	/usr/include/opencv2/core/core.hpp	/^    operator _Tp* ();$/;"	p	class:cv::Ptr	access:public	signature:()
operator _Tp*	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator _Tp* ()$/;"	f	class:cv::AutoBuffer	signature:()
operator _Tp*	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::operator _Tp* () { return obj; }$/;"	f	class:cv::Ptr	signature:()
operator const CvMat*	/usr/include/opencv2/legacy/legacy.hpp	/^    operator const CvMat* () const { return matrix; }$/;"	f	class:CvMatrix	access:public	signature:() const
operator const IplImage*	/usr/include/opencv2/legacy/legacy.hpp	/^    operator const IplImage* () const { return image; }$/;"	f	class:CvImage	access:public	signature:() const
operator const _Tp*	/usr/include/opencv2/core/core.hpp	/^    operator const _Tp* () const;$/;"	p	class:cv::AutoBuffer	access:public	signature:() const
operator const _Tp*	/usr/include/opencv2/core/core.hpp	/^    operator const _Tp*() const;$/;"	p	class:cv::Ptr	access:public	signature:() const
operator const _Tp*	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator const _Tp* () const$/;"	f	class:cv::AutoBuffer	signature:() const
operator const _Tp*	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::operator const _Tp*() const { return obj; }$/;"	f	class:cv::Ptr	signature:() const
operator const int*	/usr/include/opencv2/core/core.hpp	/^        operator const int*() const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:() const
operator const int*	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MSize::operator const int*() const { return p; }$/;"	f	class:cv::Mat::MSize	signature:() const
operator double	/usr/include/opencv2/core/core.hpp	/^    operator double() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
operator double	/usr/include/opencv2/core/core.hpp	/^    operator double();$/;"	p	class:cv::RNG	access:public	signature:()
operator double	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::operator double() const$/;"	f	class:cv::FileNode	signature:() const
operator double	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator double()$/;"	f	class:cv::RNG	signature:()
operator float	/usr/include/opencv2/core/core.hpp	/^    operator float() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
operator float	/usr/include/opencv2/core/core.hpp	/^    operator float();$/;"	p	class:cv::RNG	access:public	signature:()
operator float	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::operator float() const$/;"	f	class:cv::FileNode	signature:() const
operator float	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator float() { return next()*2.3283064365386962890625e-10f; }$/;"	f	class:cv::RNG	signature:()
operator int	/usr/include/opencv2/core/core.hpp	/^    operator int() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
operator int	/usr/include/opencv2/core/core.hpp	/^    operator int();$/;"	p	class:cv::RNG	access:public	signature:()
operator int	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::operator int() const$/;"	f	class:cv::FileNode	signature:() const
operator int	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator int() { return (int)next(); }$/;"	f	class:cv::RNG	signature:()
operator schar	/usr/include/opencv2/core/core.hpp	/^    operator schar();$/;"	p	class:cv::RNG	access:public	signature:()
operator schar	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator schar() { return (schar)next(); }$/;"	f	class:cv::RNG	signature:()
operator short	/usr/include/opencv2/core/core.hpp	/^    operator short();$/;"	p	class:cv::RNG	access:public	signature:()
operator short	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator short() { return (short)next(); }$/;"	f	class:cv::RNG	signature:()
operator size_t	/usr/include/opencv2/core/core.hpp	/^        operator size_t() const;$/;"	p	struct:cv::Mat::MStep	access:public	signature:() const
operator size_t	/usr/include/opencv2/core/mat.hpp	/^inline Mat::MStep::operator size_t() const$/;"	f	class:cv::Mat::MStep	signature:() const
operator std::complex<_Tp>	/usr/include/opencv2/core/core.hpp	/^    operator std::complex<_Tp>() const;$/;"	p	class:cv::Complex	access:public	signature:() const
operator string	/usr/include/opencv2/core/core.hpp	/^    operator string() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
operator string	/usr/include/opencv2/core/operations.hpp	/^inline FileNode::operator string() const$/;"	f	class:cv::FileNode	signature:() const
operator uchar	/usr/include/opencv2/core/core.hpp	/^    operator uchar();$/;"	p	class:cv::RNG	access:public	signature:()
operator uchar	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator uchar() { return (uchar)next(); }$/;"	f	class:cv::RNG	signature:()
operator unsigned	/usr/include/opencv2/core/core.hpp	/^    operator unsigned();$/;"	p	class:cv::RNG	access:public	signature:()
operator unsigned	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator unsigned() { return next(); }$/;"	f	class:cv::RNG	signature:()
operator ushort	/usr/include/opencv2/core/core.hpp	/^    operator ushort();$/;"	p	class:cv::RNG	access:public	signature:()
operator ushort	/usr/include/opencv2/core/operations.hpp	/^inline RNG::operator ushort() { return (ushort)next(); }$/;"	f	class:cv::RNG	signature:()
operator vector<_Tp>	/usr/include/opencv2/core/core.hpp	/^    operator vector<_Tp>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
operator vector<_Tp>	/usr/include/opencv2/core/core.hpp	/^    operator vector<_Tp>() const;$/;"	p	class:cv::Seq	access:public	signature:() const
operator vector<_Tp>	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> operator vector<_Tp>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator vector<_Tp>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat::operator vector<_Tp>() const$/;"	f	class:cv::Mat	signature:() const
operator vector<_Tp>	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::operator vector<_Tp>() const$/;"	f	class:cv::Mat_	signature:() const
operator vector<_Tp>	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::operator vector<_Tp>() const$/;"	f	class:cv::Seq	signature:() const
operator |	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator |	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator |	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
operator |	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator | (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
operator |	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS GpuMat operator | (const GpuMat& src1, const GpuMat& src2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2)
operator |=	/usr/include/opencv2/core/mat.hpp	/^operator |= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator |=	/usr/include/opencv2/core/mat.hpp	/^operator |= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
operator |=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator |= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator |=	/usr/include/opencv2/core/mat.hpp	/^static inline Mat& operator |= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator |=	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator |= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Rect_<_Tp>& b )
operator ~	/usr/include/opencv2/core/mat.hpp	/^CV_EXPORTS MatExpr operator ~(const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
operator ~	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS GpuMat operator ~ (const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
optimize	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void optimize(); \/\/main function that runs minimization$/;"	p	class:cv::LevMarqSparse	access:protected	signature:()
optimizeKDTree	/usr/include/opencv2/flann/autotuned_index.h	/^    KDTreeCostData optimizeKDTree()$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:()
optimizeKMeans	/usr/include/opencv2/flann/autotuned_index.h	/^    KMeansCostData optimizeKMeans()$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:()
optimizeSimplexDownhill	/usr/include/opencv2/flann/simplex_downhill.h	/^float optimizeSimplexDownhill(T* points, int n, F func, float* vals = NULL )$/;"	f	namespace:cvflann	signature:(T* points, int n, F func, float* vals = NULL )
ord	/usr/include/opencv2/ml/ml.hpp	/^        ord;$/;"	m	union:CvDTreeSplit::__anon83	typeref:struct:CvDTreeSplit::__anon83::__anon84	access:public
ord_var_count	/usr/include/opencv2/ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
origWinSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    Size origWinSize;$/;"	m	class:cv::CascadeClassifier	access:public
orig_response	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* orig_response;$/;"	m	class:CvBoost	access:protected
orig_response	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* orig_response;$/;"	m	class:CvGBTrees	access:protected
orig_window_size	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvSize orig_window_size;$/;"	m	struct:CvHaarClassifierCascade	access:public
origin	/usr/include/opencv2/core/types_c.h	/^    CvPoint  origin;$/;"	m	struct:CvChain	access:public
origin	/usr/include/opencv2/core/types_c.h	/^    int  origin;            \/* 0 - top-left origin,$/;"	m	struct:_IplImage	access:public
origin	/usr/include/opencv2/legacy/legacy.hpp	/^    int origin() const { return image ? image->origin : 0; }$/;"	f	class:CvImage	access:public	signature:() const
original_num_classes	/usr/include/opencv2/features2d/features2d.hpp	/^  inline int original_num_classes() const { return original_num_classes_; }$/;"	f	class:cv::RTreeClassifier	access:public	signature:() const
original_num_classes_	/usr/include/opencv2/features2d/features2d.hpp	/^  int original_num_classes_;$/;"	m	class:cv::RTreeClassifier	access:private
other	/usr/include/opencv2/core/core.hpp	/^    template<typename U> class rebind { typedef Allocator<U> other; };$/;"	t	class:cv::Allocator::rebind	access:private
out	/usr/include/opencv2/contrib/contrib.hpp	/^        std::ostream* out;$/;"	m	class:cv::SpinImageModel	access:protected
out	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat out;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
out	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat out;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
overlap	/usr/include/opencv2/features2d/features2d.hpp	/^    static float overlap(const KeyPoint& kp1, const KeyPoint& kp2);$/;"	p	class:cv::KeyPoint	access:public	signature:(const KeyPoint& kp1, const KeyPoint& kp2)
p	/usr/include/opencv2/core/core.hpp	/^        int* p;$/;"	m	struct:cv::Mat::MSize	access:public
p	/usr/include/opencv2/core/core.hpp	/^        size_t* p;$/;"	m	struct:cv::Mat::MStep	access:public
p	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f p; \/\/ pgruebele: So we do not loose precision, this needs to be float$/;"	m	struct:__anon173	access:public
p	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint3D32f p;             \/\/ location of the tracked object$/;"	m	struct:__anon174	access:public
p	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double      p; \/\/ for CV_SVM_EPS_SVR$/;"	m	struct:CvSVMParams	access:public
p	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int p;$/;"	m	struct:__anon60	access:public
p1	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint p1;            \/* the first point of the binary tree root segment *\/$/;"	m	struct:CvContourTree	access:public
p2	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint p2;            \/* the last point of the binary tree root segment *\/$/;"	m	struct:CvContourTree	access:public
pBD	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobDetector*         pBD;           \/* Selected blob detector module. 					    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pBT	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTracker*          pBT;           \/* Selected blob tracking module.					    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pBTA	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTrackAnalysis*    pBTA;          \/* Selected blob trajectory analysis module.                             *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pBTGen	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTrackGen*         pBTGen;        \/* Selected blob trajectory generator.				    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pBTPP	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobTrackPostProc*    pBTPP;         \/* Selected blob trajectory postprocessing module.			    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pBlobSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvBlobSeq*  pBlobSeq;$/;"	m	struct:CvBlobTrack	access:public
pComment	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*               pComment;$/;"	m	struct:CvDefParam	access:public
pDouble	/usr/include/opencv2/legacy/blobtrack.hpp	/^    double*             pDouble;$/;"	m	struct:CvDefParam	access:public
pFG	/usr/include/opencv2/legacy/blobtrack.hpp	/^    CvFGDetector*           pFG;           \/* FGDetector module. If this field is NULL the Process FG mask is used. *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pFloat	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float*              pFloat;$/;"	m	struct:CvDefParam	access:public
pInt	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int*                pInt;$/;"	m	struct:CvDefParam	access:public
pName	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char*               pName;$/;"	m	struct:CvDefParam	access:public
pStr	/usr/include/opencv2/legacy/blobtrack.hpp	/^    char**              pStr;$/;"	m	struct:CvDefParam	access:public
packRandomScaledSpins	/usr/include/opencv2/contrib/contrib.hpp	/^        Mat packRandomScaledSpins(bool separateScale = false, size_t xCount = 10, size_t yCount = 10) const;$/;"	p	class:cv::SpinImageModel	access:public	signature:(bool separateScale = false, size_t xCount = 10, size_t yCount = 10) const
parallel_do	/usr/include/opencv2/core/internal.hpp	/^        void parallel_do( Iterator first, Iterator last, const Body& body )$/;"	f	namespace:cv	signature:( Iterator first, Iterator last, const Body& body )
parallel_for	/usr/include/opencv2/core/internal.hpp	/^        void parallel_for( const BlockedRange& range, const Body& body )$/;"	f	namespace:cv	signature:( const BlockedRange& range, const Body& body )
parallel_reduce	/usr/include/opencv2/core/internal.hpp	/^        void parallel_reduce( const BlockedRange& range, Body& body )$/;"	f	namespace:cv	signature:( const BlockedRange& range, Body& body )
param	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> param;$/;"	m	class:CvLevMarq	access:public
param	/usr/include/opencv2/legacy/compat.hpp	/^    CvScalar  param[2]; \/* parameters of RNG *\/$/;"	m	struct:CvRandState	access:public
params	/usr/include/opencv2/core/operations.hpp	/^    vector<int> params;$/;"	m	struct:cv::Formatted	access:public
params	/usr/include/opencv2/features2d/features2d.hpp	/^	Params params;$/;"	m	class:cv::DenseFeatureDetector	access:protected
params	/usr/include/opencv2/features2d/features2d.hpp	/^	Params params;$/;"	m	class:cv::GoodFeaturesToTrackDetector	access:protected
params	/usr/include/opencv2/features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
params	/usr/include/opencv2/features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
params	/usr/include/opencv2/ml/ml.hpp	/^    CvANN_MLP_TrainParams params;$/;"	m	class:CvANN_MLP	access:protected
params	/usr/include/opencv2/ml/ml.hpp	/^    CvBoostParams params;$/;"	m	class:CvBoost	access:protected
params	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeParams params;$/;"	m	struct:CvDTreeTrainData	access:public
params	/usr/include/opencv2/ml/ml.hpp	/^    CvEMParams params;$/;"	m	class:CvEM	access:protected
params	/usr/include/opencv2/ml/ml.hpp	/^    CvGBTreesParams params;$/;"	m	class:CvGBTrees	access:protected
params	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMParams params;$/;"	m	class:CvSVM	access:protected
params	/usr/include/opencv2/ml/ml.hpp	/^    const CvSVMParams* params;$/;"	m	class:CvSVMSolver	access:public
params	/usr/include/opencv2/ml/ml.hpp	/^    const CvSVMParams* params;$/;"	m	struct:CvSVMKernel	access:public
params	/usr/include/opencv2/video/background_segm.hpp	/^    CvFGDStatModelParams   params;$/;"	m	struct:CvFGDStatModel	access:public
params	/usr/include/opencv2/video/background_segm.hpp	/^    CvGaussBGStatModelParams   params;    $/;"	m	struct:CvGaussBGModel	access:public
params_	/usr/include/opencv2/features2d/features2d.hpp	/^	CvStarDetectorParams params_; \/\/todo use these instead of thresh_$/;"	m	class:cv::StarAdjuster	access:protected
parent	/usr/include/opencv2/core/core_c.h	/^CVAPI(CvMemStorage*)  cvCreateChildMemStorage( CvMemStorage* parent );$/;"	v
parent	/usr/include/opencv2/core/types_c.h	/^    struct  CvMemStorage* parent; \/* We get new blocks from parent as needed. *\/$/;"	m	struct:CvMemStorage	typeref:struct:CvMemStorage::CvMemStorage	access:public
parent	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode* parent;$/;"	m	struct:CvDTreeNode	access:public
parent	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int parent;$/;"	m	struct:CvHaarStageClassifier	access:public
partition	/usr/include/opencv2/core/operations.hpp	/^partition( const vector<_Tp>& _vec, vector<int>& labels,$/;"	f	namespace:cv	signature:( const vector<_Tp>& _vec, vector<int>& labels, _EqPredicate predicate=_EqPredicate())
patchGenerator	/usr/include/opencv2/features2d/features2d.hpp	/^        PatchGenerator patchGenerator;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
patchSize	/usr/include/opencv2/features2d/features2d.hpp	/^        Size patchSize;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
patchSize	/usr/include/opencv2/features2d/features2d.hpp	/^        int patchSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
patchSize	/usr/include/opencv2/features2d/features2d.hpp	/^    Size patchSize;$/;"	m	class:cv::FernClassifier	access:protected
pcaFilename	/usr/include/opencv2/features2d/features2d.hpp	/^        string pcaFilename;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
perform_morphing	/usr/include/opencv2/video/background_segm.hpp	/^    int    perform_morphing;	\/* Number of erode-dilate-erode foreground-blob cleanup iterations.						*\/$/;"	m	struct:CvFGDStatModelParams	access:public
perspectiveTransform	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void perspectiveTransform(const Mat& src, CV_OUT Mat& dst, const Mat& m );$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, const Mat& m )
phase	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void phase(const Mat& x, const Mat& y, CV_OUT Mat& angle,$/;"	p	namespace:cv	signature:(const Mat& x, const Mat& y, CV_OUT Mat& angle, bool angleInDegrees=false)
phase	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void phase(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees = false)
phase	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void phase(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees, const Stream& stream)
phi	/usr/include/opencv2/features2d/features2d.hpp	/^    float phi;$/;"	m	class:cv::CvAffinePose	access:public
phiMax	/usr/include/opencv2/features2d/features2d.hpp	/^    double phiMin, phiMax;$/;"	m	class:cv::PatchGenerator	access:public
phiMin	/usr/include/opencv2/features2d/features2d.hpp	/^    double phiMin, phiMax;$/;"	m	class:cv::PatchGenerator	access:public
pivot	/usr/include/opencv2/flann/kmeans_index.h	/^		DIST_TYPE* pivot;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
pix_size	/usr/include/opencv2/legacy/legacy.hpp	/^    int pix_size() const { return image ? ((image->depth & 255)>>3)*image->nChannels : 0; }$/;"	f	class:CvImage	access:public	signature:() const
pix_size	/usr/include/opencv2/legacy/legacy.hpp	/^    int pix_size() const { return matrix ? CV_ELEM_SIZE(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
pixel_stat	/usr/include/opencv2/video/background_segm.hpp	/^    CvBGPixelStat*         pixel_stat;$/;"	m	struct:CvFGDStatModel	access:public
planes	/usr/include/opencv2/core/core.hpp	/^    Mat* planes;$/;"	m	class:cv::NAryMatIterator	access:public
plusDelta	/usr/include/opencv2/core/core.hpp	/^    int minusDelta, plusDelta;$/;"	m	class:cv::LineIterator	access:public
plusStep	/usr/include/opencv2/core/core.hpp	/^    int minusStep, plusStep;$/;"	m	class:cv::LineIterator	access:public
plus_delta	/usr/include/opencv2/core/types_c.h	/^    int  plus_delta;$/;"	m	struct:CvLineIterator	access:public
plus_step	/usr/include/opencv2/core/types_c.h	/^    int  plus_step;$/;"	m	struct:CvLineIterator	access:public
pointCount	/usr/include/opencv2/features2d/features2d.hpp	/^        int pointCount;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
pointPolygonTest	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double pointPolygonTest( const Mat& contour,$/;"	p	namespace:cv	signature:( const Mat& contour, Point2f pt, bool measureDist )
pointer	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp* pointer;$/;"	t	class:cv::MatIterator_	access:public
pointer	/usr/include/opencv2/core/core.hpp	/^    typedef const _Tp* pointer;$/;"	t	class:cv::MatConstIterator_	access:public
pointer	/usr/include/opencv2/core/core.hpp	/^    typedef const uchar** pointer;$/;"	t	class:cv::MatConstIterator	access:public
pointer	/usr/include/opencv2/core/core.hpp	/^    typedef value_type* pointer;$/;"	t	class:cv::Allocator	access:public
points	/usr/include/opencv2/contrib/contrib.hpp	/^        vector<Point3f> points;$/;"	m	class:cv::Octree	access:private
points	/usr/include/opencv2/contrib/contrib.hpp	/^    std::vector<CvFuzzyPoint> points;$/;"	m	class:CvFuzzyCurve	access:private
points	/usr/include/opencv2/core/core.hpp	/^    CV_PROP Mat points; \/\/!< all the points. It can be a reordered copy of the input vector set or the original vector set.$/;"	m	class:cv::KDTree	access:public
points	/usr/include/opencv2/core/core.hpp	/^    void points(Point2f pts[]) const;$/;"	p	class:cv::RotatedRect	access:public	signature:(Point2f pts[]) const
points	/usr/include/opencv2/imgproc/imgproc_c.h	/^CVAPI(CvBox2D) cvFitEllipse2( const CvArr* points );$/;"	v
points	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f* points[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
polarToCart	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void polarToCart(const Mat& magnitude, const Mat& angle,$/;"	p	namespace:cv	signature:(const Mat& magnitude, const Mat& angle, CV_OUT Mat& x, CV_OUT Mat& y, bool angleInDegrees=false)
polarToCart	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void polarToCart(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees = false)
polarToCart	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void polarToCart(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees, const Stream& stream)
polylines	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void polylines(Mat& img, const Point** pts, const int* npts,$/;"	p	namespace:cv	signature:(Mat& img, const Point** pts, const int* npts, int ncontours, bool isClosed, const Scalar& color, int thickness=1, int lineType=8, int shift=0 )
pool	/usr/include/opencv2/core/core.hpp	/^        vector<uchar> pool;$/;"	m	struct:cv::SparseMat::Hdr	access:public
pool	/usr/include/opencv2/flann/kdtree_index.h	/^	PooledAllocator pool;$/;"	m	class:cvflann::KDTreeIndex	access:private
pool	/usr/include/opencv2/flann/kmeans_index.h	/^	PooledAllocator pool;$/;"	m	class:cvflann::KMeansIndex	access:private
popMin	/usr/include/opencv2/flann/heap.h	/^	bool popMin(T& value)$/;"	f	class:cvflann::Heap	access:public	signature:(T& value)
pop_back	/usr/include/opencv2/core/core.hpp	/^    void pop_back();$/;"	p	class:cv::Seq	access:public	signature:()
pop_back	/usr/include/opencv2/core/core.hpp	/^    void pop_back(_Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(_Tp* elems, size_t count)
pop_back	/usr/include/opencv2/core/core.hpp	/^    void pop_back(size_t nelems=1);$/;"	p	class:cv::Mat	access:public	signature:(size_t nelems=1)
pop_back	/usr/include/opencv2/core/operations.hpp	/^    Vector<_Tp>& pop_back()$/;"	f	class:cv::Vector	access:public	signature:()
pop_back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_back()$/;"	f	class:cv::Seq	signature:()
pop_back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_back(_Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(_Tp* elem, size_t count)
pop_front	/usr/include/opencv2/core/core.hpp	/^    void pop_front();$/;"	p	class:cv::Seq	access:public	signature:()
pop_front	/usr/include/opencv2/core/core.hpp	/^    void pop_front(_Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(_Tp* elems, size_t count)
pop_front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_front()$/;"	f	class:cv::Seq	signature:()
pop_front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_front(_Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(_Tp* elem, size_t count)
portion	/usr/include/opencv2/ml/ml.hpp	/^        float *portion;$/;"	m	union:CvTrainTestSplit::__anon92	access:public
portion	/usr/include/opencv2/ml/ml.hpp	/^        float portion;$/;"	m	union:CvTrainTestSplit::__anon91	access:public
pos	/usr/include/opencv2/core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::LineIterator	access:public	signature:() const
pos	/usr/include/opencv2/core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
pos	/usr/include/opencv2/core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:() const
pos	/usr/include/opencv2/core/core.hpp	/^    void pos(int* _idx) const;$/;"	p	class:cv::MatConstIterator	access:public	signature:(int* _idx) const
pos	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Point MatConstIterator_<_Tp>::pos() const$/;"	f	class:cv::MatConstIterator_	signature:() const
pos	/usr/include/opencv2/core/operations.hpp	/^inline Point LineIterator::pos() const$/;"	f	class:cv::LineIterator	signature:() const
poseCount	/usr/include/opencv2/features2d/features2d.hpp	/^        int poseCount;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
posit_object	/usr/include/opencv2/calib3d/calib3d.hpp	/^CVAPI(void)  cvReleasePOSITObject( CvPOSITObject**  posit_object );$/;"	v
posteriors	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<float> posteriors;$/;"	m	class:cv::FernClassifier	access:protected
posteriors2_	/usr/include/opencv2/features2d/features2d.hpp	/^  uchar **posteriors2_;     \/\/ 16-bytes aligned posteriors$/;"	m	class:cv::RandomizedTree	access:private
posteriors_	/usr/include/opencv2/features2d/features2d.hpp	/^  float **posteriors_;        \/\/ 16-bytes aligned posteriors$/;"	m	class:cv::RandomizedTree	access:private
posteriors_	/usr/include/opencv2/features2d/features2d.hpp	/^  mutable uchar **posteriors_;$/;"	m	class:cv::RTreeClassifier	access:private
pow	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void pow(const Mat& src, double power, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, double power, CV_OUT Mat& dst)
ppFaceTracker	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(void) cvReleaseFaceTracker(CvFaceTracker** ppFaceTracker);$/;"	v
preCornerDetect	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void preCornerDetect( const Mat& src, CV_OUT Mat& dst, int ksize,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ksize, int borderType=BORDER_DEFAULT )
preFilterCap	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int preFilterCap;$/;"	m	class:cv::StereoSGBM	access:public
preFilterCap	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int preFilterCap; \/\/ the output of pre-filtering is clipped by [-preFilterCap,preFilterCap]$/;"	m	struct:CvStereoBMState	access:public
preFilterSize	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int preFilterSize; \/\/ averaging window size: ~5x5..21x21$/;"	m	struct:CvStereoBMState	access:public
preFilterType	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int preFilterType; \/\/ =CV_STEREO_BM_NORMALIZED_RESPONSE now$/;"	m	struct:CvStereoBMState	access:public
preFilteredImg0	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* preFilteredImg0;$/;"	m	struct:CvStereoBMState	access:public
preFilteredImg1	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* preFilteredImg1;$/;"	m	struct:CvStereoBMState	access:public
predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual CvDTreeNode* predict( const cv::Mat& sample, const cv::Mat& missingDataMask=cv::Mat(),$/;"	p	class:CvDTree	access:public	signature:( const cv::Mat& sample, const cv::Mat& missingDataMask=cv::Mat(), bool preprocessedInput=false ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& inputs, cv::Mat& outputs ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& inputs, cv::Mat& outputs ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, CV_OUT cv::Mat* probs=0 ) const;$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& sample, CV_OUT cv::Mat* probs=0 ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, bool returnDFVal=false ) const;    $/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& sample, bool returnDFVal=false ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const;$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(),$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(), const cv::Range& slice=cv::Range::all(), bool rawMode=false, bool returnSum=false ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(),$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(), const cv::Range& slice = cv::Range::all(), int k=-1 ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& samples, CV_OUT cv::Mat* results=0 ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& samples, CV_OUT cv::Mat* results=0 ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeNode* predict( const CvMat* sample, const CvMat* missingDataMask=0,$/;"	p	class:CvDTree	access:public	signature:( const CvMat* sample, const CvMat* missingDataMask=0, bool preprocessedInput=false ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* inputs, CV_OUT CvMat* outputs ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* inputs, CV_OUT CvMat* outputs ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* sample, CV_OUT CvMat* probs ) const;$/;"	p	class:CvEM	access:public	signature:( const CvMat* sample, CV_OUT CvMat* probs ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* sample, bool returnDFVal=false ) const;$/;"	p	class:CvSVM	access:public	signature:( const CvMat* sample, bool returnDFVal=false ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing = 0 ) const;$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample, const CvMat* missing = 0 ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing=0,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* sample, const CvMat* missing=0, CvMat* weak_responses=0, CvSlice slice=CV_WHOLE_SEQ, bool raw_mode=false, bool return_sum=false ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing=0,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* sample, const CvMat* missing=0, CvMat* weakResponses=0, CvSlice slice = CV_WHOLE_SEQ, int k=-1 ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const CvMat* samples, CV_OUT CvMat* results=0 ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* samples, CV_OUT CvMat* results=0 ) const
predict	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict( const float* row_sample, int row_len, bool returnDFVal=false ) const;$/;"	p	class:CvSVM	access:protected	signature:( const float* row_sample, int row_len, bool returnDFVal=false ) const
predict	/usr/include/opencv2/video/tracking.hpp	/^    CV_WRAP const Mat& predict(const Mat& control=Mat());$/;"	p	class:cv::KalmanFilter	access:public	signature:(const Mat& control=Mat())
predict_prob	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual float predict_prob( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const;$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const
predict_prob	/usr/include/opencv2/ml/ml.hpp	/^    virtual float predict_prob( const CvMat* sample, const CvMat* missing = 0 ) const;$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample, const CvMat* missing = 0 ) const
prepare	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void prepare(int _nclasses, int _patchSize, int _signatureSize,$/;"	p	class:cv::FernClassifier	access:protected	signature:(int _nclasses, int _patchSize, int _signatureSize, int _nstructs, int _structSize, int _nviews, int _compressionMethod)
prepare_to_train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool prepare_to_train( const CvMat* _inputs, const CvMat* _outputs,$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _inputs, const CvMat* _outputs, const CvMat* _sample_weights, const CvMat* sampleIdx, CvVectors* _ivecs, CvVectors* _ovecs, double** _sw, int _flags )
preset	/usr/include/opencv2/gpu/gpu.hpp	/^            int preset;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
prev	/usr/include/opencv2/core/types_c.h	/^    struct CvMemBlock*  prev;$/;"	m	struct:CvMemBlock	typeref:struct:CvMemBlock::CvMemBlock	access:public
prev	/usr/include/opencv2/core/types_c.h	/^    struct CvSeqBlock*  prev; \/* Previous sequence block.                   *\/$/;"	m	struct:CvSeqBlock	typeref:struct:CvSeqBlock::CvSeqBlock	access:public
prev	/usr/include/opencv2/core/types_c.h	/^    struct CvTypeInfo* prev;$/;"	m	struct:CvTypeInfo	typeref:struct:CvTypeInfo::CvTypeInfo	access:public
prev	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernelRow* prev;$/;"	m	struct:CvSVMKernelRow	access:public
prevErrNorm	/usr/include/opencv2/calib3d/calib3d.hpp	/^    double prevErrNorm, errNorm;$/;"	m	class:CvLevMarq	access:public
prevErrNorm	/usr/include/opencv2/contrib/contrib.hpp	/^        double prevErrNorm, errNorm;$/;"	m	class:cv::LevMarqSparse	access:protected
prevP	/usr/include/opencv2/contrib/contrib.hpp	/^        CvMat* prevP; \/\/current already accepted parameter.$/;"	m	class:cv::LevMarqSparse	access:protected
prevParam	/usr/include/opencv2/calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> prevParam;$/;"	m	class:CvLevMarq	access:public
prevTrainCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int prevTrainCount;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
prevTrainCount	/usr/include/opencv2/features2d/features2d.hpp	/^    int prevTrainCount;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
prev_frame	/usr/include/opencv2/video/background_segm.hpp	/^    IplImage*              prev_frame;$/;"	m	struct:CvFGDStatModel	access:public
principal_point	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f principal_point; \/* copied from intrinsics so this structure *\/$/;"	m	struct:__anon175	access:public
principal_point	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f principal_point;$/;"	m	struct:__anon176	access:public
print	/usr/include/opencv2/flann/autotuned_index.h	/^	void print() const$/;"	f	struct:cvflann::AutotunedIndexParams	access:public	signature:() const
print	/usr/include/opencv2/flann/composite_index.h	/^	void print() const$/;"	f	struct:cvflann::CompositeIndexParams	access:public	signature:() const
print	/usr/include/opencv2/flann/flann_base.hpp	/^	void print() const$/;"	f	struct:cvflann::SavedIndexParams	access:public	signature:() const
print	/usr/include/opencv2/flann/general.h	/^	virtual void print() const = 0;$/;"	p	struct:cvflann::IndexParams	access:public	signature:() const
print	/usr/include/opencv2/flann/kdtree_index.h	/^	void print() const$/;"	f	struct:cvflann::KDTreeIndexParams	access:public	signature:() const
print	/usr/include/opencv2/flann/kmeans_index.h	/^	void print() const$/;"	f	struct:cvflann::KMeansIndexParams	access:public	signature:() const
print	/usr/include/opencv2/flann/linear_index.h	/^	void print() const$/;"	f	struct:cvflann::LinearIndexParams	access:public	signature:() const
priors	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* priors;$/;"	m	struct:CvDTreeTrainData	access:public
priors	/usr/include/opencv2/ml/ml.hpp	/^    const float* priors;$/;"	m	struct:CvDTreeParams	access:public
priors_mult	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* priors_mult;$/;"	m	struct:CvDTreeTrainData	access:public
problem_type	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool problem_type() const;$/;"	p	class:CvGBTrees	access:protected	signature:() const
probs	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* probs;$/;"	m	class:CvEM	access:protected
probs	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* probs;$/;"	m	struct:CvEMParams	access:public
proceed	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual int proceed(const uchar* src, int srcStep, int srcCount,$/;"	p	class:cv::FilterEngine	access:public	signature:(const uchar* src, int srcStep, int srcCount, uchar* dst, int dstStep)
process	/usr/include/opencv2/contrib/contrib.hpp	/^    virtual void process(IplImage *inputBGRImage, IplImage *outputHueMask);$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:(IplImage *inputBGRImage, IplImage *outputHueMask)
process	/usr/include/opencv2/core/mat.hpp	/^process( const Mat_<T1>& m1, Mat_<T2>& m2, Op op )$/;"	f	namespace:cv	signature:( const Mat_<T1>& m1, Mat_<T2>& m2, Op op )
process	/usr/include/opencv2/core/mat.hpp	/^process( const Mat_<T1>& m1, const Mat_<T2>& m2, Mat_<T3>& m3, Op op )$/;"	f	namespace:cv	signature:( const Mat_<T1>& m1, const Mat_<T2>& m2, Mat_<T3>& m3, Op op )
processNoiseCov	/usr/include/opencv2/video/tracking.hpp	/^    Mat processNoiseCov;    \/\/!< process noise covariance matrix (Q)$/;"	m	class:cv::KalmanFilter	access:public
process_noise_cov	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* process_noise_cov;   \/* process noise covariance matrix (Q) *\/$/;"	m	struct:CvKalman	access:public
productsum	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** productsum;$/;"	m	class:CvNormalBayesClassifier	access:protected
project	/usr/include/opencv2/core/core.hpp	/^    Mat project(const Mat& vec) const;$/;"	p	class:cv::PCA	access:public	signature:(const Mat& vec) const
project	/usr/include/opencv2/core/core.hpp	/^    void project(const Mat& vec, CV_OUT Mat& result) const;$/;"	p	class:cv::PCA	access:public	signature:(const Mat& vec, CV_OUT Mat& result) const
projectPoints	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_AS(projectPointsJ) void projectPoints( const Mat& objectPoints,$/;"	p	namespace:cv	signature:( const Mat& objectPoints, const Mat& rvec, const Mat& tvec, const Mat& cameraMatrix, const Mat& distCoeffs, CV_OUT vector<Point2f>& imagePoints, CV_OUT Mat& dpdrot, CV_OUT Mat& dpdt, CV_OUT Mat& dpdf, CV_OUT Mat& dpdc, CV_OUT Mat& dpddist, double aspectRatio=0 )
projectPoints	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void projectPoints( const Mat& objectPoints,$/;"	p	namespace:cv	signature:( const Mat& objectPoints, const Mat& rvec, const Mat& tvec, const Mat& cameraMatrix, const Mat& distCoeffs, CV_OUT vector<Point2f>& imagePoints )
prune	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void prune( CvSlice slice );$/;"	p	class:CvBoost	access:public	signature:( CvSlice slice )
prune_cv	/usr/include/opencv2/ml/ml.hpp	/^    virtual void prune_cv();$/;"	p	class:CvDTree	access:protected	signature:()
pruned_tree_idx	/usr/include/opencv2/ml/ml.hpp	/^    int pruned_tree_idx;$/;"	m	class:CvDTree	access:public
pt	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW Point2f pt; \/\/!< coordinates of the keypoints$/;"	m	class:cv::KeyPoint	access:public
pt	/usr/include/opencv2/features2d/features2d.hpp	/^    CvPoint pt;$/;"	m	struct:CvStarKeypoint	access:public
pt	/usr/include/opencv2/features2d/features2d.hpp	/^    CvPoint2D32f pt;$/;"	m	struct:CvSURFPoint	access:public
pt	/usr/include/opencv2/imgproc/types_c.h	/^    CvPoint   pt;$/;"	m	struct:CvChainPtReader	access:public
ptemp_	/usr/include/opencv2/features2d/features2d.hpp	/^  mutable unsigned short *ptemp_;$/;"	m	class:cv::RTreeClassifier	access:private
ptr	/usr/include/opencv2/core/core.hpp	/^    _Tp* ptr;$/;"	m	class:cv::AutoBuffer	access:protected
ptr	/usr/include/opencv2/core/core.hpp	/^    const uchar* ptr(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
ptr	/usr/include/opencv2/core/core.hpp	/^    const uchar* ptr(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
ptr	/usr/include/opencv2/core/core.hpp	/^    const uchar* ptr(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
ptr	/usr/include/opencv2/core/core.hpp	/^    const uchar* ptr(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
ptr	/usr/include/opencv2/core/core.hpp	/^    template<int n> const uchar* ptr(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
ptr	/usr/include/opencv2/core/core.hpp	/^    template<int n> uchar* ptr(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> _Tp* ptr(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp, int n> const _Tp* ptr(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp* ptr(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
ptr	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(const int* idx, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, bool createMissing, size_t* hashval=0)
ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, bool createMissing, size_t* hashval=0)
ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0, int i1, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, bool createMissing, size_t* hashval=0)
ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, bool createMissing, size_t* hashval=0)
ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::LineIterator	access:public
ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::MatConstIterator	access:public
ptr	/usr/include/opencv2/core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::SparseMatConstIterator	access:public
ptr	/usr/include/opencv2/core/core_c.h	/^    uchar* ptr[CV_MAX_ARR]; \/* pointers to the array slices *\/$/;"	m	struct:CvNArrayIterator	access:public
ptr	/usr/include/opencv2/core/mat.hpp	/^inline const uchar* Mat::ptr(const int* idx) const$/;"	f	class:cv::Mat	signature:(const int* idx) const
ptr	/usr/include/opencv2/core/mat.hpp	/^inline const uchar* Mat::ptr(int i0, int i1) const$/;"	f	class:cv::Mat	signature:(int i0, int i1) const
ptr	/usr/include/opencv2/core/mat.hpp	/^inline const uchar* Mat::ptr(int i0, int i1, int i2) const$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2) const
ptr	/usr/include/opencv2/core/mat.hpp	/^inline const uchar* Mat::ptr(int y) const$/;"	f	class:cv::Mat	signature:(int y) const
ptr	/usr/include/opencv2/core/mat.hpp	/^inline uchar* Mat::ptr(const int* idx)$/;"	f	class:cv::Mat	signature:(const int* idx)
ptr	/usr/include/opencv2/core/mat.hpp	/^inline uchar* Mat::ptr(int i0, int i1)$/;"	f	class:cv::Mat	signature:(int i0, int i1)
ptr	/usr/include/opencv2/core/mat.hpp	/^inline uchar* Mat::ptr(int i0, int i1, int i2)$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2)
ptr	/usr/include/opencv2/core/mat.hpp	/^inline uchar* Mat::ptr(int y)$/;"	f	class:cv::Mat	signature:(int y)
ptr	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat::ptr(int y)$/;"	f	class:cv::Mat	signature:(int y)
ptr	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat::ptr(int y) const$/;"	f	class:cv::Mat	signature:(int y) const
ptr	/usr/include/opencv2/core/types_c.h	/^        uchar* ptr;$/;"	m	union:CvMat::__anon94	access:public
ptr	/usr/include/opencv2/core/types_c.h	/^        uchar* ptr;$/;"	m	union:CvMatND::__anon97	access:public
ptr	/usr/include/opencv2/core/types_c.h	/^    CvPoint2D32f* ptr;$/;"	m	struct:CvGraphVtx2D	access:public
ptr	/usr/include/opencv2/core/types_c.h	/^    char* ptr;$/;"	m	struct:CvString	access:public
ptr	/usr/include/opencv2/core/types_c.h	/^    uchar* ptr;$/;"	m	struct:CvLineIterator	access:public
ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return (T*)( (char*)data + y * step ); }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int y = 0)
ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return (T*)( (char*)data + y * step); }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(int y = 0)
ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return PtrStep_<T>::data + y * PtrStep_<T>::step; }$/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(int y = 0)
ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return (const T*)( (const char*)data + y * step ); }            $/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int y = 0) const
ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return (const T*)( (const char*)data + y * step); }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(int y = 0) const
ptr	/usr/include/opencv2/gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return PtrStep_<T>::data + y * PtrStep_<T>::step; }$/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(int y = 0) const
ptr	/usr/include/opencv2/gpu/gpu.hpp	/^            const uchar* ptr(int y = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0) const
ptr	/usr/include/opencv2/gpu/gpu.hpp	/^            template<typename _Tp> _Tp* ptr(int y = 0);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0)
ptr	/usr/include/opencv2/gpu/gpu.hpp	/^            template<typename _Tp> const _Tp* ptr(int y = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0) const
ptr	/usr/include/opencv2/gpu/gpu.hpp	/^            uchar* ptr(int y = 0);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0)
ptr	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline const uchar* GpuMat::ptr(int y) const$/;"	f	class:cv::gpu::GpuMat	signature:(int y) const
ptr	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline uchar* GpuMat::ptr(int y)$/;"	f	class:cv::gpu::GpuMat	signature:(int y)
ptr	/usr/include/opencv2/gpu/matrix_operations.hpp	/^template<typename _Tp> inline _Tp* GpuMat::ptr(int y)$/;"	f	class:cv::gpu::GpuMat	signature:(int y)
ptr	/usr/include/opencv2/gpu/matrix_operations.hpp	/^template<typename _Tp> inline const _Tp* GpuMat::ptr(int y) const$/;"	f	class:cv::gpu::GpuMat	signature:(int y) const
ptr	/usr/include/opencv2/ml/ml.hpp	/^        uchar** ptr;$/;"	m	union:CvVectors::__anon76	access:public
ptr0	/usr/include/opencv2/core/core.hpp	/^    const uchar* ptr0;$/;"	m	class:cv::LineIterator	access:public
ptrLeft	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* ptrLeft;$/;"	m	struct:CvStereoGCState	access:public
ptrRight	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* ptrRight;$/;"	m	struct:CvStereoGCState	access:public
push_back	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> void push_back(const Mat_<_Tp>& elem);$/;"	p	class:cv::Mat	access:public	signature:(const Mat_<_Tp>& elem)
push_back	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> void push_back(const _Tp& elem);$/;"	p	class:cv::Mat	access:public	signature:(const _Tp& elem)
push_back	/usr/include/opencv2/core/core.hpp	/^    void push_back(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
push_back	/usr/include/opencv2/core/core.hpp	/^    void push_back(const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem)
push_back	/usr/include/opencv2/core/core.hpp	/^    void push_back(const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp* elems, size_t count)
push_back	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat::push_back(const Mat_<_Tp>& m)$/;"	f	class:cv::Mat	signature:(const Mat_<_Tp>& m)
push_back	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline void Mat::push_back(const _Tp& elem)$/;"	f	class:cv::Mat	signature:(const _Tp& elem)
push_back	/usr/include/opencv2/core/operations.hpp	/^    Vector<_Tp>& push_back(const _Tp& elem)$/;"	f	class:cv::Vector	access:public	signature:(const _Tp& elem)
push_back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp& elem)$/;"	f	class:cv::Seq	signature:(const _Tp& elem)
push_back	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(const _Tp* elem, size_t count)
push_back_	/usr/include/opencv2/core/core.hpp	/^    void push_back_(const void* elem);$/;"	p	class:cv::Mat	access:public	signature:(const void* elem)
push_front	/usr/include/opencv2/core/core.hpp	/^    void push_front(const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem)
push_front	/usr/include/opencv2/core/core.hpp	/^    void push_front(const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp* elems, size_t count)
push_front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp& elem)$/;"	f	class:cv::Seq	signature:(const _Tp& elem)
push_front	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(const _Tp* elem, size_t count)
putText	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void putText( Mat& img, const string& text, Point org,$/;"	p	namespace:cv	signature:( Mat& img, const string& text, Point org, int fontFace, double fontScale, Scalar color, int thickness=1, int linetype=8, bool bottomLeftOrigin=false )
pyrDown	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrDown( const Mat& src, CV_OUT Mat& dst, const Size& dstsize=Size());$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Size& dstsize=Size())
pyrMeanShiftFiltering	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrMeanShiftFiltering( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, double sp, double sr, int maxLevel=1, TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) )
pyrUp	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrUp( const Mat& src, CV_OUT Mat& dst, const Size& dstsize=Size());$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Size& dstsize=Size())
qangle	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat grad, qangle;            $/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
quad	/usr/include/opencv2/legacy/legacy.hpp	/^    CvPoint2D32f quad[2][4]; \/* coordinates of destination quadrangle after$/;"	m	struct:CvStereoCamera	access:public
quality	/usr/include/opencv2/ml/ml.hpp	/^    float quality;$/;"	m	struct:CvDTreeSplit	access:public
qualityLevel	/usr/include/opencv2/features2d/features2d.hpp	/^        double qualityLevel;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
quantizeVector	/usr/include/opencv2/features2d/features2d.hpp	/^  static void quantizeVector(float *src, int dim, int N, float bnds[2], uchar *dst);$/;"	p	class:cv::RandomizedTree	access:public	signature:(float *src, int dim, int N, float bnds[2], uchar *dst)
quantizeVector	/usr/include/opencv2/features2d/features2d.hpp	/^  static void quantizeVector(float *vec, int dim, int N, float bnds[2], int clamp_mode=0);$/;"	p	class:cv::RandomizedTree	access:public	signature:(float *vec, int dim, int N, float bnds[2], int clamp_mode=0)
query	/usr/include/opencv2/legacy/legacy.hpp	/^    float query( int* bin ) const$/;"	f	class:CvCamShiftTracker	access:public	signature:( int* bin ) const
queryIdx	/usr/include/opencv2/features2d/features2d.hpp	/^    int queryIdx; \/\/ query descriptor index$/;"	m	struct:cv::DMatch	access:public
queryIfComplete	/usr/include/opencv2/gpu/gpu.hpp	/^            bool queryIfComplete();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
r	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
r	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
r	/usr/include/opencv2/ml/ml.hpp	/^    double r;   \/\/ for Solver_NU$/;"	m	struct:CvSVMSolutionInfo	access:public
r	/usr/include/opencv2/objdetect/objdetect.hpp	/^        CvRect r;$/;"	m	struct:CvHaarFeature::__anon58	access:public
r2	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
radius	/usr/include/opencv2/features2d/features2d.hpp	/^    int radius;$/;"	m	class:cv::LDetector	access:public
radius	/usr/include/opencv2/flann/kmeans_index.h	/^		DIST_TYPE radius;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
radius	/usr/include/opencv2/flann/result_set.h	/^	float radius;$/;"	m	class:cvflann::RadiusResultSet	access:private
radius	/usr/include/opencv2/gpu/gpu.hpp	/^            int radius;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
radiusMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const Mat& mask=Mat(), bool compactResult=false ) const
radiusMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
radiusMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const Mat& mask=Mat(), bool compactResult=false ) const
radiusMatch	/usr/include/opencv2/features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::BruteForceMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::OneWayDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::VectorDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^void BruteForceMatcher<Distance>::radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches,$/;"	f	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusMatchImpl	/usr/include/opencv2/features2d/features2d.hpp	/^void BruteForceMatcher<L2<float> >::radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches,$/;"	p	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusSearch	/usr/include/opencv2/flann/flann.hpp	/^	int radiusSearch(const Mat& query, Mat& indices, Mat& dists, float radius, const SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& query, Mat& indices, Mat& dists, float radius, const SearchParams& params)
radiusSearch	/usr/include/opencv2/flann/flann.hpp	/^	int radiusSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const vector<T>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& params)
radiusSearch	/usr/include/opencv2/flann/flann.hpp	/^int Index_<T>::radiusSearch(const Mat& query, Mat& indices, Mat& dists, float radius, const SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const Mat& query, Mat& indices, Mat& dists, float radius, const SearchParams& searchParams)
radiusSearch	/usr/include/opencv2/flann/flann.hpp	/^int Index_<T>::radiusSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const vector<T>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& searchParams)
radiusSearch	/usr/include/opencv2/flann/flann_base.hpp	/^	int radiusSearch(const Matrix<T>& query, Matrix<int>& indices, Matrix<float>& dists, float radius, const SearchParams& params);$/;"	p	class:cvflann::Index	access:public	signature:(const Matrix<T>& query, Matrix<int>& indices, Matrix<float>& dists, float radius, const SearchParams& params)
radiusSearch	/usr/include/opencv2/flann/flann_base.hpp	/^int Index<T>::radiusSearch(const Matrix<T>& query, Matrix<int>& indices, Matrix<float>& dists, float radius, const SearchParams& searchParams)$/;"	f	class:cvflann::Index	signature:(const Matrix<T>& query, Matrix<int>& indices, Matrix<float>& dists, float radius, const SearchParams& searchParams)
randShuffle	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void randShuffle(Mat& dst, double iterFactor=1., RNG* rng=0);$/;"	p	namespace:cv	signature:(Mat& dst, double iterFactor=1., RNG* rng=0)
rand_double	/usr/include/opencv2/flann/random.h	/^CV_EXPORTS double rand_double(double high = 1.0, double low=0);$/;"	p	namespace:cvflann	signature:(double high = 1.0, double low=0)
rand_int	/usr/include/opencv2/flann/random.h	/^CV_EXPORTS int rand_int(int high = RAND_MAX, int low = 0);$/;"	p	namespace:cvflann	signature:(int high = RAND_MAX, int low = 0)
randn	/usr/include/opencv2/core/core.hpp	/^    static Matx randn(_Tp a, _Tp b);$/;"	p	class:cv::Matx	access:public	signature:(_Tp a, _Tp b)
randn	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void randn(CV_OUT Mat& dst, const Scalar& mean, const Scalar& stddev);$/;"	p	namespace:cv	signature:(CV_OUT Mat& dst, const Scalar& mean, const Scalar& stddev)
randn	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::randn(_Tp a, _Tp b)$/;"	f	class:cv::Matx	signature:(_Tp a, _Tp b)
randomBlur	/usr/include/opencv2/features2d/features2d.hpp	/^    bool randomBlur;$/;"	m	class:cv::PatchGenerator	access:public
random_sample	/usr/include/opencv2/flann/sampling.h	/^Matrix<T> random_sample(Matrix<T>& srcMatrix, long size, bool remove = false)$/;"	f	namespace:cvflann	signature:(Matrix<T>& srcMatrix, long size, bool remove = false)
random_sample	/usr/include/opencv2/flann/sampling.h	/^Matrix<T> random_sample(const Matrix<T>& srcMatrix, size_t size)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& srcMatrix, size_t size)
randu	/usr/include/opencv2/core/core.hpp	/^    static Matx randu(_Tp a, _Tp b);$/;"	p	class:cv::Matx	access:public	signature:(_Tp a, _Tp b)
randu	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void randu(CV_OUT Mat& dst, const Scalar& low, const Scalar& high);$/;"	p	namespace:cv	signature:(CV_OUT Mat& dst, const Scalar& low, const Scalar& high)
randu	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> static inline _Tp randu() { return (_Tp)theRNG(); }$/;"	f	namespace:cv	signature:()
randu	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::randu(_Tp a, _Tp b)$/;"	f	class:cv::Matx	signature:(_Tp a, _Tp b)
re	/usr/include/opencv2/core/core.hpp	/^    _Tp re, im; \/\/< the real and the imaginary parts$/;"	m	class:cv::Complex	access:public
read	/usr/include/opencv2/core/operations.hpp	/^    static void* read(CvFileStorage* fs, CvFileNode* n)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(CvFileStorage* fs, CvFileNode* n)
read	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void read(const FileNode& node, SparseMat& mat, const SparseMat& default_mat=SparseMat() );    $/;"	p	namespace:cv	signature:(const FileNode& node, SparseMat& mat, const SparseMat& default_mat=SparseMat() )
read	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void read(const FileNode& node, Mat& mat, const Mat& default_mat=Mat() );$/;"	p	namespace:cv	signature:(const FileNode& node, Mat& mat, const Mat& default_mat=Mat() )
read	/usr/include/opencv2/core/operations.hpp	/^read( FileNode& node, vector<_Tp>& vec, const vector<_Tp>& default_value=vector<_Tp>() )$/;"	f	namespace:cv	signature:( FileNode& node, vector<_Tp>& vec, const vector<_Tp>& default_value=vector<_Tp>() )
read	/usr/include/opencv2/core/operations.hpp	/^read( FileNodeIterator& it, vector<_Tp>& vec, size_t maxCount=(size_t)INT_MAX )$/;"	f	namespace:cv	signature:( FileNodeIterator& it, vector<_Tp>& vec, size_t maxCount=(size_t)INT_MAX )
read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, bool& value, bool default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, bool& value, bool default_value)
read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, double& value, double default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, double& value, double default_value)
read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, float& value, float default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, float& value, float default_value)
read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, int& value, int default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, int& value, int default_value)
read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, schar& value, schar default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, schar& value, schar default_value)
read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, short& value, short default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, short& value, short default_value)
read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, string& value, const string& default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, string& value, const string& default_value)
read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, uchar& value, uchar default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, uchar& value, uchar default_value)
read	/usr/include/opencv2/core/operations.hpp	/^static inline void read(const FileNode& node, ushort& value, ushort default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, ushort& value, ushort default_value)
read	/usr/include/opencv2/core/types_c.h	/^    CvReadFunc read;$/;"	m	struct:CvTypeInfo	access:public
read	/usr/include/opencv2/features2d/features2d.hpp	/^        void read( const FileNode& fn );$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( const FileNode& fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( const FileNode &fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( const FileNode &fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const FileNode &fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( const FileNode &fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( const FileNode &fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const FileNode& )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const FileNode& )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::FeatureDetector	access:public	signature:( const FileNode& )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const FileNode& )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( const FileNode& )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( const FileNode& fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( const FileNode& fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( const FileNode& fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( const FileNode& fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( const FileNode& fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( const FileNode& fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const FileNode& fn )
read	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void read(const FileNode& n);$/;"	p	class:cv::FernClassifier	access:public	signature:(const FileNode& n)
read	/usr/include/opencv2/features2d/features2d.hpp	/^    void read(const FileNode& node);$/;"	p	class:cv::LDetector	access:public	signature:(const FileNode& node)
read	/usr/include/opencv2/features2d/features2d.hpp	/^    void read(const FileNode& node);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const FileNode& node)
read	/usr/include/opencv2/features2d/features2d.hpp	/^  void read(const char* file_name);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(const char* file_name)
read	/usr/include/opencv2/features2d/features2d.hpp	/^  void read(const char* file_name, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:public	signature:(const char* file_name, int num_quant_bits)
read	/usr/include/opencv2/features2d/features2d.hpp	/^  void read(std::istream &is);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::istream &is)
read	/usr/include/opencv2/features2d/features2d.hpp	/^  void read(std::istream &is, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::istream &is, int num_quant_bits)
read	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void read(const FileNode& node, CV_OUT vector<KeyPoint>& keypoints);    $/;"	p	namespace:cv	signature:(const FileNode& node, CV_OUT vector<KeyPoint>& keypoints)
read	/usr/include/opencv2/features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::read( const FileNode& )$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( const FileNode& )
read	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool read(CV_OUT Mat& image);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image)
read	/usr/include/opencv2/legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* mapname, const char* imgname );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* imgname )
read	/usr/include/opencv2/legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* mapname, const char* matname );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* matname )
read	/usr/include/opencv2/legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* seqname, int idx );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
read	/usr/include/opencv2/legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* seqname, int idx );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvANN_MLP	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvGBTrees	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvRTrees	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node, CvRTrees* forest, CvDTreeTrainData* _data );$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvRTrees* forest, CvDTreeTrainData* _data )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvBoost* ensemble, CvDTreeTrainData* _data )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvBoost	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvSVM	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
read	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvStatModel	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
read	/usr/include/opencv2/objdetect/objdetect.hpp	/^    bool read(const FileNode& node);$/;"	p	class:cv::CascadeClassifier	access:public	signature:(const FileNode& node)
read	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual bool read(FileNode& fn);$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(FileNode& fn)
read	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual bool read(const FileNode& node);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(const FileNode& node)
readObj	/usr/include/opencv2/core/core.hpp	/^    void* readObj() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
readRaw	/usr/include/opencv2/core/core.hpp	/^    FileNodeIterator& readRaw( const string& fmt, uchar* vec,$/;"	p	class:cv::FileNodeIterator	access:public	signature:( const string& fmt, uchar* vec, size_t maxCount=(size_t)INT_MAX )
readRaw	/usr/include/opencv2/core/core.hpp	/^    void readRaw( const string& fmt, uchar* vec, size_t len ) const;$/;"	p	class:cv::FileNode	access:public	signature:( const string& fmt, uchar* vec, size_t len ) const
readRaw	/usr/include/opencv2/core/operations.hpp	/^inline void FileNode::readRaw( const string& fmt, uchar* vec, size_t len ) const$/;"	f	class:cv::FileNode	signature:( const string& fmt, uchar* vec, size_t len ) const
read_csv	/usr/include/opencv2/ml/ml.hpp	/^    int read_csv(const char* filename);$/;"	p	class:CvMLData	access:public	signature:(const char* filename)
read_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeNode* read_node( CvFileStorage* fs, CvFileNode* node, CvDTreeNode* parent );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeNode* parent )
read_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* fnode );$/;"	p	class:CvGBTrees	access:protected	signature:( CvFileStorage* fs, CvFileNode* fnode )
read_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
read_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvBoost	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
read_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvSVM	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
read_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read_split	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeSplit* read_split( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
read_tree_nodes	/usr/include/opencv2/ml/ml.hpp	/^    virtual void read_tree_nodes( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
reader	/usr/include/opencv2/core/core.hpp	/^    CvSeqReader reader;$/;"	m	class:cv::FileNodeIterator	access:public
reader	/usr/include/opencv2/core/core_c.h	/^CVAPI(int)  cvGetSeqReaderPos( CvSeqReader* reader );$/;"	v
reader	/usr/include/opencv2/imgproc/imgproc_c.h	/^CVAPI(CvPoint) cvReadChainPoint( CvChainPtReader* reader );$/;"	v
real_window_size	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvSize real_window_size;$/;"	m	struct:CvHaarClassifierCascade	access:public
rebind	/usr/include/opencv2/core/core.hpp	/^    template<typename U> class rebind { typedef Allocator<U> other; };$/;"	c	class:cv::Allocator	access:public
recalculateAngles	/usr/include/opencv2/features2d/features2d.hpp	/^        bool recalculateAngles;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
rect	/usr/include/opencv2/imgproc/types_c.h	/^    CvRect rect;    \/* ROI of the component  *\/$/;"	m	struct:CvConnectedComp	access:public
rect	/usr/include/opencv2/objdetect/objdetect.hpp	/^	CvRect rect;$/;"	m	struct:CvObjectDetection	access:public
rect	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvRect rect;$/;"	m	struct:CvAvgComp	access:public
rect	/usr/include/opencv2/objdetect/objdetect.hpp	/^    } rect[CV_HAAR_FEATURE_MAX];$/;"	m	struct:CvHaarFeature	typeref:struct:CvHaarFeature::__anon58	access:public
rectMap	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat*  rectMap[MAX_CAMERAS][2];$/;"	m	class:CvCalibFilter	access:protected
rectStdDev	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void rectStdDev(const GpuMat& src, const GpuMat& sqr, GpuMat& dst, const Rect& rect);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const GpuMat& sqr, GpuMat& dst, const Rect& rect)
rectangle	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void rectangle(Mat& img, Rect rec,$/;"	p	namespace:cv	signature:(Mat& img, Rect rec, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
rectangle	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void rectangle(Mat& img, Point pt1, Point pt2,$/;"	p	namespace:cv	signature:(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
rectify3Collinear	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W float rectify3Collinear( const Mat& cameraMatrix1, const Mat& distCoeffs1,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix1, const Mat& distCoeffs1, const Mat& cameraMatrix2, const Mat& distCoeffs2, const Mat& cameraMatrix3, const Mat& distCoeffs3, const vector<vector<Point2f> >& imgpt1, const vector<vector<Point2f> >& imgpt3, Size imageSize, const Mat& R12, const Mat& T12, const Mat& R13, const Mat& T13, CV_OUT Mat& R1, CV_OUT Mat& R2, CV_OUT Mat& R3, CV_OUT Mat& P1, CV_OUT Mat& P2, CV_OUT Mat& P3, CV_OUT Mat& Q, double alpha, Size newImgSize, CV_OUT Rect* roi1, CV_OUT Rect* roi2, int flags )
redirectError	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS ErrorCallback redirectError( ErrorCallback errCallback,$/;"	p	namespace:cv	signature:( ErrorCallback errCallback, void* userdata=0, void** prevUserdata=0)
reduce	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void reduce(const Mat& src, CV_OUT Mat& dst, int dim, int rtype, int dtype=-1);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int dim, int rtype, int dtype=-1)
ref	/usr/include/opencv2/core/core.hpp	/^    _Tp& ref(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(const int* idx, size_t* hashval=0)
ref	/usr/include/opencv2/core/core.hpp	/^    _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
ref	/usr/include/opencv2/core/core.hpp	/^    _Tp& ref(int i0, int i1, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, size_t* hashval=0)
ref	/usr/include/opencv2/core/core.hpp	/^    _Tp& ref(int i0, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, size_t* hashval=0)
ref	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& ref(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0)
ref	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
ref	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, int i1, size_t* hashval=0);   $/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0)
ref	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, size_t* hashval=0);   $/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0)
ref	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::ref(const int* idx, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(const int* idx, size_t* hashval)
ref	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, int i1, int i2, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, int i2, size_t* hashval)
ref	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, int i1, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, size_t* hashval)
ref	/usr/include/opencv2/core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, size_t* hashval)
ref	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(const int* idx, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval)
ref	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, int i2, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval)
ref	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval)
ref	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval)
refcount	/usr/include/opencv2/core/core.hpp	/^        int refcount;$/;"	m	struct:cv::SparseMat::Hdr	access:public
refcount	/usr/include/opencv2/core/core.hpp	/^    int* refcount; \/\/< the associated                         bbbbbbbbbbbbbbbbbb reference counter$/;"	m	class:cv::Ptr	access:protected
refcount	/usr/include/opencv2/core/core.hpp	/^    int* refcount;$/;"	m	class:cv::Mat	access:public
refcount	/usr/include/opencv2/core/operations.hpp	/^        int* refcount;$/;"	m	struct:cv::Vector::Hdr	access:public
refcount	/usr/include/opencv2/core/types_c.h	/^    int* refcount;$/;"	m	struct:CvMat	access:public
refcount	/usr/include/opencv2/core/types_c.h	/^    int* refcount;$/;"	m	struct:CvMatND	access:public
refcount	/usr/include/opencv2/core/types_c.h	/^    int* refcount;$/;"	m	struct:CvSparseMat	access:public
refcount	/usr/include/opencv2/gpu/gpu.hpp	/^            int* refcount;$/;"	m	class:cv::gpu::CudaMem	access:public
refcount	/usr/include/opencv2/gpu/gpu.hpp	/^            int* refcount;$/;"	m	class:cv::gpu::GpuMat	access:public
refcount	/usr/include/opencv2/legacy/legacy.hpp	/^    int* refcount;$/;"	m	class:CvImage	access:protected
reference	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp& reference;$/;"	t	class:cv::MatIterator_	access:public
reference	/usr/include/opencv2/core/core.hpp	/^    typedef const _Tp& reference;$/;"	t	class:cv::MatConstIterator_	access:public
reference	/usr/include/opencv2/core/core.hpp	/^    typedef uchar* reference;$/;"	t	class:cv::MatConstIterator	access:public
reference	/usr/include/opencv2/core/core.hpp	/^    typedef value_type& reference;$/;"	t	class:cv::Allocator	access:public
reference	/usr/include/opencv2/core/operations.hpp	/^    typedef _Tp& reference;$/;"	t	class:cv::Vector	access:public
register_	/usr/include/opencv2/flann/object_factory.h	/^   bool register_(UniqueIdType id)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id)
regression	/usr/include/opencv2/ml/ml.hpp	/^    bool regression;$/;"	m	class:CvKNearest	access:protected
regression_accuracy	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW float regression_accuracy;$/;"	m	struct:CvDTreeParams	access:public
release	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP virtual void release();$/;"	p	class:cv::FileStorage	access:public	signature:()
release	/usr/include/opencv2/core/core.hpp	/^    void release();$/;"	p	class:cv::Mat	access:public	signature:()
release	/usr/include/opencv2/core/core.hpp	/^    void release();$/;"	p	class:cv::Ptr	access:public	signature:()
release	/usr/include/opencv2/core/core.hpp	/^    void release();$/;"	p	class:cv::SparseMat	access:public	signature:()
release	/usr/include/opencv2/core/mat.hpp	/^inline void Mat::release()$/;"	f	class:cv::Mat	signature:()
release	/usr/include/opencv2/core/mat.hpp	/^inline void SparseMat::release()$/;"	f	class:cv::SparseMat	signature:()
release	/usr/include/opencv2/core/operations.hpp	/^    static void release(void** dbptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(void** dbptr)
release	/usr/include/opencv2/core/operations.hpp	/^    void release()$/;"	f	class:cv::Vector	access:public	signature:()
release	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::release()$/;"	f	class:cv::Ptr	signature:()
release	/usr/include/opencv2/core/types_c.h	/^    CvReleaseFunc release;$/;"	m	struct:CvTypeInfo	access:public
release	/usr/include/opencv2/flann/matrix.h	/^    void release()$/;"	f	class:cvflann::Matrix	access:public	signature:()
release	/usr/include/opencv2/gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
release	/usr/include/opencv2/gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
release	/usr/include/opencv2/gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::Stream	access:private	signature:()
release	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual void release();$/;"	p	class:cv::VideoCapture	access:public	signature:()
release	/usr/include/opencv2/legacy/legacy.hpp	/^    void release() { detach(); }$/;"	f	class:CvImage	access:public	signature:()
release	/usr/include/opencv2/legacy/legacy.hpp	/^    void release()$/;"	f	class:CvMatrix	access:public	signature:()
remaining	/usr/include/opencv2/core/core.hpp	/^    size_t remaining;$/;"	m	class:cv::FileNodeIterator	access:public
remaining	/usr/include/opencv2/flann/allocator.h	/^	int 	remaining;  \/* Number of bytes left in current block of storage. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
remainingInputRows	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int remainingInputRows() const;$/;"	p	class:cv::FilterEngine	access:public	signature:() const
remainingOutputRows	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int remainingOutputRows() const;$/;"	p	class:cv::FilterEngine	access:public	signature:() const
remap	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void remap(const GpuMat& src, GpuMat& dst, const GpuMat& xmap, const GpuMat& ymap);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const GpuMat& xmap, const GpuMat& ymap)
remap	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void remap( const Mat& src, CV_OUT Mat& dst, const Mat& map1, const Mat& map2,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& map1, const Mat& map2, int interpolation, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
remove	/usr/include/opencv2/core/core.hpp	/^    void remove(const Range& r);$/;"	p	class:cv::Seq	access:public	signature:(const Range& r)
remove	/usr/include/opencv2/core/core.hpp	/^    void remove(int idx);$/;"	p	class:cv::Seq	access:public	signature:(int idx)
remove	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::remove(const Range& r)$/;"	f	class:cv::Seq	signature:(const Range& r)
remove	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::remove(int idx)$/;"	f	class:cv::Seq	signature:(int idx)
removeBorderKeypoints	/usr/include/opencv2/features2d/features2d.hpp	/^    static void removeBorderKeypoints( vector<KeyPoint>& keypoints,$/;"	p	class:cv::DescriptorExtractor	access:protected	signature:( vector<KeyPoint>& keypoints, Size imageSize, int borderSize )
removeInvalidPoints	/usr/include/opencv2/features2d/features2d.hpp	/^    static void removeInvalidPoints( const Mat& mask, vector<KeyPoint>& keypoints );$/;"	p	class:cv::FeatureDetector	access:protected	signature:( const Mat& mask, vector<KeyPoint>& keypoints )
removeNode	/usr/include/opencv2/core/core.hpp	/^    void removeNode(size_t hidx, size_t nidx, size_t previdx);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t hidx, size_t nidx, size_t previdx)
repackSpinImages	/usr/include/opencv2/contrib/contrib.hpp	/^        void repackSpinImages(const vector<uchar>& mask, Mat& spinImages, bool reAlloc = true) const;$/;"	p	class:cv::SpinImageModel	access:protected	signature:(const vector<uchar>& mask, Mat& spinImages, bool reAlloc = true) const
repeat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS Mat repeat(const Mat& src, int ny, int nx);$/;"	p	namespace:cv	signature:(const Mat& src, int ny, int nx)
repeat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void repeat(const Mat& src, int ny, int nx, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, int ny, int nx, CV_OUT Mat& dst)
reprojectImageTo3D	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void reprojectImageTo3D( const Mat& disparity,$/;"	p	namespace:cv	signature:( const Mat& disparity, CV_OUT Mat& _3dImage, const Mat& Q, bool handleMissingValues=false )
reprojectImageTo3D	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void reprojectImageTo3D(const GpuMat& disp, GpuMat& xyzw, const Mat& Q);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& disp, GpuMat& xyzw, const Mat& Q)
reprojectImageTo3D	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void reprojectImageTo3D(const GpuMat& disp, GpuMat& xyzw, const Mat& Q, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& disp, GpuMat& xyzw, const Mat& Q, const Stream& stream)
reserve	/usr/include/opencv2/core/core.hpp	/^    void reserve(size_t sz);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz)
reserve	/usr/include/opencv2/core/operations.hpp	/^    void reserve(size_t newCapacity)$/;"	f	class:cv::Vector	access:public	signature:(size_t newCapacity)
reset	/usr/include/opencv2/contrib/contrib.hpp	/^        void reset();$/;"	p	class:cv::TickMeter	access:public	signature:()
reset	/usr/include/opencv2/flann/timer.h	/^    void reset() {$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
reset	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void reset();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
reset	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual void reset();$/;"	p	class:cv::BaseFilter	access:public	signature:()
resetValues	/usr/include/opencv2/contrib/contrib.hpp	/^    void resetValues();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
reset_histogram	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual void  reset_histogram();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
reset_roi	/usr/include/opencv2/legacy/legacy.hpp	/^    void reset_roi() { cvResetImageROI(image); }$/;"	f	class:CvImage	access:public	signature:()
reshape	/usr/include/opencv2/core/core.hpp	/^    Mat reshape(int _cn, int _newndims, const int* _newsz) const;$/;"	p	class:cv::Mat	access:public	signature:(int _cn, int _newndims, const int* _newsz) const
reshape	/usr/include/opencv2/core/core.hpp	/^    Mat reshape(int _cn, int _rows=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int _cn, int _rows=0) const
reshape	/usr/include/opencv2/core/core.hpp	/^    Mat_ reshape(int _rows) const;$/;"	p	class:cv::Mat_	access:public	signature:(int _rows) const
reshape	/usr/include/opencv2/core/core.hpp	/^    template<int m1, int n1> Matx<_Tp, m1, n1> reshape() const;$/;"	p	class:cv::Matx	access:public	signature:() const
reshape	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::reshape(int _rows) const$/;"	f	class:cv::Mat_	signature:(int _rows) const
reshape	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, m1, n1> Matx<_Tp, m, n>::reshape() const$/;"	f	class:cv::Matx	signature:() const
reshape	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat reshape(int cn, int rows = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int cn, int rows = 0) const
resize	/usr/include/opencv2/core/core.hpp	/^    void resize(size_t sz);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz)
resize	/usr/include/opencv2/core/core.hpp	/^    void resize(size_t sz, const Scalar& s);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz, const Scalar& s)
resize	/usr/include/opencv2/core/operations.hpp	/^    void resize(size_t newSize)$/;"	f	class:cv::Vector	access:public	signature:(size_t newSize)
resize	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void resize(const GpuMat& src, GpuMat& dst, Size dsize, double fx=0, double fy=0, int interpolation = INTER_LINEAR);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size dsize, double fx=0, double fy=0, int interpolation = INTER_LINEAR)
resize	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void resize( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR )
resizeHashTab	/usr/include/opencv2/core/core.hpp	/^    void resizeHashTab(size_t newsize);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t newsize)
resize_vecs	/usr/include/opencv2/flann/result_set.h	/^	void resize_vecs()$/;"	f	class:cvflann::RadiusResultSet	access:private	signature:()
resolution	/usr/include/opencv2/contrib/contrib.hpp	/^        float resolution;$/;"	m	class:cv::Mesh3D	access:public
response	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW float response; \/\/!< the response by which the most strong keypoints have been selected. Can be used for the further sorting or subsampling$/;"	m	class:cv::KeyPoint	access:public
response	/usr/include/opencv2/features2d/features2d.hpp	/^    float response;$/;"	m	struct:CvStarKeypoint	access:public
response	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float response;$/;"	m	struct:CvDetectedBlob	access:public
responseThreshold	/usr/include/opencv2/features2d/features2d.hpp	/^    int responseThreshold;$/;"	m	struct:CvStarDetectorParams	access:public
response_idx	/usr/include/opencv2/ml/ml.hpp	/^    int response_idx;$/;"	m	class:CvMLData	access:protected
response_out	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* response_out; \/\/ header$/;"	m	class:CvMLData	access:protected
responses	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* responses;$/;"	m	struct:CvDTreeTrainData	access:public
responses_copy	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* responses_copy; \/\/ used in Boosting$/;"	m	struct:CvDTreeTrainData	access:public
retrieve	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool retrieve(CV_OUT Mat& image, int channel=0);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image, int channel=0)
rho	/usr/include/opencv2/ml/ml.hpp	/^    double rho;$/;"	m	struct:CvSVMDecisionFunc	access:public
rho	/usr/include/opencv2/ml/ml.hpp	/^    double rho;$/;"	m	struct:CvSVMSolutionInfo	access:public
riBuf	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
right	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* right;$/;"	m	struct:CvStereoGCState	access:public
right	/usr/include/opencv2/core/core.hpp	/^        int left, right;$/;"	m	struct:cv::KDTree::Node	access:public
right	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode* right;$/;"	m	struct:CvDTreeNode	access:public
right	/usr/include/opencv2/objdetect/objdetect.hpp	/^        int right;$/;"	m	struct:cv::CascadeClassifier::DTreeNode	access:public
right	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int* right;$/;"	m	struct:CvHaarClassifier	access:public
ringBuf	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<uchar> ringBuf;$/;"	m	class:cv::FilterEngine	access:public
rmEdgeDensityFuzzy	/usr/include/opencv2/contrib/contrib.hpp	/^        rmEdgeDensityFuzzy      = 1,$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
rmEdgeDensityLinear	/usr/include/opencv2/contrib/contrib.hpp	/^        rmEdgeDensityLinear     = 0,$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
rmInnerDensity	/usr/include/opencv2/contrib/contrib.hpp	/^        rmInnerDensity          = 2$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
rng	/usr/include/opencv2/ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvANN_MLP	access:protected
rng	/usr/include/opencv2/ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvGBTrees	access:protected
rng	/usr/include/opencv2/ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvMLData	access:protected
rng	/usr/include/opencv2/ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvRTrees	access:protected
rng	/usr/include/opencv2/ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	struct:CvDTreeTrainData	access:public
roi	/usr/include/opencv2/core/mat.hpp	/^    virtual void roi(const MatExpr& expr, const Range& rowRange,$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, const Range& rowRange, const Range& colRange, MatExpr& res) const
roi	/usr/include/opencv2/core/types_c.h	/^    struct _IplROI *roi;    \/* Image ROI. If NULL, the whole image is selected. *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplROI	access:public
roi	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Rect roi;$/;"	m	class:cv::FilterEngine	access:public
roi	/usr/include/opencv2/legacy/legacy.hpp	/^    CvRect roi() const$/;"	f	class:CvImage	access:public	signature:() const
roi1	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvRect roi1, roi2;$/;"	m	struct:CvStereoBMState	access:public
roi2	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvRect roi1, roi2;$/;"	m	struct:CvStereoBMState	access:public
roi_row	/usr/include/opencv2/legacy/legacy.hpp	/^    const uchar* roi_row(int y) const$/;"	f	class:CvImage	access:public	signature:(int y) const
roi_row	/usr/include/opencv2/legacy/legacy.hpp	/^    uchar* roi_row(int y)$/;"	f	class:CvImage	access:public	signature:(int y)
roi_size	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSize roi_size() const$/;"	f	class:CvImage	access:public	signature:() const
root	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP FileNode root(int streamidx=0) const;$/;"	p	class:cv::FileStorage	access:public	signature:(int streamidx=0) const
root	/usr/include/opencv2/flann/kmeans_index.h	/^	KMeansNode root;$/;"	m	class:cvflann::KMeansIndex	access:private
root	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeNode* root;$/;"	m	class:CvDTree	access:protected
rotMatr	/usr/include/opencv2/legacy/legacy.hpp	/^    float   rotMatr[9];$/;"	m	struct:CvCamera	access:public
rotMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    float rotMatrix[9];$/;"	m	struct:CvStereoCamera	access:public
rotate	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void rotate(const GpuMat& src, GpuMat& dst, Size dsize, double angle, double xShift = 0, double yShift = 0, int interpolation = INTER_LINEAR);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size dsize, double angle, double xShift = 0, double yShift = 0, int interpolation = INTER_LINEAR)
row	/usr/include/opencv2/core/core.hpp	/^    Mat row(int y) const;$/;"	p	class:cv::Mat	access:public	signature:(int y) const
row	/usr/include/opencv2/core/core.hpp	/^    Mat_ row(int y) const;$/;"	p	class:cv::Mat_	access:public	signature:(int y) const
row	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, 1, n> row(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
row	/usr/include/opencv2/core/mat.hpp	/^    MatExpr row(int y) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int y) const
row	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::row(int y) const { return Mat(*this, Range(y, y+1), Range::all()); }$/;"	f	class:cv::Mat	signature:(int y) const
row	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::row(int y) const$/;"	f	class:cv::Mat_	signature:(int y) const
row	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, 1, n> Matx<_Tp, m, n>::row(int i) const$/;"	f	class:cv::Matx	signature:(int i) const
row	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat row(int y) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y) const
row	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::row(int y) const { return GpuMat(*this, Range(y, y+1), Range::all()); }$/;"	f	class:cv::gpu::GpuMat	signature:(int y) const
row	/usr/include/opencv2/legacy/legacy.hpp	/^    const uchar* row(int i) const$/;"	f	class:CvMatrix	access:public	signature:(int i) const
row	/usr/include/opencv2/legacy/legacy.hpp	/^    uchar* row(int i) { return !matrix ? 0 : matrix->data.ptr + i*matrix->step; }$/;"	f	class:CvMatrix	access:public	signature:(int i)
rowBorderType	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int rowBorderType, columnBorderType;$/;"	m	class:cv::FilterEngine	access:public
rowCount	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
rowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Ptr<BaseRowFilter> rowFilter;$/;"	m	class:cv::FilterEngine	access:public
rowRange	/usr/include/opencv2/core/core.hpp	/^    Mat rowRange(const Range& r) const;$/;"	p	class:cv::Mat	access:public	signature:(const Range& r) const
rowRange	/usr/include/opencv2/core/core.hpp	/^    Mat rowRange(int startrow, int endrow) const;$/;"	p	class:cv::Mat	access:public	signature:(int startrow, int endrow) const
rowRange	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::rowRange(const Range& r) const$/;"	f	class:cv::Mat	signature:(const Range& r) const
rowRange	/usr/include/opencv2/core/mat.hpp	/^inline Mat Mat::rowRange(int startrow, int endrow) const$/;"	f	class:cv::Mat	signature:(int startrow, int endrow) const
rowRange	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat rowRange(const Range& r) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Range& r) const
rowRange	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat rowRange(int startrow, int endrow) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int startrow, int endrow) const
rowRange	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::rowRange(const Range& r) const { return GpuMat(*this, r, Range::all()); }$/;"	f	class:cv::gpu::GpuMat	signature:(const Range& r) const
rowRange	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::rowRange(int startrow, int endrow) const { return GpuMat(*this, Range(startrow, endrow), Range::all()); }$/;"	f	class:cv::gpu::GpuMat	signature:(int startrow, int endrow) const
rows	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon120
rows	/usr/include/opencv2/core/core.hpp	/^    int rows, cols;$/;"	m	class:cv::Mat	access:public
rows	/usr/include/opencv2/core/types_c.h	/^        int rows;$/;"	m	union:CvMat::__anon95	access:public
rows	/usr/include/opencv2/core/types_c.h	/^    int rows;$/;"	m	struct:CvMat	access:public
rows	/usr/include/opencv2/flann/matrix.h	/^    size_t rows;$/;"	m	class:cvflann::Matrix	access:public
rows	/usr/include/opencv2/flann/matrix.h	/^    size_t rows;$/;"	m	class:cvflann::UntypedMatrix	access:public
rows	/usr/include/opencv2/flann/saving.h	/^	int rows;$/;"	m	struct:cvflann::IndexHeader	access:public
rows	/usr/include/opencv2/gpu/devmem2d.hpp	/^            int rows;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
rows	/usr/include/opencv2/gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::CudaMem	access:public
rows	/usr/include/opencv2/gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::GpuMat	access:public
rows	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<uchar*> rows;$/;"	m	class:cv::FilterEngine	access:public
rows	/usr/include/opencv2/legacy/legacy.hpp	/^    int rows() const { return matrix ? matrix->rows : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
rows	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMKernelRow* rows;$/;"	m	class:CvSVMSolver	access:public
rp_dw0	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
rp_dw_max	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
rp_dw_min	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
rp_dw_minus	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
rp_dw_plus	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
rules	/usr/include/opencv2/contrib/contrib.hpp	/^    std::vector<CvFuzzyRule*> rules;$/;"	m	class:CvFuzzyController	access:private
run	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual void run( int npoints, \/\/ number of points$/;"	p	class:cv::LevMarqSparse	access:public	signature:( int npoints, int ncameras, int nPointParams, int nCameraParams, int nErrParams, Mat& visibility, Mat& P0, Mat& X, TermCriteria criteria, void (CV_CDECL * fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data), void (CV_CDECL * func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data), void* data )
runAt	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int runAt( Ptr<FeatureEvaluator>&, Point );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( Ptr<FeatureEvaluator>&, Point )
run_em	/usr/include/opencv2/ml/ml.hpp	/^    virtual double run_em( const CvVectors& train_data );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data )
s	/usr/include/opencv2/core/mat.hpp	/^    Scalar s;$/;"	m	class:cv::MatExpr	access:public
s	/usr/include/opencv2/core/types_c.h	/^        short* s;$/;"	m	union:CvMat::__anon94	access:public
s	/usr/include/opencv2/core/types_c.h	/^        short* s;$/;"	m	union:CvMatND::__anon97	access:public
s	/usr/include/opencv2/legacy/legacy.hpp	/^    int* s; \/\/for selected candidate$/;"	m	struct:CvCliqueFinder	access:public
safeSignatureAlloc	/usr/include/opencv2/features2d/features2d.hpp	/^  static inline uchar* safeSignatureAlloc(int num_sig=1, int sig_len=176);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(int num_sig=1, int sig_len=176)
safeSignatureAlloc	/usr/include/opencv2/features2d/features2d.hpp	/^  static inline void safeSignatureAlloc(uchar **sig, int num_sig=1, int sig_len=176);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(uchar **sig, int num_sig=1, int sig_len=176)
sample_count	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
sample_count	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count;$/;"	m	class:CvSVMSolver	access:public
sample_count	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count;$/;"	m	struct:CvDTreeNode	access:public
sample_fraction	/usr/include/opencv2/flann/autotuned_index.h	/^    float sample_fraction;     \/\/ what fraction of the dataset to use for autotuning$/;"	m	struct:cvflann::AutotunedIndexParams	access:public
sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* sample_idx;$/;"	m	class:CvGBTrees	access:protected
sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    int* sample_idx; \/\/ data of train_sample_idx and test_sample_idx$/;"	m	class:CvMLData	access:protected
sample_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* sample_weights;$/;"	m	class:CvANN_MLP	access:protected
sampledDataset	/usr/include/opencv2/flann/autotuned_index.h	/^    Matrix<ELEM_TYPE> sampledDataset;$/;"	m	class:cvflann::AutotunedIndex	access:private
samples	/usr/include/opencv2/ml/ml.hpp	/^    CvVectors* samples;$/;"	m	class:CvKNearest	access:protected
samples	/usr/include/opencv2/ml/ml.hpp	/^    const float** samples;$/;"	m	class:CvSVMSolver	access:public
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline int saturate_cast<int>(double v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(double v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline int saturate_cast<int>(float v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(float v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(double v)$/;"	f	namespace:cv	signature:(double v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(float v)$/;"	f	namespace:cv	signature:(float v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(int v)$/;"	f	namespace:cv	signature:(int v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(short v)$/;"	f	namespace:cv	signature:(short v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(uchar v)$/;"	f	namespace:cv	signature:(uchar v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline schar saturate_cast<schar>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline short saturate_cast<short>(double v)$/;"	f	namespace:cv	signature:(double v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline short saturate_cast<short>(float v)$/;"	f	namespace:cv	signature:(float v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline short saturate_cast<short>(int v)$/;"	f	namespace:cv	signature:(int v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline short saturate_cast<short>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline short saturate_cast<short>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(double v)$/;"	f	namespace:cv	signature:(double v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(float v)$/;"	f	namespace:cv	signature:(float v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(int v)$/;"	f	namespace:cv	signature:(int v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(schar v)$/;"	f	namespace:cv	signature:(schar v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(short v)$/;"	f	namespace:cv	signature:(short v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline unsigned saturate_cast<unsigned>(double v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(double v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline unsigned saturate_cast<unsigned>(float v){ return cvRound(v); }$/;"	f	namespace:cv	signature:(float v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(double v)$/;"	f	namespace:cv	signature:(double v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(float v)$/;"	f	namespace:cv	signature:(float v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(int v)$/;"	f	namespace:cv	signature:(int v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(schar v)$/;"	f	namespace:cv	signature:(schar v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(short v)$/;"	f	namespace:cv	signature:(short v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(double v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(double v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(float v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(float v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(int v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(int v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(schar v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(schar v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(short v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(short v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(uchar v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(uchar v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(unsigned v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(unsigned v)
saturate_cast	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(ushort v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(ushort v)
save	/usr/include/opencv2/flann/flann.hpp	/^	void save(std::string filename) { nnIndex->save(filename); }$/;"	f	class:cv::flann::Index_	access:public	signature:(std::string filename)
save	/usr/include/opencv2/flann/flann_base.hpp	/^	void save(std::string filename);$/;"	p	class:cvflann::Index	access:public	signature:(std::string filename)
save	/usr/include/opencv2/flann/flann_base.hpp	/^void Index<T>::save(string filename)$/;"	f	class:cvflann::Index	signature:(string filename)
save	/usr/include/opencv2/legacy/legacy.hpp	/^    void save( const char* filename, const char* imgname, const int* params=0 );$/;"	p	class:CvImage	access:public	signature:( const char* filename, const char* imgname, const int* params=0 )
save	/usr/include/opencv2/legacy/legacy.hpp	/^    void save( const char* filename, const char* matname, const int* params=0 );$/;"	p	class:CvMatrix	access:public	signature:( const char* filename, const char* matname, const int* params=0 )
save	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual void save( const char* filename, const char* name=0 ) const;$/;"	p	class:CvStatModel	access:public	signature:( const char* filename, const char* name=0 ) const
save	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void save(const String& filename, const String& objname=String()) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const String& filename, const String& objname=String()) const
saveAllBytePosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void saveAllBytePosteriors(std::string file_url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string file_url)
saveAllFloatPosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void saveAllFloatPosteriors(std::string file_url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string file_url)
saveIndex	/usr/include/opencv2/flann/autotuned_index.h	/^    virtual void saveIndex(FILE* stream)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(FILE* stream)
saveIndex	/usr/include/opencv2/flann/composite_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(FILE* stream)
saveIndex	/usr/include/opencv2/flann/kdtree_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(FILE* stream)
saveIndex	/usr/include/opencv2/flann/kmeans_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(FILE* stream)
saveIndex	/usr/include/opencv2/flann/linear_index.h	/^    void saveIndex(FILE*)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(FILE*)
saveIndex	/usr/include/opencv2/flann/nn_index.h	/^	virtual void saveIndex(FILE* stream) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(FILE* stream)
savePosteriors	/usr/include/opencv2/features2d/features2d.hpp	/^  void savePosteriors(std::string url, bool append=false);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::string url, bool append=false)
savePosteriors2	/usr/include/opencv2/features2d/features2d.hpp	/^  void savePosteriors2(std::string url, bool append=false);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::string url, bool append=false)
saveWindowParameters	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void saveWindowParameters(const string& windowName);$/;"	p	namespace:cv	signature:(const string& windowName)
save_header	/usr/include/opencv2/flann/saving.h	/^void save_header(FILE* stream, const NNIndex<ELEM_TYPE>& index)$/;"	f	namespace:cvflann	signature:(FILE* stream, const NNIndex<ELEM_TYPE>& index)
save_to_file	/usr/include/opencv2/flann/hdf5.h	/^void save_to_file(const cvflann::Matrix<T>& flann_dataset, const std::string& filename, const std::string& name)$/;"	f	namespace:cvflann	signature:(const cvflann::Matrix<T>& flann_dataset, const std::string& filename, const std::string& name)
save_tree	/usr/include/opencv2/flann/kdtree_index.h	/^    void save_tree(FILE* stream, Tree tree)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(FILE* stream, Tree tree)
save_tree	/usr/include/opencv2/flann/kmeans_index.h	/^    void save_tree(FILE* stream, KMeansNode node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(FILE* stream, KMeansNode node)
save_value	/usr/include/opencv2/flann/saving.h	/^void save_value(FILE* stream, const T& value, int count = 1)$/;"	f	namespace:cvflann	signature:(FILE* stream, const T& value, int count = 1)
scalarToRawData	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void scalarToRawData(const Scalar& s, void* buf, int type, int unroll_to=0);$/;"	p	namespace:cv	signature:(const Scalar& s, void* buf, int type, int unroll_to=0)
scale	/usr/include/opencv2/ml/ml.hpp	/^    virtual void scale( double s );$/;"	p	class:CvBoostTree	access:public	signature:( double s )
scale	/usr/include/opencv2/objdetect/objdetect.hpp	/^    double scale;$/;"	m	struct:CvHaarClassifierCascade	access:public
scaleAdd	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void scaleAdd(const Mat& src1, double alpha, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, double alpha, const Mat& src2, CV_OUT Mat& dst)
scale_input	/usr/include/opencv2/ml/ml.hpp	/^    virtual void scale_input( const CvMat* _src, CvMat* _dst ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _src, CvMat* _dst ) const
scale_max	/usr/include/opencv2/features2d/features2d.hpp	/^    float scale_max;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
scale_min	/usr/include/opencv2/features2d/features2d.hpp	/^    float scale_min;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
scale_output	/usr/include/opencv2/ml/ml.hpp	/^    virtual void scale_output( const CvMat* _src, CvMat* _dst ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _src, CvMat* _dst ) const
scale_step	/usr/include/opencv2/features2d/features2d.hpp	/^    float scale_step;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
scanner	/usr/include/opencv2/core/core_c.h	/^CVAPI(int)  cvNextGraphItem( CvGraphScanner* scanner );$/;"	v
scanner	/usr/include/opencv2/core/core_c.h	/^CVAPI(void) cvReleaseGraphScanner( CvGraphScanner** scanner );$/;"	v
scanner	/usr/include/opencv2/imgproc/imgproc_c.h	/^CVAPI(CvSeq*)  cvEndFindContours( CvContourScanner* scanner );$/;"	v
scanner	/usr/include/opencv2/imgproc/imgproc_c.h	/^CVAPI(CvSeq*)  cvFindNextContour( CvContourScanner scanner );$/;"	v
schar	/usr/include/opencv2/core/types_c.h	/^typedef signed char schar;$/;"	t
score	/usr/include/opencv2/objdetect/objdetect.hpp	/^	float score;$/;"	m	struct:CvObjectDetection	access:public
score_threshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^	float score_threshold;$/;"	m	struct:CvLatentSvmDetector	access:public
searchLevel	/usr/include/opencv2/flann/kdtree_index.h	/^	void searchLevel(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, Tree node, float mindistsq, int& checkCount, int maxCheck,$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, Tree node, float mindistsq, int& checkCount, int maxCheck, Heap<BranchSt>* heap, vector<bool>& checked)
searchLevelExact	/usr/include/opencv2/flann/kdtree_index.h	/^	void searchLevelExact(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, Tree node, float mindistsq)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<ELEM_TYPE>& result, const ELEM_TYPE* vec, Tree node, float mindistsq)
searchMode	/usr/include/opencv2/contrib/contrib.hpp	/^    int searchMode;$/;"	m	class:CvFuzzyMeanShiftTracker	access:public
searchParams	/usr/include/opencv2/features2d/features2d.hpp	/^    Ptr<flann::SearchParams> searchParams;$/;"	m	class:cv::FlannBasedMatcher	access:protected
searchTimeCost	/usr/include/opencv2/flann/autotuned_index.h	/^        float searchTimeCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
search_modules	/usr/include/opencv2/core/types_c.h	/^    int search_modules;$/;"	m	struct:CvPluginFuncInfo	access:public
search_with_ground_truth	/usr/include/opencv2/flann/index_testing.h	/^float search_with_ground_truth(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches, int nn, int checks, float& time, float& dist, int skipMatches)$/;"	f	namespace:cvflann	signature:(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches, int nn, int checks, float& time, float& dist, int skipMatches)
seed_random	/usr/include/opencv2/flann/random.h	/^CV_EXPORTS void seed_random(unsigned int seed);$/;"	p	namespace:cvflann	signature:(unsigned int seed)
seek	/usr/include/opencv2/core/core.hpp	/^    void seek(const int* _idx, bool relative=false);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const int* _idx, bool relative=false)
seek	/usr/include/opencv2/core/core.hpp	/^    void seek(ptrdiff_t ofs, bool relative=false);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs, bool relative=false)
seek	/usr/include/opencv2/core/core.hpp	/^    void seek(size_t pos);$/;"	p	class:cv::SeqIterator	access:public	signature:(size_t pos)
seek	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void SeqIterator<_Tp>::seek(size_t pos)$/;"	f	class:cv::SeqIterator	signature:(size_t pos)
seekEnd	/usr/include/opencv2/core/core.hpp	/^    void seekEnd();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
seekEnd	/usr/include/opencv2/core/mat.hpp	/^inline void SparseMatConstIterator::seekEnd()$/;"	f	class:cv::SparseMatConstIterator	signature:()
selectDivision	/usr/include/opencv2/flann/kdtree_index.h	/^	int selectDivision(DIST_TYPE* v)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(DIST_TYPE* v)
selectRandomSubset	/usr/include/opencv2/contrib/contrib.hpp	/^        void selectRandomSubset(float ratio);$/;"	p	class:cv::SpinImageModel	access:public	signature:(float ratio)
select_working_set	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool select_working_set( int& i, int& j );$/;"	p	class:CvSVMSolver	access:public	signature:( int& i, int& j )
select_working_set_func	/usr/include/opencv2/ml/ml.hpp	/^    SelectWorkingSet select_working_set_func;$/;"	m	class:CvSVMSolver	access:public
select_working_set_nu_svm	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool select_working_set_nu_svm( int& i, int& j );$/;"	p	class:CvSVMSolver	access:public	signature:( int& i, int& j )
sepFilter2D	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void sepFilter2D(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY, Point anchor = Point(-1,-1))
sepFilter2D	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void sepFilter2D( const Mat& src, CV_OUT Mat& dst, int ddepth,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT )
seq	/usr/include/opencv2/core/core.hpp	/^    CvSeq* seq;$/;"	m	class:cv::Seq	access:public
seq	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvClearSeq( CvSeq* seq );$/;"	v
seq	/usr/include/opencv2/core/core_c.h	/^CVAPI(void) cvSeqInvert( CvSeq* seq );$/;"	v
seq	/usr/include/opencv2/core/types_c.h	/^        CvSeq* seq; \/* sequence (ordered collection of file nodes) *\/$/;"	m	union:CvFileNode::__anon100	access:public
seqInsertSlice	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqInsertSlice( CvSeq* seq, int before_index, const CvArr* from_arr );    $/;"	p	namespace:cv	signature:( CvSeq* seq, int before_index, const CvArr* from_arr )
seqPop	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqPop( CvSeq* seq, void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, void* element=0)
seqPopFront	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqPopFront( CvSeq* seq, void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, void* element=0)
seqPopMulti	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqPopMulti( CvSeq* seq, void* elements,$/;"	p	namespace:cv	signature:( CvSeq* seq, void* elements, int count, int in_front=0 )
seqPush	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS schar*  seqPush( CvSeq* seq, const void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, const void* element=0)
seqPushFront	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS schar*  seqPushFront( CvSeq* seq, const void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, const void* element=0)
seqRemove	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqRemove( CvSeq* seq, int index );$/;"	p	namespace:cv	signature:( CvSeq* seq, int index )
seqRemoveSlice	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void  seqRemoveSlice( CvSeq* seq, CvSlice slice );$/;"	p	namespace:cv	signature:( CvSeq* seq, CvSlice slice )
set	/usr/include/opencv2/core/operations.hpp	/^    void set(_Tp* _data, size_t _size, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(_Tp* _data, size_t _size, bool _copyData=false)
set	/usr/include/opencv2/features2d/features2d.hpp	/^        void set( const vector<Mat>& descriptors );$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( const vector<Mat>& descriptors )
set	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual bool set(int propId, double value);$/;"	p	class:cv::VideoCapture	access:public	signature:(int propId, double value)
set	/usr/include/opencv2/legacy/legacy.hpp	/^    void set( CvMat* m, bool add_ref )$/;"	f	class:CvMatrix	access:public	signature:( CvMat* m, bool add_ref )
setAffineParam	/usr/include/opencv2/features2d/features2d.hpp	/^    void setAffineParam(double lambda, double theta, double phi);$/;"	p	class:cv::PatchGenerator	access:public	signature:(double lambda, double theta, double phi)
setBreakOnError	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS bool setBreakOnError(bool flag);$/;"	p	namespace:cv	signature:(bool flag)
setCentre	/usr/include/opencv2/contrib/contrib.hpp	/^    void setCentre(double _centre);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double _centre)
setDefault	/usr/include/opencv2/core/operations.hpp	/^    static const Formatter* setDefault(const Formatter* fmt);$/;"	p	class:cv::Formatter	access:public	signature:(const Formatter* fmt)
setDestination	/usr/include/opencv2/flann/logger.h	/^    void setDestination(const char* name)$/;"	f	class:cvflann::Logger	access:public	signature:(const char* name)
setDevice	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void setDevice(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
setFloatPosteriorsFromTextfile_176	/usr/include/opencv2/features2d/features2d.hpp	/^  void setFloatPosteriorsFromTextfile_176(std::string url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string url)
setIdentity	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void setIdentity(Mat& mtx, const Scalar& s=Scalar(1));$/;"	p	namespace:cv	signature:(Mat& mtx, const Scalar& s=Scalar(1))
setImage	/usr/include/opencv2/objdetect/objdetect.hpp	/^    bool setImage( Ptr<FeatureEvaluator>&, const Mat& );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( Ptr<FeatureEvaluator>&, const Mat& )
setImage	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual bool setImage(const Mat&, Size origWinSize);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(const Mat&, Size origWinSize)
setLevel	/usr/include/opencv2/flann/logger.h	/^    void setLevel(int level) { logLevel = level; }$/;"	f	class:cvflann::Logger	access:public	signature:(int level)
setLogger	/usr/include/opencv2/contrib/contrib.hpp	/^        void setLogger(std::ostream* log);$/;"	p	class:cv::SpinImageModel	access:public	signature:(std::ostream* log)
setMouseCallback	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS void setMouseCallback( const string& windowName, MouseCallback onMouse, void* param=0);$/;"	p	namespace:cv	signature:( const string& windowName, MouseCallback onMouse, void* param=0)
setNumThreads	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void setNumThreads(int nthreads);$/;"	p	namespace:cv	signature:(int nthreads)
setQuantization	/usr/include/opencv2/features2d/features2d.hpp	/^  void setQuantization(int num_quant_bits);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(int num_quant_bits)
setRule	/usr/include/opencv2/contrib/contrib.hpp	/^    void setRule(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1);$/;"	p	class:CvFuzzyRule	access:public	signature:(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1)
setSVMDetector	/usr/include/opencv2/gpu/gpu.hpp	/^            void setSVMDetector(const vector<float>& detector);$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const vector<float>& detector)
setSVMDetector	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_WRAP virtual void setSVMDetector(const vector<float>& _svmdetector);$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const vector<float>& _svmdetector)
setSize	/usr/include/opencv2/contrib/contrib.hpp	/^        void setSize(int _x, int _y, int _width, int _height);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int _x, int _y, int _width, int _height)
setSubset	/usr/include/opencv2/contrib/contrib.hpp	/^        void setSubset(const vector<int>& subset);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const vector<int>& subset)
setTo	/usr/include/opencv2/core/core.hpp	/^    Mat& setTo(const Scalar& s, const Mat& mask=Mat());$/;"	p	class:cv::Mat	access:public	signature:(const Scalar& s, const Mat& mask=Mat())
setTo	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat& setTo(const Scalar& s, const GpuMat& mask = GpuMat());$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Scalar& s, const GpuMat& mask = GpuMat())
setTrackbarPos	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W void setTrackbarPos( const string& trackbarname, const string& winname, int pos );$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname, int pos )
setUseOptimized	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void setUseOptimized(bool onoff);$/;"	p	namespace:cv	signature:(bool onoff)
setValue	/usr/include/opencv2/contrib/contrib.hpp	/^    void setValue(double _value);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double _value)
setVerbose	/usr/include/opencv2/features2d/features2d.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::FernClassifier	access:public	signature:(bool verbose)
setVerbose	/usr/include/opencv2/features2d/features2d.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::LDetector	access:public	signature:(bool verbose)
setVerbose	/usr/include/opencv2/features2d/features2d.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(bool verbose)
setVocabulary	/usr/include/opencv2/features2d/features2d.hpp	/^    void setVocabulary( const Mat& vocabulary );$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Mat& vocabulary )
setWindow	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual bool setWindow(Point p);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(Point p)
setWindowProperty	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W void setWindowProperty(const string& winname, int prop_id, double prop_value);\/\/YV$/;"	p	namespace:cv	signature:(const string& winname, int prop_id, double prop_value)
set_activ_func	/usr/include/opencv2/ml/ml.hpp	/^    virtual void set_activ_func( int _activ_func=SIGMOID_SYM,$/;"	p	class:CvANN_MLP	access:protected	signature:( int _activ_func=SIGMOID_SYM, double _f_param1=0, double _f_param2=0 )
set_cb_index	/usr/include/opencv2/flann/kmeans_index.h	/^    void set_cb_index( float index)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:( float index)
set_coi	/usr/include/opencv2/legacy/legacy.hpp	/^    void set_coi(int coi) { cvSetImageCOI(image,coi); }$/;"	f	class:CvImage	access:public	signature:(int coi)
set_data	/usr/include/opencv2/legacy/legacy.hpp	/^    void set_data( void* data, int step=CV_AUTOSTEP )$/;"	f	class:CvMatrix	access:public	signature:( void* data, int step=CV_AUTOSTEP )
set_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void set_data( const CvMat* trainData, int tflag,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false, bool _update_data=false )
set_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void set_data( const CvMat* trainData, int tflag,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false, bool _update_data=false )
set_delimiter	/usr/include/opencv2/ml/ml.hpp	/^    void set_delimiter( char ch );$/;"	p	class:CvMLData	access:public	signature:( char ch )
set_distance_type	/usr/include/opencv2/flann/flann_base.hpp	/^CV_EXPORTS void set_distance_type(flann_distance_t distance_type, int order);$/;"	p	namespace:cvflann	signature:(flann_distance_t distance_type, int order)
set_header	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvClearSet( CvSet* set_header );$/;"	v
set_hist_bin_range	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_hist_bin_range( int dim, int min_val, int max_val );$/;"	p	class:CvCamShiftTracker	access:public	signature:( int dim, int min_val, int max_val )
set_hist_dims	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_hist_dims( int c_dims, int* dims );\/\/ set the histogram parameters$/;"	p	class:CvCamShiftTracker	access:public	signature:( int c_dims, int* dims )
set_max_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_max_ch_val( int channel, int val ) \/\/ set the maximum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel, int val )
set_min_ch_val	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_min_ch_val( int channel, int val ) \/\/ set the minimum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel, int val )
set_miss_ch	/usr/include/opencv2/ml/ml.hpp	/^    void set_miss_ch( char ch );$/;"	p	class:CvMLData	access:public	signature:( char ch )
set_num_valid	/usr/include/opencv2/ml/ml.hpp	/^    void set_num_valid(int vi, int n) { if( num_valid ) num_valid[vi] = n; }$/;"	f	struct:CvDTreeNode	access:public	signature:(int vi, int n)
set_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool set_params( const CvBoostParams& params );$/;"	p	class:CvBoost	access:protected	signature:( const CvBoostParams& params )
set_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool set_params( const CvDTreeParams& params );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvDTreeParams& params )
set_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool set_params( const CvSVMParams& params );$/;"	p	class:CvSVM	access:protected	signature:( const CvSVMParams& params )
set_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void set_params( const CvEMParams& params,$/;"	p	class:CvEM	access:protected	signature:( const CvEMParams& params, const CvVectors& train_data )
set_postprocess_func	/usr/include/opencv2/highgui/highgui_c.h	394;"	d
set_preprocess_func	/usr/include/opencv2/highgui/highgui_c.h	393;"	d
set_response_idx	/usr/include/opencv2/ml/ml.hpp	/^    void set_response_idx( int idx ); \/\/ old response become predictors, new response_idx = idx$/;"	p	class:CvMLData	access:public	signature:( int idx )
set_roi	/usr/include/opencv2/legacy/legacy.hpp	/^    void set_roi(CvRect roi) { cvSetImageROI(image,roi); }$/;"	f	class:CvImage	access:public	signature:(CvRect roi)
set_threshold	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_threshold( int threshold ) \/\/ threshold applied to the histogram bins$/;"	f	class:CvCamShiftTracker	access:public	signature:( int threshold )
set_train_test_split	/usr/include/opencv2/ml/ml.hpp	/^    void set_train_test_split( const CvTrainTestSplit * spl);$/;"	p	class:CvMLData	access:public	signature:( const CvTrainTestSplit * spl)
set_var_types	/usr/include/opencv2/ml/ml.hpp	/^    void set_var_types( const char* str );  \/\/ str examples:$/;"	p	class:CvMLData	access:public	signature:( const char* str )
set_window	/usr/include/opencv2/legacy/legacy.hpp	/^    bool    set_window( CvRect window)$/;"	f	class:CvCamShiftTracker	access:public	signature:( CvRect window)
shape	/usr/include/opencv2/legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	m	struct:CvDrawShape	typeref:enum:CvDrawShape::__anon178	access:public
shared	/usr/include/opencv2/ml/ml.hpp	/^    bool shared;$/;"	m	struct:CvDTreeTrainData	access:public
shear	/usr/include/opencv2/core/core_c.h	/^    float       shear; 			\/* slope coefficient: 0 - normal, >0 - italic *\/$/;"	m	struct:CvFont	access:public
shift	/usr/include/opencv2/contrib/contrib.hpp	/^        bool shift();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
shift1	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int shift1,shift2;$/;"	m	struct:CvTracksTimePos	access:public
shift2	/usr/include/opencv2/legacy/blobtrack.hpp	/^    int shift1,shift2;$/;"	m	struct:CvTracksTimePos	access:public
show	/usr/include/opencv2/legacy/legacy.hpp	/^    void show( const char* window_name );$/;"	p	class:CvImage	access:public	signature:( const char* window_name )
show	/usr/include/opencv2/legacy/legacy.hpp	/^    void show( const char* window_name );$/;"	p	class:CvMatrix	access:public	signature:( const char* window_name )
shrinkage	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW float shrinkage;$/;"	m	struct:CvGBTreesParams	access:public
sift	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT sift;$/;"	m	class:cv::SiftDescriptorExtractor	access:protected
sift	/usr/include/opencv2/features2d/features2d.hpp	/^    SIFT sift;$/;"	m	class:cv::SiftFeatureDetector	access:protected
sigma	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float   sigma;$/;"	m	struct:CvBlobTrackerParamMS	access:public
sigma_range	/usr/include/opencv2/gpu/gpu.hpp	/^            float sigma_range;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
signature	/usr/include/opencv2/core/types_c.h	/^    int signature;$/;"	m	struct:CvMemStorage	access:public
signature	/usr/include/opencv2/flann/saving.h	/^	char signature[16];$/;"	m	struct:cvflann::IndexHeader	access:public
signatureSize	/usr/include/opencv2/features2d/features2d.hpp	/^        int signatureSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
signatureSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int signatureSize;$/;"	m	class:cv::FernClassifier	access:protected
size	/usr/include/opencv2/core/core.hpp	/^        int size[CV_MAX_DIM];$/;"	m	struct:cv::SparseMat::Hdr	access:public
size	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP size_t size() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
size	/usr/include/opencv2/core/core.hpp	/^    MSize size;$/;"	m	class:cv::Mat	access:public
size	/usr/include/opencv2/core/core.hpp	/^    Size2f size;    \/\/< width and height of the rectangle$/;"	m	class:cv::RotatedRect	access:public
size	/usr/include/opencv2/core/core.hpp	/^    Size_<_Tp> size() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
size	/usr/include/opencv2/core/core.hpp	/^    const int* size() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
size	/usr/include/opencv2/core/core.hpp	/^    int size() const;$/;"	p	class:cv::Range	access:public	signature:() const
size	/usr/include/opencv2/core/core.hpp	/^    int size(int i) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i) const
size	/usr/include/opencv2/core/core.hpp	/^    size_t size() const;$/;"	p	class:cv::Seq	access:public	signature:() const
size	/usr/include/opencv2/core/core.hpp	/^    size_t size;$/;"	m	class:cv::AutoBuffer	access:protected
size	/usr/include/opencv2/core/core_c.h	/^    CvSize size; \/* maximal common linear size: { width = size, height = 1 } *\/$/;"	m	struct:CvNArrayIterator	access:public
size	/usr/include/opencv2/core/core_c.h	/^CVAPI(void*)  cvAlloc( size_t size );$/;"	v
size	/usr/include/opencv2/core/mat.hpp	/^inline const int* SparseMat::size() const$/;"	f	class:cv::SparseMat	signature:() const
size	/usr/include/opencv2/core/mat.hpp	/^inline int SparseMat::size(int i) const$/;"	f	class:cv::SparseMat	signature:(int i) const
size	/usr/include/opencv2/core/operations.hpp	/^        size_t size;$/;"	m	struct:cv::Vector::Hdr	access:public
size	/usr/include/opencv2/core/operations.hpp	/^    size_t size() const { return hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:() const
size	/usr/include/opencv2/core/operations.hpp	/^inline int Range::size() const { return end - start; }$/;"	f	class:cv::Range	signature:() const
size	/usr/include/opencv2/core/operations.hpp	/^inline size_t FileNode::size() const$/;"	f	class:cv::FileNode	signature:() const
size	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp> Rect_<_Tp>::size() const { return Size_<_Tp>(width, height); }$/;"	f	class:cv::Rect_	signature:() const
size	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::size() const$/;"	f	class:cv::Seq	signature:() const
size	/usr/include/opencv2/core/types_c.h	/^        int size;$/;"	m	struct:CvMatND::__anon98	access:public
size	/usr/include/opencv2/core/types_c.h	/^    CvSize2D32f  size;    \/* Box width and length.                       *\/$/;"	m	struct:CvBox2D	access:public
size	/usr/include/opencv2/core/types_c.h	/^    int size[CV_MAX_DIM];$/;"	m	struct:CvSparseMat	access:public
size	/usr/include/opencv2/features2d/features2d.hpp	/^        int size() const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:() const
size	/usr/include/opencv2/features2d/features2d.hpp	/^    CV_PROP_RW float size; \/\/!< diameter of the meaningfull keypoint neighborhood$/;"	m	class:cv::KeyPoint	access:public
size	/usr/include/opencv2/features2d/features2d.hpp	/^    int size;$/;"	m	class:cv::BOWTrainer	access:protected
size	/usr/include/opencv2/features2d/features2d.hpp	/^    int size;$/;"	m	struct:CvSURFPoint	access:public
size	/usr/include/opencv2/features2d/features2d.hpp	/^    int size;$/;"	m	struct:CvStarKeypoint	access:public
size	/usr/include/opencv2/flann/autotuned_index.h	/^	virtual size_t size() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
size	/usr/include/opencv2/flann/composite_index.h	/^    size_t size() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
size	/usr/include/opencv2/flann/flann.hpp	/^	int size() const { return nnIndex->size(); }$/;"	f	class:cv::flann::Index_	access:public	signature:() const
size	/usr/include/opencv2/flann/flann_base.hpp	/^	int size() const;$/;"	p	class:cvflann::Index	access:public	signature:() const
size	/usr/include/opencv2/flann/flann_base.hpp	/^int Index<T>::size() const$/;"	f	class:cvflann::Index	signature:() const
size	/usr/include/opencv2/flann/heap.h	/^	int size()$/;"	f	class:cvflann::Heap	access:public	signature:()
size	/usr/include/opencv2/flann/kdtree_index.h	/^    size_t size() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
size	/usr/include/opencv2/flann/kmeans_index.h	/^		int size;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
size	/usr/include/opencv2/flann/kmeans_index.h	/^	size_t size() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
size	/usr/include/opencv2/flann/linear_index.h	/^	size_t size() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
size	/usr/include/opencv2/flann/nn_index.h	/^	virtual size_t size() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
size	/usr/include/opencv2/flann/random.h	/^    int size;$/;"	m	class:cvflann::UniqueRandom	access:private
size	/usr/include/opencv2/flann/result_set.h	/^	virtual size_t size() const = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:() const
size	/usr/include/opencv2/flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
size	/usr/include/opencv2/flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
size	/usr/include/opencv2/gpu/gpu.hpp	/^            Size size() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
size	/usr/include/opencv2/gpu/gpu.hpp	/^            Size size() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
size	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline Size CudaMem::size() const { return Size(cols, rows); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
size	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline Size GpuMat::size() const { return Size(cols, rows); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
size	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSize size() const { return image ? cvSize(image->width, image->height) : cvSize(0,0); }$/;"	f	class:CvImage	access:public	signature:() const
size	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSize size() const$/;"	f	class:CvMatrix	access:public	signature:() const
size	/usr/include/opencv2/video/background_segm.hpp	/^    CvSize size;$/;"	m	struct:CvBGCodeBookModel	access:public
sizeX	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int sizeX;$/;"	m	struct:__anon60	access:public
sizeY	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int sizeY;$/;"	m	struct:__anon60	access:public
size_	/usr/include/opencv2/flann/kdtree_index.h	/^	size_t size_;$/;"	m	class:cvflann::KDTreeIndex	access:private
size_	/usr/include/opencv2/flann/kmeans_index.h	/^    size_t size_;$/;"	m	class:cvflann::KMeansIndex	access:private
size_type	/usr/include/opencv2/core/core.hpp	/^    typedef size_t size_type;$/;"	t	class:cv::Allocator	access:public
skinHueHistogram	/usr/include/opencv2/contrib/contrib.hpp	/^    Histogram histogramHueMotion, skinHueHistogram;$/;"	m	class:CvAdaptiveSkinDetector	access:private
sliceEnd	/usr/include/opencv2/core/core.hpp	/^    uchar* sliceEnd;$/;"	m	class:cv::MatConstIterator	access:public
sliceStart	/usr/include/opencv2/core/core.hpp	/^    uchar* sliceStart;$/;"	m	class:cv::MatConstIterator	access:public
slidingSumBuf	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* slidingSumBuf;$/;"	m	struct:CvStereoBMState	access:public
small	/usr/include/opencv2/core/internal.hpp	67;"	d
smallSize	/usr/include/opencv2/contrib/contrib.hpp	/^        int smallSize;$/;"	m	class:cv::SelfSimDescriptor	access:public
solve	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, n, 1> solve(const Matx<_Tp, m, 1>& rhs, int method) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, 1>& rhs, int method) const
solve	/usr/include/opencv2/core/core.hpp	/^    template<int l> Matx<_Tp, n, l> solve(const Matx<_Tp, m, l>& rhs, int flags=DECOMP_LU) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, l>& rhs, int flags=DECOMP_LU) const
solve	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W bool solve(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, int flags=DECOMP_LU);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, int flags=DECOMP_LU)
solve	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, n, l> Matx<_Tp, m, n>::solve(const Matx<_Tp, m, l>& rhs, int method) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, l>& rhs, int method) const
solveCubic	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W int solveCubic(const Mat& coeffs, CV_OUT Mat& roots);$/;"	p	namespace:cv	signature:(const Mat& coeffs, CV_OUT Mat& roots)
solvePnP	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void solvePnP( const Mat& objectPoints,$/;"	p	namespace:cv	signature:( const Mat& objectPoints, const Mat& imagePoints, const Mat& cameraMatrix, const Mat& distCoeffs, CV_OUT Mat& rvec, CV_OUT Mat& tvec, bool useExtrinsicGuess=false )
solvePoly	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W double solvePoly(const Mat& coeffs, CV_OUT Mat& roots, int maxIters=300);$/;"	p	namespace:cv	signature:(const Mat& coeffs, CV_OUT Mat& roots, int maxIters=300)
solveZ	/usr/include/opencv2/core/core.hpp	/^    static void solveZ( const Mat& src, CV_OUT Mat& dst );$/;"	p	class:cv::SVD	access:public	signature:( const Mat& src, CV_OUT Mat& dst )
solveZ	/usr/include/opencv2/core/mat.hpp	/^inline void SVD::solveZ( const Mat& m, Mat& dst )$/;"	f	class:cv::SVD	signature:( const Mat& m, Mat& dst )
solve_c_svc	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_c_svc( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
solve_eps_svr	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_eps_svr( int count, int var_count, const float** samples, const float* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, const float* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
solve_generic	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_generic( CvSVMSolutionInfo& si );$/;"	p	class:CvSVMSolver	access:public	signature:( CvSVMSolutionInfo& si )
solve_nu_svc	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_nu_svc( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
solve_nu_svr	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_nu_svr( int count, int var_count, const float** samples, const float* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, const float* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
solve_one_class	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool solve_one_class( int count, int var_count, const float** samples,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
solver	/usr/include/opencv2/ml/ml.hpp	/^    CvSVMSolver* solver;$/;"	m	class:CvSVM	access:protected
sort	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void sort(const Mat& src, CV_OUT Mat& dst, int flags);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags)
sort	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, class _LT> void sort( vector<_Tp>& vec, _LT LT=_LT() )$/;"	f	namespace:cv	signature:( vector<_Tp>& vec, _LT LT=_LT() )
sortIdx	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void sortIdx(const Mat& src, CV_OUT Mat& dst, int flags);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, int flags)
sorted	/usr/include/opencv2/flann/result_set.h	/^	bool sorted;$/;"	m	class:cvflann::RadiusResultSet	access:private
speckleRange	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int speckleRange;$/;"	m	class:cv::StereoSGBM	access:public
speckleRange	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int speckleRange; \/\/ acceptable range of variation in window$/;"	m	struct:CvStereoBMState	access:public
speckleWindowSize	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int speckleWindowSize;$/;"	m	class:cv::StereoSGBM	access:public
speckleWindowSize	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int speckleWindowSize; \/\/ disparity variation window$/;"	m	struct:CvStereoBMState	access:public
speedup	/usr/include/opencv2/flann/autotuned_index.h	/^    float speedup;$/;"	m	class:cvflann::AutotunedIndex	access:private
spinCorrelation	/usr/include/opencv2/contrib/contrib.hpp	/^        static bool spinCorrelation(const Mat& spin1, const Mat& spin2, float lambda, float& result);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Mat& spin1, const Mat& spin2, float lambda, float& result)
spinImages	/usr/include/opencv2/contrib/contrib.hpp	/^        Mat spinImages;$/;"	m	class:cv::SpinImageModel	access:protected
split	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void split(const Mat& src, Mat* mvbegin);$/;"	p	namespace:cv	signature:(const Mat& src, Mat* mvbegin)
split	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void split(const Mat& m, vector<Mat>& mv);$/;"	p	namespace:cv	signature:(const Mat& m, vector<Mat>& mv)
split	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> void split(const Mat& src, vector<Mat_<_Tp> >& mv)$/;"	f	namespace:cv	signature:(const Mat& src, vector<Mat_<_Tp> >& mv)
split	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, GpuMat* dst);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat* dst)
split	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, GpuMat* dst, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat* dst, const Stream& stream)
split	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, vector<GpuMat>& dst);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, vector<GpuMat>& dst)
split	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, vector<GpuMat>& dst, const Stream& stream);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, vector<GpuMat>& dst, const Stream& stream)
split	/usr/include/opencv2/ml/ml.hpp	/^    CvDTreeSplit* split;$/;"	m	struct:CvDTreeNode	access:public
split_buf	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* split_buf;$/;"	m	struct:CvDTreeTrainData	access:public
split_criteria	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int split_criteria;$/;"	m	struct:CvBoostParams	access:public
split_heap	/usr/include/opencv2/ml/ml.hpp	/^    CvSet* split_heap;$/;"	m	struct:CvDTreeTrainData	access:public
split_node_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void split_node_data( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
split_node_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual void split_node_data( CvDTreeNode* n );$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n )
split_point	/usr/include/opencv2/ml/ml.hpp	/^            int split_point;$/;"	m	struct:CvDTreeSplit::__anon83::__anon84	access:public
sqrt	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void sqrt(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
srcRow	/usr/include/opencv2/imgproc/imgproc.hpp	/^    vector<uchar> srcRow;$/;"	m	class:cv::FilterEngine	access:public
srcType	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
stack	/usr/include/opencv2/core/core_c.h	/^    CvSeq*   stack;        \/* the graph vertex stack *\/$/;"	m	struct:CvGraphScanner	access:public
stack	/usr/include/opencv2/core/core_c.h	/^    int stack[CV_MAX_DIM]; \/* for internal use *\/$/;"	m	struct:CvNArrayIterator	access:public
stageType	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int stageType;$/;"	m	class:cv::CascadeClassifier	access:public
stage_classifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CvHaarStageClassifier* stage_classifier;$/;"	m	struct:CvHaarClassifierCascade	access:public
stages	/usr/include/opencv2/objdetect/objdetect.hpp	/^    vector<Stage> stages;$/;"	m	class:cv::CascadeClassifier	access:public
stale	/usr/include/opencv2/video/background_segm.hpp	/^    int stale;$/;"	m	struct:CvBGCodeBookElem	access:public
star	/usr/include/opencv2/features2d/features2d.hpp	/^    StarDetector star;$/;"	m	class:cv::StarFeatureDetector	access:protected
start	/usr/include/opencv2/contrib/contrib.hpp	/^        void start();$/;"	p	class:cv::TickMeter	access:public	signature:()
start	/usr/include/opencv2/core/core.hpp	/^    int start, end;$/;"	m	class:cv::Range	access:public
start	/usr/include/opencv2/flann/timer.h	/^    void start() {$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
start	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual int start(Size wholeSize, Rect roi, int maxBufRows=-1);$/;"	p	class:cv::FilterEngine	access:public	signature:(Size wholeSize, Rect roi, int maxBufRows=-1)
start	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual int start(const Mat& src, const Rect& srcRoi=Rect(0,0,-1,-1),$/;"	p	class:cv::FilterEngine	access:public	signature:(const Mat& src, const Rect& srcRoi=Rect(0,0,-1,-1), bool isolated=false, int maxBufRows=-1)
start	/usr/include/opencv2/imgproc/types_c.h	/^    CvPoint* start; \/* point of the contour where the defect begins *\/$/;"	m	struct:CvConvexityDefect	access:public
startDistanceBucket	/usr/include/opencv2/contrib/contrib.hpp	/^        int startDistanceBucket;$/;"	m	class:cv::SelfSimDescriptor	access:public
startIdxs	/usr/include/opencv2/features2d/features2d.hpp	/^        vector<int> startIdxs;$/;"	m	class:cv::DescriptorMatcher::DescriptorCollection	access:protected
startIndices	/usr/include/opencv2/features2d/features2d.hpp	/^        vector<int> startIndices;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
startLoop	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS  int startLoop(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[]);$/;"	p	namespace:cv	signature:(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[])
startTime	/usr/include/opencv2/contrib/contrib.hpp	/^        int64 startTime;$/;"	m	class:cv::TickMeter	access:private
startTime	/usr/include/opencv2/flann/timer.h	/^    clock_t startTime;$/;"	m	class:cvflann::StartStopTimer	access:private
startWindowThread	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W int startWindowThread();$/;"	p	namespace:cv	signature:()
startY	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
startY0	/usr/include/opencv2/imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
start_index	/usr/include/opencv2/core/types_c.h	/^    int  start_index, end_index;$/;"	m	struct:CvSlice	access:public
start_index	/usr/include/opencv2/core/types_c.h	/^  int    start_index;         \/* Index of the first element in the block +  *\/$/;"	m	struct:CvSeqBlock	access:public
start_step	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int start_step;$/;"	m	struct:CvEMParams	access:public
state	/usr/include/opencv2/calib3d/calib3d.hpp	/^    Ptr<CvStereoBMState> state;$/;"	m	class:cv::StereoBM	access:public
state	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int state;$/;"	m	class:CvLevMarq	access:public
state	/usr/include/opencv2/calib3d/calib3d.hpp	/^CVAPI(void) cvReleaseStereoBMState( CvStereoBMState** state );$/;"	v
state	/usr/include/opencv2/calib3d/calib3d.hpp	/^CVAPI(void) cvReleaseStereoGCState( CvStereoGCState** state );$/;"	v
state	/usr/include/opencv2/core/core.hpp	/^    int state; \/\/!< the writer state$/;"	m	class:cv::FileStorage	access:public
state	/usr/include/opencv2/core/core.hpp	/^    uint64 state;$/;"	m	class:cv::RNG	access:public
state	/usr/include/opencv2/legacy/compat.hpp	/^    CvRNG     state;    \/* RNG state (the current seed and carry)*\/$/;"	m	struct:CvRandState	access:public
state	/usr/include/opencv2/legacy/legacy.hpp	/^        CvEHMMState* state; \/* if level == 0 points to real states array,$/;"	m	union:CvEHMM::__anon171	access:public
state	/usr/include/opencv2/legacy/legacy.hpp	/^    int* state;\/* arr of pairs superstate\/state to which observation belong *\/$/;"	m	struct:CvImgObsInfo	access:public
statePost	/usr/include/opencv2/video/tracking.hpp	/^    Mat statePost;          \/\/!< corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))$/;"	m	class:cv::KalmanFilter	access:public
statePre	/usr/include/opencv2/video/tracking.hpp	/^    Mat statePre;           \/\/!< predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k)$/;"	m	class:cv::KalmanFilter	access:public
state_post	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* state_post;          \/* corrected state (x(k)):$/;"	m	struct:CvKalman	access:public
state_pre	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* state_pre;           \/* predicted state (x'(k)):$/;"	m	struct:CvKalman	access:public
status	/usr/include/opencv2/legacy/legacy.hpp	/^    int status;$/;"	m	struct:CvCliqueFinder	access:public
std_threshold	/usr/include/opencv2/video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
step	/usr/include/opencv2/calib3d/calib3d.hpp	/^    void step();$/;"	p	class:CvLevMarq	access:public	signature:()
step	/usr/include/opencv2/core/core.hpp	/^    MStep step;$/;"	m	class:cv::Mat	access:public
step	/usr/include/opencv2/core/core.hpp	/^    int step, elemSize;$/;"	m	class:cv::LineIterator	access:public
step	/usr/include/opencv2/core/types_c.h	/^        int step;$/;"	m	struct:CvMatND::__anon98	access:public
step	/usr/include/opencv2/core/types_c.h	/^    int step;$/;"	m	struct:CvMat	access:public
step	/usr/include/opencv2/gpu/devmem2d.hpp	/^            size_t step;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
step	/usr/include/opencv2/gpu/devmem2d.hpp	/^            size_t step;$/;"	m	struct:cv::gpu::PtrStep_	access:public
step	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t step;$/;"	m	class:cv::gpu::CudaMem	access:public
step	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t step;$/;"	m	class:cv::gpu::GpuMat	access:public
step	/usr/include/opencv2/legacy/compat.hpp	/^    int     step;                   \/* distance between lines ( in elements of single   *\/$/;"	m	struct:_CvPixelPosition8u	access:public
step	/usr/include/opencv2/legacy/compat.hpp	/^    int     step;$/;"	m	struct:_CvPixelPosition32f	access:public
step	/usr/include/opencv2/legacy/compat.hpp	/^    int     step;$/;"	m	struct:_CvPixelPosition8s	access:public
step	/usr/include/opencv2/legacy/legacy.hpp	/^    int step() const { return image ? image->widthStep : 0; }$/;"	f	class:CvImage	access:public	signature:() const
step	/usr/include/opencv2/legacy/legacy.hpp	/^    int step() const { return matrix ? matrix->step : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
step	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double step;$/;"	m	struct:CvParamGrid	access:public
step1	/usr/include/opencv2/core/core.hpp	/^    size_t step1(int i=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i=0) const
step1	/usr/include/opencv2/core/core.hpp	/^    size_t step1(int i=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int i=0) const
step1	/usr/include/opencv2/core/mat.hpp	/^inline size_t Mat::step1(int i) const { return step.p[i]\/elemSize1(); }$/;"	f	class:cv::Mat	signature:(int i) const
step1	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::step1(int i) const { return step.p[i]\/elemSize1(); }$/;"	f	class:cv::Mat_	signature:(int i) const
step1	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t step1() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
step1	/usr/include/opencv2/gpu/gpu.hpp	/^            size_t step1() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
step1	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t CudaMem::step1() const { return step\/elemSize1(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
step1	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline size_t GpuMat::step1() const { return step\/elemSize1(); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
stepScale	/usr/include/opencv2/features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
stepT	/usr/include/opencv2/core/core.hpp	/^    size_t stepT(int i=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int i=0) const
stepT	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::stepT(int i) const { return step.p[i]\/elemSize(); }$/;"	f	class:cv::Mat_	signature:(int i) const
step_arr	/usr/include/opencv2/legacy/compat.hpp	/^    int     step_arr[3];            \/* array: ( 0, -step, step ). It is used for        *\/$/;"	m	struct:_CvPixelPosition8u	access:public
step_arr	/usr/include/opencv2/legacy/compat.hpp	/^    int     step_arr[3];$/;"	m	struct:_CvPixelPosition32f	access:public
step_arr	/usr/include/opencv2/legacy/compat.hpp	/^    int     step_arr[3];$/;"	m	struct:_CvPixelPosition8s	access:public
stereo	/usr/include/opencv2/legacy/legacy.hpp	/^    CvStereoCamera stereo;$/;"	m	class:CvCalibFilter	access:protected
stereoCalibrate	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W double stereoCalibrate( const vector<vector<Point3f> >& objectPoints,$/;"	p	namespace:cv	signature:( const vector<vector<Point3f> >& objectPoints, const vector<vector<Point2f> >& imagePoints1, const vector<vector<Point2f> >& imagePoints2, CV_IN_OUT Mat& cameraMatrix1, CV_IN_OUT Mat& distCoeffs1, CV_IN_OUT Mat& cameraMatrix2, CV_IN_OUT Mat& distCoeffs2, Size imageSize, CV_OUT Mat& R, CV_OUT Mat& T, CV_OUT Mat& E, CV_OUT Mat& F, TermCriteria criteria = TermCriteria(TermCriteria::COUNT+ TermCriteria::EPS, 30, 1e-6), int flags=CALIB_FIX_INTRINSIC )
stereoCamera	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(int) icvComputeCoeffForStereo(  CvStereoCamera* stereoCamera);$/;"	v
stereoCamera	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(void) icvComputeStereoParamsForCameras(CvStereoCamera* stereoCamera);$/;"	v
stereoCamera	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(void) icvGetQuadsTransformStruct(  CvStereoCamera* stereoCamera);$/;"	v
stereoRectify	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS void stereoRectify( const Mat& cameraMatrix1, const Mat& distCoeffs1,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix1, const Mat& distCoeffs1, const Mat& cameraMatrix2, const Mat& distCoeffs2, Size imageSize, const Mat& R, const Mat& T, CV_OUT Mat& R1, CV_OUT Mat& R2, CV_OUT Mat& P1, CV_OUT Mat& P2, CV_OUT Mat& Q, int flags=CALIB_ZERO_DISPARITY )
stereoRectify	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void stereoRectify( const Mat& cameraMatrix1, const Mat& distCoeffs1,$/;"	p	namespace:cv	signature:( const Mat& cameraMatrix1, const Mat& distCoeffs1, const Mat& cameraMatrix2, const Mat& distCoeffs2, Size imageSize, const Mat& R, const Mat& T, CV_OUT Mat& R1, CV_OUT Mat& R2, CV_OUT Mat& P1, CV_OUT Mat& P2, CV_OUT Mat& Q, double alpha, Size newImageSize=Size(), CV_OUT Rect* validPixROI1=0, CV_OUT Rect* validPixROI2=0, int flags=CALIB_ZERO_DISPARITY )
stereoRectifyUncalibrated	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W bool stereoRectifyUncalibrated( const Mat& points1, const Mat& points2,$/;"	p	namespace:cv	signature:( const Mat& points1, const Mat& points2, const Mat& F, Size imgSize, CV_OUT Mat& H1, CV_OUT Mat& H2, double threshold=5 )
stereoparams	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(int) icvComputeRestStereoParams(CvStereoCamera *stereoparams);$/;"	v
stop	/usr/include/opencv2/contrib/contrib.hpp	/^        void stop();$/;"	p	class:cv::TickMeter	access:public	signature:()
stop	/usr/include/opencv2/flann/timer.h	/^    void stop() {$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
stopLoop	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS  void stopLoop();$/;"	p	namespace:cv	signature:()
storage	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvClearMemStorage( CvMemStorage* storage );$/;"	v
storage	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvReleaseMemStorage( CvMemStorage** storage );$/;"	v
storage	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvCalibFilter	access:protected
storage	/usr/include/opencv2/ml/ml.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvSVM	access:protected
storage	/usr/include/opencv2/ml/ml.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvSVMSolver	access:public
storage	/usr/include/opencv2/video/background_segm.hpp	/^    CvMemStorage* storage;$/;"	m	struct:CvBGCodeBookModel	access:public
str	/usr/include/opencv2/core/types_c.h	/^        CvString str; \/* text string *\/$/;"	m	union:CvFileNode::__anon100	access:public
str	/usr/include/opencv2/core/types_c.h	/^    CvString str;$/;"	m	struct:CvStringHashNode	access:public
str_to_flt_elem	/usr/include/opencv2/ml/ml.hpp	/^    void str_to_flt_elem( const char* token, float& flt_elem, int& type);$/;"	p	class:CvMLData	access:protected	signature:( const char* token, float& flt_elem, int& type)
strdup	/usr/include/opencv2/legacy/blobtrack.hpp	56;"	d
stream	/usr/include/opencv2/flann/logger.h	/^    FILE* stream;$/;"	m	class:cvflann::Logger	access:private
stricmp	/usr/include/opencv2/legacy/blobtrack.hpp	57;"	d
structSize	/usr/include/opencv2/features2d/features2d.hpp	/^        int structSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
structSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int structSize;$/;"	m	class:cv::FernClassifier	access:protected
structs	/usr/include/opencv2/core/core.hpp	/^    vector<char> structs; \/\/!< the stack of written structures$/;"	m	class:cv::FileStorage	access:public
subdiv	/usr/include/opencv2/imgproc/imgproc_c.h	/^CVAPI(void)  cvCalcSubdivVoronoi2D( CvSubdiv2D* subdiv );$/;"	v
subdiv	/usr/include/opencv2/imgproc/imgproc_c.h	/^CVAPI(void)  cvClearSubdivVoronoi2D( CvSubdiv2D* subdiv );$/;"	v
subdiv	/usr/include/opencv2/legacy/legacy.hpp	/^CVAPI(int)   icvSubdiv2DCheck( CvSubdiv2D* subdiv );$/;"	v
subdivide	/usr/include/opencv2/flann/kdtree_index.h	/^	void subdivide(Tree node, int first, int last)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(Tree node, int first, int last)
subsample_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeNode* subsample_data( const CvMat* _subsample_idx );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* _subsample_idx )
subsample_data	/usr/include/opencv2/ml/ml.hpp	/^    virtual CvDTreeNode* subsample_data( const CvMat* _subsample_idx );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* _subsample_idx )
subsample_mask	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* subsample_mask;$/;"	m	class:CvBoost	access:protected
subsample_portion	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW float subsample_portion;$/;"	m	struct:CvGBTreesParams	access:public
subsample_test	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* subsample_test;$/;"	m	class:CvGBTrees	access:protected
subsample_train	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* subsample_train;$/;"	m	class:CvGBTrees	access:protected
subset	/usr/include/opencv2/contrib/contrib.hpp	/^        vector<int> subset;$/;"	m	class:cv::SpinImageModel	access:protected
subset	/usr/include/opencv2/ml/ml.hpp	/^        int subset[2];$/;"	m	union:CvDTreeSplit::__anon83	access:public
subsets	/usr/include/opencv2/objdetect/objdetect.hpp	/^    vector<int> subsets;$/;"	m	class:cv::CascadeClassifier	access:public
subtract	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void subtract(const Mat& src1, const Mat& src2, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst)
subtract	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void subtract(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask CV_WRAP_DEFAULT(Mat()));$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask CV_WRAP_DEFAULT(Mat()))
subtract	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void subtract(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Mat& src1, const Scalar& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
subtract	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void subtract(const Scalar& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat());$/;"	p	namespace:cv	signature:(const Scalar& src1, const Mat& src2, CV_OUT Mat& dst, const Mat& mask=Mat())
subtract	/usr/include/opencv2/core/mat.hpp	/^    virtual void subtract(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
subtract	/usr/include/opencv2/core/mat.hpp	/^    virtual void subtract(const Scalar& s, const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const Scalar& s, const MatExpr& expr, MatExpr& res) const
subtract	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void subtract(const GpuMat& a, const GpuMat& b, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c)
subtract	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void subtract(const GpuMat& a, const Scalar& sc, GpuMat& c);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c)
subtree_weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* subtree_weights;$/;"	m	class:CvBoost	access:protected
sum	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W Scalar sum(const Mat& src);$/;"	p	namespace:cv	signature:(const Mat& src)
sum	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS Scalar sum(const GpuMat& m);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& m)
sum	/usr/include/opencv2/ml/ml.hpp	/^    CvMat** sum;$/;"	m	class:CvNormalBayesClassifier	access:protected
sumTime	/usr/include/opencv2/contrib/contrib.hpp	/^        int64 sumTime;$/;"	m	class:cv::TickMeter	access:private
sum_response	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* sum_response;$/;"	m	class:CvBoost	access:protected
sum_response	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* sum_response;$/;"	m	class:CvGBTrees	access:protected
sum_response_tmp	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* sum_response_tmp;$/;"	m	class:CvGBTrees	access:protected
suppressNonmaxSize	/usr/include/opencv2/features2d/features2d.hpp	/^    int suppressNonmaxSize;$/;"	m	struct:CvStarDetectorParams	access:public
surf	/usr/include/opencv2/features2d/features2d.hpp	/^    SURF surf;$/;"	m	class:cv::SurfDescriptorExtractor	access:protected
surf	/usr/include/opencv2/features2d/features2d.hpp	/^    SURF surf;$/;"	m	class:cv::SurfFeatureDetector	access:protected
sv	/usr/include/opencv2/ml/ml.hpp	/^    float** sv;$/;"	m	class:CvSVM	access:protected
sv_count	/usr/include/opencv2/ml/ml.hpp	/^    int sv_count;$/;"	m	struct:CvSVMDecisionFunc	access:public
sv_index	/usr/include/opencv2/ml/ml.hpp	/^    int* sv_index;$/;"	m	struct:CvSVMDecisionFunc	access:public
sv_total	/usr/include/opencv2/ml/ml.hpp	/^    int sv_total;$/;"	m	class:CvSVM	access:protected
svmDetector	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP vector<float> svmDetector;$/;"	m	struct:cv::HOGDescriptor	access:public
svm_type	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int         svm_type;$/;"	m	struct:CvSVMParams	access:public
swap	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void swap(Mat& a, Mat& b);$/;"	p	namespace:cv	signature:(Mat& a, Mat& b)
swap	/usr/include/opencv2/gpu/gpu.hpp	/^            void swap(GpuMat& mat);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(GpuMat& mat)
swap	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline void GpuMat::swap(GpuMat& b)$/;"	f	class:cv::gpu::GpuMat	signature:(GpuMat& b)
swap	/usr/include/opencv2/gpu/matrix_operations.hpp	/^static inline void swap( GpuMat& a, GpuMat& b ) { a.swap(b); }$/;"	f	namespace:cv::gpu	signature:( GpuMat& a, GpuMat& b )
t	/usr/include/opencv2/core/core.hpp	/^    MatExpr t() const;$/;"	p	class:cv::Mat	access:public	signature:() const
t	/usr/include/opencv2/core/core.hpp	/^    Matx<_Tp, n, m> t() const;$/;"	p	class:cv::Matx	access:public	signature:() const
t	/usr/include/opencv2/core/mat.hpp	/^    MatExpr t() const;$/;"	p	class:cv::MatExpr	access:public	signature:() const
t	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp, n, m> Matx<_Tp, m, n>::t() const$/;"	f	class:cv::Matx	signature:() const
t	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat t() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
t	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat GpuMat::t() const$/;"	f	class:cv::gpu::GpuMat	signature:() const
t	/usr/include/opencv2/video/background_segm.hpp	/^    int t;$/;"	m	struct:CvBGCodeBookModel	access:public
tLastUpdate	/usr/include/opencv2/video/background_segm.hpp	/^    int tLastUpdate;$/;"	m	struct:CvBGCodeBookElem	access:public
table_color	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat table_color;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
table_space	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat table_space;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
tag	/usr/include/opencv2/core/types_c.h	/^    int tag;$/;"	m	struct:CvFileNode	access:public
target	/usr/include/opencv2/flann/result_set.h	/^	const ELEM_TYPE* target;$/;"	m	class:cvflann::KNNResultSet	access:private
target	/usr/include/opencv2/flann/result_set.h	/^	const ELEM_TYPE* target;$/;"	m	class:cvflann::RadiusResultSet	access:private
target_end	/usr/include/opencv2/flann/result_set.h	/^	const ELEM_TYPE* target_end;$/;"	m	class:cvflann::KNNResultSet	access:private
target_end	/usr/include/opencv2/flann/result_set.h	/^	const ELEM_TYPE* target_end;$/;"	m	class:cvflann::RadiusResultSet	access:private
target_precision	/usr/include/opencv2/flann/autotuned_index.h	/^	float target_precision;    \/\/ precision desired (used for autotuning, -1 otherwise)$/;"	m	struct:cvflann::AutotunedIndexParams	access:public
tell	/usr/include/opencv2/core/core.hpp	/^    size_t tell() const;$/;"	p	class:cv::SeqIterator	access:public	signature:() const
tell	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline size_t SeqIterator<_Tp>::tell() const$/;"	f	class:cv::SeqIterator	signature:() const
temp	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat temp;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
temp1	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* temp1;               \/* temporary matrices *\/$/;"	m	struct:CvKalman	access:public
temp1	/usr/include/opencv2/video/tracking.hpp	/^    Mat temp1;$/;"	m	class:cv::KalmanFilter	access:public
temp2	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* temp2;$/;"	m	struct:CvKalman	access:public
temp2	/usr/include/opencv2/video/tracking.hpp	/^    Mat temp2;$/;"	m	class:cv::KalmanFilter	access:public
temp3	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* temp3;$/;"	m	struct:CvKalman	access:public
temp3	/usr/include/opencv2/video/tracking.hpp	/^    Mat temp3;$/;"	m	class:cv::KalmanFilter	access:public
temp4	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* temp4;$/;"	m	struct:CvKalman	access:public
temp4	/usr/include/opencv2/video/tracking.hpp	/^    Mat temp4;$/;"	m	class:cv::KalmanFilter	access:public
temp5	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* temp5;$/;"	m	struct:CvKalman	access:public
temp5	/usr/include/opencv2/video/tracking.hpp	/^    Mat temp5;$/;"	m	class:cv::KalmanFilter	access:public
tempImg	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat*  tempImg;$/;"	m	class:CvCalibFilter	access:protected
temp_storage	/usr/include/opencv2/ml/ml.hpp	/^    CvMemStorage* temp_storage;$/;"	m	struct:CvDTreeTrainData	access:public
term_crit	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit; \/\/ termination criteria$/;"	m	struct:CvSVMParams	access:public
term_crit	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
term_crit	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvEMParams	access:public
term_crit	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvRTParams	access:public
termcrit	/usr/include/opencv2/features2d/features2d.hpp	/^    TermCriteria termcrit;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
testDataset	/usr/include/opencv2/flann/autotuned_index.h	/^    Matrix<ELEM_TYPE> testDataset;$/;"	m	class:cvflann::AutotunedIndex	access:private
test_fn_	/usr/include/opencv2/features2d/features2d.hpp	/^    PixelTestFn test_fn_;$/;"	m	class:cv::BriefDescriptorExtractor	access:protected
test_index_checks	/usr/include/opencv2/flann/index_testing.h	/^float test_index_checks(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches,$/;"	f	namespace:cvflann	signature:(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches, int checks, float& precision, int nn = 1, int skipMatches = 0)
test_index_precision	/usr/include/opencv2/flann/index_testing.h	/^float test_index_precision(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches,$/;"	f	namespace:cvflann	signature:(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches, float precision, int& checks, int nn = 1, int skipMatches = 0)
test_index_precisions	/usr/include/opencv2/flann/index_testing.h	/^float test_index_precisions(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches,$/;"	f	namespace:cvflann	signature:(NNIndex<ELEM_TYPE>& index, const Matrix<ELEM_TYPE>& inputData, const Matrix<ELEM_TYPE>& testData, const Matrix<int>& matches, float* precisions, int precisions_length, int nn = 1, int skipMatches = 0, float maxTime = 0)
test_sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* test_sample_idx;$/;"	m	class:CvMLData	access:protected
textureThreshold	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int textureThreshold;  \/\/ the disparity is only computed for pixels$/;"	m	struct:CvStereoBMState	access:public
tflag	/usr/include/opencv2/ml/ml.hpp	/^    int tflag;$/;"	m	struct:CvDTreeTrainData	access:public
theRNG	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS RNG& theRNG();$/;"	p	namespace:cv	signature:()
theta	/usr/include/opencv2/features2d/features2d.hpp	/^    float theta;$/;"	m	class:cv::CvAffinePose	access:public
thetaMax	/usr/include/opencv2/features2d/features2d.hpp	/^    double thetaMin, thetaMax;$/;"	m	class:cv::PatchGenerator	access:public
thetaMin	/usr/include/opencv2/features2d/features2d.hpp	/^    double thetaMin, thetaMax;$/;"	m	class:cv::PatchGenerator	access:public
thickness	/usr/include/opencv2/core/core_c.h	/^    int         thickness; 		\/\/Qt: weight               \/* letters thickness *\/$/;"	m	struct:CvFont	access:public
thresh	/usr/include/opencv2/core/types_c.h	/^    float   thresh[CV_MAX_DIM][2];  \/* For uniform histograms.                      *\/$/;"	m	struct:CvHistogram	access:public
thresh2	/usr/include/opencv2/core/types_c.h	/^    float** thresh2;                \/* For non-uniform histograms.                  *\/$/;"	m	struct:CvHistogram	access:public
thresh_	/usr/include/opencv2/features2d/features2d.hpp	/^	double thresh_;$/;"	m	class:cv::StarAdjuster	access:protected
thresh_	/usr/include/opencv2/features2d/features2d.hpp	/^	double thresh_;$/;"	m	class:cv::SurfAdjuster	access:protected
thresh_	/usr/include/opencv2/features2d/features2d.hpp	/^	int thresh_;$/;"	m	class:cv::FastAdjuster	access:protected
threshold	/usr/include/opencv2/features2d/features2d.hpp	/^        double threshold, edgeThreshold;$/;"	m	struct:cv::SIFT::DetectorParams	access:public
threshold	/usr/include/opencv2/features2d/features2d.hpp	/^    int threshold;$/;"	m	class:cv::FastFeatureDetector	access:protected
threshold	/usr/include/opencv2/features2d/features2d.hpp	/^    int threshold;$/;"	m	class:cv::LDetector	access:public
threshold	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS double threshold(const GpuMat& src, GpuMat& dst, double thresh);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, double thresh)
threshold	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W double threshold( const Mat& src, CV_OUT Mat& dst, double thresh, double maxval, int type );$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, double thresh, double maxval, int type )
threshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^        float threshold; \/\/ for ordered features only$/;"	m	struct:cv::CascadeClassifier::DTreeNode	access:public
threshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^        float threshold;$/;"	m	struct:cv::CascadeClassifier::Stage	access:public
threshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^    float threshold;$/;"	m	struct:CvHaarStageClassifier	access:public
threshold	/usr/include/opencv2/objdetect/objdetect.hpp	/^    float* threshold;$/;"	m	struct:CvHaarClassifier	access:public
threshold_L2hys	/usr/include/opencv2/gpu/gpu.hpp	/^            double threshold_L2hys;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
tileInfo	/usr/include/opencv2/core/types_c.h	/^    struct _IplTileInfo *tileInfo;  \/* "           " *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplTileInfo	access:public
tilted	/usr/include/opencv2/objdetect/objdetect.hpp	/^    int  tilted;$/;"	m	struct:CvHaarFeature	access:public
timeCost	/usr/include/opencv2/flann/autotuned_index.h	/^        float timeCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
tl	/usr/include/opencv2/core/core.hpp	/^    Point_<_Tp> tl() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
tl	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::tl() const { return Point_<_Tp>(x,y); }$/;"	f	class:cv::Rect_	signature:() const
toUtf16	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS WString toUtf16(const string& str);$/;"	p	namespace:cv	signature:(const string& str)
tooFew	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooFew(int min, int n_detected) = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:(int min, int n_detected)
tooFew	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int min, int n_detected)
tooFew	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::StarAdjuster	access:public	signature:(int min, int n_detected)
tooFew	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::SurfAdjuster	access:public	signature:(int min, int n_detected)
tooMany	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooMany(int max, int n_detected) = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:(int max, int n_detected)
tooMany	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int max, int n_detected)
tooMany	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::StarAdjuster	access:public	signature:(int max, int n_detected)
tooMany	/usr/include/opencv2/features2d/features2d.hpp	/^	virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::SurfAdjuster	access:public	signature:(int max, int n_detected)
top	/usr/include/opencv2/core/types_c.h	/^    CvMemBlock* top;              \/* Current memory block - top of the stack. *\/$/;"	m	struct:CvMemStorage	access:public
top	/usr/include/opencv2/core/types_c.h	/^    CvMemBlock* top;$/;"	m	struct:CvMemStoragePos	access:public
topline	/usr/include/opencv2/legacy/compat.hpp	/^    float*  topline;$/;"	m	struct:_CvPixelPosition32f	access:public
topline	/usr/include/opencv2/legacy/compat.hpp	/^    schar*  topline;$/;"	m	struct:_CvPixelPosition8s	access:public
topline	/usr/include/opencv2/legacy/compat.hpp	/^    uchar*  topline;       \/* pointer to the start of the top pixel line       *\/$/;"	m	struct:_CvPixelPosition8u	access:public
total	/usr/include/opencv2/core/core.hpp	/^    size_t total() const;$/;"	p	class:cv::Mat	access:public	signature:() const
total	/usr/include/opencv2/core/mat.hpp	/^inline size_t Mat::total() const$/;"	f	class:cv::Mat	signature:() const
total	/usr/include/opencv2/ml/ml.hpp	/^    int total;$/;"	m	class:CvKNearest	access:protected
totalCost	/usr/include/opencv2/flann/autotuned_index.h	/^        float totalCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
total_class_count	/usr/include/opencv2/ml/ml.hpp	/^    int total_class_count;$/;"	m	class:CvMLData	access:protected
trace	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W Scalar trace(const Mat& mtx);$/;"	p	namespace:cv	signature:(const Mat& mtx)
trace	/usr/include/opencv2/core/operations.hpp	/^double trace(const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a)
track	/usr/include/opencv2/contrib/contrib.hpp	/^    void track(IplImage *maskImage, IplImage *depthMap, int resizeMethod, bool resetSearch, int minKernelMass = MinKernelMass);$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:(IplImage *maskImage, IplImage *depthMap, int resizeMethod, bool resetSearch, int minKernelMass = MinKernelMass)
track_object	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool  track_object( const IplImage* cur_frame );$/;"	p	class:CvCamShiftTracker	access:public	signature:( const IplImage* cur_frame )
train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:()
train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train(const vector<Mat>& pyr, int _npoints=300,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, int _npoints=300, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
train	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void train(const vector<vector<Point2f> >& points,$/;"	p	class:cv::FernClassifier	access:public	signature:(const vector<vector<Point2f> >& points, const vector<Mat>& refimgs, const vector<vector<int> >& labels=vector<vector<int> >(), int _nclasses=0, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
train	/usr/include/opencv2/features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set, RNG &rng,$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, PatchGenerator &make_patch, int depth, int views, size_t reduced_num_dim, int num_quant_bits)
train	/usr/include/opencv2/features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set, RNG &rng,$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, int depth, int views, size_t reduced_num_dim, int num_quant_bits)
train	/usr/include/opencv2/features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set,$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, PatchGenerator &make_patch, int num_trees = RTreeClassifier::DEFAULT_TREES, int depth = RandomizedTree::DEFAULT_DEPTH, int views = RandomizedTree::DEFAULT_VIEWS, size_t reduced_num_dim = RandomizedTree::DEFAULT_REDUCED_NUM_DIM, int num_quant_bits = DEFAULT_NUM_QUANT_BITS)
train	/usr/include/opencv2/features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set,$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, int num_trees = RTreeClassifier::DEFAULT_TREES, int depth = RandomizedTree::DEFAULT_DEPTH, int views = RandomizedTree::DEFAULT_VIEWS, size_t reduced_num_dim = RandomizedTree::DEFAULT_REDUCED_NUM_DIM, int num_quant_bits = DEFAULT_NUM_QUANT_BITS)
train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& samples,$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(), CvEMParams params=CvEMParams(), CV_OUT cv::Mat* labels=0 )
train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& sampleIdx=cv::Mat(), bool isRegression=false, int maxK=32, bool updateBase=false )
train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx = cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), bool update=false )
train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), CvSVMParams params=CvSVMParams() )
train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvBoostParams params=CvBoostParams(), bool update=false )
train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvDTree	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvDTreeParams params=CvDTreeParams() )
train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvERTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvRTParams params=CvRTParams())
train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvGBTreesParams params=CvGBTreesParams(), bool update=false )
train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvRTParams params=CvRTParams() )
train	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual int train( const cv::Mat& inputs, const cv::Mat& outputs,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& inputs, const cv::Mat& outputs, const cv::Mat& sampleWeights, const cv::Mat& sampleIdx=cv::Mat(), CvANN_MLP_TrainParams params = CvANN_MLP_TrainParams(), int flags=0 )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx );$/;"	p	class:CvBoostTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx );$/;"	p	class:CvForestTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx, CvRTrees* forest );$/;"	p	class:CvForestTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx, CvRTrees* forest )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* subsampleIdx );$/;"	p	class:CvDTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* subsampleIdx )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData,$/;"	p	class:CvBoostTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* subsample_idx, CvBoost* ensemble )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvMLData* data, CvRTParams params=CvRTParams() );$/;"	p	class:CvERTrees	access:public	signature:( CvMLData* data, CvRTParams params=CvRTParams() )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvMLData* data, CvRTParams params=CvRTParams() );$/;"	p	class:CvRTrees	access:public	signature:( CvMLData* data, CvRTParams params=CvRTParams() )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvMLData* data,$/;"	p	class:CvBoost	access:public	signature:( CvMLData* data, CvBoostParams params=CvBoostParams(), bool update=false )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvMLData* data,$/;"	p	class:CvGBTrees	access:public	signature:( CvMLData* data, CvGBTreesParams params=CvGBTreesParams(), bool update=false )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( CvMLData* trainData, CvDTreeParams params=CvDTreeParams() );$/;"	p	class:CvDTree	access:public	signature:( CvMLData* trainData, CvDTreeParams params=CvDTreeParams() )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* samples, const CvMat* sampleIdx=0,$/;"	p	class:CvEM	access:public	signature:( const CvMat* samples, const CvMat* sampleIdx=0, CvEMParams params=CvEMParams(), CvMat* labels=0 )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* sampleIdx=0, bool is_regression=false, int maxK=32, bool updateBase=false )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx = 0, const CvMat* sampleIdx=0, bool update=false )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, CvSVMParams params=CvSVMParams() )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvBoostParams params=CvBoostParams(), bool update=false )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvBoostTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvDTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvERTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvRTParams params=CvRTParams())
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvForestTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvGBTreesParams params=CvGBTreesParams(), bool update=false )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvRTParams params=CvRTParams() )
train	/usr/include/opencv2/ml/ml.hpp	/^    virtual int train( const CvMat* inputs, const CvMat* outputs,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* inputs, const CvMat* outputs, const CvMat* sampleWeights, const CvMat* sampleIdx=0, CvANN_MLP_TrainParams params = CvANN_MLP_TrainParams(), int flags=0 )
train1	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train1( int sample_count, int var_count, const float** samples,$/;"	p	class:CvSVM	access:protected	signature:( int sample_count, int var_count, const float** samples, const void* responses, double Cp, double Cn, CvMemStorage* _storage, double* alpha, double& rho )
trainDescCollection	/usr/include/opencv2/features2d/features2d.hpp	/^    vector<Mat> trainDescCollection;$/;"	m	class:cv::DescriptorMatcher	access:protected
trainFernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    void trainFernClassifier();$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:()
trainFromSingleView	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void trainFromSingleView(const Mat& image,$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& image, const vector<KeyPoint>& keypoints, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
trainIdx	/usr/include/opencv2/features2d/features2d.hpp	/^    int trainIdx; \/\/ train descriptor index$/;"	m	struct:cv::DMatch	access:public
trainImagesList	/usr/include/opencv2/features2d/features2d.hpp	/^        string trainImagesList;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
trainPath	/usr/include/opencv2/features2d/features2d.hpp	/^        string trainPath;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
trainPointCollection	/usr/include/opencv2/features2d/features2d.hpp	/^    KeyPointCollection trainPointCollection;$/;"	m	class:cv::GenericDescriptorMatcher	access:protected
train_auto	/usr/include/opencv2/ml/ml.hpp	/^    CV_WRAP virtual bool train_auto( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx, const cv::Mat& sampleIdx, CvSVMParams params, int k_fold = 10, CvParamGrid Cgrid = CvSVM::get_default_grid(CvSVM::C), CvParamGrid gammaGrid = CvSVM::get_default_grid(CvSVM::GAMMA), CvParamGrid pGrid = CvSVM::get_default_grid(CvSVM::P), CvParamGrid nuGrid = CvSVM::get_default_grid(CvSVM::NU), CvParamGrid coeffGrid = CvSVM::get_default_grid(CvSVM::COEF), CvParamGrid degreeGrid = CvSVM::get_default_grid(CvSVM::DEGREE), bool balanced=false)
train_auto	/usr/include/opencv2/ml/ml.hpp	/^    virtual bool train_auto( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, CvSVMParams params, int kfold = 10, CvParamGrid Cgrid = get_default_grid(CvSVM::C), CvParamGrid gammaGrid = get_default_grid(CvSVM::GAMMA), CvParamGrid pGrid = get_default_grid(CvSVM::P), CvParamGrid nuGrid = get_default_grid(CvSVM::NU), CvParamGrid coeffGrid = get_default_grid(CvSVM::COEF), CvParamGrid degreeGrid = get_default_grid(CvSVM::DEGREE), bool balanced=false )
train_backprop	/usr/include/opencv2/ml/ml.hpp	/^    virtual int train_backprop( CvVectors _ivecs, CvVectors _ovecs, const double* _sw );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvVectors _ivecs, CvVectors _ovecs, const double* _sw )
train_data	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* train_data;$/;"	m	struct:CvDTreeTrainData	access:public
train_method	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int train_method;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
train_rprop	/usr/include/opencv2/ml/ml.hpp	/^    virtual int train_rprop( CvVectors _ivecs, CvVectors _ovecs, const double* _sw );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvVectors _ivecs, CvVectors _ovecs, const double* _sw )
train_sample_count	/usr/include/opencv2/ml/ml.hpp	/^    int train_sample_count;$/;"	m	class:CvMLData	access:protected
train_sample_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* train_sample_idx;$/;"	m	class:CvMLData	access:protected
train_sample_part	/usr/include/opencv2/ml/ml.hpp	/^    } train_sample_part;$/;"	m	struct:CvTrainTestSplit	typeref:union:CvTrainTestSplit::__anon91	access:public
train_sample_part_mode	/usr/include/opencv2/ml/ml.hpp	/^    int train_sample_part_mode;$/;"	m	struct:CvTrainTestSplit	access:public
transP	/usr/include/opencv2/legacy/legacy.hpp	/^    float*  transP;\/*transition probab. matrices for states *\/$/;"	m	struct:CvEHMM	access:public
transVect	/usr/include/opencv2/legacy/legacy.hpp	/^    float   transVect[3]; \/* rotation matrix and transition vector relatively$/;"	m	struct:CvCamera	access:public
transVector	/usr/include/opencv2/legacy/legacy.hpp	/^    float transVector[3];$/;"	m	struct:CvStereoCamera	access:public
transform	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void transform(const Mat& src, CV_OUT Mat& dst, const Mat& m );$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst, const Mat& m )
transitionMatrix	/usr/include/opencv2/video/tracking.hpp	/^    Mat transitionMatrix;   \/\/!< state transition matrix (A)$/;"	m	class:cv::KalmanFilter	access:public
transition_matrix	/usr/include/opencv2/video/tracking.hpp	/^    CvMat* transition_matrix;   \/* state transition matrix (A) *\/$/;"	m	struct:CvKalman	access:public
transpose	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void transpose(const Mat& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src, CV_OUT Mat& dst)
transpose	/usr/include/opencv2/core/mat.hpp	/^    virtual void transpose(const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, MatExpr& res) const
transpose	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void transpose(const GpuMat& src1, GpuMat& dst);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, GpuMat& dst)
tree_error	/usr/include/opencv2/ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
tree_iterator	/usr/include/opencv2/core/core_c.h	/^CVAPI(void*) cvNextTreeNode( CvTreeNodeIterator* tree_iterator );$/;"	v
tree_iterator	/usr/include/opencv2/core/core_c.h	/^CVAPI(void*) cvPrevTreeNode( CvTreeNodeIterator* tree_iterator );$/;"	v
tree_risk	/usr/include/opencv2/ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
tree_storage	/usr/include/opencv2/ml/ml.hpp	/^    CvMemStorage* tree_storage;$/;"	m	struct:CvDTreeTrainData	access:public
trees	/usr/include/opencv2/flann/composite_index.h	/^	int trees;                 \/\/ number of randomized trees to use (for kdtree)$/;"	m	struct:cvflann::CompositeIndexParams	access:public
trees	/usr/include/opencv2/flann/kdtree_index.h	/^	int trees;                 \/\/ number of randomized trees to use (for kdtree)$/;"	m	struct:cvflann::KDTreeIndexParams	access:public
trees	/usr/include/opencv2/flann/kdtree_index.h	/^    Tree* trees;$/;"	m	class:cvflann::KDTreeIndex	access:private
trees	/usr/include/opencv2/ml/ml.hpp	/^    CvForestTree** trees;$/;"	m	class:CvRTrees	access:protected
trees_	/usr/include/opencv2/features2d/features2d.hpp	/^  std::vector<RandomizedTree> trees_;$/;"	m	class:cv::RTreeClassifier	access:public
trim_weights	/usr/include/opencv2/ml/ml.hpp	/^    virtual void trim_weights();$/;"	p	class:CvBoost	access:protected	signature:()
truncate_pruned_tree	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW bool  truncate_pruned_tree;$/;"	m	struct:CvDTreeParams	access:public
trySmallerWindows	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int trySmallerWindows; \/\/ if 1, the results may be more accurate,$/;"	m	struct:CvStereoBMState	access:public
try_split_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual void try_split_node( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
try_split_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual void try_split_node( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
tsDisabled	/usr/include/opencv2/contrib/contrib.hpp	/^        tsDisabled      = 10$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
tsNone	/usr/include/opencv2/contrib/contrib.hpp	/^        tsNone          = 0,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
tsSearching	/usr/include/opencv2/contrib/contrib.hpp	/^        tsSearching     = 1,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
tsSetWindow	/usr/include/opencv2/contrib/contrib.hpp	/^        tsSetWindow     = 3,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
tsTracking	/usr/include/opencv2/contrib/contrib.hpp	/^        tsTracking      = 2,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon123
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon124
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon125
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon126
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon127
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon128
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon129
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon130
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon131
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon132
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon133
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon134
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon135
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon136
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon137
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon138
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon139
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon140
type	/usr/include/opencv2/core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Matx::__anon120
type	/usr/include/opencv2/core/core.hpp	/^        type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon122
type	/usr/include/opencv2/core/core.hpp	/^    CV_WRAP int type() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
type	/usr/include/opencv2/core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon121
type	/usr/include/opencv2/core/core.hpp	/^    int type() const;$/;"	p	class:cv::Mat	access:public	signature:() const
type	/usr/include/opencv2/core/core.hpp	/^    int type() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
type	/usr/include/opencv2/core/core.hpp	/^    int type() const;$/;"	p	class:cv::Seq	access:public	signature:() const
type	/usr/include/opencv2/core/core.hpp	/^    int type() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
type	/usr/include/opencv2/core/core.hpp	/^    int type() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
type	/usr/include/opencv2/core/core.hpp	/^    int type; \/\/!< the type of termination criteria: COUNT, EPS or COUNT + EPS$/;"	m	class:cv::TermCriteria	access:public
type	/usr/include/opencv2/core/mat.hpp	/^inline int Mat::type() const { return CV_MAT_TYPE(flags); }$/;"	f	class:cv::Mat	signature:() const
type	/usr/include/opencv2/core/mat.hpp	/^inline int SparseMat::type() const$/;"	f	class:cv::SparseMat	signature:() const
type	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::type() const$/;"	f	class:cv::Mat_	signature:() const
type	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::type() const$/;"	f	class:cv::SparseMat_	signature:() const
type	/usr/include/opencv2/core/operations.hpp	/^    int type() const { return DataType<_Tp>::type; }$/;"	f	class:cv::Vector	access:public	signature:() const
type	/usr/include/opencv2/core/operations.hpp	/^inline int FileNode::type() const { return !node ? NONE : (node->tag & TYPE_MASK); }$/;"	f	class:cv::FileNode	signature:() const
type	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::type() const$/;"	f	class:cv::Seq	signature:() const
type	/usr/include/opencv2/core/types_c.h	/^    int     type;$/;"	m	struct:CvHistogram	access:public
type	/usr/include/opencv2/core/types_c.h	/^    int    type;  \/* may be combination of$/;"	m	struct:CvTermCriteria	access:public
type	/usr/include/opencv2/core/types_c.h	/^    int type;$/;"	m	struct:CvMat	access:public
type	/usr/include/opencv2/core/types_c.h	/^    int type;$/;"	m	struct:CvMatND	access:public
type	/usr/include/opencv2/core/types_c.h	/^    int type;$/;"	m	struct:CvSparseMat	access:public
type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<char> { static int type() { return CV_8S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<double> { static int type() { return CV_64F; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<float> { static int type() { return CV_32F; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<int> { static int type() { return CV_32S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<short> { static int type() { return CV_16S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<unsigned char> { static int type() { return CV_8U; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	/usr/include/opencv2/flann/flann.hpp	/^template <> struct CvType<unsigned short> { static int type() { return CV_16U; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	/usr/include/opencv2/flann/general.h	/^	typedef ELEM_TYPE type;$/;"	t	struct:cvflann::DistType	access:public
type	/usr/include/opencv2/flann/general.h	/^	typedef float type;$/;"	t	struct:cvflann::DistType	access:public
type	/usr/include/opencv2/flann/matrix.h	/^    flann_datatype_t type;$/;"	m	class:cvflann::UntypedMatrix	access:public
type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<char> { static flann_datatype_t type() { return INT8; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<double> { static flann_datatype_t type() { return FLOAT64; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<float> { static flann_datatype_t type() { return FLOAT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<int> { static flann_datatype_t type() { return INT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<short> { static flann_datatype_t type() { return INT16; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned char> { static flann_datatype_t type() { return UINT8; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned int> { static flann_datatype_t type() { return UINT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	/usr/include/opencv2/flann/saving.h	/^template<> struct Datatype<unsigned short> { static flann_datatype_t type() { return UINT16; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	/usr/include/opencv2/gpu/gpu.hpp	/^            int type() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
type	/usr/include/opencv2/gpu/gpu.hpp	/^            int type() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
type	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int CudaMem::type() const { return CV_MAT_TYPE(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
type	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline int GpuMat::type() const { return CV_MAT_TYPE(flags); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
type	/usr/include/opencv2/legacy/legacy.hpp	/^    int type() const { return matrix ? CV_MAT_TYPE(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
type	/usr/include/opencv2/ml/ml.hpp	/^    int type;$/;"	m	struct:CvVectors	access:public
type_name	/usr/include/opencv2/core/types_c.h	/^    const char* type_name;$/;"	m	struct:CvTypeInfo	access:public
u	/usr/include/opencv2/core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
u	/usr/include/opencv2/core/types_c.h	/^    uint64 u;$/;"	m	union:Cv64suf	access:public
u	/usr/include/opencv2/core/types_c.h	/^    unsigned u;$/;"	m	union:Cv32suf	access:public
u	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
u	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
u	/usr/include/opencv2/legacy/legacy.hpp	/^    } u;$/;"	m	struct:CvEHMM	typeref:union:CvEHMM::__anon171	access:public
u	/usr/include/opencv2/ml/ml.hpp	/^    unsigned short* u;$/;"	m	struct:CvPair16u32s	access:public
u2	/usr/include/opencv2/gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
uchar	/usr/include/opencv2/core/types_c.h	/^typedef unsigned char uchar;$/;"	t
uint64	/usr/include/opencv2/core/types_c.h	/^typedef uint64_t uint64;$/;"	t
uint64	/usr/include/opencv2/core/types_c.h	/^typedef unsigned __int64 uint64;$/;"	t
undistImg	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat*  undistImg;$/;"	m	class:CvCalibFilter	access:protected
undistMap	/usr/include/opencv2/legacy/legacy.hpp	/^    CvMat*  undistMap[MAX_CAMERAS][2];$/;"	m	class:CvCalibFilter	access:protected
undistort	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void undistort( const Mat& src, CV_OUT Mat& dst, const Mat& cameraMatrix,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& cameraMatrix, const Mat& distCoeffs, const Mat& newCameraMatrix=Mat() )
undistortPoints	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS void undistortPoints( const Mat& src, CV_OUT vector<Point2f>& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT vector<Point2f>& dst, const Mat& cameraMatrix, const Mat& distCoeffs, const Mat& R=Mat(), const Mat& P=Mat())
undistortPoints	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void undistortPoints( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& cameraMatrix, const Mat& distCoeffs, const Mat& R=Mat(), const Mat& P=Mat())
uniform	/usr/include/opencv2/core/core.hpp	/^    double uniform(double a, double b);$/;"	p	class:cv::RNG	access:public	signature:(double a, double b)
uniform	/usr/include/opencv2/core/core.hpp	/^    float uniform(float a, float b);$/;"	p	class:cv::RNG	access:public	signature:(float a, float b)
uniform	/usr/include/opencv2/core/core.hpp	/^    int uniform(int a, int b);$/;"	p	class:cv::RNG	access:public	signature:(int a, int b)
uniform	/usr/include/opencv2/core/operations.hpp	/^inline double RNG::uniform(double a, double b) { return ((float)*this)*(b - a) + a; }$/;"	f	class:cv::RNG	signature:(double a, double b)
uniform	/usr/include/opencv2/core/operations.hpp	/^inline float RNG::uniform(float a, float b) { return ((float)*this)*(b - a) + a; }$/;"	f	class:cv::RNG	signature:(float a, float b)
uniform	/usr/include/opencv2/core/operations.hpp	/^inline int RNG::uniform(int a, int b) { return a == b ? a : next()%(b - a) + a; }$/;"	f	class:cv::RNG	signature:(int a, int b)
uniquenessRatio	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CV_PROP_RW int uniquenessRatio;$/;"	m	class:cv::StereoSGBM	access:public
uniquenessRatio	/usr/include/opencv2/calib3d/calib3d.hpp	/^    int uniquenessRatio;   \/\/ accept the computed disparity d* only if$/;"	m	struct:CvStereoBMState	access:public
unregister	/usr/include/opencv2/flann/object_factory.h	/^   bool unregister(UniqueIdType id)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id)
update	/usr/include/opencv2/calib3d/calib3d.hpp	/^    bool update( const CvMat*& param, CvMat*& J, CvMat*& err );$/;"	p	class:CvLevMarq	access:public	signature:( const CvMat*& param, CvMat*& J, CvMat*& err )
updateAlt	/usr/include/opencv2/calib3d/calib3d.hpp	/^    bool updateAlt( const CvMat*& param, CvMat*& JtJ, CvMat*& JtErr, double*& errNorm );$/;"	p	class:CvLevMarq	access:public	signature:( const CvMat*& param, CvMat*& JtJ, CvMat*& JtErr, double*& errNorm )
updateMotionHistory	/usr/include/opencv2/video/tracking.hpp	/^CV_EXPORTS_W void updateMotionHistory( const Mat& silhouette, Mat& mhi,$/;"	p	namespace:cv	signature:( const Mat& silhouette, Mat& mhi, double timestamp, double duration )
update_histogram	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual bool  update_histogram( const IplImage* cur_frame );$/;"	p	class:CvCamShiftTracker	access:public	signature:( const IplImage* cur_frame )
update_tree_rnc	/usr/include/opencv2/ml/ml.hpp	/^    virtual double update_tree_rnc( int T, int fold );$/;"	p	class:CvDTree	access:protected	signature:( int T, int fold )
update_weights	/usr/include/opencv2/ml/ml.hpp	/^    virtual void update_weights( CvBoostTree* tree );$/;"	p	class:CvBoost	access:protected	signature:( CvBoostTree* tree )
upload	/usr/include/opencv2/gpu/gpu.hpp	/^            void upload(const CudaMem& m, Stream& stream);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const CudaMem& m, Stream& stream)
upload	/usr/include/opencv2/gpu/gpu.hpp	/^            void upload(const cv::Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const cv::Mat& m)
upper_bound_n	/usr/include/opencv2/ml/ml.hpp	/^    double upper_bound_n;$/;"	m	struct:CvSVMSolutionInfo	access:public
upper_bound_p	/usr/include/opencv2/ml/ml.hpp	/^    double upper_bound_p;$/;"	m	struct:CvSVMSolutionInfo	access:public
useHarrisDetector	/usr/include/opencv2/features2d/features2d.hpp	/^        bool useHarrisDetector;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
useOptimized	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W bool useOptimized();$/;"	p	namespace:cv	signature:()
use_1se_rule	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW bool  use_1se_rule;$/;"	m	struct:CvDTreeParams	access:public
use_local_init_data_cost	/usr/include/opencv2/gpu/gpu.hpp	/^            bool use_local_init_data_cost;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
use_surrogates	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW bool  use_surrogates;$/;"	m	struct:CvDTreeParams	access:public
usedMemory	/usr/include/opencv2/flann/allocator.h	/^	int 	usedMemory;$/;"	m	class:cvflann::PooledAllocator	access:public
usedMemory	/usr/include/opencv2/flann/autotuned_index.h	/^ 	virtual int usedMemory() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
usedMemory	/usr/include/opencv2/flann/composite_index.h	/^	int usedMemory() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
usedMemory	/usr/include/opencv2/flann/kdtree_index.h	/^	int usedMemory() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
usedMemory	/usr/include/opencv2/flann/kmeans_index.h	/^	int usedMemory() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
usedMemory	/usr/include/opencv2/flann/linear_index.h	/^	int usedMemory() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
usedMemory	/usr/include/opencv2/flann/nn_index.h	/^	virtual int usedMemory() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
ushort	/usr/include/opencv2/core/types_c.h	/^typedef unsigned short ushort;$/;"	t
v	/usr/include/opencv2/video/background_segm.hpp	/^    uchar          v[3];$/;"	m	struct:CvBGPixelCStatTable	access:public
v	/usr/include/opencv2/video/background_segm.hpp	/^    uchar          v[6];$/;"	m	struct:CvBGPixelCCStatTable	access:public
val	/usr/include/opencv2/core/core.hpp	/^    _Tp val[m*n]; \/\/< matrix elements$/;"	m	class:cv::Matx	access:public
val	/usr/include/opencv2/core/types_c.h	/^    double val[4];$/;"	m	struct:CvScalar	access:public
valid	/usr/include/opencv2/legacy/legacy.hpp	/^    CvBool valid;$/;"	m	struct:__anon175	access:public
validateDisparity	/usr/include/opencv2/calib3d/calib3d.hpp	/^CV_EXPORTS_W void validateDisparity( Mat& disparity, const Mat& cost,$/;"	p	namespace:cv	signature:( Mat& disparity, const Mat& cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp=1 )
valoffset	/usr/include/opencv2/core/types_c.h	/^    int valoffset;$/;"	m	struct:CvSparseMat	access:public
vals	/usr/include/opencv2/flann/random.h	/^	int* vals;$/;"	m	class:cvflann::UniqueRandom	access:private
value	/usr/include/opencv2/contrib/contrib.hpp	/^    double value, centre;$/;"	m	class:CvFuzzyCurve	access:private
value	/usr/include/opencv2/contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp value(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0) const
value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0) const
value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0) const
value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& value() const;$/;"	p	class:cv::SparseMatIterator	access:public	signature:() const
value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> _Tp& value(Node* n);$/;"	p	class:cv::SparseMat	access:public	signature:(Node* n)
value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& value() const;$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:() const
value	/usr/include/opencv2/core/core.hpp	/^    template<typename _Tp> const _Tp& value(const Node* n) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const Node* n) const
value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon109
value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon112
value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	e	enum:cv::DataDepth::__anon118
value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	e	enum:cv::DataDepth::__anon117
value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon115
value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon111
value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	e	enum:cv::DataDepth::__anon114
value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon110
value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon116
value	/usr/include/opencv2/core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	e	enum:cv::DataDepth::__anon113
value	/usr/include/opencv2/core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	e	enum:cv::DataDepth::__anon119
value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval) const
value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval) const
value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval) const
value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval) const
value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::value(Node* n)$/;"	f	class:cv::SparseMat	signature:(Node* n)
value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMatIterator::value() const$/;"	f	class:cv::SparseMatIterator	signature:() const
value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& SparseMat::value(const Node* n) const$/;"	f	class:cv::SparseMat	signature:(const Node* n) const
value	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline const _Tp& SparseMatConstIterator::value() const$/;"	f	class:cv::SparseMatConstIterator	signature:() const
value	/usr/include/opencv2/flann/timer.h	/^    double value;$/;"	m	class:cvflann::StartStopTimer	access:public
value	/usr/include/opencv2/imgproc/types_c.h	/^    CvScalar value; \/* average color of the connected component *\/$/;"	m	struct:CvConnectedComp	access:public
value	/usr/include/opencv2/ml/ml.hpp	/^    double value;$/;"	m	struct:CvDTreeNode	access:public
valueOffset	/usr/include/opencv2/core/core.hpp	/^        int valueOffset;$/;"	m	struct:cv::SparseMat::Hdr	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Complex<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Point3_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Point_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Range value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Rect_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Scalar_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Size_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef Vec<_Tp, cn> value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Allocator	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::AutoBuffer	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::MatConstIterator_	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Mat_	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Matx	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Point3_	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Point_	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Rect_	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Size_	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Vec	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef bool value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef double value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef float value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef int value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef schar value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef short value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef std::complex<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef uchar value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef uchar* value_type;$/;"	t	class:cv::MatConstIterator	access:public
value_type	/usr/include/opencv2/core/core.hpp	/^    typedef ushort value_type;$/;"	t	class:cv::DataType	access:public
value_type	/usr/include/opencv2/core/operations.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Vector	access:public
values	/usr/include/opencv2/core/types_c.h	/^    float *values;$/;"	m	struct:_IplConvKernelFP	access:public
values	/usr/include/opencv2/core/types_c.h	/^    int *values;$/;"	m	struct:_IplConvKernel	access:public
values	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* values;$/;"	m	class:CvMLData	access:protected
var	/usr/include/opencv2/flann/kdtree_index.h	/^    DIST_TYPE* var;$/;"	m	class:cvflann::KDTreeIndex	access:private
varThreshold	/usr/include/opencv2/video/background_segm.hpp	/^    double varThreshold;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
var_all	/usr/include/opencv2/ml/ml.hpp	/^    int     var_count, var_all;$/;"	m	class:CvNormalBayesClassifier	access:protected
var_all	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
var_all	/usr/include/opencv2/ml/ml.hpp	/^    int var_all;$/;"	m	class:CvSVM	access:protected
var_count	/usr/include/opencv2/ml/ml.hpp	/^    int     var_count, var_all;$/;"	m	class:CvNormalBayesClassifier	access:protected
var_count	/usr/include/opencv2/ml/ml.hpp	/^    int max_k, var_count;$/;"	m	class:CvKNearest	access:protected
var_count	/usr/include/opencv2/ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
var_count	/usr/include/opencv2/ml/ml.hpp	/^    int var_count;$/;"	m	class:CvSVMSolver	access:public
var_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat*  var_idx;$/;"	m	class:CvNormalBayesClassifier	access:protected
var_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_idx;$/;"	m	class:CvSVM	access:protected
var_idx	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_idx;$/;"	m	struct:CvDTreeTrainData	access:public
var_idx	/usr/include/opencv2/ml/ml.hpp	/^    int var_idx;$/;"	m	struct:CvDTreeSplit	access:public
var_idx_mask	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_idx_mask;$/;"	m	class:CvMLData	access:protected
var_idx_out	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_idx_out; \/\/ mat$/;"	m	class:CvMLData	access:protected
var_importance	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_importance;$/;"	m	class:CvDTree	access:protected
var_importance	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_importance;$/;"	m	class:CvRTrees	access:protected
var_type	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_type; \/\/ i-th element =$/;"	m	struct:CvDTreeTrainData	access:public
var_types	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_types;$/;"	m	class:CvMLData	access:protected
var_types_out	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* var_types_out; \/\/ mat$/;"	m	class:CvMLData	access:protected
variance	/usr/include/opencv2/flann/kmeans_index.h	/^		DIST_TYPE variance;$/;"	m	struct:cvflann::KMeansIndex::KMeansNodeSt	access:public
variance	/usr/include/opencv2/video/background_segm.hpp	/^    double      variance[CV_BGFG_MOG_NCOLORS];$/;"	m	struct:CvGaussBGValues	access:public
variance_init	/usr/include/opencv2/video/background_segm.hpp	/^    double  weight_init, variance_init;$/;"	m	struct:CvGaussBGStatModelParams	access:public
varyImgBoundWithScale	/usr/include/opencv2/features2d/features2d.hpp	/^        bool varyImgBoundWithScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
varyXyStepWithScale	/usr/include/opencv2/features2d/features2d.hpp	/^        bool varyXyStepWithScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
vconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void vconcat(const Mat& src1, const Mat& src2, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, Mat& dst)
vconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS void vconcat(const Mat* src, size_t nsrc, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrc, Mat& dst)
vconcat	/usr/include/opencv2/core/core.hpp	/^CV_EXPORTS_W void vconcat(const vector<Mat>& src, CV_OUT Mat& dst);$/;"	p	namespace:cv	signature:(const vector<Mat>& src, CV_OUT Mat& dst)
vec_type	/usr/include/opencv2/core/core.hpp	/^    typedef Vec<channel_type, channels> vec_type;$/;"	t	class:cv::DataType	access:public
vec_type	/usr/include/opencv2/core/core.hpp	/^    typedef value_type vec_type;$/;"	t	class:cv::DataType	access:public
veclen	/usr/include/opencv2/flann/autotuned_index.h	/^	virtual size_t veclen() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
veclen	/usr/include/opencv2/flann/composite_index.h	/^	size_t veclen() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
veclen	/usr/include/opencv2/flann/flann.hpp	/^	int veclen() const { return nnIndex->veclen(); }$/;"	f	class:cv::flann::Index_	access:public	signature:() const
veclen	/usr/include/opencv2/flann/flann_base.hpp	/^	int veclen() const;$/;"	p	class:cvflann::Index	access:public	signature:() const
veclen	/usr/include/opencv2/flann/flann_base.hpp	/^int Index<T>::veclen() const$/;"	f	class:cvflann::Index	signature:() const
veclen	/usr/include/opencv2/flann/kdtree_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
veclen	/usr/include/opencv2/flann/kmeans_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
veclen	/usr/include/opencv2/flann/linear_index.h	/^	size_t veclen() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
veclen	/usr/include/opencv2/flann/nn_index.h	/^	virtual size_t veclen() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
veclen	/usr/include/opencv2/flann/result_set.h	/^    int veclen;$/;"	m	class:cvflann::KNNResultSet	access:private
veclen	/usr/include/opencv2/flann/result_set.h	/^    int veclen;$/;"	m	class:cvflann::RadiusResultSet	access:private
veclen_	/usr/include/opencv2/flann/kdtree_index.h	/^	size_t veclen_;$/;"	m	class:cvflann::KDTreeIndex	access:private
veclen_	/usr/include/opencv2/flann/kmeans_index.h	/^    size_t veclen_;$/;"	m	class:cvflann::KMeansIndex	access:private
vector_add	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual int vector_add(const void* data) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(const void* data)
vector_count	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual unsigned int vector_count() = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:()
vector_lookup	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual const void* vector_lookup(int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int i)
vector_remove	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual void vector_remove(int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int i)
vector_reserve	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual void vector_reserve(int n) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int n)
verbose	/usr/include/opencv2/features2d/features2d.hpp	/^    bool verbose;$/;"	m	class:cv::FernClassifier	access:protected
verbose	/usr/include/opencv2/features2d/features2d.hpp	/^    bool verbose;$/;"	m	class:cv::LDetector	access:public
verbose	/usr/include/opencv2/features2d/features2d.hpp	/^    bool verbose;$/;"	m	class:cv::PlanarObjectDetector	access:protected
version	/usr/include/opencv2/core/types_c.h	/^    const char* version;$/;"	m	struct:CvModuleInfo	access:public
version	/usr/include/opencv2/flann/saving.h	/^	char version[16];$/;"	m	struct:cvflann::IndexHeader	access:public
vertex_weights	/usr/include/opencv2/legacy/legacy.hpp	/^    float* vertex_weights;$/;"	m	struct:CvCliqueFinder	access:public
verticalEdgeLeft	/usr/include/opencv2/contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
verticalEdgeRight	/usr/include/opencv2/contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
vind	/usr/include/opencv2/flann/kdtree_index.h	/^	int* vind;$/;"	m	class:cvflann::KDTreeIndex	access:private
vocabulary	/usr/include/opencv2/features2d/features2d.hpp	/^    Mat vocabulary;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
vscale	/usr/include/opencv2/core/core_c.h	/^    float       hscale, vscale;$/;"	m	struct:CvFont	access:public
vt	/usr/include/opencv2/core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
vtx	/usr/include/opencv2/contrib/contrib.hpp	/^        vector<Point3f> vtx;$/;"	m	class:cv::Mesh3D	access:public
vtx	/usr/include/opencv2/core/core_c.h	/^    CvGraphVtx* vtx;       \/* current graph vertex (or current edge origin) *\/$/;"	m	struct:CvGraphScanner	access:public
vtxBuf	/usr/include/opencv2/calib3d/calib3d.hpp	/^    CvMat* vtxBuf;$/;"	m	struct:CvStereoGCState	access:public
w	/usr/include/opencv2/core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
w	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float   w,h; \/* blob sizes      *\/$/;"	m	struct:CvBlob	access:public
waitForCompletion	/usr/include/opencv2/gpu/gpu.hpp	/^            void waitForCompletion();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
waitKey	/usr/include/opencv2/highgui/highgui.hpp	/^CV_EXPORTS_W int waitKey(int delay=0);$/;"	p	namespace:cv	signature:(int delay=0)
warn	/usr/include/opencv2/flann/logger.h	/^    int warn(const char* fmt, ...);$/;"	p	class:cvflann::Logger	access:public	signature:(const char* fmt, ...)
warpAffine	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void warpAffine(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR)
warpAffine	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void warpAffine( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
warpPerspective	/usr/include/opencv2/gpu/gpu.hpp	/^        CV_EXPORTS void warpPerspective(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR)
warpPerspective	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void warpPerspective( const Mat& src, CV_OUT Mat& dst,$/;"	p	namespace:cv	signature:( const Mat& src, CV_OUT Mat& dst, const Mat& M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
warpSize	/usr/include/opencv2/legacy/legacy.hpp	/^    CvSize warpSize;$/;"	m	struct:CvStereoCamera	access:public
warpWholeImage	/usr/include/opencv2/features2d/features2d.hpp	/^    void warpWholeImage(const Mat& image, Mat& matT, Mat& buf,$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, Mat& matT, Mat& buf, CV_OUT Mat& warped, int border, RNG& rng) const
wastedMemory	/usr/include/opencv2/flann/allocator.h	/^	int 	wastedMemory;$/;"	m	class:cvflann::PooledAllocator	access:public
watershed	/usr/include/opencv2/imgproc/imgproc.hpp	/^CV_EXPORTS_W void watershed( const Mat& image, Mat& markers );$/;"	p	namespace:cv	signature:( const Mat& image, Mat& markers )
wbuf	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* wbuf;$/;"	m	class:CvANN_MLP	access:protected
weak	/usr/include/opencv2/ml/ml.hpp	/^    CvSeq* weak;$/;"	m	class:CvBoost	access:protected
weak	/usr/include/opencv2/ml/ml.hpp	/^    CvSeq** weak;$/;"	m	class:CvGBTrees	access:protected
weak_count	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int weak_count;$/;"	m	struct:CvBoostParams	access:public
weak_count	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW int weak_count;$/;"	m	struct:CvGBTreesParams	access:public
weak_eval	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* weak_eval;$/;"	m	class:CvBoost	access:protected
weak_eval	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* weak_eval;$/;"	m	class:CvGBTrees	access:protected
weight	/usr/include/opencv2/legacy/legacy.hpp	/^    float* weight;      \/*array of mixture weights. Summ of all weights in state is 1. *\/$/;"	m	struct:CvEHMMState	access:public
weight	/usr/include/opencv2/objdetect/objdetect.hpp	/^        float weight;$/;"	m	struct:CvHaarFeature::__anon58	access:public
weight	/usr/include/opencv2/video/background_segm.hpp	/^    double      weight;$/;"	m	struct:CvGaussBGValues	access:public
weight_init	/usr/include/opencv2/video/background_segm.hpp	/^    double  weight_init, variance_init;$/;"	m	struct:CvGaussBGStatModelParams	access:public
weight_trim_rate	/usr/include/opencv2/ml/ml.hpp	/^    CV_PROP_RW double weight_trim_rate;$/;"	m	struct:CvBoostParams	access:public
weighted	/usr/include/opencv2/legacy/legacy.hpp	/^    int weighted;$/;"	m	struct:CvCliqueFinder	access:public
weighted_edges	/usr/include/opencv2/legacy/legacy.hpp	/^    int weighted_edges;    $/;"	m	struct:CvCliqueFinder	access:public
weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* weights;$/;"	m	class:CvBoost	access:protected
weights	/usr/include/opencv2/ml/ml.hpp	/^    CvMat* weights;$/;"	m	class:CvEM	access:protected
weights	/usr/include/opencv2/ml/ml.hpp	/^    const CvMat* weights;$/;"	m	struct:CvEMParams	access:public
weights	/usr/include/opencv2/ml/ml.hpp	/^    double** weights;$/;"	m	class:CvANN_MLP	access:protected
what	/usr/include/opencv2/core/core.hpp	/^	virtual const char *what() const throw() { return msg.c_str(); }$/;"	f	class:cv::Exception	access:public	signature:() const
wholeSize	/usr/include/opencv2/imgproc/imgproc.hpp	/^    Size wholeSize;$/;"	m	class:cv::FilterEngine	access:public
width	/usr/include/opencv2/contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
width	/usr/include/opencv2/core/core.hpp	/^    _Tp width, height; \/\/ the width and the height$/;"	m	class:cv::Size_	access:public
width	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
width	/usr/include/opencv2/core/types_c.h	/^        int width;$/;"	m	union:CvMat::__anon96	access:public
width	/usr/include/opencv2/core/types_c.h	/^    float width;$/;"	m	struct:CvSize2D32f	access:public
width	/usr/include/opencv2/core/types_c.h	/^    int  width;             \/* Image width in pixels.                           *\/$/;"	m	struct:_IplImage	access:public
width	/usr/include/opencv2/core/types_c.h	/^    int  width;$/;"	m	struct:_IplROI	access:public
width	/usr/include/opencv2/core/types_c.h	/^    int width;$/;"	m	struct:CvRect	access:public
width	/usr/include/opencv2/core/types_c.h	/^    int width;$/;"	m	struct:__anon99	access:public
width	/usr/include/opencv2/legacy/compat.hpp	/^    int     width;                  \/* width of the image  ( in pixels )                *\/$/;"	m	struct:_CvPixelPosition8u	access:public
width	/usr/include/opencv2/legacy/compat.hpp	/^    int     width;$/;"	m	struct:_CvPixelPosition32f	access:public
width	/usr/include/opencv2/legacy/compat.hpp	/^    int     width;$/;"	m	struct:_CvPixelPosition8s	access:public
width	/usr/include/opencv2/legacy/legacy.hpp	/^    float width;$/;"	m	struct:CvLCMEdge	access:public
width	/usr/include/opencv2/legacy/legacy.hpp	/^    int width() const { return image ? image->width : 0; }$/;"	f	class:CvImage	access:public	signature:() const
widthStep	/usr/include/opencv2/core/types_c.h	/^    int  widthStep;         \/* Size of aligned image row in bytes.    *\/$/;"	m	struct:_IplImage	access:public
winSigma	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP double winSigma;$/;"	m	struct:cv::HOGDescriptor	access:public
winSize	/usr/include/opencv2/gpu/gpu.hpp	/^            int winSize;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
winSize	/usr/include/opencv2/objdetect/objdetect.hpp	/^    CV_PROP Size winSize;$/;"	m	struct:cv::HOGDescriptor	access:public
win_sigma	/usr/include/opencv2/gpu/gpu.hpp	/^            double win_sigma;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
win_size	/usr/include/opencv2/gpu/gpu.hpp	/^            Size win_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
win_size	/usr/include/opencv2/video/background_segm.hpp	/^    int     win_size;               \/* = 1\/alpha *\/$/;"	m	struct:CvGaussBGStatModelParams	access:public
windowedMatchingMask	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS Mat windowedMatchingMask( const vector<KeyPoint>& keypoints1, const vector<KeyPoint>& keypoints2,$/;"	p	namespace:cv	signature:( const vector<KeyPoint>& keypoints1, const vector<KeyPoint>& keypoints2, float maxDeltaX, float maxDeltaY )
work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Point3_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Point_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Rect_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Scalar_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Size_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
work_type	/usr/include/opencv2/core/core.hpp	/^    typedef Vec<typename DataType<_Tp>::work_type, cn> work_type;$/;"	t	class:cv::DataType	access:public
work_type	/usr/include/opencv2/core/core.hpp	/^    typedef int work_type;$/;"	t	class:cv::DataType	access:public
work_type	/usr/include/opencv2/core/core.hpp	/^    typedef value_type work_type;$/;"	t	class:cv::DataType	access:public
work_var_count	/usr/include/opencv2/ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
worstDist	/usr/include/opencv2/flann/result_set.h	/^	float worstDist() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
worstDist	/usr/include/opencv2/flann/result_set.h	/^	float worstDist() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
worstDist	/usr/include/opencv2/flann/result_set.h	/^	virtual float worstDist() const = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:() const
write	/usr/include/opencv2/core/operations.hpp	/^    static void write(CvFileStorage* _fs, const char* name, const void* ptr, CvAttrList)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(CvFileStorage* _fs, const char* name, const void* ptr, CvAttrList)
write	/usr/include/opencv2/core/operations.hpp	/^    virtual void write(std::ostream& out, const Mat& m, const int* params=0, int nparams=0) const = 0;$/;"	p	class:cv::Formatter	access:public	signature:(std::ostream& out, const Mat& m, const int* params=0, int nparams=0) const
write	/usr/include/opencv2/core/operations.hpp	/^    virtual void write(std::ostream& out, const void* data, int nelems, int type,$/;"	p	class:cv::Formatter	access:public	signature:(std::ostream& out, const void* data, int nelems, int type, const int* params=0, int nparams=0) const
write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void write( FileStorage& fs, const string& name, const SparseMat& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const SparseMat& value )
write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, const Mat& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const Mat& value )
write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, const string& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const string& value )
write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, double value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, double value )
write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, float value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, float value )
write	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, int value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, int value )
write	/usr/include/opencv2/core/operations.hpp	/^inline void write(FileStorage& fs, const Range& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Range& r )
write	/usr/include/opencv2/core/operations.hpp	/^inline void write(FileStorage& fs, const string& name, const Range& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Range& r )
write	/usr/include/opencv2/core/operations.hpp	/^template<> inline void write( FileStorage& fs, const double& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const double& value )
write	/usr/include/opencv2/core/operations.hpp	/^template<> inline void write( FileStorage& fs, const float& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const float& value )
write	/usr/include/opencv2/core/operations.hpp	/^template<> inline void write( FileStorage& fs, const int& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const int& value )
write	/usr/include/opencv2/core/operations.hpp	/^template<> inline void write( FileStorage& fs, const string& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const string& value )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline void write(FileStorage& fs, const Vec<_Tp, cn>& v )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Vec<_Tp, cn>& v )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, int cn> inline void write(FileStorage& fs, const string& name, const Vec<_Tp, cn>& v )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Vec<_Tp, cn>& v )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Complex<_Tp>& c )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Complex<_Tp>& c )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Point3_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Point3_<_Tp>& pt )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Point_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Point_<_Tp>& pt )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Rect_<_Tp>& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Rect_<_Tp>& r )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Scalar_<_Tp>& s )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Scalar_<_Tp>& s )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Size_<_Tp>& sz )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Size_<_Tp>& sz )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const _Tp& value)$/;"	f	namespace:cv	signature:(FileStorage& fs, const _Tp& value)
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Complex<_Tp>& c )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Complex<_Tp>& c )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point3_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Point3_<_Tp>& pt )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Point_<_Tp>& pt )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Rect_<_Tp>& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Rect_<_Tp>& r )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Scalar_<_Tp>& s )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Scalar_<_Tp>& s )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Size_<_Tp>& sz )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Size_<_Tp>& sz )
write	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> static inline void write( FileStorage& fs, const vector<_Tp>& vec )$/;"	f	namespace:cv	signature:( FileStorage& fs, const vector<_Tp>& vec )
write	/usr/include/opencv2/core/types_c.h	/^    CvWriteFunc write;$/;"	m	struct:CvTypeInfo	access:public
write	/usr/include/opencv2/features2d/features2d.hpp	/^        void write( FileStorage& fs ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( FileStorage& fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( FileStorage& ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( FileStorage& ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( FileStorage& ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( FileStorage& ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( FileStorage& ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( FileStorage& fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( FileStorage& fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( FileStorage& fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( FileStorage& fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( FileStorage& fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( FileStorage& fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(FileStorage& fs, const String& name=String()) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::LDetector	access:public	signature:(FileStorage& fs, const String& name=String()) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^    void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(FileStorage& fs, const String& name=String()) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^  void write(const char* file_name) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(const char* file_name) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^  void write(const char* file_name) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(const char* file_name) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^  void write(std::ostream &os) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::ostream &os) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^  void write(std::ostream &os) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::ostream &os) const
write	/usr/include/opencv2/features2d/features2d.hpp	/^CV_EXPORTS void write(FileStorage& fs, const string& name, const vector<KeyPoint>& keypoints);$/;"	p	namespace:cv	signature:(FileStorage& fs, const string& name, const vector<KeyPoint>& keypoints)
write	/usr/include/opencv2/features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::write( FileStorage& ) const$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( FileStorage& ) const
write	/usr/include/opencv2/highgui/highgui.hpp	/^    CV_WRAP virtual void write(const Mat& image);$/;"	p	class:cv::VideoWriter	access:public	signature:(const Mat& image)
write	/usr/include/opencv2/legacy/legacy.hpp	/^    void write( CvFileStorage* fs, const char* imgname );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* imgname )
write	/usr/include/opencv2/legacy/legacy.hpp	/^    void write( CvFileStorage* fs, const char* matname );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* matname )
write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* fs ) const;$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs ) const
write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, const char* name ) const
write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvGBTrees	access:public	signature:( CvFileStorage* fs, const char* name ) const
write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvRTrees	access:public	signature:( CvFileStorage* fs, const char* name ) const
write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( CvFileStorage* storage, const char* name ) const
write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvBoost	access:public	signature:( CvFileStorage* storage, const char* name ) const
write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( CvFileStorage* storage, const char* name ) const
write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvSVM	access:public	signature:( CvFileStorage* storage, const char* name ) const
write	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvStatModel	access:public	signature:( CvFileStorage* storage, const char* name ) const
write	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual void write(FileStorage& fs, const String& objname) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(FileStorage& fs, const String& objname) const
writeAsVrml	/usr/include/opencv2/contrib/contrib.hpp	/^        void writeAsVrml(const String& file, const vector<Scalar>& colors = vector<Scalar>()) const;$/;"	p	class:cv::Mesh3D	access:public	signature:(const String& file, const vector<Scalar>& colors = vector<Scalar>()) const
writeObj	/usr/include/opencv2/core/core.hpp	/^    void writeObj( const string& name, const void* obj );$/;"	p	class:cv::FileStorage	access:public	signature:( const string& name, const void* obj )
writeRaw	/usr/include/opencv2/core/core.hpp	/^    void writeRaw( const string& fmt, const uchar* vec, size_t len );$/;"	p	class:cv::FileStorage	access:public	signature:( const string& fmt, const uchar* vec, size_t len )
writeScalar	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, const string& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& value )
writeScalar	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, double value );$/;"	p	namespace:cv	signature:( FileStorage& fs, double value )
writeScalar	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, float value );$/;"	p	namespace:cv	signature:( FileStorage& fs, float value )
writeScalar	/usr/include/opencv2/core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, int value );$/;"	p	namespace:cv	signature:( FileStorage& fs, int value )
write_node	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_node( CvFileStorage* fs, CvDTreeNode* node ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvDTreeNode* node ) const
write_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( CvFileStorage* fs ) const
write_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvBoost	access:protected	signature:( CvFileStorage* fs ) const
write_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvGBTrees	access:protected	signature:( CvFileStorage* fs ) const
write_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvSVM	access:protected	signature:( CvFileStorage* fs ) const
write_params	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvFileStorage* fs ) const
write_results	/usr/include/opencv2/ml/ml.hpp	/^    virtual float write_results( int k, int k1, int start, int end,$/;"	p	class:CvKNearest	access:protected	signature:( int k, int k1, int start, int end, const float* neighbor_responses, const float* dist, CvMat* _results, CvMat* _neighbor_responses, CvMat* _dist, Cv32suf* sort_buf ) const
write_split	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_split( CvFileStorage* fs, CvDTreeSplit* split ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvDTreeSplit* split ) const
write_tree_nodes	/usr/include/opencv2/ml/ml.hpp	/^    virtual void write_tree_nodes( CvFileStorage* fs ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs ) const
writer	/usr/include/opencv2/core/core_c.h	/^CVAPI(CvSeq*)  cvEndWriteSeq( CvSeqWriter* writer );$/;"	v
writer	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)   cvFlushSeqWriter( CvSeqWriter* writer );$/;"	v
writer	/usr/include/opencv2/core/core_c.h	/^CVAPI(void)  cvCreateSeqBlock( CvSeqWriter* writer );$/;"	v
writer	/usr/include/opencv2/highgui/highgui.hpp	/^    Ptr<CvVideoWriter> writer;$/;"	m	class:cv::VideoWriter	access:protected
writer	/usr/include/opencv2/highgui/highgui_c.h	/^CVAPI(void) cvReleaseVideoWriter( CvVideoWriter** writer );$/;"	v
x	/usr/include/opencv2/contrib/contrib.hpp	/^        int x, y;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
x	/usr/include/opencv2/contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
x	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
x	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
x	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y; \/\/< the point coordinates$/;"	m	class:cv::Point_	access:public
x	/usr/include/opencv2/core/types_c.h	/^    double x;$/;"	m	struct:CvPoint2D64f	access:public
x	/usr/include/opencv2/core/types_c.h	/^    double x;$/;"	m	struct:CvPoint3D64f	access:public
x	/usr/include/opencv2/core/types_c.h	/^    float x;$/;"	m	struct:CvPoint2D32f	access:public
x	/usr/include/opencv2/core/types_c.h	/^    float x;$/;"	m	struct:CvPoint3D32f	access:public
x	/usr/include/opencv2/core/types_c.h	/^    int x;$/;"	m	struct:CvPoint	access:public
x	/usr/include/opencv2/core/types_c.h	/^    int x;$/;"	m	struct:CvRect	access:public
x	/usr/include/opencv2/features2d/features2d.hpp	/^  int x;$/;"	m	struct:cv::BaseKeypoint	access:public
x	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float   x,y; \/* blob position   *\/$/;"	m	struct:CvBlob	access:public
x	/usr/include/opencv2/legacy/compat.hpp	/^    int     x;                      \/* current x coordinate ( in pixels )               *\/$/;"	m	struct:_CvPixelPosition8u	access:public
x	/usr/include/opencv2/legacy/compat.hpp	/^    int     x;$/;"	m	struct:_CvPixelPosition32f	access:public
x	/usr/include/opencv2/legacy/compat.hpp	/^    int     x;$/;"	m	struct:_CvPixelPosition8s	access:public
x	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int x;$/;"	m	struct:__anon59	access:public
x1	/usr/include/opencv2/features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
x2	/usr/include/opencv2/features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
xGc	/usr/include/opencv2/contrib/contrib.hpp	/^        int xGc, yGc;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
xOffset	/usr/include/opencv2/core/types_c.h	/^    int  xOffset;$/;"	m	struct:_IplROI	access:public
x_max	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
x_min	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
xp	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int xp;$/;"	m	struct:__anon60	access:public
y	/usr/include/opencv2/contrib/contrib.hpp	/^        int x, y;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
y	/usr/include/opencv2/contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
y	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
y	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
y	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y; \/\/< the point coordinates$/;"	m	class:cv::Point_	access:public
y	/usr/include/opencv2/core/types_c.h	/^    double y;$/;"	m	struct:CvPoint2D64f	access:public
y	/usr/include/opencv2/core/types_c.h	/^    double y;$/;"	m	struct:CvPoint3D64f	access:public
y	/usr/include/opencv2/core/types_c.h	/^    float y;$/;"	m	struct:CvPoint2D32f	access:public
y	/usr/include/opencv2/core/types_c.h	/^    float y;$/;"	m	struct:CvPoint3D32f	access:public
y	/usr/include/opencv2/core/types_c.h	/^    int y;$/;"	m	struct:CvPoint	access:public
y	/usr/include/opencv2/core/types_c.h	/^    int y;$/;"	m	struct:CvRect	access:public
y	/usr/include/opencv2/features2d/features2d.hpp	/^  int y;$/;"	m	struct:cv::BaseKeypoint	access:public
y	/usr/include/opencv2/legacy/blobtrack.hpp	/^    float   x,y; \/* blob position   *\/$/;"	m	struct:CvBlob	access:public
y	/usr/include/opencv2/ml/ml.hpp	/^    schar* y;$/;"	m	class:CvSVMSolver	access:public
y	/usr/include/opencv2/objdetect/objdetect.hpp	/^    unsigned int y;$/;"	m	struct:__anon59	access:public
y1	/usr/include/opencv2/features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
y2	/usr/include/opencv2/features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
yGc	/usr/include/opencv2/contrib/contrib.hpp	/^        int xGc, yGc;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
yOffset	/usr/include/opencv2/core/types_c.h	/^    int  yOffset;$/;"	m	struct:_IplROI	access:public
y_max	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
y_min	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
z	/usr/include/opencv2/core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
z	/usr/include/opencv2/core/types_c.h	/^    double z;$/;"	m	struct:CvPoint3D64f	access:public
z	/usr/include/opencv2/core/types_c.h	/^    float z;$/;"	m	struct:CvPoint3D32f	access:public
z_max	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
z_min	/usr/include/opencv2/contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
zero	/usr/include/opencv2/flann/dist.h	/^CV_EXPORTS ZeroIterator<float>& zero();$/;"	p	namespace:cvflann	signature:()
zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(int ndims, const int* sz, int type);$/;"	p	class:cv::Mat	access:public	signature:(int ndims, const int* sz, int type)
zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
zeros	/usr/include/opencv2/core/core.hpp	/^    static MatExpr zeros(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
zeros	/usr/include/opencv2/core/core.hpp	/^    static Matx zeros();$/;"	p	class:cv::Matx	access:public	signature:()
zeros	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
zeros	/usr/include/opencv2/core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
zeros	/usr/include/opencv2/core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::zeros()$/;"	f	class:cv::Matx	signature:()
~AdjusterAdapter	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~AdjusterAdapter() {}$/;"	f	class:cv::AdjusterAdapter	access:public	signature:()
~Allocator	/usr/include/opencv2/core/core.hpp	/^    ~Allocator() {}$/;"	f	class:cv::Allocator	access:public	signature:()
~AutoBuffer	/usr/include/opencv2/core/core.hpp	/^    ~AutoBuffer();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
~AutoBuffer	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::~AutoBuffer()$/;"	f	class:cv::AutoBuffer	signature:()
~AutotunedIndex	/usr/include/opencv2/flann/autotuned_index.h	/^    virtual ~AutotunedIndex()$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:()
~BOWImgDescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~BOWImgDescriptorExtractor();$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:()
~BOWKMeansTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~BOWKMeansTrainer();$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:()
~BOWTrainer	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~BOWTrainer();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
~BackgroundSubtractor	/usr/include/opencv2/video/background_segm.hpp	/^    virtual ~BackgroundSubtractor();$/;"	p	class:cv::BackgroundSubtractor	access:public	signature:()
~BackgroundSubtractorMOG	/usr/include/opencv2/video/background_segm.hpp	/^    virtual ~BackgroundSubtractorMOG();$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:()
~BaseColumnFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual ~BaseColumnFilter();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
~BaseColumnFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual ~BaseColumnFilter_GPU() {}$/;"	f	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:()
~BaseFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual ~BaseFilter();$/;"	p	class:cv::BaseFilter	access:public	signature:()
~BaseFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual ~BaseFilter_GPU() {}$/;"	f	class:cv::gpu::BaseFilter_GPU	access:public	signature:()
~BaseRowFilter	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual ~BaseRowFilter();$/;"	p	class:cv::BaseRowFilter	access:public	signature:()
~BaseRowFilter_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual ~BaseRowFilter_GPU() {}$/;"	f	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:()
~BruteForceMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~BruteForceMatcher() {}$/;"	f	class:cv::BruteForceMatcher	access:public	signature:()
~CascadeClassifier	/usr/include/opencv2/objdetect/objdetect.hpp	/^    ~CascadeClassifier();$/;"	p	class:cv::CascadeClassifier	access:public	signature:()
~CompositeIndex	/usr/include/opencv2/flann/composite_index.h	/^	virtual ~CompositeIndex()$/;"	f	class:cvflann::CompositeIndex	access:public	signature:()
~CudaMem	/usr/include/opencv2/gpu/gpu.hpp	/^            ~CudaMem();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
~CudaMem	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline CudaMem::~CudaMem()$/;"	f	class:cv::gpu::CudaMem	signature:()
~CvANN_MLP	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvANN_MLP();$/;"	p	class:CvANN_MLP	access:public	signature:()
~CvANN_MLP_TrainParams	/usr/include/opencv2/ml/ml.hpp	/^    ~CvANN_MLP_TrainParams();$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:()
~CvAdaptiveSkinDetector	/usr/include/opencv2/contrib/contrib.hpp	/^    virtual ~CvAdaptiveSkinDetector();$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:()
~CvBlobSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual ~CvBlobSeq()$/;"	f	class:CvBlobSeq	access:public	signature:()
~CvBlobTrackAnalysisOne	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual ~CvBlobTrackAnalysisOne() {};$/;"	f	class:CvBlobTrackAnalysisOne	access:public	signature:()
~CvBlobTrackSeq	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual ~CvBlobTrackSeq();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
~CvBoost	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvBoost();$/;"	p	class:CvBoost	access:public	signature:()
~CvBoostTree	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvBoostTree();$/;"	p	class:CvBoostTree	access:public	signature:()
~CvCalibFilter	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual ~CvCalibFilter();$/;"	p	class:CvCalibFilter	access:public	signature:()
~CvCamShiftTracker	/usr/include/opencv2/legacy/legacy.hpp	/^    virtual ~CvCamShiftTracker();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
~CvDTree	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvDTree();$/;"	p	class:CvDTree	access:public	signature:()
~CvDTreeTrainData	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvDTreeTrainData();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
~CvEM	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvEM();$/;"	p	class:CvEM	access:public	signature:()
~CvERTrees	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvERTrees();$/;"	p	class:CvERTrees	access:public	signature:()
~CvForestTree	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvForestTree();$/;"	p	class:CvForestTree	access:public	signature:()
~CvFuzzyController	/usr/include/opencv2/contrib/contrib.hpp	/^    ~CvFuzzyController();$/;"	p	class:CvFuzzyController	access:public	signature:()
~CvFuzzyCurve	/usr/include/opencv2/contrib/contrib.hpp	/^    ~CvFuzzyCurve();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
~CvFuzzyFunction	/usr/include/opencv2/contrib/contrib.hpp	/^    ~CvFuzzyFunction();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
~CvFuzzyMeanShiftTracker	/usr/include/opencv2/contrib/contrib.hpp	/^    ~CvFuzzyMeanShiftTracker();$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:()
~CvFuzzyRule	/usr/include/opencv2/contrib/contrib.hpp	/^    ~CvFuzzyRule();$/;"	p	class:CvFuzzyRule	access:public	signature:()
~CvGBTrees	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvGBTrees();$/;"	p	class:CvGBTrees	access:public	signature:()
~CvImage	/usr/include/opencv2/legacy/legacy.hpp	/^    ~CvImage()$/;"	f	class:CvImage	access:public	signature:()
~CvImageDrawer	/usr/include/opencv2/legacy/blobtrack.hpp	/^    ~CvImageDrawer() { cvReleaseImage( &m_image ); }$/;"	f	class:CvImageDrawer	access:public	signature:()
~CvKNearest	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvKNearest();$/;"	p	class:CvKNearest	access:public	signature:()
~CvLSHOperations	/usr/include/opencv2/imgproc/imgproc.hpp	/^  virtual ~CvLSHOperations() {}$/;"	f	struct:CvLSHOperations	access:public	signature:()
~CvLevMarq	/usr/include/opencv2/calib3d/calib3d.hpp	/^    ~CvLevMarq();$/;"	p	class:CvLevMarq	access:public	signature:()
~CvMLData	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvMLData();$/;"	p	class:CvMLData	access:public	signature:()
~CvMatrix	/usr/include/opencv2/legacy/legacy.hpp	/^    ~CvMatrix()$/;"	f	class:CvMatrix	access:public	signature:()
~CvModule	/usr/include/opencv2/core/core_c.h	/^    ~CvModule();$/;"	p	struct:CvModule	access:public	signature:()
~CvNormalBayesClassifier	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvNormalBayesClassifier();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
~CvObjectDetector	/usr/include/opencv2/legacy/blobtrack.hpp	/^    ~CvObjectDetector();$/;"	p	class:CvObjectDetector	access:public	signature:()
~CvProb	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual ~CvProb() {};$/;"	f	class:CvProb	access:public	signature:()
~CvRTrees	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvRTrees();$/;"	p	class:CvRTrees	access:public	signature:()
~CvSVM	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvSVM();$/;"	p	class:CvSVM	access:public	signature:()
~CvSVMKernel	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvSVMKernel();$/;"	p	struct:CvSVMKernel	access:public	signature:()
~CvSVMSolver	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvSVMSolver();$/;"	p	class:CvSVMSolver	access:public	signature:()
~CvStatModel	/usr/include/opencv2/ml/ml.hpp	/^    virtual ~CvStatModel();$/;"	p	class:CvStatModel	access:public	signature:()
~CvType	/usr/include/opencv2/core/core_c.h	/^    ~CvType();$/;"	p	struct:CvType	access:public	signature:()
~CvVSModule	/usr/include/opencv2/legacy/blobtrack.hpp	/^    virtual ~CvVSModule();$/;"	p	class:CvVSModule	access:public	signature:()
~DefaultRngAuto	/usr/include/opencv2/features2d/features2d.hpp	/^        ~DefaultRngAuto() { theRNG().state = old_state; }$/;"	f	struct:cv::DefaultRngAuto	access:public	signature:()
~DescriptorCollection	/usr/include/opencv2/features2d/features2d.hpp	/^        virtual ~DescriptorCollection();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
~DescriptorExtractor	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~DescriptorExtractor();$/;"	p	class:cv::DescriptorExtractor	access:public	signature:()
~DescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~DescriptorMatcher();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
~Exception	/usr/include/opencv2/core/core.hpp	/^	virtual ~Exception() throw() {}$/;"	f	class:cv::Exception	access:public	signature:()
~FeatureDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~FeatureDetector();$/;"	p	class:cv::FeatureDetector	access:public	signature:()
~FeatureEvaluator	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual ~FeatureEvaluator();$/;"	p	class:cv::FeatureEvaluator	access:public	signature:()
~FernClassifier	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~FernClassifier();$/;"	p	class:cv::FernClassifier	access:public	signature:()
~FernDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~FernDescriptorMatcher();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
~FileStorage	/usr/include/opencv2/core/core.hpp	/^    virtual ~FileStorage();$/;"	p	class:cv::FileStorage	access:public	signature:()
~FilterEngine	/usr/include/opencv2/imgproc/imgproc.hpp	/^    virtual ~FilterEngine();$/;"	p	class:cv::FilterEngine	access:public	signature:()
~FilterEngine_GPU	/usr/include/opencv2/gpu/gpu.hpp	/^            virtual ~FilterEngine_GPU() {}$/;"	f	class:cv::gpu::FilterEngine_GPU	access:public	signature:()
~Formatter	/usr/include/opencv2/core/operations.hpp	/^    virtual ~Formatter() {}$/;"	f	class:cv::Formatter	access:public	signature:()
~GenericDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~GenericDescriptorMatcher();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
~GpuMat	/usr/include/opencv2/gpu/gpu.hpp	/^            ~GpuMat();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
~GpuMat	/usr/include/opencv2/gpu/matrix_operations.hpp	/^inline GpuMat::~GpuMat() { release(); }$/;"	f	class:cv::gpu::GpuMat	signature:()
~HOGDescriptor	/usr/include/opencv2/objdetect/objdetect.hpp	/^    virtual ~HOGDescriptor() {}$/;"	f	struct:cv::HOGDescriptor	access:public	signature:()
~Heap	/usr/include/opencv2/flann/heap.h	/^	~Heap()$/;"	f	class:cvflann::Heap	access:public	signature:()
~Histogram	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual ~Histogram();$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:()
~Index	/usr/include/opencv2/flann/flann_base.hpp	/^	~Index();$/;"	p	class:cvflann::Index	access:public	signature:()
~Index	/usr/include/opencv2/flann/flann_base.hpp	/^Index<T>::~Index()$/;"	f	class:cvflann::Index	signature:()
~IndexParams	/usr/include/opencv2/flann/general.h	/^	virtual ~IndexParams() {}$/;"	f	struct:cvflann::IndexParams	access:public	signature:()
~Index_	/usr/include/opencv2/flann/flann.hpp	/^	~Index_();$/;"	p	class:cv::flann::Index_	access:public	signature:()
~Index_	/usr/include/opencv2/flann/flann.hpp	/^Index_<T>::~Index_()$/;"	f	class:cv::flann::Index_	signature:()
~KDTreeIndex	/usr/include/opencv2/flann/kdtree_index.h	/^	~KDTreeIndex()$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:()
~KMeansIndex	/usr/include/opencv2/flann/kmeans_index.h	/^	virtual ~KMeansIndex()$/;"	f	class:cvflann::KMeansIndex	access:public	signature:()
~KNNResultSet	/usr/include/opencv2/flann/result_set.h	/^	~KNNResultSet()$/;"	f	class:cvflann::KNNResultSet	access:public	signature:()
~LevMarqSparse	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual ~LevMarqSparse();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
~Logger	/usr/include/opencv2/flann/logger.h	/^    ~Logger()$/;"	f	class:cvflann::Logger	access:public	signature:()
~Mat	/usr/include/opencv2/core/core.hpp	/^    ~Mat();$/;"	p	class:cv::Mat	access:public	signature:()
~Mat	/usr/include/opencv2/core/mat.hpp	/^inline Mat::~Mat()$/;"	f	class:cv::Mat	signature:()
~MatAllocator	/usr/include/opencv2/core/core.hpp	/^    virtual ~MatAllocator() {}$/;"	f	class:cv::MatAllocator	access:public	signature:()
~MatOp	/usr/include/opencv2/core/mat.hpp	/^    virtual ~MatOp() {};$/;"	f	class:cv::MatOp	access:public	signature:()
~Matrix	/usr/include/opencv2/flann/matrix.h	/^	~Matrix()$/;"	f	class:cvflann::Matrix	access:public	signature:()
~Mesh3D	/usr/include/opencv2/contrib/contrib.hpp	/^        ~Mesh3D();$/;"	p	class:cv::Mesh3D	access:public	signature:()
~NNIndex	/usr/include/opencv2/flann/nn_index.h	/^	virtual ~NNIndex() {};$/;"	f	class:cvflann::NNIndex	access:public	signature:()
~Octree	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual ~Octree();$/;"	p	class:cv::Octree	access:public	signature:()
~OneWayDescriptor	/usr/include/opencv2/features2d/features2d.hpp	/^    ~OneWayDescriptor();$/;"	p	class:cv::OneWayDescriptor	access:public	signature:()
~OneWayDescriptorBase	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~OneWayDescriptorBase();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
~OneWayDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~OneWayDescriptorMatcher();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
~OneWayDescriptorObject	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~OneWayDescriptorObject();$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:()
~PlanarObjectDetector	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~PlanarObjectDetector();$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:()
~PooledAllocator	/usr/include/opencv2/flann/allocator.h	/^ 	~PooledAllocator()$/;"	f	class:cvflann::PooledAllocator	access:public	signature:()
~Ptr	/usr/include/opencv2/core/core.hpp	/^    ~Ptr();$/;"	p	class:cv::Ptr	access:public	signature:()
~Ptr	/usr/include/opencv2/core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }$/;"	f	class:cv::Ptr	signature:()
~RadiusResultSet	/usr/include/opencv2/flann/result_set.h	/^	~RadiusResultSet()$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:()
~RandomizedTree	/usr/include/opencv2/features2d/features2d.hpp	/^  ~RandomizedTree();$/;"	p	class:cv::RandomizedTree	access:public	signature:()
~ResultSet	/usr/include/opencv2/flann/result_set.h	/^	virtual ~ResultSet() {};$/;"	f	class:cvflann::ResultSet	access:public	signature:()
~SearchWindow	/usr/include/opencv2/contrib/contrib.hpp	/^        ~SearchWindow();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
~SelfSimDescriptor	/usr/include/opencv2/contrib/contrib.hpp	/^        virtual ~SelfSimDescriptor();$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:()
~SparseMat	/usr/include/opencv2/core/core.hpp	/^    ~SparseMat();$/;"	p	class:cv::SparseMat	access:public	signature:()
~SparseMat	/usr/include/opencv2/core/mat.hpp	/^inline SparseMat::~SparseMat()$/;"	f	class:cv::SparseMat	signature:()
~SpinImageModel	/usr/include/opencv2/contrib/contrib.hpp	/^        ~SpinImageModel();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
~StereoSGBM	/usr/include/opencv2/calib3d/calib3d.hpp	/^    virtual ~StereoSGBM();$/;"	p	class:cv::StereoSGBM	access:public	signature:()
~Stream	/usr/include/opencv2/gpu/gpu.hpp	/^            ~Stream();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
~UniqueRandom	/usr/include/opencv2/flann/random.h	/^	~UniqueRandom()$/;"	f	class:cvflann::UniqueRandom	access:public	signature:()
~UntypedMatrix	/usr/include/opencv2/flann/matrix.h	/^    ~UntypedMatrix()$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:()
~Vector	/usr/include/opencv2/core/operations.hpp	/^    ~Vector()  { release(); }$/;"	f	class:cv::Vector	access:public	signature:()
~VectorDescriptorMatcher	/usr/include/opencv2/features2d/features2d.hpp	/^    virtual ~VectorDescriptorMatcher();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
~VideoCapture	/usr/include/opencv2/highgui/highgui.hpp	/^    virtual ~VideoCapture();$/;"	p	class:cv::VideoCapture	access:public	signature:()
~VideoWriter	/usr/include/opencv2/highgui/highgui.hpp	/^    virtual ~VideoWriter();$/;"	p	class:cv::VideoWriter	access:public	signature:()
~WImage	/usr/include/opencv2/core/wimage.hpp	/^    virtual ~WImage() = 0;$/;"	p	class:cv::WImage	access:public	signature:()
~WImage	/usr/include/opencv2/core/wimage.hpp	/^template<typename T> inline WImage<T>::~WImage() {}$/;"	f	class:cv::WImage	signature:()
~WImageBuffer	/usr/include/opencv2/core/wimage.hpp	/^    ~WImageBuffer() {$/;"	f	class:cv::WImageBuffer	access:public	signature:()
~WImageBufferC	/usr/include/opencv2/core/wimage.hpp	/^    ~WImageBufferC() {$/;"	f	class:cv::WImageBufferC	access:public	signature:()
~WImageC	/usr/include/opencv2/core/wimage.hpp	/^    virtual ~WImageC() = 0;$/;"	p	class:cv::WImageC	access:public	signature:()
~WImageC	/usr/include/opencv2/core/wimage.hpp	/^template<typename T, int C> inline WImageC<T, C>::~WImageC() {}$/;"	f	class:cv::WImageC	signature:()
~WImageViewC	/usr/include/opencv2/core/wimage.hpp	/^    virtual ~WImageViewC() {}$/;"	f	class:cv::WImageViewC	access:public	signature:()
~WriteStructContext	/usr/include/opencv2/core/operations.hpp	/^    ~WriteStructContext();$/;"	p	class:cv::WriteStructContext	access:public	signature:()
